
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>spectrocloud: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/addon_deployment.go (0.0%)</option>
				
				<option value="file1">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/application_common.go (0.0%)</option>
				
				<option value="file2">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/application_create_common.go (0.0%)</option>
				
				<option value="file3">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/cluster_common.go (0.0%)</option>
				
				<option value="file4">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/cluster_common_attachment.go (0.0%)</option>
				
				<option value="file5">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/cluster_common_crud.go (0.0%)</option>
				
				<option value="file6">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/cluster_common_fields.go (0.0%)</option>
				
				<option value="file7">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/cluster_common_hash.go (0.6%)</option>
				
				<option value="file8">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/cluster_common_host.go (0.0%)</option>
				
				<option value="file9">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/cluster_common_labels.go (0.0%)</option>
				
				<option value="file10">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/cluster_common_location.go (0.0%)</option>
				
				<option value="file11">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/cluster_common_metadata.go (0.0%)</option>
				
				<option value="file12">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/cluster_common_namespaces.go (0.0%)</option>
				
				<option value="file13">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/cluster_common_ospatch.go (0.0%)</option>
				
				<option value="file14">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/cluster_common_policies.go (0.0%)</option>
				
				<option value="file15">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/cluster_common_profiles.go (0.0%)</option>
				
				<option value="file16">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/cluster_common_rbac.go (0.0%)</option>
				
				<option value="file17">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/cluster_common_tags.go (76.5%)</option>
				
				<option value="file18">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/cluster_common_taints.go (0.0%)</option>
				
				<option value="file19">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/cluster_common_update_strategy.go (0.0%)</option>
				
				<option value="file20">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/cluster_common_virtual_machine.go (0.0%)</option>
				
				<option value="file21">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/cluster_node_common.go (0.0%)</option>
				
				<option value="file22">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/cluster_profile_common_crud.go (0.0%)</option>
				
				<option value="file23">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/common/safe_conversions.go (0.0%)</option>
				
				<option value="file24">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/common_backup_storage_location.go (0.0%)</option>
				
				<option value="file25">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/common_cluster_profile.go (0.0%)</option>
				
				<option value="file26">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/common_utils.go (73.3%)</option>
				
				<option value="file27">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/convert/hapi_to_kubevirt_common.go (0.0%)</option>
				
				<option value="file28">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/convert/hapi_to_kubevirt_spec.go (0.0%)</option>
				
				<option value="file29">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/convert/hapi_to_kubevirt_status.go (0.0%)</option>
				
				<option value="file30">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/convert/kubevirt_to_hapi_common.go (0.0%)</option>
				
				<option value="file31">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/convert/kubevirt_to_hapi_spec.go (0.0%)</option>
				
				<option value="file32">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/convert/kubevirt_to_hapi_status.go (0.0%)</option>
				
				<option value="file33">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/convert/volume_hapi_to_kubevirt_common.go (0.0%)</option>
				
				<option value="file34">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/convert/volume_kubevirt_to_hapi_common.go (0.0%)</option>
				
				<option value="file35">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/data_source_appliance.go (2.9%)</option>
				
				<option value="file36">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/data_source_appliances.go (4.8%)</option>
				
				<option value="file37">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/data_source_application_profile.go (6.2%)</option>
				
				<option value="file38">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/data_source_backup_storage_location.go (4.5%)</option>
				
				<option value="file39">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/data_source_cloud_account_apache_cloudstack.go (3.1%)</option>
				
				<option value="file40">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/data_source_cloud_account_aws.go (3.1%)</option>
				
				<option value="file41">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/data_source_cloud_account_azure.go (2.9%)</option>
				
				<option value="file42">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/data_source_cloud_account_custom.go (3.0%)</option>
				
				<option value="file43">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/data_source_cloud_account_gcp.go (3.2%)</option>
				
				<option value="file44">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/data_source_cloud_account_maas.go (2.6%)</option>
				
				<option value="file45">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/data_source_cloud_account_openstack.go (3.1%)</option>
				
				<option value="file46">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/data_source_cloud_account_vsphere.go (3.1%)</option>
				
				<option value="file47">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/data_source_cluster.go (3.2%)</option>
				
				<option value="file48">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/data_source_cluster_config_policy.go (3.1%)</option>
				
				<option value="file49">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/data_source_cluster_config_template.go (3.1%)</option>
				
				<option value="file50">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/data_source_cluster_group.go (57.1%)</option>
				
				<option value="file51">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/data_source_cluster_profile.go (1.6%)</option>
				
				<option value="file52">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/data_source_common.go (0.0%)</option>
				
				<option value="file53">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/data_source_filter.go (5.6%)</option>
				
				<option value="file54">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/data_source_helm.go (9.1%)</option>
				
				<option value="file55">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/data_source_macros.go (66.7%)</option>
				
				<option value="file56">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/data_source_oci_ecr.go (8.3%)</option>
				
				<option value="file57">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/data_source_pack.go (0.5%)</option>
				
				<option value="file58">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/data_source_pack_simple.go (2.0%)</option>
				
				<option value="file59">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/data_source_pcg_dns_map.go (2.0%)</option>
				
				<option value="file60">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/data_source_pcg_ippool.go (6.2%)</option>
				
				<option value="file61">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/data_source_permission.go (6.7%)</option>
				
				<option value="file62">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/data_source_private_cloud_gateway.go (7.7%)</option>
				
				<option value="file63">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/data_source_project.go (81.8%)</option>
				
				<option value="file64">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/data_source_registration_token.go (3.3%)</option>
				
				<option value="file65">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/data_source_registry.go (3.0%)</option>
				
				<option value="file66">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/data_source_registry_pack.go (9.1%)</option>
				
				<option value="file67">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/data_source_role.go (5.0%)</option>
				
				<option value="file68">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/data_source_ssh_key.go (3.8%)</option>
				
				<option value="file69">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/data_source_team.go (5.0%)</option>
				
				<option value="file70">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/data_source_user.go (9.1%)</option>
				
				<option value="file71">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/data_source_workspace.go (8.3%)</option>
				
				<option value="file72">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/filter_common.go (0.0%)</option>
				
				<option value="file73">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/kubevirt/schema/datavolume/data_volume.go (6.2%)</option>
				
				<option value="file74">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/kubevirt/schema/datavolume/options.go (100.0%)</option>
				
				<option value="file75">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/kubevirt/schema/datavolume/source.go (16.9%)</option>
				
				<option value="file76">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/kubevirt/schema/datavolume/spec.go (4.0%)</option>
				
				<option value="file77">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/kubevirt/schema/datavolume/status.go (21.4%)</option>
				
				<option value="file78">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/kubevirt/schema/k8s/affinity_spec.go (5.0%)</option>
				
				<option value="file79">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/kubevirt/schema/k8s/label_selector.go (3.2%)</option>
				
				<option value="file80">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/kubevirt/schema/k8s/local_object_reference.go (23.1%)</option>
				
				<option value="file81">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/kubevirt/schema/k8s/metadata.go (9.4%)</option>
				
				<option value="file82">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/kubevirt/schema/k8s/persistent_volume_claim.go (4.6%)</option>
				
				<option value="file83">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/kubevirt/schema/k8s/pod_dns_config.go (6.2%)</option>
				
				<option value="file84">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/kubevirt/schema/k8s/toleration.go (7.3%)</option>
				
				<option value="file85">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/kubevirt/schema/virtualmachine/conditions.go (11.5%)</option>
				
				<option value="file86">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/kubevirt/schema/virtualmachine/data_volume_template.go (13.0%)</option>
				
				<option value="file87">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/kubevirt/schema/virtualmachine/spec.go (0.0%)</option>
				
				<option value="file88">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/kubevirt/schema/virtualmachine/state_change_requests.go (12.0%)</option>
				
				<option value="file89">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/kubevirt/schema/virtualmachine/status.go (12.0%)</option>
				
				<option value="file90">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/kubevirt/schema/virtualmachine/virtual_machine.go (5.3%)</option>
				
				<option value="file91">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/kubevirt/schema/virtualmachineinstance/domain_spec.go (0.0%)</option>
				
				<option value="file92">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/kubevirt/schema/virtualmachineinstance/networks.go (5.2%)</option>
				
				<option value="file93">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/kubevirt/schema/virtualmachineinstance/probe.go (30.0%)</option>
				
				<option value="file94">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/kubevirt/schema/virtualmachineinstance/spec.go (0.0%)</option>
				
				<option value="file95">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/kubevirt/schema/virtualmachineinstance/template_spec.go (0.0%)</option>
				
				<option value="file96">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/kubevirt/schema/virtualmachineinstance/volumes.go (1.4%)</option>
				
				<option value="file97">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/kubevirt/test_utils/expand_utils/expand_utils.go (0.0%)</option>
				
				<option value="file98">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/kubevirt/test_utils/flatten_utils/flatten_utils.go (0.0%)</option>
				
				<option value="file99">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/kubevirt/test_utils/test_utils.go (0.0%)</option>
				
				<option value="file100">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/kubevirt/utils/patch/patch_operations.go (0.0%)</option>
				
				<option value="file101">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/kubevirt/utils/structures.go (4.2%)</option>
				
				<option value="file102">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/kubevirt/utils/validators.go (1.9%)</option>
				
				<option value="file103">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/provider.go (9.7%)</option>
				
				<option value="file104">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/resource_alert.go (0.5%)</option>
				
				<option value="file105">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/resource_alert_import.go (0.0%)</option>
				
				<option value="file106">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/resource_appliance.go (1.0%)</option>
				
				<option value="file107">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/resource_appliance_import.go (0.0%)</option>
				
				<option value="file108">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/resource_application.go (1.0%)</option>
				
				<option value="file109">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/resource_application_import.go (0.0%)</option>
				
				<option value="file110">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/resource_application_profile.go (0.5%)</option>
				
				<option value="file111">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/resource_application_profile_import.go (0.0%)</option>
				
				<option value="file112">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/resource_backup_storage_location.go (2.9%)</option>
				
				<option value="file113">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/resource_backup_storage_location_import.go (0.0%)</option>
				
				<option value="file114">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/resource_cloud_account_apache_cloudstack.go (1.5%)</option>
				
				<option value="file115">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/resource_cloud_account_aws.go (22.9%)</option>
				
				<option value="file116">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/resource_cloud_account_aws_import.go (0.0%)</option>
				
				<option value="file117">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/resource_cloud_account_azure.go (1.1%)</option>
				
				<option value="file118">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/resource_cloud_account_custom.go (1.1%)</option>
				
				<option value="file119">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/resource_cloud_account_gcp.go (2.2%)</option>
				
				<option value="file120">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/resource_cloud_account_gcp_import.go (0.0%)</option>
				
				<option value="file121">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/resource_cloud_account_maas.go (1.8%)</option>
				
				<option value="file122">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/resource_cloud_account_openstack.go (1.5%)</option>
				
				<option value="file123">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/resource_cloud_account_vsphere.go (1.5%)</option>
				
				<option value="file124">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/resource_cluster_aks.go (0.4%)</option>
				
				<option value="file125">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/resource_cluster_aks_import.go (0.0%)</option>
				
				<option value="file126">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/resource_cluster_apache_cloudstack.go (0.3%)</option>
				
				<option value="file127">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/resource_cluster_attachment.go (1.0%)</option>
				
				<option value="file128">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/resource_cluster_aws.go (0.4%)</option>
				
				<option value="file129">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/resource_cluster_aws_import.go (0.0%)</option>
				
				<option value="file130">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/resource_cluster_azure.go (0.4%)</option>
				
				<option value="file131">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/resource_cluster_azure_import.go (0.0%)</option>
				
				<option value="file132">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/resource_cluster_brownfield.go (0.3%)</option>
				
				<option value="file133">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/resource_cluster_config_policy.go (1.4%)</option>
				
				<option value="file134">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/resource_cluster_config_template.go (0.5%)</option>
				
				<option value="file135">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/resource_cluster_custom_cloud.go (0.1%)</option>
				
				<option value="file136">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/resource_cluster_custom_cloud_import.go (0.0%)</option>
				
				<option value="file137">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/resource_cluster_edge_native.go (0.3%)</option>
				
				<option value="file138">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/resource_cluster_edge_native_import.go (0.0%)</option>
				
				<option value="file139">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/resource_cluster_edge_vsphere.go (0.5%)</option>
				
				<option value="file140">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/resource_cluster_edge_vsphere_import.go (0.0%)</option>
				
				<option value="file141">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/resource_cluster_eks.go (0.2%)</option>
				
				<option value="file142">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/resource_cluster_eks_import.go (0.0%)</option>
				
				<option value="file143">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/resource_cluster_gcp.go (0.5%)</option>
				
				<option value="file144">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/resource_cluster_gcp_import.go (0.0%)</option>
				
				<option value="file145">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/resource_cluster_gke.go (0.6%)</option>
				
				<option value="file146">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/resource_cluster_gke_import.go (0.0%)</option>
				
				<option value="file147">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/resource_cluster_group.go (0.8%)</option>
				
				<option value="file148">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/resource_cluster_group_import.go (0.0%)</option>
				
				<option value="file149">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/resource_cluster_maas.go (0.4%)</option>
				
				<option value="file150">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/resource_cluster_maas_import.go (0.0%)</option>
				
				<option value="file151">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/resource_cluster_openstack.go (0.5%)</option>
				
				<option value="file152">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/resource_cluster_openstack_import.go (0.0%)</option>
				
				<option value="file153">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/resource_cluster_profile.go (0.4%)</option>
				
				<option value="file154">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/resource_cluster_profile_import.go (0.0%)</option>
				
				<option value="file155">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/resource_cluster_profile_import_feature.go (1.9%)</option>
				
				<option value="file156">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/resource_cluster_virtual.go (0.7%)</option>
				
				<option value="file157">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/resource_cluster_virtual_import.go (0.0%)</option>
				
				<option value="file158">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/resource_cluster_vsphere.go (0.3%)</option>
				
				<option value="file159">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/resource_cluster_vsphere_import.go (0.0%)</option>
				
				<option value="file160">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/resource_developer_setting.go (1.1%)</option>
				
				<option value="file161">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/resource_filter.go (3.0%)</option>
				
				<option value="file162">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/resource_filter_import.go (0.0%)</option>
				
				<option value="file163">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/resource_kubevirt_datavolume.go (1.1%)</option>
				
				<option value="file164">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/resource_kubevirt_virtual_machine.go (0.7%)</option>
				
				<option value="file165">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/resource_macros.go (48.1%)</option>
				
				<option value="file166">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/resource_password_policy.go (0.9%)</option>
				
				<option value="file167">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/resource_pcg_dns_map.go (2.0%)</option>
				
				<option value="file168">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/resource_pcg_dns_map_import.go (0.0%)</option>
				
				<option value="file169">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/resource_pcg_ippool.go (1.2%)</option>
				
				<option value="file170">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/resource_pcg_ippool_import.go (0.0%)</option>
				
				<option value="file171">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/resource_platform_setting.go (0.4%)</option>
				
				<option value="file172">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/resource_project.go (87.5%)</option>
				
				<option value="file173">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/resource_project_import.go (0.0%)</option>
				
				<option value="file174">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/resource_registration_token.go (1.1%)</option>
				
				<option value="file175">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/resource_registry_helm.go (0.7%)</option>
				
				<option value="file176">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/resource_registry_helm_import.go (0.0%)</option>
				
				<option value="file177">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/resource_registry_oci_ecr.go (0.3%)</option>
				
				<option value="file178">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/resource_registry_oci_import.go (0.0%)</option>
				
				<option value="file179">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/resource_resource_limit.go (1.2%)</option>
				
				<option value="file180">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/resource_role.go (1.6%)</option>
				
				<option value="file181">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/resource_ssh_key.go (2.0%)</option>
				
				<option value="file182">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/resource_ssh_key_import.go (0.0%)</option>
				
				<option value="file183">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/resource_sso.go (0.3%)</option>
				
				<option value="file184">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/resource_team.go (11.4%)</option>
				
				<option value="file185">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/resource_team_import.go (0.0%)</option>
				
				<option value="file186">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/resource_user.go (0.3%)</option>
				
				<option value="file187">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/resource_user_import.go (0.0%)</option>
				
				<option value="file188">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/resource_workspace.go (1.5%)</option>
				
				<option value="file189">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/retired_clusters_schema.go (85.7%)</option>
				
				<option value="file190">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/schemas/application_pack.go (33.3%)</option>
				
				<option value="file191">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/schemas/backup_policy.go (100.0%)</option>
				
				<option value="file192">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/schemas/cluster_host_config.go (100.0%)</option>
				
				<option value="file193">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/schemas/cluster_location_config.go (18.2%)</option>
				
				<option value="file194">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/schemas/cluster_namespaces.go (100.0%)</option>
				
				<option value="file195">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/schemas/cluster_node.go (100.0%)</option>
				
				<option value="file196">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/schemas/cluster_profile.go (100.0%)</option>
				
				<option value="file197">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/schemas/cluster_rbac_binding.go (100.0%)</option>
				
				<option value="file198">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/schemas/cluster_taints.go (100.0%)</option>
				
				<option value="file199">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/schemas/cluster_template.go (100.0%)</option>
				
				<option value="file200">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/schemas/cluster_type.go (100.0%)</option>
				
				<option value="file201">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/schemas/eks_template.go (100.0%)</option>
				
				<option value="file202">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/schemas/override_scaling.go (100.0%)</option>
				
				<option value="file203">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/schemas/pack.go (2.7%)</option>
				
				<option value="file204">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/schemas/profile_variables.go (100.0%)</option>
				
				<option value="file205">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/schemas/scan_policy.go (100.0%)</option>
				
				<option value="file206">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/schemas/subnet.go (100.0%)</option>
				
				<option value="file207">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/schemas/vm_device.go (0.0%)</option>
				
				<option value="file208">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/schemas/vm_disk.go (0.0%)</option>
				
				<option value="file209">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/schemas/vm_interface.go (0.0%)</option>
				
				<option value="file210">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/schemas/vm_nic.go (0.0%)</option>
				
				<option value="file211">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/schemas/vm_volume.go (0.0%)</option>
				
				<option value="file212">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/schemas/workspace_namespaces.go (1.8%)</option>
				
				<option value="file213">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/testutil/acctest.go (7.1%)</option>
				
				<option value="file214">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/testutil/fixtures.go (41.4%)</option>
				
				<option value="file215">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/testutil/vcr/vcr.go (16.2%)</option>
				
				<option value="file216">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/utils.go (0.0%)</option>
				
				<option value="file217">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/workspace_backup.go (0.0%)</option>
				
				<option value="file218">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/workspace_cluster.go (0.0%)</option>
				
				<option value="file219">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/workspace_common.go (0.0%)</option>
				
				<option value="file220">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/workspace_namespace.go (0.0%)</option>
				
				<option value="file221">github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/workspace_rbac.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package spectrocloud

import (
        "strings"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/spectrocloud/palette-sdk-go/api/models"
        "github.com/spectrocloud/palette-sdk-go/client"

        "github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/schemas"
        "github.com/spectrocloud/terraform-provider-spectrocloud/types"
)

// readAddonDeployment reads a single addon profile from the cluster
func readAddonDeployment(c *client.V1Client, d *schema.ResourceData, cluster *models.V1SpectroCluster) (diag.Diagnostics, bool) <span class="cov0" title="0">{
        var diags diag.Diagnostics

        profileId, err := getClusterProfileUID(d.Id())
        if err != nil </span><span class="cov0" title="0">{
                return nil, false
        }</span>

        <span class="cov0" title="0">clusterProfile, err := c.GetClusterProfile(profileId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, false
        }</span>

        <span class="cov0" title="0">for _, profile := range cluster.Spec.ClusterProfileTemplates </span><span class="cov0" title="0">{
                if profile != nil &amp;&amp; clusterProfile != nil </span><span class="cov0" title="0">{
                        if profile.Name == clusterProfile.Metadata.Name </span><span class="cov0" title="0">{
                                if profile.ProfileVersion == clusterProfile.Spec.Published.ProfileVersion </span><span class="cov0" title="0">{
                                        diagnostics, done := flattenAddonDeployment(c, d, profile)
                                        if done </span><span class="cov0" title="0">{
                                                return diagnostics, true
                                        }</span>
                                        <span class="cov0" title="0">return diags, true</span>
                                }
                        }
                }
        }

        <span class="cov0" title="0">d.SetId("") // deleted.
        return diags, false</span>
}

func flattenAddonDeployment(c *client.V1Client, d *schema.ResourceData, profile *models.V1ClusterProfileTemplate) (diag.Diagnostics, bool) <span class="cov0" title="0">{
        var diags diag.Diagnostics

        // Check if user has defined packs in their config
        hasPacksInConfig := false
        profiles := d.Get("cluster_profile").([]interface{})
        if len(profiles) &gt; 0 </span><span class="cov0" title="0">{
                for _, p := range profiles </span><span class="cov0" title="0">{
                        profileMap := p.(map[string]interface{})
                        if packs, ok := profileMap["pack"]; ok &amp;&amp; packs != nil </span><span class="cov0" title="0">{
                                packsList := packs.([]interface{})
                                if len(packsList) &gt; 0 </span><span class="cov0" title="0">{
                                        hasPacksInConfig = true
                                        break</span>
                                }
                        }
                }
        }

        <span class="cov0" title="0">cluster_profiles := make([]interface{}, 0)
        cluster_profile := make(map[string]interface{})
        cluster_profile["id"] = profile.UID

        // Only flatten packs if user has defined them in config
        if hasPacksInConfig </span><span class="cov0" title="0">{
                packManifests, d2, done2 := getPacksContent(profile.Packs, c, d)
                if done2 </span><span class="cov0" title="0">{
                        return d2, false
                }</span>

                <span class="cov0" title="0">diagPacks, diagnostics, done := GetAddonDeploymentDiagPacks(d, nil)
                if done </span><span class="cov0" title="0">{
                        return diagnostics, false
                }</span>

                // Build registry maps to track which packs use registry_name or registry_uid
                <span class="cov0" title="0">registryNameMap := buildPackRegistryNameMap(d)
                registryUIDMap := buildPackRegistryUIDMap(d)
                packs, err := flattenPacksWithRegistryMaps(c, diagPacks, profile.Packs, packManifests, registryNameMap, registryUIDMap)
                if err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err), false
                }</span>
                <span class="cov0" title="0">cluster_profile["pack"] = packs</span>
        }

        // Flatten profile variables
        <span class="cov0" title="0">clusterUID := d.Get("cluster_uid").(string)
        if clusterUID != "" </span><span class="cov0" title="0">{
                clusterVars, err := c.GetClusterVariables(clusterUID)
                if err == nil </span><span class="cov0" title="0">{
                        // Find variables for this specific profile
                        for _, clusterVar := range clusterVars </span><span class="cov0" title="0">{
                                if clusterVar.ProfileUID != nil &amp;&amp; *clusterVar.ProfileUID == profile.UID &amp;&amp; clusterVar.Variables != nil </span><span class="cov0" title="0">{
                                        vars := make(map[string]interface{})
                                        for _, v := range clusterVar.Variables </span><span class="cov0" title="0">{
                                                if v.Name != nil &amp;&amp; v.Value != "" </span><span class="cov0" title="0">{
                                                        vars[*v.Name] = v.Value
                                                }</span>
                                        }
                                        <span class="cov0" title="0">if len(vars) &gt; 0 </span><span class="cov0" title="0">{
                                                cluster_profile["variables"] = vars
                                        }</span>
                                        <span class="cov0" title="0">break</span>
                                }
                        }
                }
        }

        <span class="cov0" title="0">cluster_profiles = append(cluster_profiles, cluster_profile)

        if err := d.Set("cluster_profile", cluster_profiles); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err), false
        }</span>

        <span class="cov0" title="0">return diags, true</span>
}

func GetAddonDeploymentDiagPacks(d *schema.ResourceData, err error) ([]*models.V1PackManifestEntity, diag.Diagnostics, bool) <span class="cov0" title="0">{
        diagPacks := make([]*models.V1PackManifestEntity, 0)
        profiles := d.Get("cluster_profile").([]interface{})
        if len(profiles) &gt; 0 </span><span class="cov0" title="0">{
                for _, profile := range profiles </span><span class="cov0" title="0">{
                        p := profile.(map[string]interface{})
                        for _, pack := range p["pack"].([]interface{}) </span><span class="cov0" title="0">{
                                if p, e := toAddonDeploymentPackCreate(pack); e != nil </span><span class="cov0" title="0">{
                                        return nil, diag.FromErr(err), true
                                }</span> else<span class="cov0" title="0"> {
                                        diagPacks = append(diagPacks, p)
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">return diagPacks, nil, false</span>
}

func toAddonDeploymentPackCreate(pSrc interface{}) (*models.V1PackManifestEntity, error) <span class="cov0" title="0">{
        p := pSrc.(map[string]interface{})

        pName := p["name"].(string)
        pTag := p["tag"].(string)
        pRegistryUID := ""
        if p["registry_uid"] != nil </span><span class="cov0" title="0">{
                pRegistryUID = p["registry_uid"].(string)
        }</span>
        <span class="cov0" title="0">pType := models.V1PackType(p["type"].(string))

        // Validate pack fields (validates both registry_uid and registry_name)
        if err := schemas.ValidatePackUIDOrResolutionFields(p); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">pack := &amp;models.V1PackManifestEntity{
                Name:        types.Ptr(pName),
                Tag:         pTag,
                RegistryUID: pRegistryUID,
                Type:        &amp;pType,
                // UI strips a single newline, so we should do the same
                Values: strings.TrimSpace(p["values"].(string)),
        }

        manifests := make([]*models.V1ManifestInputEntity, 0)
        if len(p["manifest"].([]interface{})) &gt; 0 </span><span class="cov0" title="0">{
                for _, manifest := range p["manifest"].([]interface{}) </span><span class="cov0" title="0">{
                        m := manifest.(map[string]interface{})
                        manifests = append(manifests, &amp;models.V1ManifestInputEntity{
                                Content: strings.TrimSpace(m["content"].(string)),
                                Name:    m["name"].(string),
                        })
                }</span>
        }
        <span class="cov0" title="0">pack.Manifests = manifests

        return pack, nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package spectrocloud

import (
        "context"
        "errors"
        "log"
        "time"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/spectrocloud/palette-sdk-go/client"
)

var resourceApplicationCreatePendingStates = []string{
        "Tier:Error",
        "PackPending",
        "Tier:NotReady",
        "Application:NotReady",
        "Application:Peding",
}

func waitForApplication(ctx context.Context, d *schema.ResourceData, diags diag.Diagnostics, c *client.V1Client, state string) (diag.Diagnostics, bool) <span class="cov0" title="0">{
        application, err := c.GetApplication(d.Id())
        if err != nil </span><span class="cov0" title="0">{
                return diags, true
        }</span>

        <span class="cov0" title="0">if _, found := application.Metadata.Labels["skip_apps"]; found </span><span class="cov0" title="0">{
                return diags, true
        }</span>

        <span class="cov0" title="0">stateConf := &amp;retry.StateChangeConf{
                Pending:    resourceApplicationCreatePendingStates,
                Target:     []string{"True"},
                Refresh:    resourceApplicationStateRefreshFunc(c, d, 5, 60),
                Timeout:    d.Timeout(state) - 1*time.Minute,
                MinTimeout: 10 * time.Second,
                Delay:      30 * time.Second,
        }

        // Wait, catching any errors
        _, err = stateConf.WaitForStateContext(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err), true
        }</span>
        <span class="cov0" title="0">return nil, false</span>
}

func waitForApplicationCreation(ctx context.Context, d *schema.ResourceData, diags diag.Diagnostics, c *client.V1Client) (diag.Diagnostics, bool) <span class="cov0" title="0">{
        return waitForApplication(ctx, d, diags, c, schema.TimeoutCreate)
}</span>

func waitForApplicationUpdate(ctx context.Context, d *schema.ResourceData, diags diag.Diagnostics, c *client.V1Client) (diag.Diagnostics, bool) <span class="cov0" title="0">{
        return waitForApplication(ctx, d, diags, c, schema.TimeoutUpdate)
}</span>

func resourceApplicationStateRefreshFunc(c *client.V1Client, d *schema.ResourceData, retryAttempts int, duration int) retry.StateRefreshFunc <span class="cov0" title="0">{
        return func() (interface{}, string, error) </span><span class="cov0" title="0">{
                application, err := c.GetApplication(d.Id())
                if err != nil </span><span class="cov0" title="0">{
                        return nil, "", err
                }</span> else<span class="cov0" title="0"> if application == nil </span><span class="cov0" title="0">{
                        return nil, "Deleted", nil
                }</span>

                <span class="cov0" title="0">for _, tier_status := range application.Status.AppTiers </span><span class="cov0" title="0">{
                        log.Printf("Cluster (%s): tier:%s, condition status:%s", d.Id(), tier_status.Name, *tier_status.Condition.Status)
                        if *tier_status.Condition.Type == "Error" </span><span class="cov0" title="0">{
                                // invoke recursive call h.retryAttempts number of times
                                if retryAttempts &gt; 0 </span><span class="cov0" title="0">{
                                        time.Sleep(time.Duration(duration) * time.Second)
                                        return resourceApplicationStateRefreshFunc(c, d, retryAttempts-1, duration)()
                                }</span> else<span class="cov0" title="0"> {
                                        return application, "Tier:Error", errors.New(tier_status.Condition.Message)
                                }</span>
                        }
                        <span class="cov0" title="0">if *tier_status.Condition.Status != "True" || *tier_status.Condition.Type != "Ready" </span><span class="cov0" title="0">{
                                return application, "Tier:NotReady", nil
                        }</span>
                }

                <span class="cov0" title="0">if application.Status.State != "Deployed" </span><span class="cov0" title="0">{
                        return application, "Application:NotReady", nil
                }</span>

                <span class="cov0" title="0">return application, "True", nil</span>
        }
}

func resourceApplicationDelete(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        configList := d.Get("config")
        c := getV1ClientWithResourceContext(m, "")
        if configList.([]interface{})[0] != nil </span><span class="cov0" title="0">{
                config := configList.([]interface{})[0].(map[string]interface{})
                resourceContext := config["cluster_context"].(string)
                c = getV1ClientWithResourceContext(m, resourceContext)
        }</span>
        <span class="cov0" title="0">var diags diag.Diagnostics
        err := c.DeleteApplication(d.Id())
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">return diags</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package spectrocloud

import (
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

        "github.com/spectrocloud/palette-sdk-go/api/models"
        "github.com/spectrocloud/terraform-provider-spectrocloud/types"
)

// New Sandbox cluster.
func toAppDeploymentClusterGroupEntity(d *schema.ResourceData) *models.V1AppDeploymentClusterGroupEntity <span class="cov0" title="0">{
        return &amp;models.V1AppDeploymentClusterGroupEntity{
                Metadata: &amp;models.V1ObjectMetaInputEntity{
                        Name:   d.Get("name").(string),
                        Labels: toTags(d),
                },
                Spec: toAppDeploymentClusterGroupSpec(d),
        }
}</span>

func toAppDeploymentClusterGroupSpec(d *schema.ResourceData) *models.V1AppDeploymentClusterGroupSpec <span class="cov0" title="0">{
        return &amp;models.V1AppDeploymentClusterGroupSpec{
                Config:  toV1AppDeploymentClusterGroupConfigEntity(d),
                Profile: toV1AppDeploymentProfileEntity(d),
        }
}</span>

func toV1AppDeploymentClusterGroupConfigEntity(d *schema.ResourceData) *models.V1AppDeploymentClusterGroupConfigEntity <span class="cov0" title="0">{
        return &amp;models.V1AppDeploymentClusterGroupConfigEntity{
                TargetSpec: toAppDeploymentClusterGroupTargetSpec(d),
        }
}</span>

func toAppDeploymentClusterGroupTargetSpec(d *schema.ResourceData) *models.V1AppDeploymentClusterGroupTargetSpec <span class="cov0" title="0">{
        configList := d.Get("config")
        config := configList.([]interface{})[0].(map[string]interface{})

        return &amp;models.V1AppDeploymentClusterGroupTargetSpec{
                ClusterGroupUID: types.Ptr(config["cluster_group_uid"].(string)),
                ClusterLimits:   toAppDeploymentTargetClusterLimits(d),
                ClusterName:     types.Ptr(config["cluster_name"].(string)),
        }
}</span>

func toAppDeploymentTargetClusterLimits(d *schema.ResourceData) *models.V1AppDeploymentTargetClusterLimits <span class="cov0" title="0">{
        configList := d.Get("config")
        if configList.([]interface{})[0] != nil </span><span class="cov0" title="0">{
                config := configList.([]interface{})[0].(map[string]interface{})
                for i := range config["limits"].([]interface{}) </span><span class="cov0" title="0">{
                        if config["limits"].([]interface{})[i] != nil </span><span class="cov0" title="0">{
                                limits := config["limits"].([]interface{})[i].(map[string]interface{})
                                if limits["cpu"] != nil &amp;&amp; limits["memory"] != nil </span><span class="cov0" title="0">{
                                        return &amp;models.V1AppDeploymentTargetClusterLimits{
                                                CPU:        SafeInt32(limits["cpu"].(int)),
                                                MemoryMiB:  SafeInt32(limits["memory"].(int)),
                                                StorageGiB: SafeInt32(limits["storage"].(int)),
                                        }
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">return &amp;models.V1AppDeploymentTargetClusterLimits{}</span>
}

func toV1AppDeploymentProfileEntity(d *schema.ResourceData) *models.V1AppDeploymentProfileEntity <span class="cov0" title="0">{
        return &amp;models.V1AppDeploymentProfileEntity{
                AppProfileUID: types.Ptr(d.Get("application_profile_uid").(string)),
        }
}</span>

// Existing sandbox cluster
func toAppDeploymentVirtualClusterEntity(d *schema.ResourceData) *models.V1AppDeploymentVirtualClusterEntity <span class="cov0" title="0">{
        return &amp;models.V1AppDeploymentVirtualClusterEntity{
                Metadata: &amp;models.V1ObjectMetaInputEntity{
                        Name:   d.Get("name").(string),
                        Labels: toTags(d),
                },
                Spec: toAppDeploymentVirtualClusterSpec(d),
        }
}</span>

func toAppDeploymentVirtualClusterSpec(d *schema.ResourceData) *models.V1AppDeploymentVirtualClusterSpec <span class="cov0" title="0">{
        return &amp;models.V1AppDeploymentVirtualClusterSpec{
                Config:  toAppDeploymentVirtualClusterConfigEntity(d),
                Profile: toV1AppDeploymentProfileEntity(d),
        }
}</span>

func toAppDeploymentVirtualClusterConfigEntity(d *schema.ResourceData) *models.V1AppDeploymentVirtualClusterConfigEntity <span class="cov0" title="0">{
        return &amp;models.V1AppDeploymentVirtualClusterConfigEntity{
                TargetSpec: toAppDeploymentVirtualClusterTargetSpec(d),
        }
}</span>

func toAppDeploymentVirtualClusterTargetSpec(d *schema.ResourceData) *models.V1AppDeploymentVirtualClusterTargetSpec <span class="cov0" title="0">{
        configList := d.Get("config")
        config := configList.([]interface{})[0].(map[string]interface{})

        return &amp;models.V1AppDeploymentVirtualClusterTargetSpec{
                ClusterUID: types.Ptr(config["cluster_uid"].(string)),
        }
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package spectrocloud

import (
        "errors"
        "fmt"
        "strings"

        "github.com/hashicorp/go-cty/cty"
        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/spectrocloud/palette-sdk-go/api/models"
        "github.com/spectrocloud/palette-sdk-go/client"
)

var (
        DefaultDiskType = "Standard_LRS"
        DefaultDiskSize = 60
        NameToCloudType = map[string]string{
                "spectrocloud_cluster_aks":               "aks",
                "spectrocloud_cluster_aws":               "aws",
                "spectrocloud_cluster_azure":             "azure",
                "spectrocloud_cluster_edge_native":       "edge-native",
                "spectrocloud_cluster_eks":               "eks",
                "spectrocloud_cluster_edge_vsphere":      "edge-vsphere",
                "spectrocloud_cluster_gcp":               "gcp",
                "spectrocloud_cluster_maas":              "maas",
                "spectrocloud_cluster_openstack":         "openstack",
                "spectrocloud_cluster_vsphere":           "vsphere",
                "spectrocloud_cluster_gke":               "gke",
                "spectrocloud_cluster_apache_cloudstack": "apache-cloudstack",
        }
        //clusterVsphereKeys = []string{"name", "context", "tags", "description", "cluster_meta_attribute", "cluster_profile", "apply_setting", "cloud_account_id", "cloud_config_id", "review_repave_state", "pause_agent_upgrades", "os_patch_on_boot", "os_patch_schedule", "os_patch_after", "kubeconfig", "admin_kube_config", "cloud_config", "machine_pool", "backup_policy", "scan_policy", "cluster_rbac_binding", "namespaces", "host_config", "location_config", "skip_completion", "force_delete", "force_delete_delay"}
)

const (
        tenantString  = "tenant"
        projectString = "project"
)

func toNtpServers(in map[string]interface{}) []string <span class="cov0" title="0">{
        servers := make([]string, 0, 1)
        if _, ok := in["ntp_servers"]; ok </span><span class="cov0" title="0">{
                for _, t := range in["ntp_servers"].(*schema.Set).List() </span><span class="cov0" title="0">{
                        ntp := t.(string)
                        servers = append(servers, ntp)
                }</span>
        }
        <span class="cov0" title="0">return servers</span>
}

func toClusterConfig(d *schema.ResourceData) *models.V1ClusterConfigEntity <span class="cov0" title="0">{
        config := &amp;models.V1ClusterConfigEntity{
                ClusterMetaAttribute:    toClusterMetaAttribute(d),
                MachineManagementConfig: toMachineManagementConfig(d),
                Resources:               toClusterResourceConfig(d),
                HostClusterConfig:       toClusterHostConfigs(d),
                Location:                toClusterLocationConfigs(d),
                Timezone:                toClusterTimezone(d),
        }

        // Set UpdateWorkerPoolsInParallel if specified
        if v, ok := d.GetOk("update_worker_pools_in_parallel"); ok </span><span class="cov0" title="0">{
                config.UpdateWorkerPoolsInParallel = v.(bool)
        }</span>

        <span class="cov0" title="0">return config</span>
}

func toClusterMetaAttribute(d *schema.ResourceData) string <span class="cov0" title="0">{
        clusterMetadataAttribute := ""
        if v, ok := d.GetOk("cluster_meta_attribute"); ok </span><span class="cov0" title="0">{
                clusterMetadataAttribute = v.(string)
        }</span>
        <span class="cov0" title="0">return clusterMetadataAttribute</span>
}

func toClusterTimezone(d *schema.ResourceData) string <span class="cov0" title="0">{
        timezone := ""
        if v, ok := d.GetOk("cluster_timezone"); ok </span><span class="cov0" title="0">{
                timezone = v.(string)
        }</span>
        <span class="cov0" title="0">return timezone</span>
}

func toMachineManagementConfig(d *schema.ResourceData) *models.V1MachineManagementConfig <span class="cov0" title="0">{
        return &amp;models.V1MachineManagementConfig{
                OsPatchConfig: toOsPatchConfig(d),
        }
}</span>

func toClusterResourceConfig(d *schema.ResourceData) *models.V1ClusterResourcesEntity <span class="cov0" title="0">{
        return &amp;models.V1ClusterResourcesEntity{
                Namespaces: toClusterNamespaces(d),
                Rbacs:      toClusterRBACsInputEntities(d),
        }
}</span>

func toSSHKeys(cloudConfig map[string]interface{}) ([]string, error) <span class="cov0" title="0">{
        var sshKeys []string
        var sshKeysList []interface{}
        if cloudConfig["ssh_keys"] != nil </span><span class="cov0" title="0">{
                sshKeysList = cloudConfig["ssh_keys"].(*schema.Set).List()
        }</span>
        <span class="cov0" title="0">if cloudConfig["ssh_key"] != nil </span><span class="cov0" title="0">{
                sshKey := cloudConfig["ssh_key"].(string)
                if sshKey != "" </span><span class="cov0" title="0">{
                        sshKeys = append(sshKeys, strings.TrimSpace(sshKey))
                }</span>
        }
        <span class="cov0" title="0">if len(sshKeysList) &gt; 0 || len(sshKeys) &gt; 0 </span><span class="cov0" title="0">{
                for _, sk := range sshKeysList </span><span class="cov0" title="0">{
                        sshKeys = append(sshKeys, strings.TrimSpace(sk.(string)))
                }</span>
                <span class="cov0" title="0">return sshKeys, nil</span>
        }
        <span class="cov0" title="0">return nil, errors.New("validation ssh_key: Kindly specify any one attribute ssh_key or ssh_keys")</span>
}

func FlattenControlPlaneAndRepaveInterval(isControlPlane *bool, oi map[string]interface{}, nodeRepaveInterval int32) <span class="cov0" title="0">{
        if isControlPlane != nil </span><span class="cov0" title="0">{
                oi["control_plane"] = *isControlPlane
                if !*isControlPlane </span><span class="cov0" title="0">{
                        oi["node_repave_interval"] = int32(nodeRepaveInterval)
                }</span>
        }
}

func ValidationNodeRepaveIntervalForControlPlane(nodeRepaveInterval int) error <span class="cov0" title="0">{
        if nodeRepaveInterval != 0 </span><span class="cov0" title="0">{
                errMsg := fmt.Sprintf("Validation error: The `node_repave_interval` attribute is not applicable for the control plane. Attempted value: %d.", nodeRepaveInterval)
                return errors.New(errMsg)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func ValidateContext(context string) error <span class="cov0" title="0">{
        if context != "project" &amp;&amp; context != "tenant" </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid Context set - %s", context)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func ValidateCloudType(resourceName string, cluster *models.V1SpectroCluster) error <span class="cov0" title="0">{
        if cluster.Spec == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cluster spec is nil in cluster %s", cluster.Metadata.UID)
        }</span>
        <span class="cov0" title="0">if cluster.Spec.CloudType != NameToCloudType[resourceName] </span><span class="cov0" title="0">{
                return fmt.Errorf("resource with id %s is not of type %s, need to correct resource type", cluster.Metadata.UID, resourceName)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func updateAgentUpgradeSetting(c *client.V1Client, d *schema.ResourceData) error <span class="cov0" title="0">{
        if v, ok := d.GetOk("pause_agent_upgrades"); ok </span><span class="cov0" title="0">{
                setting := &amp;models.V1ClusterUpgradeSettingsEntity{
                        SpectroComponents: v.(string),
                }
                if err := c.UpdatePauseAgentUpgradeSettingCluster(setting, d.Id()); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// This function is called during import cluster from palette to set default terraform value
func flattenCommonAttributeForClusterImport(c *client.V1Client, d *schema.ResourceData) error <span class="cov0" title="0">{
        clusterProfiles, err := flattenClusterProfileForImport(c, d)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">err = d.Set("cluster_profile", clusterProfiles)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var diags diag.Diagnostics
        cluster, err := resourceClusterRead(d, c, diags)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if cluster.Spec.ClusterConfig.Timezone != "" </span><span class="cov0" title="0">{
                if err := d.Set("cluster_timezone", cluster.Spec.ClusterConfig.Timezone); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">if cluster.Metadata.Annotations["description"] != "" </span><span class="cov0" title="0">{
                if err := d.Set("description", cluster.Metadata.Annotations["description"]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">if cluster.Status.SpcApply != nil </span><span class="cov0" title="0">{
                err = d.Set("apply_setting", cluster.Status.SpcApply.ActionType)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">err = d.Set("pause_agent_upgrades", getSpectroComponentsUpgrade(cluster))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if cluster.Spec.ClusterConfig.MachineManagementConfig != nil </span><span class="cov0" title="0">{
                err = d.Set("os_patch_on_boot", cluster.Spec.ClusterConfig.MachineManagementConfig.OsPatchConfig.PatchOnBoot)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">err = d.Set("os_patch_schedule", cluster.Spec.ClusterConfig.MachineManagementConfig.OsPatchConfig.Schedule)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">if cluster.Status.Repave != nil </span><span class="cov0" title="0">{
                if err = d.Set("review_repave_state", cluster.Status.Repave.State); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">err = d.Set("force_delete", false)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">err = d.Set("force_delete_delay", 20)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">err = d.Set("skip_completion", false)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func GetCommonCluster(d *schema.ResourceData, m interface{}) (*client.V1Client, error) <span class="cov0" title="0">{
        // parse resource ID and scope
        resourceContext, clusterID, err := ParseResourceID(d)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">c := getV1ClientWithResourceContext(m, resourceContext)

        // Use the IDs to retrieve the cluster data from the API
        cluster, err := c.GetCluster(clusterID)
        if err != nil </span><span class="cov0" title="0">{
                return c, fmt.Errorf("unable to retrieve cluster data: %s", err)
        }</span>
        <span class="cov0" title="0">if cluster != nil </span><span class="cov0" title="0">{
                err = d.Set("name", cluster.Metadata.Name)
                if err != nil </span><span class="cov0" title="0">{
                        return c, err
                }</span>
                <span class="cov0" title="0">err = d.Set("context", cluster.Metadata.Annotations["scope"])
                if err != nil </span><span class="cov0" title="0">{
                        return c, err
                }</span>

                // Set the ID of the resource in the state. This ID is used to track the
                // resource and must be set in the state during the import.
                <span class="cov0" title="0">d.SetId(clusterID)</span>
        } else<span class="cov0" title="0"> {
                return c, fmt.Errorf("couldnt find cluster. Kindly check the cluster UID and context")
        }</span>

        <span class="cov0" title="0">return c, nil</span>
}

func generalWarningForRepave(diags *diag.Diagnostics) <span class="cov0" title="0">{
        message := "Please note that certain day 2 operations on a running cluster may trigger a node pool repave or a full repave of your cluster. This process might temporarily affect your clusters performance or configuration. For more details, please refer to the https://docs.spectrocloud.com/clusters/cluster-management/node-pool/"
        *diags = append(*diags, diag.Diagnostic{
                Severity: diag.Warning,
                Summary:  "Warning",
                Detail:   message,
        })
}</span>

func flattenCommonAttributeForCustomClusterImport(c *client.V1Client, d *schema.ResourceData) error <span class="cov0" title="0">{
        clusterProfiles, err := flattenClusterProfileForImport(c, d)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">err = d.Set("cluster_profile", clusterProfiles)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var diags diag.Diagnostics
        cluster, err := resourceClusterRead(d, c, diags)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if cluster.Metadata.Annotations["description"] != "" </span><span class="cov0" title="0">{
                if err := d.Set("description", cluster.Metadata.Annotations["description"]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">if cluster.Status.SpcApply != nil </span><span class="cov0" title="0">{
                err = d.Set("apply_setting", cluster.Status.SpcApply.ActionType)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">if cluster.Spec.ClusterConfig.Timezone != "" </span><span class="cov0" title="0">{
                if err := d.Set("cluster_timezone", cluster.Spec.ClusterConfig.Timezone); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">err = d.Set("pause_agent_upgrades", getSpectroComponentsUpgrade(cluster))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if cluster.Spec.ClusterConfig.MachineManagementConfig != nil </span><span class="cov0" title="0">{
                err = d.Set("os_patch_on_boot", cluster.Spec.ClusterConfig.MachineManagementConfig.OsPatchConfig.PatchOnBoot)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">err = d.Set("os_patch_schedule", cluster.Spec.ClusterConfig.MachineManagementConfig.OsPatchConfig.Schedule)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">err = d.Set("force_delete", false)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">err = d.Set("force_delete_delay", 20)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">err = d.Set("skip_completion", false)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func flattenCloudConfigGeneric(configUID string, d *schema.ResourceData, c *client.V1Client) diag.Diagnostics <span class="cov0" title="0">{
        if err := d.Set("cloud_config_id", configUID); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">return diag.Diagnostics{}</span>
}

func validateCloudType(data interface{}, path cty.Path) diag.Diagnostics <span class="cov0" title="0">{
        var diags diag.Diagnostics
        inCloudType := data.(string)
        for _, cloudType := range []string{"aws", "azure", "gcp", "vsphere", "generic"} </span><span class="cov0" title="0">{
                if cloudType == inCloudType </span><span class="cov0" title="0">{
                        return diags
                }</span>
        }
        <span class="cov0" title="0">return diag.FromErr(fmt.Errorf("cloud type '%s' is invalid. valid cloud types are %v", inCloudType, "cloud_types"))</span>
}

func toTagsMap(d *schema.ResourceData) map[string]string <span class="cov0" title="0">{
        tags := make(map[string]string)
        if d.Get("tags_map") != nil </span><span class="cov0" title="0">{
                for k, v := range d.Get("tags_map").(map[string]interface{}) </span><span class="cov0" title="0">{
                        vStr := v.(string)
                        if v != "" </span><span class="cov0" title="0">{
                                tags[k] = vStr
                        }</span> else<span class="cov0" title="0"> {
                                tags[k] = "spectro__tag"
                        }</span>
                }
                <span class="cov0" title="0">return tags</span>
        } else<span class="cov0" title="0"> {
                return nil
        }</span>
}

func flattenTagsMap(labels map[string]string) map[string]string <span class="cov0" title="0">{
        tags := make(map[string]string)
        if len(labels) &gt; 0 </span><span class="cov0" title="0">{
                for k, v := range labels </span><span class="cov0" title="0">{
                        tags[k] = v
                }</span>
                <span class="cov0" title="0">return tags</span>
        } else<span class="cov0" title="0"> {
                return nil
        }</span>
}

// updateClusterTimezone updates the timezone configuration for a cluster.
func updateClusterTimezone(c *client.V1Client, d *schema.ResourceData) error <span class="cov0" title="0">{
        if v, ok := d.GetOk("cluster_timezone"); ok </span><span class="cov0" title="0">{
                timezone := v.(string)
                if err := c.UpdateClusterTimezone(d.Id(), timezone); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// toClusterType converts the terraform cluster_type value to the API model.
// Returns nil if cluster_type is not set.
func toClusterType(d *schema.ResourceData) *models.V1ClusterType <span class="cov0" title="0">{
        if v, ok := d.GetOk("cluster_type"); ok </span><span class="cov0" title="0">{
                clusterType := models.V1ClusterType(v.(string))
                return &amp;clusterType
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// validateTimezone validates that the provided timezone is in valid IANA format.
// Valid examples: "America/New_York", "Asia/Kolkata", "Europe/London", "UTC"
func validateTimezone(val interface{}, key string) (warns []string, errs []error) <span class="cov0" title="0">{
        timezone := val.(string)
        if timezone == "" </span><span class="cov0" title="0">{
                return warns, errs
        }</span>

        // Common validation patterns for IANA timezone format
        // IANA timezones are in format: Area/Location or Area/Location/Sublocation
        // Examples: America/New_York, Asia/Kolkata, Europe/London, UTC, GMT

        // Check for basic IANA timezone format
        // Valid patterns: UTC, GMT, or Area/Location format
        <span class="cov0" title="0">if timezone == "UTC" || timezone == "GMT" </span><span class="cov0" title="0">{
                return warns, errs
        }</span>

        // Check if it contains at least one '/' for Area/Location format
        <span class="cov0" title="0">if !strings.Contains(timezone, "/") </span><span class="cov0" title="0">{
                errs = append(errs, fmt.Errorf(
                        "%q must be a valid IANA timezone string (e.g., 'America/New_York', 'Asia/Kolkata', 'Europe/London', 'UTC'). Got: %s",
                        key, timezone))
                return warns, errs
        }</span>

        // Additional validation: timezone shouldn't have spaces or invalid characters
        <span class="cov0" title="0">if strings.Contains(timezone, " ") </span><span class="cov0" title="0">{
                errs = append(errs, fmt.Errorf(
                        "%q timezone cannot contain spaces. Got: %s", key, timezone))
                return warns, errs
        }</span>

        <span class="cov0" title="0">return warns, errs</span>
}

// ValidateClusterTypeUpdate checks if cluster_type has been modified during an update operation.
// Returns an error if the cluster_type field has changed, as it is a create-only field.
func ValidateClusterTypeUpdate(d *schema.ResourceData) error <span class="cov0" title="0">{
        if d.HasChange("cluster_type") </span><span class="cov0" title="0">{
                oldVal, newVal := d.GetChange("cluster_type")
                return fmt.Errorf("cluster_type cannot be modified after cluster creation. "+
                        "Current value: %q, attempted new value: %q. "+
                        "To change the cluster type, you must delete and recreate the cluster", oldVal, newVal)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package spectrocloud

import (
        "context"
        "errors"
        "log"
        "time"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/spectrocloud/palette-sdk-go/api/models"
        "github.com/spectrocloud/palette-sdk-go/client"
)

var resourceAddonDeploymentCreatePendingStates = []string{
        "Node:NotReady",
        "Pack:Error",
        "PackPending",
        "Pack:NotReady",
        "Profile:NotAttached",
}

func waitForAddonDeployment(ctx context.Context, d *schema.ResourceData, cl models.V1SpectroCluster, profile_uid string, diags diag.Diagnostics, c *client.V1Client, state string) (diag.Diagnostics, bool) <span class="cov0" title="0">{
        cluster, err := c.GetCluster(cl.Metadata.UID)
        if err != nil </span><span class="cov0" title="0">{
                return diags, true
        }</span>

        <span class="cov0" title="0">if _, found := cluster.Metadata.Labels["skip_packs"]; found </span><span class="cov0" title="0">{
                return diags, true
        }</span>

        <span class="cov0" title="0">stateConf := &amp;retry.StateChangeConf{
                Pending:    resourceAddonDeploymentCreatePendingStates,
                Target:     []string{"True"},
                Refresh:    resourceAddonDeploymentStateRefreshFunc(c, *cluster, profile_uid),
                Timeout:    d.Timeout(state) - 1*time.Minute,
                MinTimeout: 10 * time.Second,
                Delay:      30 * time.Second,
        }

        // Wait, catching any errors
        _, err = stateConf.WaitForStateContext(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err), true
        }</span>
        <span class="cov0" title="0">return nil, false</span>
}

func waitForAddonDeploymentCreation(ctx context.Context, d *schema.ResourceData, cluster models.V1SpectroCluster, profile_uid string, diags diag.Diagnostics, c *client.V1Client) (diag.Diagnostics, bool) <span class="cov0" title="0">{
        return waitForAddonDeployment(ctx, d, cluster, profile_uid, diags, c, schema.TimeoutCreate)
}</span>

func waitForAddonDeploymentUpdate(ctx context.Context, d *schema.ResourceData, cluster models.V1SpectroCluster, profile_uid string, diags diag.Diagnostics, c *client.V1Client) (diag.Diagnostics, bool) <span class="cov0" title="0">{
        return waitForAddonDeployment(ctx, d, cluster, profile_uid, diags, c, schema.TimeoutUpdate)
}</span>

func resourceAddonDeploymentStateRefreshFunc(c *client.V1Client, cluster models.V1SpectroCluster, profile_uid string) retry.StateRefreshFunc <span class="cov0" title="0">{
        return func() (interface{}, string, error) </span><span class="cov0" title="0">{
                cluster, err := c.GetCluster(cluster.Metadata.UID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, "", err
                }</span> else<span class="cov0" title="0"> if cluster == nil </span><span class="cov0" title="0">{
                        return nil, "Deleted", nil
                }</span>

                // wait for nodes to be ready
                <span class="cov0" title="0">for _, node_condition := range cluster.Status.Conditions </span><span class="cov0" title="0">{
                        if *node_condition.Status != "True" </span><span class="cov0" title="0">{
                                log.Printf("Node state (%s): %s", cluster.Metadata.UID, *node_condition.Status)
                                return cluster, "Node:NotReady", nil
                        }</span>
                }

                // wait for profile to attach
                <span class="cov0" title="0">found := false
                for _, pack_status := range cluster.Status.Packs </span><span class="cov0" title="0">{
                        if pack_status.ProfileUID == profile_uid </span><span class="cov0" title="0">{
                                found = true
                        }</span>
                }

                <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                        return cluster, "Profile:NotAttached", nil
                }</span>

                <span class="cov0" title="0">for _, pack_status := range cluster.Status.Packs </span><span class="cov0" title="0">{
                        if pack_status.ProfileUID == profile_uid </span><span class="cov0" title="0">{ // check only packs within this profile
                                log.Printf("Pack state (%s): %s, %s", cluster.Metadata.UID, pack_status.Name, *pack_status.Condition.Status)
                                if *pack_status.Condition.Type == "Error" </span><span class="cov0" title="0">{
                                        return cluster, "Pack:Error", errors.New(pack_status.Condition.Message)
                                }</span>
                                <span class="cov0" title="0">if *pack_status.Condition.Status != "True" || *pack_status.Condition.Type != "Ready" </span><span class="cov0" title="0">{
                                        return cluster, "Pack:NotReady", nil
                                }</span>
                        }
                }

                <span class="cov0" title="0">return cluster, "True", nil</span>
        }
}

func resourceAddonDeploymentDelete(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        resourceContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, resourceContext)

        var diags diag.Diagnostics
        clusterUid := d.Get("cluster_uid").(string)

        cluster, err := c.GetCluster(clusterUid)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span> else<span class="cov0" title="0"> if cluster == nil </span><span class="cov0" title="0">{
                return diags
        }</span>

        // Get single profile UID from the resource ID
        <span class="cov0" title="0">profileId, err := getClusterProfileUID(d.Id())
        if err != nil </span><span class="cov0" title="0">{
                return diags
        }</span>

        <span class="cov0" title="0">log.Printf("Deleting addon profile %s from cluster %s", profileId, clusterUid)
        err = c.DeleteAddonDeployment(clusterUid, &amp;models.V1SpectroClusterProfilesDeleteEntity{
                ProfileUids: []string{profileId},
        })
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">return diags</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package spectrocloud

import (
        "context"
        "errors"
        "fmt"
        "log"
        "time"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/spectrocloud/palette-sdk-go/api/models"
        "github.com/spectrocloud/palette-sdk-go/client"
)

var resourceClusterReadyPendingStates = []string{
        "NotReady",
}

var resourceClusterDeletePendingStates = []string{
        "Pending",
        "Provisioning",
        "Running",
        "Deleting",
        "Importing",
}
var resourceClusterCreatePendingStates = []string{
        "Unknown",
        "Pending",
        "Running",
        "Provisioning",
        "Importing",
}

var virtualClusterLifecycleStates = []string{
        "Resuming",
        "Pausing",
        "Paused",
}

func waitForClusterReady(ctx context.Context, d *schema.ResourceData, uid string, diags diag.Diagnostics, c *client.V1Client) (diag.Diagnostics, bool) <span class="cov0" title="0">{
        d.SetId(uid)

        stateConf := &amp;retry.StateChangeConf{
                Pending:    resourceClusterReadyPendingStates,
                Target:     []string{"Ready"},
                Refresh:    resourceClusterReadyRefreshFunc(c, d.Id()),
                Timeout:    d.Timeout(schema.TimeoutCreate) - 1*time.Minute,
                MinTimeout: 10 * time.Second,
                Delay:      30 * time.Second,
        }

        // Wait, catching any errors
        _, err := stateConf.WaitForStateContext(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err), true
        }</span>
        <span class="cov0" title="0">return nil, false</span>
}

func waitForVirtualClusterLifecyclePause(ctx context.Context, d *schema.ResourceData, uid string, diags diag.Diagnostics, c *client.V1Client) (diag.Diagnostics, bool) <span class="cov0" title="0">{
        clusterContext := d.Get("context").(string)

        d.SetId(uid)
        stateConf := &amp;retry.StateChangeConf{
                Pending:    virtualClusterLifecycleStates,
                Target:     []string{"Paused"},
                Refresh:    resourceVirtualClusterLifecycleStateRefreshFunc(c, clusterContext, d.Id()),
                Timeout:    d.Timeout(schema.TimeoutCreate) - 1*time.Minute,
                MinTimeout: 10 * time.Second,
                Delay:      30 * time.Second,
        }

        // Wait, catching any errors
        _, err := stateConf.WaitForStateContext(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err), true
        }</span>
        <span class="cov0" title="0">return nil, false</span>
}
func waitForVirtualClusterLifecycleResume(ctx context.Context, d *schema.ResourceData, uid string, diags diag.Diagnostics, c *client.V1Client) (diag.Diagnostics, bool) <span class="cov0" title="0">{
        clusterContext := d.Get("context").(string)

        d.SetId(uid)
        stateConf := &amp;retry.StateChangeConf{
                Pending:    virtualClusterLifecycleStates,
                Target:     []string{"Running"},
                Refresh:    resourceVirtualClusterLifecycleStateRefreshFunc(c, clusterContext, d.Id()),
                Timeout:    d.Timeout(schema.TimeoutCreate) - 1*time.Minute,
                MinTimeout: 10 * time.Second,
                Delay:      30 * time.Second,
        }

        // Wait, catching any errors
        _, err := stateConf.WaitForStateContext(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err), true
        }</span>
        <span class="cov0" title="0">return nil, false</span>
}

func resourceClusterReadyRefreshFunc(c *client.V1Client, id string) retry.StateRefreshFunc <span class="cov0" title="0">{
        return func() (interface{}, string, error) </span><span class="cov0" title="0">{
                cluster, err := c.GetClusterWithoutStatus(id)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, "", err
                }</span> else<span class="cov0" title="0"> if cluster == nil || cluster.Status == nil </span><span class="cov0" title="0">{
                        return nil, "NotReady", nil
                }</span>
                <span class="cov0" title="0">return cluster, "Ready", nil</span>
        }
}

func waitForClusterCreation(ctx context.Context, d *schema.ResourceData, uid string, diags diag.Diagnostics, c *client.V1Client, initial bool) (diag.Diagnostics, bool) <span class="cov0" title="0">{
        d.SetId(uid)

        if initial </span><span class="cov0" title="0">{ // only skip_completion when initially creating a cluster, do not skip when attach addon profile
                if d.Get("skip_completion") != nil &amp;&amp; d.Get("skip_completion").(bool) </span><span class="cov0" title="0">{
                        return diags, true
                }</span>

                <span class="cov0" title="0">if _, found := toTags(d)["skip_completion"]; found </span><span class="cov0" title="0">{
                        return diags, true
                }</span>
        }

        <span class="cov0" title="0">diagnostics, isError := waitForClusterReady(ctx, d, uid, diags, c)
        if isError </span><span class="cov0" title="0">{
                return diagnostics, true
        }</span>

        <span class="cov0" title="0">stateConf := &amp;retry.StateChangeConf{
                Pending:    resourceClusterCreatePendingStates,
                Target:     []string{"Running-Healthy"},
                Refresh:    resourceClusterStateRefreshFunc(c, d.Id()),
                Timeout:    d.Timeout(schema.TimeoutCreate) - 1*time.Minute,
                MinTimeout: 10 * time.Second,
                Delay:      30 * time.Second,
        }

        // Wait, catching any errors
        _, err := stateConf.WaitForStateContext(ctx)
        if err != nil </span><span class="cov0" title="0">{
                // Always handle timeout errors gracefully (default behavior)
                var timeoutErr *retry.TimeoutError
                if errors.As(err, &amp;timeoutErr) </span><span class="cov0" title="0">{
                        log.Printf("waitForClusterCreation (Running-Healthy phase): timeout occurred, returning warning instead of error")

                        // Get current cluster state for warning message
                        cluster, stateErr := c.GetCluster(d.Id())
                        currentState := timeoutErr.LastState
                        if currentState == "" </span><span class="cov0" title="0">{
                                currentState = "Unknown"
                        }</span>
                        <span class="cov0" title="0">if stateErr == nil &amp;&amp; cluster != nil &amp;&amp; cluster.Status != nil </span><span class="cov0" title="0">{
                                currentState = cluster.Status.State
                                if cluster.Status.State == "Running" </span><span class="cov0" title="0">{
                                        if clusterSummary, _ := c.GetClusterOverview(d.Id()); clusterSummary != nil &amp;&amp; clusterSummary.Status.Health != nil </span><span class="cov0" title="0">{
                                                if clusterSummary.Status.Health.State != "" &amp;&amp; clusterSummary.Status.Health.State != "Healthy" </span><span class="cov0" title="0">{
                                                        currentState += "-" + clusterSummary.Status.Health.State
                                                }</span>
                                        }
                                }
                        }

                        // Always return warning instead of error for timeout
                        <span class="cov0" title="0">diags = append(diags, diag.Diagnostic{
                                Severity: diag.Warning,
                                Summary:  "Cluster creation timeout",
                                Detail: fmt.Sprintf(
                                        "Cluster creation timed out after waiting for %v. Current cluster state is '%s'. "+
                                                "The cluster may still be provisioning in the background and could eventually reach the 'Running-Healthy' state.",
                                        d.Timeout(schema.TimeoutCreate)-1*time.Minute, currentState),
                        })
                        return diags, false</span>
                }
                // For non-timeout errors, still return the error
                <span class="cov0" title="0">return diag.FromErr(err), true</span>
        }
        <span class="cov0" title="0">return nil, false</span>
}

//        var resourceClusterUpdatePendingStates = []string{
//                "backing-up",
//                "modifying",
//                "resetting-master-credentials",
//                "upgrading",
//        }
func waitForClusterDeletion(ctx context.Context, c *client.V1Client, scope, id string, timeout time.Duration) error <span class="cov0" title="0">{
        stateConf := &amp;retry.StateChangeConf{
                Pending:    resourceClusterDeletePendingStates,
                Target:     nil, // wait for deleted
                Refresh:    resourceClusterStateRefreshFunc(c, id),
                Timeout:    timeout,
                MinTimeout: 10 * time.Second,
                Delay:      30 * time.Second,
        }

        _, err := stateConf.WaitForStateContext(ctx)

        return err
}</span>

func resourceClusterStateRefreshFunc(c *client.V1Client, id string) retry.StateRefreshFunc <span class="cov0" title="0">{
        return func() (interface{}, string, error) </span><span class="cov0" title="0">{
                cluster, err := c.GetCluster(id)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, "", err
                }</span> else<span class="cov0" title="0"> if cluster == nil </span><span class="cov0" title="0">{
                        return nil, "Deleted", nil
                }</span>

                <span class="cov0" title="0">state := cluster.Status.State
                if cluster.Status.State == "Running" </span><span class="cov0" title="0">{
                        clusterSummary, _ := c.GetClusterOverview(id)
                        if clusterSummary.Status.Health != nil &amp;&amp; clusterSummary.Status.Health.State != "" </span><span class="cov0" title="0">{
                                if clusterSummary.Status.Health.State == "Healthy" </span><span class="cov0" title="0">{
                                        state += "-" + clusterSummary.Status.Health.State
                                }</span>
                        }
                }

                <span class="cov0" title="0">log.Printf("Cluster state (%s): %s", id, state)

                return cluster, state, nil</span>
        }
}

func resourceVirtualClusterLifecycleStateRefreshFunc(c *client.V1Client, scope, id string) retry.StateRefreshFunc <span class="cov0" title="0">{
        return func() (interface{}, string, error) </span><span class="cov0" title="0">{
                cluster, err := c.GetCluster(id)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, "", err
                }</span> else<span class="cov0" title="0"> if cluster == nil </span><span class="cov0" title="0">{
                        return nil, "Deleted", nil
                }</span>

                <span class="cov0" title="0">state := cluster.Status.Virtual.LifecycleStatus.Status
                log.Printf("Cluster state (%s): %s", id, state)

                return cluster, state, nil</span>
        }
}

func resourceClusterRead(d *schema.ResourceData, c *client.V1Client, diags diag.Diagnostics) (*models.V1SpectroCluster, error) <span class="cov0" title="0">{
        uid := d.Id()

        //clusterContext := "project"
        //if v, ok := d.GetOk("context"); ok {
        //        clusterContext = v.(string)
        //}
        cluster, err := c.GetCluster(uid)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return cluster, nil</span>
}

func resourceClusterDelete(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        resourceContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, resourceContext)
        var diags diag.Diagnostics
        var err error
        clusterContext := d.Get("context").(string)
        if forceDelete, ok := d.GetOk("force_delete"); ok &amp;&amp; forceDelete == true </span><span class="cov0" title="0">{
                forceDeleteDelay := d.Get("force_delete_delay").(int)
                forceDeleteDelaDuration := time.Duration(forceDeleteDelay) * time.Minute
                if forceDeleteDelaDuration &lt;= d.Timeout(schema.TimeoutDelete) </span><span class="cov0" title="0">{
                        err = c.DeleteCluster(d.Id())
                        if err != nil </span><span class="cov0" title="0">{
                                return diag.FromErr(err)
                        }</span>
                        <span class="cov0" title="0">err = waitForClusterDeletion(ctx, c, clusterContext, d.Id(), forceDeleteDelaDuration) // It will wait for 20 minutes by default and try force_delete
                        if err != nil </span><span class="cov0" title="0">{
                                err = c.ForceDeleteCluster(d.Id(), true)
                                if err != nil </span><span class="cov0" title="0">{
                                        return diag.FromErr(err)
                                }</span>
                        }
                } else<span class="cov0" title="0"> {
                        diags = append(diags, diag.Diagnostic{
                                Severity: diag.Error,
                                Summary:  "Force delete validation failed",
                                Detail:   "`force_delete_delay` is should not be greater than default delete timeout.",
                        })
                        return diags
                }</span>
        } else<span class="cov0" title="0"> {
                err = c.DeleteCluster(d.Id())
                if err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
        }
        <span class="cov0" title="0">if err := waitForClusterDeletion(ctx, c, clusterContext, d.Id(), d.Timeout(schema.TimeoutDelete)); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">return diags</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package spectrocloud

import (
        "errors"
        "fmt"
        "strings"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/spectrocloud/palette-sdk-go/api/models"
        "github.com/spectrocloud/palette-sdk-go/client"
)

// read common fields like kubeconfig, tags, backup policy, scan policy, cluster_rbac_binding, namespaces
func readCommonFields(c *client.V1Client, d *schema.ResourceData, cluster *models.V1SpectroCluster) (diag.Diagnostics, bool) <span class="cov0" title="0">{
        //ClusterContext := "project"
        //if cluster.Metadata.Annotations["scope"] != "" {
        //        ClusterContext = cluster.Metadata.Annotations["scope"]
        //}
        kubecfg, err := c.GetClusterClientKubeConfig(d.Id())
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err), true
        }</span>
        <span class="cov0" title="0">if err := d.Set("kubeconfig", kubecfg); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err), true
        }</span>
        // When the current repave state is pending, we set the review_repave_state to Pending, For indicate the system change.
        <span class="cov0" title="0">if _, ok := d.GetOk("review_repave_state"); ok </span><span class="cov0" title="0">{
                // We are adding this check to handle virtual cluster scenario. virtual cluster doesn't have support for `review_repave_state`
                if err := d.Set("review_repave_state", cluster.Status.Repave.State); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err), true
                }</span>
        }
        <span class="cov0" title="0">adminKubeConfig, err := c.GetClusterAdminKubeConfig(d.Id())
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err), true
        }</span>
        <span class="cov0" title="0">if err := d.Set("admin_kube_config", adminKubeConfig); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err), true
        }</span>

        <span class="cov0" title="0">if err := d.Set("tags", flattenTags(cluster.Metadata.Labels)); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err), true
        }</span>

        <span class="cov0" title="0">if policy, err := c.GetClusterBackupConfig(d.Id()); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err), true
        }</span> else<span class="cov0" title="0"> if policy != nil &amp;&amp; policy.Spec.Config != nil </span><span class="cov0" title="0">{
                if err := d.Set("backup_policy", flattenBackupPolicy(policy.Spec.Config, d)); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err), true
                }</span>
        }

        <span class="cov0" title="0">if policy, err := c.GetClusterScanConfig(d.Id()); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err), true
        }</span> else<span class="cov0" title="0"> if policy != nil &amp;&amp; policy.Spec.DriverSpec != nil </span><span class="cov0" title="0">{
                if err := d.Set("scan_policy", flattenScanPolicy(policy.Spec.DriverSpec)); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err), true
                }</span>
        }

        <span class="cov0" title="0">if rbac, err := c.GetClusterRbacConfig(d.Id()); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err), true
        }</span> else<span class="cov0" title="0"> if rbac != nil &amp;&amp; rbac.Items != nil </span><span class="cov0" title="0">{
                if err := d.Set("cluster_rbac_binding", flattenClusterRBAC(rbac.Items)); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err), true
                }</span>
        }

        <span class="cov0" title="0">if namespace, err := c.GetClusterNamespaceConfig(d.Id()); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err), true
        }</span> else<span class="cov0" title="0"> if namespace != nil &amp;&amp; namespace.Items != nil </span><span class="cov0" title="0">{
                if err := d.Set("namespaces", flattenClusterNamespaces(namespace.Items)); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err), true
                }</span>
        }

        <span class="cov0" title="0">clusterAdditionalMeta := cluster.Spec.ClusterConfig.ClusterMetaAttribute
        if clusterAdditionalMeta != "" </span><span class="cov0" title="0">{
                // We are adding this check to handle virtual cluster scenario. virtual cluster doesn't have support for `cluster_meta_attribute`
                if _, ok := d.GetOk("cluster_meta_attribute"); ok </span><span class="cov0" title="0">{
                        err := d.Set("cluster_meta_attribute", clusterAdditionalMeta)
                        if err != nil </span><span class="cov0" title="0">{
                                return diag.FromErr(err), true
                        }</span>
                }
        }

        // Flatten update_worker_pools_in_parallel - always set during read (including import)
        // This field is not present in all cluster types (e.g., EKS doesn't have it)
        <span class="cov0" title="0">if _, ok := d.GetOk("update_worker_pools_in_parallel"); ok </span><span class="cov0" title="0">{
                if err := d.Set("update_worker_pools_in_parallel", cluster.Spec.ClusterConfig.UpdateWorkerPoolsInParallel); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err), true
                }</span>
        }

        // Flatten cluster_timezone - always set during read (including import)
        <span class="cov0" title="0">if cluster.Spec.ClusterConfig.Timezone != "" </span><span class="cov0" title="0">{
                if _, ok := d.GetOk("cluster_timezone"); ok </span><span class="cov0" title="0">{
                        if err := d.Set("cluster_timezone", cluster.Spec.ClusterConfig.Timezone); err != nil </span><span class="cov0" title="0">{
                                return diag.FromErr(err), true
                        }</span>
                }
        }

        // Flatten pause_agent_upgrades - always set during read (including import)
        <span class="cov0" title="0">if err := d.Set("pause_agent_upgrades", getSpectroComponentsUpgrade(cluster)); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err), true
        }</span>

        <span class="cov0" title="0">hostConfig := cluster.Spec.ClusterConfig.HostClusterConfig
        if hostConfig != nil &amp;&amp; *hostConfig.IsHostCluster </span><span class="cov0" title="0">{
                flattenHostConfig := flattenHostConfig(hostConfig)
                if len(flattenHostConfig) &gt; 0 </span><span class="cov0" title="0">{
                        if err := d.Set("host_config", flattenHostConfig); err != nil </span><span class="cov0" title="0">{
                                return diag.FromErr(err), true
                        }</span>
                }
        }

        <span class="cov0" title="0">if _, ok := d.GetOk("review_repave_state"); ok </span><span class="cov0" title="0">{
                if err := d.Set("review_repave_state", cluster.Status.Repave.State); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err), true
                }</span>
        }

        //clusterContext := d.Get("context").(string)

        <span class="cov0" title="0">if clusterStatus, err := c.GetClusterWithoutStatus(d.Id()); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err), true
        }</span> else<span class="cov0" title="0"> if clusterStatus != nil &amp;&amp; clusterStatus.Status != nil &amp;&amp; clusterStatus.Status.Location != nil </span><span class="cov0" title="0">{
                if err := d.Set("location_config", flattenLocationConfig(clusterStatus.Status.Location)); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err), true
                }</span>
        }

        // Flatten cluster_type from the cluster spec (read-only after creation)
        <span class="cov0" title="0">if _, ok := d.GetOk("cluster_type"); ok &amp;&amp; cluster.Spec != nil &amp;&amp; cluster.Spec.ClusterType != "" </span><span class="cov0" title="0">{
                if err := d.Set("cluster_type", cluster.Spec.ClusterType); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err), true
                }</span>
        }

        <span class="cov0" title="0">return diag.Diagnostics{}, false</span>
}

func getSpectroComponentsUpgrade(cluster *models.V1SpectroCluster) string <span class="cov0" title="0">{
        if cluster.Metadata.Annotations != nil </span><span class="cov0" title="0">{
                clusterAnnotation := cluster.Metadata.Annotations
                if v, ok := clusterAnnotation["spectroComponentsUpgradeForbidden"]; ok </span><span class="cov0" title="0">{
                        if v == "true" </span><span class="cov0" title="0">{
                                return "lock"
                        }</span>
                        <span class="cov0" title="0">return "unlock"</span>
                }
        }
        <span class="cov0" title="0">return "unlock"</span>
}

func updateCommonFieldsForBrownfieldCluster(d *schema.ResourceData, c *client.V1Client) diag.Diagnostics <span class="cov0" title="0">{
        _ = updateClusterMetadata(c, d)
        _ = updateClusterNamespaces(c, d)
        _ = updateClusterRBAC(c, d)
        _ = updateProfiles(c, d)
        if _, ok := d.GetOk("backup_policy"); ok </span><span class="cov0" title="0">{
                _ = updateBackupPolicy(c, d)
        }</span>
        <span class="cov0" title="0">if _, ok := d.GetOk("scan_policy"); ok </span><span class="cov0" title="0">{
                _ = updateScanPolicy(c, d)
        }</span>
        <span class="cov0" title="0">_ = updateAgentUpgradeSetting(c, d)
        _ = updateClusterTimezone(c, d)
        return diag.Diagnostics{}</span>
}

// update common fields like namespaces, cluster_rbac_binding, cluster_profile, backup_policy, scan_policy
func updateCommonFields(d *schema.ResourceData, c *client.V1Client) (diag.Diagnostics, bool) <span class="cov0" title="0">{
        if d.HasChanges("name", "tags", "description", "tags_map") </span><span class="cov0" title="0">{
                if err := updateClusterMetadata(c, d); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err), true
                }</span>
        }

        <span class="cov0" title="0">if d.HasChange("namespaces") </span><span class="cov0" title="0">{
                if err := updateClusterNamespaces(c, d); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err), true
                }</span>
        }

        <span class="cov0" title="0">if d.HasChange("cluster_rbac_binding") </span><span class="cov0" title="0">{
                if err := updateClusterRBAC(c, d); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err), true
                }</span>
        }

        <span class="cov0" title="0">if d.HasChange("os_patch_on_boot") || d.HasChange("os_patch_schedule") || d.HasChange("os_patch_after") </span><span class="cov0" title="0">{
                if err := updateClusterOsPatchConfig(c, d); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err), true
                }</span>
        }

        // Handle cluster_template changes separately using variables API (doesn't trigger full cluster update)
        <span class="cov0" title="0">if d.HasChange("cluster_template") </span><span class="cov0" title="0">{
                if err := updateClusterTemplateVariables(c, d); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err), true
                }</span>
        }

        // Handle cluster_profile changes using the existing profile update flow
        <span class="cov0" title="0">if d.HasChanges("cluster_profile", "packs", "manifests") </span><span class="cov0" title="0">{
                if err := updateProfiles(c, d); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err), true
                }</span>
        }

        <span class="cov0" title="0">if d.HasChange("backup_policy") </span><span class="cov0" title="0">{
                if err := updateBackupPolicy(c, d); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err), true
                }</span>
        }

        <span class="cov0" title="0">if d.HasChange("scan_policy") </span><span class="cov0" title="0">{
                if err := updateScanPolicy(c, d); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err), true
                }</span>
        }

        <span class="cov0" title="0">if d.HasChange("host_config") </span><span class="cov0" title="0">{
                if err := updateHostConfig(c, d); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err), true
                }</span>
        }

        <span class="cov0" title="0">if d.HasChange("pause_agent_upgrades") </span><span class="cov0" title="0">{
                if err := updateAgentUpgradeSetting(c, d); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err), true
                }</span>
        }

        <span class="cov0" title="0">if d.HasChange("cluster_meta_attribute") </span><span class="cov0" title="0">{
                if err := updateClusterAdditionalMetadata(c, d); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err), true
                }</span>
        }

        <span class="cov0" title="0">if d.HasChange("location_config") </span><span class="cov0" title="0">{
                if err := updateLocationConfig(c, d); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err), true
                }</span>
        }

        <span class="cov0" title="0">if d.HasChange("cluster_timezone") </span><span class="cov0" title="0">{
                if err := updateClusterTimezone(c, d); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err), true
                }</span>
        }

        <span class="cov0" title="0">return diag.Diagnostics{}, false</span>
}

func validateSystemRepaveApproval(d *schema.ResourceData, c *client.V1Client) error <span class="cov0" title="0">{
        approveClusterRepave := d.Get("review_repave_state").(string)
        //context := d.Get("context").(string)
        cluster, err := c.GetCluster(d.Id())
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if cluster == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">if cluster.Status.Repave.State != nil </span><span class="cov0" title="0">{
                if *cluster.Status.Repave.State == models.V1ClusterRepaveStatePending </span><span class="cov0" title="0">{
                        if approveClusterRepave == "Approved" </span><span class="cov0" title="0">{
                                err := c.ApproveClusterRepave(d.Id())
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov0" title="0">cluster, err := c.GetCluster(d.Id())
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov0" title="0">if *cluster.Status.Repave.State == models.V1ClusterRepaveStateApproved </span><span class="cov0" title="0">{
                                        return nil
                                }</span> else<span class="cov0" title="0"> {
                                        err = errors.New("repave cluster is not approved - cluster repave state is still not approved. Please set `review_repave_state` to `Approved` to approve the repave operation on the cluster")
                                        return err
                                }</span>
                        } else<span class="cov0" title="0"> {
                                reasons, err := c.GetRepaveReasons(d.Id())
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov0" title="0">err = errors.New("cluster repave state is pending. \nDue to the following reasons -  \n" + strings.Join(reasons, "\n") + "\nKindly verify the cluster and set `review_repave_state` to `Approved` to continue the repave operation and day 2 operation on the cluster.")
                                return err</span>
                        }
                }
        }

        <span class="cov0" title="0">return nil</span>
}

func validateReviewRepaveValue(val interface{}, key string) (warns []string, errs []error) <span class="cov0" title="0">{
        repaveValue := val.(string)
        validStatuses := map[string]bool{
                "":         true,
                "Approved": true,
                "Pending":  true,
        }
        if repaveValue == "Approved" </span><span class="cov0" title="0">{
                warning := []string{"Review Repave Value Warning:",
                        "Setting `review_repave_state` to `Approved` will authorize the palette to repave the cluster if any system repave is in the pending state. Please exercise caution when using `review_repave_state` attribute."}
                warns = append(warns, strings.Join(warning, "\n"))
        }</span>
        <span class="cov0" title="0">if _, ok := validStatuses[repaveValue]; !ok </span><span class="cov0" title="0">{
                errs = append(errs, fmt.Errorf("expected review_repave_state to be one of [``, `Pending`, `Approved`], got %s", repaveValue))
        }</span>
        <span class="cov0" title="0">return warns, errs</span>
}

// validateOverrideScaling validates that when update_strategy is set to "OverrideScaling",
// the override_scaling attribute must be specified with both max_surge and max_unavailable.
func validateOverrideScaling(d *schema.ResourceData, machinePoolKey string) error <span class="cov0" title="0">{
        if machinePools, ok := d.GetOk(machinePoolKey); ok </span><span class="cov0" title="0">{
                machinePoolSet := machinePools.(*schema.Set)
                for _, mp := range machinePoolSet.List() </span><span class="cov0" title="0">{
                        machinePool := mp.(map[string]interface{})

                        updateStrategy := ""
                        if us, ok := machinePool["update_strategy"].(string); ok </span><span class="cov0" title="0">{
                                updateStrategy = us
                        }</span>

                        // If update_strategy is OverrideScaling, validate override_scaling is present
                        <span class="cov0" title="0">if updateStrategy == "OverrideScaling" </span><span class="cov0" title="0">{
                                overrideScaling, hasOverrideScaling := machinePool["override_scaling"].([]interface{})

                                if !hasOverrideScaling || len(overrideScaling) == 0 </span><span class="cov0" title="0">{
                                        poolName := machinePool["name"].(string)
                                        return fmt.Errorf("machine pool '%s': when update_strategy is 'OverrideScaling', override_scaling must be specified with both max_surge and max_unavailable", poolName)
                                }</span>

                                // Validate that both max_surge and max_unavailable are provided
                                <span class="cov0" title="0">scalingConfig := overrideScaling[0].(map[string]interface{})
                                maxSurge, hasSurge := scalingConfig["max_surge"].(string)
                                maxUnavailable, hasUnavailable := scalingConfig["max_unavailable"].(string)

                                if !hasSurge || maxSurge == "" </span><span class="cov0" title="0">{
                                        poolName := machinePool["name"].(string)
                                        return fmt.Errorf("machine pool '%s': override_scaling.max_surge is required when update_strategy is 'OverrideScaling'", poolName)
                                }</span>

                                <span class="cov0" title="0">if !hasUnavailable || maxUnavailable == "" </span><span class="cov0" title="0">{
                                        poolName := machinePool["name"].(string)
                                        return fmt.Errorf("machine pool '%s': override_scaling.max_unavailable is required when update_strategy is 'OverrideScaling'", poolName)
                                }</span>
                        }
                }
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package spectrocloud

import (
        "bytes"
        "fmt"
        "hash/fnv"
        "sort"
        "strings"
        "time"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "gopkg.in/yaml.v3"
)

func CommonHash(nodePool map[string]interface{}) *bytes.Buffer <span class="cov0" title="0">{
        var buf bytes.Buffer

        if _, ok := nodePool["additional_labels"]; ok </span><span class="cov0" title="0">{
                buf.WriteString(HashStringMap(nodePool["additional_labels"]))
        }</span>
        <span class="cov0" title="0">if _, ok := nodePool["taints"]; ok </span><span class="cov0" title="0">{
                buf.WriteString(HashStringMapList(nodePool["taints"]))
        }</span>
        <span class="cov0" title="0">if val, ok := nodePool["control_plane"]; ok </span><span class="cov0" title="0">{
                var boolVal bool
                switch v := val.(type) </span>{
                case bool:<span class="cov0" title="0">
                        boolVal = v</span>
                case *bool:<span class="cov0" title="0">
                        if v != nil </span><span class="cov0" title="0">{
                                boolVal = *v
                        }</span>
                }
                <span class="cov0" title="0">buf.WriteString(fmt.Sprintf("%t-", boolVal))</span>
        }
        <span class="cov0" title="0">if val, ok := nodePool["control_plane_as_worker"]; ok </span><span class="cov0" title="0">{
                var boolVal bool
                switch v := val.(type) </span>{
                case bool:<span class="cov0" title="0">
                        boolVal = v</span>
                case *bool:<span class="cov0" title="0">
                        if v != nil </span><span class="cov0" title="0">{
                                boolVal = *v
                        }</span>
                }
                <span class="cov0" title="0">buf.WriteString(fmt.Sprintf("%t-", boolVal))</span>
        }
        <span class="cov0" title="0">if val, ok := nodePool["name"]; ok </span><span class="cov0" title="0">{
                buf.WriteString(fmt.Sprintf("%s-", val.(string)))
        }</span>
        <span class="cov0" title="0">if val, ok := nodePool["count"]; ok </span><span class="cov0" title="0">{
                buf.WriteString(fmt.Sprintf("%d-", val.(int)))
        }</span>
        <span class="cov0" title="0">if val, ok := nodePool["update_strategy"]; ok </span><span class="cov0" title="0">{
                buf.WriteString(fmt.Sprintf("%s-", val.(string)))
        }</span>
        // Hash override_scaling if present
        <span class="cov0" title="0">if overrideScaling, ok := nodePool["override_scaling"].([]interface{}); ok &amp;&amp; len(overrideScaling) &gt; 0 </span><span class="cov0" title="0">{
                scalingConfig := overrideScaling[0].(map[string]interface{})
                if maxSurge, ok := scalingConfig["max_surge"].(string); ok &amp;&amp; maxSurge != "" </span><span class="cov0" title="0">{
                        buf.WriteString(fmt.Sprintf("max_surge:%s-", maxSurge))
                }</span>
                <span class="cov0" title="0">if maxUnavailable, ok := scalingConfig["max_unavailable"].(string); ok &amp;&amp; maxUnavailable != "" </span><span class="cov0" title="0">{
                        buf.WriteString(fmt.Sprintf("max_unavailable:%s-", maxUnavailable))
                }</span>
        }
        <span class="cov0" title="0">if val, ok := nodePool["node_repave_interval"]; ok </span><span class="cov0" title="0">{
                buf.WriteString(fmt.Sprintf("%d-", val.(int)))
        }</span>
        /*if val, ok := nodePool["instance_type"]; ok {
                buf.WriteString(fmt.Sprintf("%s-", val.(string)))
        }
        if val, ok := nodePool["azs"]; ok {
                buf.WriteString(fmt.Sprintf("%s-", val.(string)))
        }*/
        <span class="cov0" title="0">if val, ok := nodePool["min"]; ok </span><span class="cov0" title="0">{
                buf.WriteString(fmt.Sprintf("%d-", val.(int)))
        }</span>
        <span class="cov0" title="0">if val, ok := nodePool["max"]; ok </span><span class="cov0" title="0">{
                buf.WriteString(fmt.Sprintf("%d-", val.(int)))
        }</span>
        <span class="cov0" title="0">if _, ok := nodePool["node"]; ok </span><span class="cov0" title="0">{
                buf.WriteString(HashStringMapList(nodePool["node"]))
        }</span>

        <span class="cov0" title="0">return &amp;buf</span>
}

func resourceMachinePoolAzureHash(v interface{}) int <span class="cov0" title="0">{
        m := v.(map[string]interface{})
        buf := CommonHash(m)

        // Hash additional annotations and override_kubeadm_configuration
        if _, ok := m["additional_annotations"]; ok </span><span class="cov0" title="0">{
                buf.WriteString(HashStringMap(m["additional_annotations"]))
        }</span>
        <span class="cov0" title="0">if val, ok := m["override_kubeadm_configuration"].(string); ok &amp;&amp; val != "" </span><span class="cov0" title="0">{
                fmt.Fprintf(buf, "%s-", val)
        }</span>

        <span class="cov0" title="0">if val, ok := m["instance_type"]; ok </span><span class="cov0" title="0">{
                fmt.Fprintf(buf, "%s-", val.(string))
        }</span>
        <span class="cov0" title="0">if val, ok := m["is_system_node_pool"]; ok </span><span class="cov0" title="0">{
                var boolVal bool
                switch v := val.(type) </span>{
                case bool:<span class="cov0" title="0">
                        boolVal = v</span>
                case *bool:<span class="cov0" title="0">
                        if v != nil </span><span class="cov0" title="0">{
                                boolVal = *v
                        }</span>
                }
                <span class="cov0" title="0">fmt.Fprintf(buf, "%t-", boolVal)</span>
        }
        <span class="cov0" title="0">if val, ok := m["os_type"]; ok &amp;&amp; val != "" </span><span class="cov0" title="0">{
                fmt.Fprintf(buf, "%s-", val.(string))
        }</span>

        <span class="cov0" title="0">return int(hash(buf.String()))</span>
}

func resourceMachinePoolAksHash(v interface{}) int <span class="cov0" title="0">{
        nodePool := v.(map[string]interface{})
        var buf bytes.Buffer

        // Hash additional annotations and override_kubeadm_configuration
        if _, ok := nodePool["additional_annotations"]; ok </span><span class="cov0" title="0">{
                buf.WriteString(HashStringMap(nodePool["additional_annotations"]))
        }</span>
        <span class="cov0" title="0">if val, ok := nodePool["override_kubeadm_configuration"].(string); ok &amp;&amp; val != "" </span><span class="cov0" title="0">{
                fmt.Fprintf(&amp;buf, "%s-", val)
        }</span>

        // Include all fields that should trigger a machine pool update
        <span class="cov0" title="0">if val, ok := nodePool["name"]; ok </span><span class="cov0" title="0">{
                buf.WriteString(fmt.Sprintf("%s-", val.(string)))
        }</span>
        <span class="cov0" title="0">if val, ok := nodePool["count"]; ok </span><span class="cov0" title="0">{
                buf.WriteString(fmt.Sprintf("%d-", val.(int)))
        }</span>
        <span class="cov0" title="0">if val, ok := nodePool["instance_type"]; ok </span><span class="cov0" title="0">{
                buf.WriteString(fmt.Sprintf("%s-", val.(string)))
        }</span>
        <span class="cov0" title="0">if val, ok := nodePool["disk_size_gb"]; ok </span><span class="cov0" title="0">{
                buf.WriteString(fmt.Sprintf("%d-", val.(int)))
        }</span>
        <span class="cov0" title="0">if val, ok := nodePool["is_system_node_pool"]; ok </span><span class="cov0" title="0">{
                var boolVal bool
                switch v := val.(type) </span>{
                case bool:<span class="cov0" title="0">
                        boolVal = v</span>
                case *bool:<span class="cov0" title="0">
                        if v != nil </span><span class="cov0" title="0">{
                                boolVal = *v
                        }</span>
                }
                <span class="cov0" title="0">buf.WriteString(fmt.Sprintf("%t-", boolVal))</span>
        }
        <span class="cov0" title="0">if val, ok := nodePool["storage_account_type"]; ok </span><span class="cov0" title="0">{
                buf.WriteString(fmt.Sprintf("%s-", val.(string)))
        }</span>

        // Additional labels (map)
        <span class="cov0" title="0">if _, ok := nodePool["additional_labels"]; ok </span><span class="cov0" title="0">{
                buf.WriteString(HashStringMap(nodePool["additional_labels"]))
        }</span>

        // Update strategy
        <span class="cov0" title="0">if val, ok := nodePool["update_strategy"]; ok </span><span class="cov0" title="0">{
                buf.WriteString(fmt.Sprintf("%s-", val.(string)))
        }</span>

        // Hash override_scaling
        <span class="cov0" title="0">if overrideScaling, ok := nodePool["override_scaling"].([]interface{}); ok &amp;&amp; len(overrideScaling) &gt; 0 </span><span class="cov0" title="0">{
                scalingConfig := overrideScaling[0].(map[string]interface{})
                if maxSurge, ok := scalingConfig["max_surge"].(string); ok &amp;&amp; maxSurge != "" </span><span class="cov0" title="0">{
                        fmt.Fprintf(&amp;buf, "max_surge:%s-", maxSurge)
                }</span>
                <span class="cov0" title="0">if maxUnavailable, ok := scalingConfig["max_unavailable"].(string); ok &amp;&amp; maxUnavailable != "" </span><span class="cov0" title="0">{
                        fmt.Fprintf(&amp;buf, "max_unavailable:%s-", maxUnavailable)
                }</span>
        }

        // Min and Max for autoscaling
        <span class="cov0" title="0">if nodePool["min"] != nil </span><span class="cov0" title="0">{
                buf.WriteString(fmt.Sprintf("%d-", nodePool["min"].(int)))
        }</span>
        <span class="cov0" title="0">if nodePool["max"] != nil </span><span class="cov0" title="0">{
                buf.WriteString(fmt.Sprintf("%d-", nodePool["max"].(int)))
        }</span>

        // Node configuration (list of maps)
        <span class="cov0" title="0">if nodePool["node"] != nil </span><span class="cov0" title="0">{
                buf.WriteString(HashStringMapList(nodePool["node"]))
        }</span>

        // Taints (list of maps)
        <span class="cov0" title="0">if _, ok := nodePool["taints"]; ok </span><span class="cov0" title="0">{
                buf.WriteString(HashStringMapList(nodePool["taints"]))
        }</span>

        <span class="cov0" title="0">return int(hash(buf.String()))</span>
}

func resourceMachinePoolGcpHash(v interface{}) int <span class="cov0" title="0">{
        m := v.(map[string]interface{})
        buf := CommonHash(m)

        // Hash additional annotations and override_kubeadm_configuration
        if _, ok := m["additional_annotations"]; ok </span><span class="cov0" title="0">{
                buf.WriteString(HashStringMap(m["additional_annotations"]))
        }</span>
        <span class="cov0" title="0">if val, ok := m["override_kubeadm_configuration"].(string); ok &amp;&amp; val != "" </span><span class="cov0" title="0">{
                fmt.Fprintf(buf, "%s-", val)
        }</span>

        <span class="cov0" title="0">if _, ok := m["disk_size_gb"]; ok </span><span class="cov0" title="0">{
                fmt.Fprintf(buf, "%d-", m["disk_size_gb"].(int))
        }</span>

        <span class="cov0" title="0">fmt.Fprintf(buf, "%s-", m["instance_type"].(string))
        if _, ok := m["azs"]; ok </span><span class="cov0" title="0">{
                if m["azs"] != nil </span><span class="cov0" title="0">{
                        azsSet := m["azs"].(*schema.Set)
                        azsList := azsSet.List()
                        azsListStr := make([]string, len(azsList))
                        for i, v := range azsList </span><span class="cov0" title="0">{
                                azsListStr[i] = v.(string)
                        }</span>
                        <span class="cov0" title="0">sort.Strings(azsListStr)
                        azsStr := strings.Join(azsListStr, "-")
                        fmt.Fprintf(buf, "%s-", azsStr)</span>
                }
        }
        <span class="cov0" title="0">return int(hash(buf.String()))</span>
}

func resourceMachinePoolAwsHash(v interface{}) int <span class="cov0" title="0">{
        m := v.(map[string]interface{})
        buf := CommonHash(m)

        // Hash additional annotations and override_kubeadm_configuration
        if _, ok := m["additional_annotations"]; ok </span><span class="cov0" title="0">{
                buf.WriteString(HashStringMap(m["additional_annotations"]))
        }</span>
        <span class="cov0" title="0">if val, ok := m["override_kubeadm_configuration"].(string); ok &amp;&amp; val != "" </span><span class="cov0" title="0">{
                fmt.Fprintf(buf, "%s-", val)
        }</span>

        <span class="cov0" title="0">if m["min"] != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(buf, "%d-", m["min"].(int))
        }</span>
        <span class="cov0" title="0">if m["max"] != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(buf, "%d-", m["max"].(int))
        }</span>
        <span class="cov0" title="0">fmt.Fprintf(buf, "%s-", m["instance_type"].(string))
        fmt.Fprintf(buf, "%s-", m["capacity_type"].(string))
        fmt.Fprintf(buf, "%s-", m["max_price"].(string))
        if m["azs"] != nil </span><span class="cov0" title="0">{
                azsSet := m["azs"].(*schema.Set)
                azsList := azsSet.List()
                azsListStr := make([]string, len(azsList))
                for i, v := range azsList </span><span class="cov0" title="0">{
                        azsListStr[i] = v.(string)
                }</span>
                <span class="cov0" title="0">sort.Strings(azsListStr)
                azsStr := strings.Join(azsListStr, "-")
                fmt.Fprintf(buf, "%s-", azsStr)</span>
        }
        <span class="cov0" title="0">fmt.Fprintf(buf, "%s-", m["azs"].(*schema.Set).GoString())
        buf.WriteString(HashStringMap(m["az_subnets"]))

        return int(hash(buf.String()))</span>
}

func resourceMachinePoolEksHash(v interface{}) int <span class="cov0" title="0">{
        nodePool := v.(map[string]interface{})
        var buf bytes.Buffer

        // Hash additional annotations and override_kubeadm_configuration
        if _, ok := nodePool["additional_annotations"]; ok </span><span class="cov0" title="0">{
                buf.WriteString(HashStringMap(nodePool["additional_annotations"]))
        }</span>
        <span class="cov0" title="0">if val, ok := nodePool["override_kubeadm_configuration"].(string); ok &amp;&amp; val != "" </span><span class="cov0" title="0">{
                fmt.Fprintf(&amp;buf, "%s-", val)
        }</span>

        <span class="cov0" title="0">if val, ok := nodePool["count"]; ok </span><span class="cov0" title="0">{
                buf.WriteString(fmt.Sprintf("%d-", val.(int)))
        }</span>
        <span class="cov0" title="0">if val, ok := nodePool["disk_size_gb"]; ok </span><span class="cov0" title="0">{
                buf.WriteString(fmt.Sprintf("%d-", val.(int)))
        }</span>
        <span class="cov0" title="0">if val, ok := nodePool["instance_type"]; ok </span><span class="cov0" title="0">{
                buf.WriteString(fmt.Sprintf("%s-", val.(string)))
        }</span>
        <span class="cov0" title="0">if val, ok := nodePool["name"]; ok </span><span class="cov0" title="0">{
                buf.WriteString(fmt.Sprintf("%s-", val.(string)))
        }</span>

        <span class="cov0" title="0">if _, ok := nodePool["additional_labels"]; ok </span><span class="cov0" title="0">{
                buf.WriteString(HashStringMap(nodePool["additional_labels"]))
        }</span>
        <span class="cov0" title="0">if val, ok := nodePool["ami_type"]; ok </span><span class="cov0" title="0">{
                buf.WriteString(fmt.Sprintf("%s-", val.(string)))
        }</span>

        <span class="cov0" title="0">keys := make([]string, 0, len(nodePool["az_subnets"].(map[string]interface{})))
        for k := range nodePool["az_subnets"].(map[string]interface{}) </span><span class="cov0" title="0">{
                keys = append(keys, k)
        }</span>
        <span class="cov0" title="0">sort.Strings(keys)
        for _, k := range keys </span><span class="cov0" title="0">{
                buf.WriteString(fmt.Sprintf("%s-%s", k, nodePool["az_subnets"].(map[string]interface{})[k].(string)))
        }</span>

        <span class="cov0" title="0">if nodePool["azs"] != nil </span><span class="cov0" title="0">{
                azsList := nodePool["azs"].([]interface{})
                azsListStr := make([]string, len(azsList))
                for i, v := range azsList </span><span class="cov0" title="0">{
                        azsListStr[i] = v.(string)
                }</span>
                <span class="cov0" title="0">sort.Strings(azsListStr)
                azsStr := strings.Join(azsListStr, "-")
                buf.WriteString(fmt.Sprintf("%s-", azsStr))</span>
        }

        <span class="cov0" title="0">if val, ok := nodePool["capacity_type"]; ok </span><span class="cov0" title="0">{
                buf.WriteString(fmt.Sprintf("%s-", val.(string)))
        }</span>

        <span class="cov0" title="0">if nodePool["min"] != nil </span><span class="cov0" title="0">{
                buf.WriteString(fmt.Sprintf("%d-", nodePool["min"].(int)))
        }</span>
        <span class="cov0" title="0">if nodePool["max"] != nil </span><span class="cov0" title="0">{
                buf.WriteString(fmt.Sprintf("%d-", nodePool["max"].(int)))
        }</span>
        <span class="cov0" title="0">if nodePool["max_price"] != nil </span><span class="cov0" title="0">{
                buf.WriteString(fmt.Sprintf("%s-", nodePool["max_price"].(string)))
        }</span>
        <span class="cov0" title="0">if nodePool["node"] != nil </span><span class="cov0" title="0">{
                buf.WriteString(HashStringMapList(nodePool["node"]))
        }</span>
        <span class="cov0" title="0">if _, ok := nodePool["taints"]; ok </span><span class="cov0" title="0">{
                buf.WriteString(HashStringMapList(nodePool["taints"]))
        }</span>
        <span class="cov0" title="0">if nodePool["eks_launch_template"] != nil </span><span class="cov0" title="0">{
                buf.WriteString(eksLaunchTemplate(nodePool["eks_launch_template"]))
        }</span>
        <span class="cov0" title="0">if val, ok := nodePool["update_strategy"]; ok </span><span class="cov0" title="0">{
                buf.WriteString(fmt.Sprintf("%s-", val.(string)))
        }</span>

        <span class="cov0" title="0">return int(hash(buf.String()))</span>
}

func resourceMachinePoolGkeHash(v interface{}) int <span class="cov0" title="0">{
        nodePool := v.(map[string]interface{})
        var buf bytes.Buffer

        // Hash additional annotations and override_kubeadm_configuration
        if _, ok := nodePool["additional_annotations"]; ok </span><span class="cov0" title="0">{
                buf.WriteString(HashStringMap(nodePool["additional_annotations"]))
        }</span>
        <span class="cov0" title="0">if val, ok := nodePool["override_kubeadm_configuration"].(string); ok &amp;&amp; val != "" </span><span class="cov0" title="0">{
                fmt.Fprintf(&amp;buf, "%s-", val)
        }</span>

        // Include all fields that should trigger a machine pool update
        <span class="cov0" title="0">if val, ok := nodePool["name"]; ok </span><span class="cov0" title="0">{
                buf.WriteString(fmt.Sprintf("%s-", val.(string)))
        }</span>
        <span class="cov0" title="0">if val, ok := nodePool["count"]; ok </span><span class="cov0" title="0">{
                buf.WriteString(fmt.Sprintf("%d-", val.(int)))
        }</span>
        <span class="cov0" title="0">if val, ok := nodePool["disk_size_gb"]; ok </span><span class="cov0" title="0">{
                buf.WriteString(fmt.Sprintf("%d-", val.(int)))
        }</span>
        <span class="cov0" title="0">if val, ok := nodePool["instance_type"]; ok </span><span class="cov0" title="0">{
                buf.WriteString(fmt.Sprintf("%s-", val.(string)))
        }</span>

        // Additional labels (map)
        <span class="cov0" title="0">if _, ok := nodePool["additional_labels"]; ok </span><span class="cov0" title="0">{
                buf.WriteString(HashStringMap(nodePool["additional_labels"]))
        }</span>

        // Update strategy
        <span class="cov0" title="0">if val, ok := nodePool["update_strategy"]; ok </span><span class="cov0" title="0">{
                buf.WriteString(fmt.Sprintf("%s-", val.(string)))
        }</span>

        // Hash override_scaling
        <span class="cov0" title="0">if overrideScaling, ok := nodePool["override_scaling"].([]interface{}); ok &amp;&amp; len(overrideScaling) &gt; 0 </span><span class="cov0" title="0">{
                scalingConfig := overrideScaling[0].(map[string]interface{})
                if maxSurge, ok := scalingConfig["max_surge"].(string); ok &amp;&amp; maxSurge != "" </span><span class="cov0" title="0">{
                        fmt.Fprintf(&amp;buf, "max_surge:%s-", maxSurge)
                }</span>
                <span class="cov0" title="0">if maxUnavailable, ok := scalingConfig["max_unavailable"].(string); ok &amp;&amp; maxUnavailable != "" </span><span class="cov0" title="0">{
                        fmt.Fprintf(&amp;buf, "max_unavailable:%s-", maxUnavailable)
                }</span>
        }

        // Node configuration (list of maps)
        <span class="cov0" title="0">if nodePool["node"] != nil </span><span class="cov0" title="0">{
                buf.WriteString(HashStringMapList(nodePool["node"]))
        }</span>

        // Taints (list of maps)
        <span class="cov0" title="0">if _, ok := nodePool["taints"]; ok </span><span class="cov0" title="0">{
                buf.WriteString(HashStringMapList(nodePool["taints"]))
        }</span>

        <span class="cov0" title="0">return int(hash(buf.String()))</span>
}

func eksLaunchTemplate(v interface{}) string <span class="cov0" title="0">{
        var buf bytes.Buffer
        if len(v.([]interface{})) &gt; 0 </span><span class="cov0" title="0">{
                m := v.([]interface{})[0].(map[string]interface{})

                if m["ami_id"] != nil </span><span class="cov0" title="0">{
                        buf.WriteString(fmt.Sprintf("%s-", m["ami_id"].(string)))
                }</span>
                <span class="cov0" title="0">if m["root_volume_type"] != nil </span><span class="cov0" title="0">{
                        buf.WriteString(fmt.Sprintf("%s-", m["root_volume_type"].(string)))
                }</span>
                <span class="cov0" title="0">if m["root_volume_iops"] != nil </span><span class="cov0" title="0">{
                        buf.WriteString(fmt.Sprintf("%d-", m["root_volume_iops"].(int)))
                }</span>
                <span class="cov0" title="0">if m["root_volume_throughput"] != nil </span><span class="cov0" title="0">{
                        buf.WriteString(fmt.Sprintf("%d-", m["root_volume_throughput"].(int)))
                }</span>
                <span class="cov0" title="0">if m["additional_security_groups"] != nil </span><span class="cov0" title="0">{
                        for _, sg := range m["additional_security_groups"].(*schema.Set).List() </span><span class="cov0" title="0">{
                                buf.WriteString(fmt.Sprintf("%s-", sg.(string)))
                        }</span>
                }
        }

        <span class="cov0" title="0">return buf.String()</span>
}

func resourceMachinePoolVsphereHash(v interface{}) int <span class="cov0" title="0">{
        m := v.(map[string]interface{})
        buf := CommonHash(m)

        // Hash additional annotations and override_kubeadm_configuration
        if _, ok := m["additional_annotations"]; ok </span><span class="cov0" title="0">{
                buf.WriteString(HashStringMap(m["additional_annotations"]))
        }</span>
        <span class="cov0" title="0">if val, ok := m["override_kubeadm_configuration"].(string); ok &amp;&amp; val != "" </span><span class="cov0" title="0">{
                fmt.Fprintf(buf, "%s-", val)
        }</span>

        <span class="cov0" title="0">if v, found := m["instance_type"]; found </span><span class="cov0" title="0">{
                if len(v.([]interface{})) &gt; 0 </span><span class="cov0" title="0">{
                        ins := v.([]interface{})[0].(map[string]interface{})
                        fmt.Fprintf(buf, "%d-", ins["cpu"].(int))
                        fmt.Fprintf(buf, "%d-", ins["disk_size_gb"].(int))
                        fmt.Fprintf(buf, "%d-", ins["memory_mb"].(int))
                }</span>
        }

        <span class="cov0" title="0">if placements, found := m["placement"]; found </span><span class="cov0" title="0">{
                for _, p := range placements.([]interface{}) </span><span class="cov0" title="0">{
                        place := p.(map[string]interface{})
                        fmt.Fprintf(buf, "%s-", place["cluster"].(string))
                        fmt.Fprintf(buf, "%s-", place["resource_pool"].(string))
                        fmt.Fprintf(buf, "%s-", place["datastore"].(string))
                        fmt.Fprintf(buf, "%s-", place["network"].(string))
                        fmt.Fprintf(buf, "%s-", place["static_ip_pool_id"].(string))
                }</span>
        }
        <span class="cov0" title="0">return int(hash(buf.String()))</span>
}

func resourceMachinePoolCustomCloudHash(v interface{}) int <span class="cov0" title="0">{
        m := v.(map[string]interface{})
        var buf bytes.Buffer

        // IMPORTANT: Only include user-provided fields in hash
        // Do NOT include computed fields (name, count, additional_labels) as they cause perpetual diffs

        if _, ok := m["taints"]; ok </span><span class="cov0" title="0">{
                buf.WriteString(HashStringMapList(m["taints"]))
        }</span>
        <span class="cov0" title="0">if val, ok := m["control_plane"]; ok </span><span class="cov0" title="0">{
                var boolVal bool
                switch v := val.(type) </span>{
                case bool:<span class="cov0" title="0">
                        boolVal = v</span>
                case *bool:<span class="cov0" title="0">
                        if v != nil </span><span class="cov0" title="0">{
                                boolVal = *v
                        }</span>
                }
                <span class="cov0" title="0">buf.WriteString(fmt.Sprintf("%t-", boolVal))</span>
        }
        <span class="cov0" title="0">if val, ok := m["control_plane_as_worker"]; ok </span><span class="cov0" title="0">{
                var boolVal bool
                switch v := val.(type) </span>{
                case bool:<span class="cov0" title="0">
                        boolVal = v</span>
                case *bool:<span class="cov0" title="0">
                        if v != nil </span><span class="cov0" title="0">{
                                boolVal = *v
                        }</span>
                }
                <span class="cov0" title="0">buf.WriteString(fmt.Sprintf("%t-", boolVal))</span>
        }

        // Normalize YAML to match StateFunc behavior (critical for preventing perpetual diffs)
        <span class="cov0" title="0">if yamlContent, ok := m["node_pool_config"].(string); ok </span><span class="cov0" title="0">{
                normalizedYAML := NormalizeYamlContent(yamlContent)
                buf.WriteString(fmt.Sprintf("%s-", normalizedYAML))
        }</span>

        // Include overrides in hash calculation for change detection
        <span class="cov0" title="0">if overrides, ok := m["overrides"]; ok </span><span class="cov0" title="0">{
                buf.WriteString(HashStringMap(overrides))
        }</span>

        <span class="cov0" title="0">return int(hash(buf.String()))</span>
}

func resourceMachinePoolVirtualHash(v interface{}) int <span class="cov0" title="0">{
        m := v.(map[string]interface{})
        buf := CommonHash(m)

        return int(hash(buf.String()))
}</span>

func resourceMachinePoolMaasHash(v interface{}) int <span class="cov0" title="0">{
        m := v.(map[string]interface{})
        buf := CommonHash(m)

        // Hash additional annotations and override_kubeadm_configuration
        if _, ok := m["additional_annotations"]; ok </span><span class="cov0" title="0">{
                buf.WriteString(HashStringMap(m["additional_annotations"]))
        }</span>
        <span class="cov0" title="0">if val, ok := m["override_kubeadm_configuration"].(string); ok &amp;&amp; val != "" </span><span class="cov0" title="0">{
                fmt.Fprintf(buf, "%s-", val)
        }</span>

        <span class="cov0" title="0">if v, found := m["instance_type"]; found </span><span class="cov0" title="0">{
                if len(v.([]interface{})) &gt; 0 </span><span class="cov0" title="0">{
                        ins := v.([]interface{})[0].(map[string]interface{})
                        fmt.Fprintf(buf, "%d-", ins["min_cpu"].(int))
                        fmt.Fprintf(buf, "%d-", ins["min_memory_mb"].(int))
                }</span>
        }
        <span class="cov0" title="0">if azs, ok := m["azs"]; ok &amp;&amp; azs != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(buf, "%s-", azs.(*schema.Set).GoString())
        }</span>
        <span class="cov0" title="0">if nodeTags, ok := m["node_tags"]; ok &amp;&amp; nodeTags != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(buf, "%s-", nodeTags.(*schema.Set).GoString())
        }</span>

        // Include placement fields if present
        <span class="cov0" title="0">if placementRaw, ok := m["placement"]; ok </span><span class="cov0" title="0">{
                placementList := placementRaw.([]interface{})
                if len(placementList) &gt; 0 </span><span class="cov0" title="0">{
                        place := placementList[0].(map[string]interface{})
                        if rp, ok := place["resource_pool"]; ok &amp;&amp; rp != nil </span><span class="cov0" title="0">{
                                fmt.Fprintf(buf, "%s-", rp.(string))
                        }</span>
                }
        }

        // Include use_lxd_vm flag
        <span class="cov0" title="0">if v, ok := m["use_lxd_vm"]; ok </span><span class="cov0" title="0">{
                fmt.Fprintf(buf, "%t-", v.(bool))
        }</span>

        // Include network settings if present
        <span class="cov0" title="0">if networkRaw, ok := m["network"]; ok </span><span class="cov0" title="0">{
                networkList := networkRaw.([]interface{})
                if len(networkList) &gt; 0 </span><span class="cov0" title="0">{
                        net := networkList[0].(map[string]interface{})
                        if name, ok := net["network_name"]; ok &amp;&amp; name != nil </span><span class="cov0" title="0">{
                                fmt.Fprintf(buf, "%s-", name.(string))
                        }</span>
                        <span class="cov0" title="0">if parent, ok := net["parent_pool_uid"]; ok &amp;&amp; parent != nil </span><span class="cov0" title="0">{
                                fmt.Fprintf(buf, "%s-", parent.(string))
                        }</span>
                        <span class="cov0" title="0">if staticIP, ok := net["static_ip"]; ok </span><span class="cov0" title="0">{
                                fmt.Fprintf(buf, "%t-", staticIP.(bool))
                        }</span>
                }
        }

        <span class="cov0" title="0">return int(hash(buf.String()))</span>
}

func InstanceTypeHash(ins map[string]interface{}) string <span class="cov0" title="0">{
        var buf bytes.Buffer
        buf.WriteString(fmt.Sprintf("%d-", ins["cpu"].(int)))
        buf.WriteString(fmt.Sprintf("%d-", ins["disk_size_gb"].(int)))
        buf.WriteString(fmt.Sprintf("%d-", ins["memory_mb"].(int)))
        buf.WriteString(fmt.Sprintf("%s-", ins["cpus_sets"].(string)))
        if ins["cache_passthrough"] != nil </span><span class="cov0" title="0">{
                buf.WriteString(fmt.Sprintf("%s-%t", "cache_passthrough", ins["cache_passthrough"].(bool)))
        }</span>
        <span class="cov0" title="0">if ins["gpu_config"] != nil </span><span class="cov0" title="0">{
                config, _ := ins["gpu_config"].(map[string]interface{})
                if config != nil </span><span class="cov0" title="0">{
                        buf.WriteString(GpuConfigHash(config))
                }</span>
        }

        <span class="cov0" title="0">if ins["attached_disks"] != nil </span><span class="cov0" title="0">{
                for _, disk := range ins["attached_disks"].([]interface{}) </span><span class="cov0" title="0">{
                        diskMap := disk.(map[string]interface{})
                        if diskMap["managed"] != nil </span><span class="cov0" title="0">{
                                buf.WriteString(fmt.Sprintf("%s-%t", "managed", diskMap["managed"].(bool)))
                        }</span>
                        <span class="cov0" title="0">if diskMap["size_in_gb"] != nil </span><span class="cov0" title="0">{
                                buf.WriteString(fmt.Sprintf("%s-%d", "size_in_gb", diskMap["size_in_gb"].(int)))
                        }</span>
                }
        }
        <span class="cov0" title="0">return buf.String()</span>
}

func GpuConfigHash(config map[string]interface{}) string <span class="cov0" title="0">{
        var buf bytes.Buffer
        buf.WriteString(fmt.Sprintf("%d-", config["num_gpus"].(int)))
        buf.WriteString(fmt.Sprintf("%s-", config["device_model"].(string)))
        buf.WriteString(fmt.Sprintf("%s-", config["vendor"].(string)))
        buf.WriteString(HashStringMap(config["addresses"]))
        return buf.String()
}</span>

func resourceMachinePoolEdgeNativeHash(v interface{}) int <span class="cov0" title="0">{
        m := v.(map[string]interface{})
        buf := CommonHash(m)

        // Hash additional annotations and override_kubeadm_configuration
        if _, ok := m["additional_annotations"]; ok </span><span class="cov0" title="0">{
                buf.WriteString(HashStringMap(m["additional_annotations"]))
        }</span>
        <span class="cov0" title="0">if val, ok := m["override_kubeadm_configuration"].(string); ok &amp;&amp; val != "" </span><span class="cov0" title="0">{
                fmt.Fprintf(buf, "%s-", val)
        }</span>

        <span class="cov0" title="0">if edgeHosts, found := m["edge_host"]; found </span><span class="cov0" title="0">{
                var edgeHostList []interface{}
                if edgeHostSet, ok := edgeHosts.(*schema.Set); ok </span><span class="cov0" title="0">{
                        edgeHostList = edgeHostSet.List()
                }</span> else<span class="cov0" title="0"> if edgeHostListRaw, ok := edgeHosts.([]interface{}); ok </span><span class="cov0" title="0">{
                        // Fallback for backward compatibility
                        edgeHostList = edgeHostListRaw
                }</span>

                <span class="cov0" title="0">for _, host := range edgeHostList </span><span class="cov0" title="0">{
                        hostMap := host.(map[string]interface{})

                        if hostName, ok := hostMap["host_name"]; ok </span><span class="cov0" title="0">{
                                fmt.Fprintf(buf, "host_name:%s-", hostName.(string))
                        }</span>

                        <span class="cov0" title="0">if hostUID, ok := hostMap["host_uid"]; ok </span><span class="cov0" title="0">{
                                fmt.Fprintf(buf, "host_uid:%s-", hostUID.(string))
                        }</span>

                        <span class="cov0" title="0">if staticIP, ok := hostMap["static_ip"]; ok </span><span class="cov0" title="0">{
                                fmt.Fprintf(buf, "static_ip:%s-", staticIP.(string))
                        }</span>

                        <span class="cov0" title="0">if nicName, ok := hostMap["nic_name"]; ok </span><span class="cov0" title="0">{
                                fmt.Fprintf(buf, "nic_name:%s-", nicName.(string))
                        }</span>

                        <span class="cov0" title="0">if defaultGateway, ok := hostMap["default_gateway"]; ok </span><span class="cov0" title="0">{
                                fmt.Fprintf(buf, "default_gateway:%s-", defaultGateway.(string))
                        }</span>

                        <span class="cov0" title="0">if subnetMask, ok := hostMap["subnet_mask"]; ok </span><span class="cov0" title="0">{
                                fmt.Fprintf(buf, "subnet_mask:%s-", subnetMask.(string))
                        }</span>

                        <span class="cov0" title="0">if dnsServers, ok := hostMap["dns_servers"]; ok </span><span class="cov0" title="0">{
                                var dns []string
                                for _, v := range dnsServers.(*schema.Set).List() </span><span class="cov0" title="0">{
                                        dns = append(dns, v.(string))
                                }</span>
                                <span class="cov0" title="0">fmt.Fprintf(buf, "dns_servers:%s-", strings.Join(dns, ","))</span>
                        }

                        <span class="cov0" title="0">if twoNodeRole, ok := hostMap["two_node_role"]; ok </span><span class="cov0" title="0">{
                                fmt.Fprintf(buf, "two_node_role:%s-", twoNodeRole.(string))
                        }</span>
                }
        }

        <span class="cov0" title="0">return int(hash(buf.String()))</span>
}

func resourceClusterHash(v interface{}) int <span class="cov0" title="0">{
        var buf bytes.Buffer
        m := v.(map[string]interface{})

        buf.WriteString(fmt.Sprintf("%s-", m["uid"].(string)))

        return int(hash(buf.String()))
}</span>

func HashStringMapList(v interface{}) string <span class="cov0" title="0">{
        var b bytes.Buffer
        m := v.([]interface{})

        if len(m) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">hashes := make([]string, 0)

        for _, i := range m </span><span class="cov0" title="0">{
                hashes = append(hashes, HashStringMap(i))
        }</span>

        <span class="cov0" title="0">sortedHashes := make([]string, len(hashes))
        copy(sortedHashes, hashes)
        sort.Strings(sortedHashes)

        for _, i := range sortedHashes </span><span class="cov0" title="0">{
                b.WriteString(i)
        }</span>

        <span class="cov0" title="0">return b.String()</span>
}

func HashStringMap(v interface{}) string <span class="cov0" title="0">{
        if v == nil </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">m, ok := v.(map[string]interface{})
        if !ok || len(m) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">var b bytes.Buffer

        // Create and sort the keys
        keys := make([]string, 0, len(m))
        for k := range m </span><span class="cov0" title="0">{
                keys = append(keys, k)
        }</span>
        <span class="cov0" title="0">sort.Strings(keys)

        // Construct the string based on sorted keys
        for _, k := range keys </span><span class="cov0" title="0">{
                b.WriteString(fmt.Sprintf("%s-%s", k, m[k].(string)))
        }</span>

        <span class="cov0" title="0">return b.String()</span>
}

func hash(s string) uint32 <span class="cov10" title="9">{
        h := fnv.New32a()
        _, _ = h.Write([]byte(s))
        return h.Sum32()
}</span>

// YamlContentHash creates a hash based on YAML semantic content, ignoring formatting
func YamlContentHash(yamlContent string) string <span class="cov0" title="0">{
        canonicalContent := yamlContentToCanonicalString(yamlContent)
        h := fnv.New64a()
        if _, err := h.Write([]byte(canonicalContent)); err != nil </span><span class="cov0" title="0">{
                // If hash writing fails, return a fallback hash
                return fmt.Sprintf("error_hash_%d", time.Now().UnixNano())
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%x", h.Sum64())</span>
}

// yamlContentToCanonicalString converts YAML content to a canonical string for hashing
func yamlContentToCanonicalString(yamlContent string) string <span class="cov0" title="0">{
        if strings.TrimSpace(yamlContent) == "" </span><span class="cov0" title="0">{
                return ""
        }</span>

        // Split multi-document YAML
        <span class="cov0" title="0">documents := strings.Split(yamlContent, "---")
        var canonicalDocs []string

        for _, doc := range documents </span><span class="cov0" title="0">{
                doc = strings.TrimSpace(doc)
                if doc == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Parse YAML document
                <span class="cov0" title="0">var yamlData interface{}
                if err := yaml.Unmarshal([]byte(doc), &amp;yamlData); err != nil </span><span class="cov0" title="0">{
                        // If parsing fails, use original doc for canonical form
                        canonicalDocs = append(canonicalDocs, doc)
                        continue</span>
                }

                // Convert to canonical string representation
                <span class="cov0" title="0">canonical := toCanonicalString(yamlData)
                canonicalDocs = append(canonicalDocs, canonical)</span>
        }

        <span class="cov0" title="0">if len(canonicalDocs) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">return strings.Join(canonicalDocs, "|||")</span> // Use ||| as document separator
}

// toCanonicalString converts a YAML structure to a deterministic string representation
func toCanonicalString(data interface{}) string <span class="cov0" title="0">{
        switch v := data.(type) </span>{
        case map[string]interface{}:<span class="cov0" title="0">
                // Sort keys for deterministic output
                keys := make([]string, 0, len(v))
                for k := range v </span><span class="cov0" title="0">{
                        keys = append(keys, k)
                }</span>
                <span class="cov0" title="0">sort.Strings(keys)

                var parts []string
                for _, k := range keys </span><span class="cov0" title="0">{
                        value := toCanonicalString(v[k])
                        parts = append(parts, fmt.Sprintf("%s:%s", k, value))
                }</span>
                <span class="cov0" title="0">return "{" + strings.Join(parts, ",") + "}"</span>

        case map[interface{}]interface{}:<span class="cov0" title="0">
                // Convert to string map and recurse
                stringMap := make(map[string]interface{})
                for key, value := range v </span><span class="cov0" title="0">{
                        if keyStr, ok := key.(string); ok </span><span class="cov0" title="0">{
                                stringMap[keyStr] = value
                        }</span>
                }
                <span class="cov0" title="0">return toCanonicalString(stringMap)</span>

        case []interface{}:<span class="cov0" title="0">
                var parts []string
                for _, item := range v </span><span class="cov0" title="0">{
                        parts = append(parts, toCanonicalString(item))
                }</span>
                <span class="cov0" title="0">return "[" + strings.Join(parts, ",") + "]"</span>

        case string:<span class="cov0" title="0">
                return fmt.Sprintf("\"%s\"", v)</span>
        case int, int64, float64, bool:<span class="cov0" title="0">
                return fmt.Sprintf("%v", v)</span>
        case nil:<span class="cov0" title="0">
                return "null"</span>
        default:<span class="cov0" title="0">
                return fmt.Sprintf("%v", v)</span>
        }
}

// NormalizeYamlContent parses YAML and re-serializes it in a consistent format for StateFunc
func NormalizeYamlContent(yamlContent string) string <span class="cov0" title="0">{
        if strings.TrimSpace(yamlContent) == "" </span><span class="cov0" title="0">{
                return ""
        }</span>

        // Split multi-document YAML
        <span class="cov0" title="0">documents := strings.Split(yamlContent, "---")
        var normalizedDocs []string

        for _, doc := range documents </span><span class="cov0" title="0">{
                doc = strings.TrimSpace(doc)
                if doc == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Parse YAML document
                <span class="cov0" title="0">var yamlData interface{}
                if err := yaml.Unmarshal([]byte(doc), &amp;yamlData); err != nil </span><span class="cov0" title="0">{
                        // If parsing fails, return original (trimmed)
                        normalizedDocs = append(normalizedDocs, doc)
                        continue</span>
                }

                // Re-serialize in consistent format
                <span class="cov0" title="0">normalizedYaml, err := yaml.Marshal(yamlData)
                if err != nil </span><span class="cov0" title="0">{
                        // If marshaling fails, return original (trimmed)
                        normalizedDocs = append(normalizedDocs, doc)
                        continue</span>
                }

                <span class="cov0" title="0">normalizedDocs = append(normalizedDocs, strings.TrimSpace(string(normalizedYaml)))</span>
        }

        <span class="cov0" title="0">if len(normalizedDocs) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">return strings.Join(normalizedDocs, "\n---\n")</span>
}

func resourceMachinePoolOpenStackHash(v interface{}) int <span class="cov0" title="0">{
        nodePool := v.(map[string]interface{})
        var buf bytes.Buffer

        // Use CommonHash for common fields: additional_labels, taints, control_plane,
        // control_plane_as_worker, name, count, update_strategy, node_repave_interval, node
        commonBuf := CommonHash(nodePool)
        buf.WriteString(commonBuf.String())

        // Hash additional annotations and override_kubeadm_configuration
        if _, ok := nodePool["additional_annotations"]; ok </span><span class="cov0" title="0">{
                buf.WriteString(HashStringMap(nodePool["additional_annotations"]))
        }</span>
        <span class="cov0" title="0">if val, ok := nodePool["override_kubeadm_configuration"].(string); ok &amp;&amp; val != "" </span><span class="cov0" title="0">{
                fmt.Fprintf(&amp;buf, "%s-", val)
        }</span>

        // Add OpenStack-specific fields
        <span class="cov0" title="0">if val, ok := nodePool["instance_type"]; ok </span><span class="cov0" title="0">{
                buf.WriteString(fmt.Sprintf("%s-", val.(string)))
        }</span>

        // Handle azs (TypeSet) - sort for deterministic hash
        <span class="cov0" title="0">if nodePool["azs"] != nil </span><span class="cov0" title="0">{
                azsSet := nodePool["azs"].(*schema.Set)
                azsList := azsSet.List()
                azsListStr := make([]string, len(azsList))
                for i, v := range azsList </span><span class="cov0" title="0">{
                        azsListStr[i] = v.(string)
                }</span>
                <span class="cov0" title="0">sort.Strings(azsListStr)
                azsStr := strings.Join(azsListStr, "-")
                buf.WriteString(fmt.Sprintf("%s-", azsStr))</span>
        }

        // Handle subnet_id (optional string field)
        <span class="cov0" title="0">if val, ok := nodePool["subnet_id"]; ok &amp;&amp; val != nil &amp;&amp; val.(string) != "" </span><span class="cov0" title="0">{
                buf.WriteString(fmt.Sprintf("%s-", val.(string)))
        }</span>

        <span class="cov0" title="0">return int(hash(buf.String()))</span>
}

// resourceEdgeHostHash creates a hash for edge_host TypeSet
func resourceEdgeHostHash(v interface{}) int <span class="cov0" title="0">{
        var buf bytes.Buffer
        host := v.(map[string]interface{})

        // Required field - always include
        if hostUID, ok := host["host_uid"]; ok &amp;&amp; hostUID != nil </span><span class="cov0" title="0">{
                buf.WriteString(fmt.Sprintf("host_uid:%s-", hostUID.(string)))
        }</span>

        // Optional fields
        <span class="cov0" title="0">if hostName, ok := host["host_name"]; ok &amp;&amp; hostName != nil &amp;&amp; hostName.(string) != "" </span><span class="cov0" title="0">{
                buf.WriteString(fmt.Sprintf("host_name:%s-", hostName.(string)))
        }</span>

        <span class="cov0" title="0">if staticIP, ok := host["static_ip"]; ok &amp;&amp; staticIP != nil &amp;&amp; staticIP.(string) != "" </span><span class="cov0" title="0">{
                buf.WriteString(fmt.Sprintf("static_ip:%s-", staticIP.(string)))
        }</span>

        <span class="cov0" title="0">if nicName, ok := host["nic_name"]; ok &amp;&amp; nicName != nil &amp;&amp; nicName.(string) != "" </span><span class="cov0" title="0">{
                buf.WriteString(fmt.Sprintf("nic_name:%s-", nicName.(string)))
        }</span>

        <span class="cov0" title="0">if defaultGateway, ok := host["default_gateway"]; ok &amp;&amp; defaultGateway != nil &amp;&amp; defaultGateway.(string) != "" </span><span class="cov0" title="0">{
                buf.WriteString(fmt.Sprintf("default_gateway:%s-", defaultGateway.(string)))
        }</span>

        <span class="cov0" title="0">if subnetMask, ok := host["subnet_mask"]; ok &amp;&amp; subnetMask != nil &amp;&amp; subnetMask.(string) != "" </span><span class="cov0" title="0">{
                buf.WriteString(fmt.Sprintf("subnet_mask:%s-", subnetMask.(string)))
        }</span>

        // Handle dns_servers (TypeSet) - sort for deterministic hash
        <span class="cov0" title="0">if dnsServers, ok := host["dns_servers"]; ok &amp;&amp; dnsServers != nil </span><span class="cov0" title="0">{
                if dnsSet, ok := dnsServers.(*schema.Set); ok </span><span class="cov0" title="0">{
                        dnsList := dnsSet.List()
                        dnsListStr := make([]string, len(dnsList))
                        for i, v := range dnsList </span><span class="cov0" title="0">{
                                dnsListStr[i] = v.(string)
                        }</span>
                        <span class="cov0" title="0">sort.Strings(dnsListStr)
                        buf.WriteString(fmt.Sprintf("dns_servers:%s-", strings.Join(dnsListStr, ",")))</span>
                }
        }

        <span class="cov0" title="0">if twoNodeRole, ok := host["two_node_role"]; ok &amp;&amp; twoNodeRole != nil &amp;&amp; twoNodeRole.(string) != "" </span><span class="cov0" title="0">{
                buf.WriteString(fmt.Sprintf("two_node_role:%s-", twoNodeRole.(string)))
        }</span>

        <span class="cov0" title="0">return int(hash(buf.String()))</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package spectrocloud

import (
        "strings"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/spectrocloud/palette-sdk-go/api/models"
        "github.com/spectrocloud/palette-sdk-go/client"
)

func toClusterHostConfigs(d *schema.ResourceData) *models.V1HostClusterConfig <span class="cov0" title="0">{
        if d.Get("host_config") != nil </span><span class="cov0" title="0">{
                for _, hostConfig := range d.Get("host_config").([]interface{}) </span><span class="cov0" title="0">{
                        return toClusterHostConfig(hostConfig.(map[string]interface{}))
                }</span>
        }

        <span class="cov0" title="0">isHostCluster := false
        return &amp;models.V1HostClusterConfig{
                ClusterEndpoint: nil,
                IsHostCluster:   &amp;isHostCluster,
        }</span>
}

func toClusterHostConfig(config map[string]interface{}) *models.V1HostClusterConfig <span class="cov0" title="0">{
        isHostCluster := true
        return &amp;models.V1HostClusterConfig{
                ClusterEndpoint: toClusterEndpoint(config),
                IsHostCluster:   &amp;isHostCluster,
        }
}</span>

func toClusterEndpoint(config map[string]interface{}) *models.V1HostClusterEndpoint <span class="cov0" title="0">{
        hostType := "Ingress"
        if config["host_endpoint_type"] != nil </span><span class="cov0" title="0">{
                hostType = config["host_endpoint_type"].(string)
        }</span>
        <span class="cov0" title="0">return &amp;models.V1HostClusterEndpoint{
                Config: toClusterEndpointConfig(config),
                Type:   hostType,
        }</span>
}

func toClusterEndpointConfig(config map[string]interface{}) *models.V1HostClusterEndpointConfig <span class="cov0" title="0">{
        return &amp;models.V1HostClusterEndpointConfig{
                IngressConfig:      toIngressConfig(config),
                LoadBalancerConfig: toLoadBalancerConfig(config),
        }
}</span>

func toIngressConfig(config map[string]interface{}) *models.V1IngressConfig <span class="cov0" title="0">{
        ingressHost := ""
        if config["ingress_host"] != nil </span><span class="cov0" title="0">{
                ingressHost = config["ingress_host"].(string)
        }</span>
        <span class="cov0" title="0">return &amp;models.V1IngressConfig{
                Host: ingressHost,
        }</span>
}

func toLoadBalancerConfig(config map[string]interface{}) *models.V1LoadBalancerConfig <span class="cov0" title="0">{
        loadBalancerConfig := &amp;models.V1LoadBalancerConfig{}

        if config["external_traffic_policy"] != nil </span><span class="cov0" title="0">{
                loadBalancerConfig.ExternalTrafficPolicy = config["external_traffic_policy"].(string)
        }</span>

        <span class="cov0" title="0">if config["load_balancer_source_ranges"] != nil </span><span class="cov0" title="0">{
                loadBalancerConfig.LoadBalancerSourceRanges = strings.Split(config["load_balancer_source_ranges"].(string), ",")
        }</span>

        <span class="cov0" title="0">return loadBalancerConfig</span>
}

func flattenHostConfig(hostConfig *models.V1HostClusterConfig) []interface{} <span class="cov0" title="0">{
        result := make(map[string]interface{})
        configs := make([]interface{}, 0)

        if hostConfig != nil &amp;&amp; hostConfig.ClusterEndpoint != nil </span><span class="cov0" title="0">{
                if hostConfig.ClusterEndpoint != nil </span><span class="cov0" title="0">{
                        result["host_endpoint_type"] = hostConfig.ClusterEndpoint.Type
                }</span>
                <span class="cov0" title="0">if hostConfig.ClusterEndpoint.Config != nil </span><span class="cov0" title="0">{
                        if hostConfig.ClusterEndpoint.Config.IngressConfig != nil </span><span class="cov0" title="0">{
                                result["ingress_host"] = hostConfig.ClusterEndpoint.Config.IngressConfig.Host
                        }</span>
                        <span class="cov0" title="0">if hostConfig.ClusterEndpoint.Config.LoadBalancerConfig != nil </span><span class="cov0" title="0">{
                                result["external_traffic_policy"] = hostConfig.ClusterEndpoint.Config.LoadBalancerConfig.ExternalTrafficPolicy
                                result["load_balancer_source_ranges"] = flattenSourceRanges(hostConfig)
                        }</span>
                }
                <span class="cov0" title="0">configs = append(configs, result)</span>
        }

        <span class="cov0" title="0">return configs</span>
}

func flattenSourceRanges(hostConfig *models.V1HostClusterConfig) string <span class="cov0" title="0">{
        srcRanges := hostConfig.ClusterEndpoint.Config.LoadBalancerConfig.LoadBalancerSourceRanges
        sourceRanges := make([]string, len(srcRanges))
        copy(sourceRanges, srcRanges)
        return strings.Join(sourceRanges, ",")
}</span>

func updateHostConfig(c *client.V1Client, d *schema.ResourceData) error <span class="cov0" title="0">{
        if hostConfigs := toClusterHostConfigs(d); hostConfigs != nil </span><span class="cov0" title="0">{
                clusterContext := d.Get("context").(string)
                err := ValidateContext(clusterContext)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return c.ApplyClusterHostConfig(d.Id(), &amp;models.V1HostClusterConfigEntity{
                        HostClusterConfig: hostConfigs,
                })</span>
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package spectrocloud

func toAdditionalNodePoolLabels(m map[string]interface{}) map[string]string <span class="cov0" title="0">{
        additionalLabels := make(map[string]string)
        if m["additional_labels"] != nil &amp;&amp; len(m["additional_labels"].(map[string]interface{})) &gt; 0 </span><span class="cov0" title="0">{
                additionalLabels = expandStringMap(m["additional_labels"].(map[string]interface{}))
        }</span>
        <span class="cov0" title="0">return additionalLabels</span>
}

func toAdditionalNodePoolAnnotations(m map[string]interface{}) map[string]string <span class="cov0" title="0">{
        additionalAnnotations := make(map[string]string)
        if m["additional_annotations"] != nil &amp;&amp; len(m["additional_annotations"].(map[string]interface{})) &gt; 0 </span><span class="cov0" title="0">{
                additionalAnnotations = expandStringMap(m["additional_annotations"].(map[string]interface{}))
        }</span>
        <span class="cov0" title="0">return additionalAnnotations</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package spectrocloud

import (
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/spectrocloud/palette-sdk-go/api/models"
        "github.com/spectrocloud/palette-sdk-go/client"
)

func toClusterLocationConfigs(d *schema.ResourceData) *models.V1ClusterLocation <span class="cov0" title="0">{
        if d.Get("location_config") != nil </span><span class="cov0" title="0">{
                for _, locationConfig := range d.Get("location_config").([]interface{}) </span><span class="cov0" title="0">{
                        return toClusterLocationConfig(locationConfig.(map[string]interface{}))
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func toClusterLocationConfig(config map[string]interface{}) *models.V1ClusterLocation <span class="cov0" title="0">{
        countryCode := ""
        if config["country_code"] != nil </span><span class="cov0" title="0">{
                countryCode = config["country_code"].(string)
        }</span>

        <span class="cov0" title="0">countryName := ""
        if config["country_name"] != nil </span><span class="cov0" title="0">{
                countryName = config["country_name"].(string)
        }</span>

        <span class="cov0" title="0">regionCode := ""
        if config["region_code"] != nil </span><span class="cov0" title="0">{
                regionCode = config["region_code"].(string)
        }</span>

        <span class="cov0" title="0">regionName := ""
        if config["region_name"] != nil </span><span class="cov0" title="0">{
                regionName = config["region_name"].(string)
        }</span>

        <span class="cov0" title="0">return &amp;models.V1ClusterLocation{
                CountryCode: countryCode,
                CountryName: countryName,
                GeoLoc:      toClusterGeoLoc(config),
                RegionCode:  regionCode,
                RegionName:  regionName,
        }</span>
}

func toClusterGeoLoc(config map[string]interface{}) *models.V1GeolocationLatlong <span class="cov0" title="0">{
        var latitude float64
        if config["latitude"] != nil </span><span class="cov0" title="0">{
                latitude = config["latitude"].(float64)
        }</span>

        <span class="cov0" title="0">var longitude float64
        if config["longitude"] != nil </span><span class="cov0" title="0">{
                longitude = config["longitude"].(float64)
        }</span>

        <span class="cov0" title="0">return &amp;models.V1GeolocationLatlong{
                Latitude:  latitude,
                Longitude: longitude,
        }</span>
}

func flattenLocationConfig(location *models.V1ClusterLocation) []interface{} <span class="cov0" title="0">{
        result := make(map[string]interface{})
        configs := make([]interface{}, 0)

        if location.GeoLoc != nil </span><span class="cov0" title="0">{
                result["latitude"] = location.GeoLoc.Latitude
                result["longitude"] = location.GeoLoc.Longitude
        }</span>

        <span class="cov0" title="0">result["country_code"] = location.CountryCode
        result["country_name"] = location.CountryName
        result["region_code"] = location.RegionCode
        result["region_name"] = location.RegionName

        configs = append(configs, result)

        return configs</span>
}

func updateLocationConfig(c *client.V1Client, d *schema.ResourceData) error <span class="cov0" title="0">{
        clusterContext := d.Get("context").(string)
        err := ValidateContext(clusterContext)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if locationConfigs := toClusterLocationConfigs(d); locationConfigs != nil </span><span class="cov0" title="0">{
                return c.ApplyClusterLocationConfig(d.Id(), &amp;models.V1SpectroClusterLocationInputEntity{
                        Location: locationConfigs,
                })
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package spectrocloud

import (
        "fmt"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/spectrocloud/palette-sdk-go/api/models"
        "github.com/spectrocloud/palette-sdk-go/client"
)

func getClusterMetadata(d *schema.ResourceData) *models.V1ObjectMeta <span class="cov0" title="0">{
        return &amp;models.V1ObjectMeta{
                Name:        d.Get("name").(string),
                UID:         d.Id(),
                Labels:      toTags(d),
                Annotations: map[string]string{"description": d.Get("description").(string)},
        }
}</span>

func safeGetOk(d *schema.ResourceData, key string) (interface{}, bool) <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        fmt.Println("[safeGetOk] recovered from panic for key:", key)
                }</span>
        }()
        <span class="cov0" title="0">return d.GetOk(key)</span>
}

func toClusterMetadataUpdate(d *schema.ResourceData) *models.V1ObjectMetaInputEntity <span class="cov0" title="0">{
        cMetadata := &amp;models.V1ObjectMetaInputEntity{
                Name:        d.Get("name").(string),
                Labels:      toTags(d),
                Annotations: map[string]string{"description": d.Get("description").(string)},
        }
        if _, ok := safeGetOk(d, "tags_map"); ok </span><span class="cov0" title="0">{
                tagMaps := toTagsMap(d)
                cMetadata.Labels = tagMaps
        }</span>
        <span class="cov0" title="0">return cMetadata</span>
}

func updateClusterMetadata(c *client.V1Client, d *schema.ResourceData) error <span class="cov0" title="0">{
        clusterContext := d.Get("context").(string)
        err := ValidateContext(clusterContext)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return c.UpdateClusterMetadata(d.Id(), toUpdateClusterMetadata(d))</span>
}

func toUpdateClusterMetadata(d *schema.ResourceData) *models.V1ObjectMetaInputEntitySchema <span class="cov0" title="0">{
        return &amp;models.V1ObjectMetaInputEntitySchema{
                Metadata: toClusterMetadataUpdate(d),
        }
}</span>

func updateClusterAdditionalMetadata(c *client.V1Client, d *schema.ResourceData) error <span class="cov0" title="0">{
        clusterContext := d.Get("context").(string)
        err := ValidateContext(clusterContext)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return c.UpdateAdditionalClusterMetadata(d.Id(), toUpdateClusterAdditionalMetadata(d))</span>
}

func toUpdateClusterAdditionalMetadata(d *schema.ResourceData) *models.V1ClusterMetaAttributeEntity <span class="cov0" title="0">{
        return &amp;models.V1ClusterMetaAttributeEntity{
                ClusterMetaAttribute: toClusterMetaAttribute(d),
        }
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package spectrocloud

import (
        "math"
        "strconv"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/spectrocloud/palette-sdk-go/api/models"
        "github.com/spectrocloud/palette-sdk-go/client"
)

func toClusterNamespaces(d *schema.ResourceData) []*models.V1ClusterNamespaceResourceInputEntity <span class="cov0" title="0">{
        clusterNamespaces := make([]*models.V1ClusterNamespaceResourceInputEntity, 0)
        if d.Get("namespaces") == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">for _, clusterNamespace := range d.Get("namespaces").([]interface{}) </span><span class="cov0" title="0">{
                ns := toClusterNamespace(clusterNamespace)
                clusterNamespaces = append(clusterNamespaces, ns)
        }</span>

        <span class="cov0" title="0">return clusterNamespaces</span>
}

func toClusterNamespace(clusterRbacBinding interface{}) *models.V1ClusterNamespaceResourceInputEntity <span class="cov0" title="0">{
        m := clusterRbacBinding.(map[string]interface{})

        resourceAllocation, _ := m["resource_allocation"].(map[string]interface{})

        cpu_cores, err := strconv.ParseFloat(resourceAllocation["cpu_cores"].(string), 64)
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">memory_MiB, err := strconv.ParseFloat(resourceAllocation["memory_MiB"].(string), 64)
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var gpuConfig *models.V1GpuConfig
        if gpuLimitVal, exists := resourceAllocation["gpu_limit"]; exists &amp;&amp; gpuLimitVal != nil </span><span class="cov0" title="0">{
                gpu_limit, err := strconv.ParseInt(gpuLimitVal.(string), 10, 32)
                if err != nil </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov0" title="0">gpu_provider := "nvidia"
                if provider, exists := resourceAllocation["gpu_provider"]; exists &amp;&amp; provider != nil </span><span class="cov0" title="0">{
                        gpu_provider = provider.(string)
                }</span>

                <span class="cov0" title="0">gpuConfig = &amp;models.V1GpuConfig{
                        Limit:    int32(gpu_limit),
                        Provider: &amp;gpu_provider,
                }</span>
        }

        <span class="cov0" title="0">resource_alloc := &amp;models.V1ClusterNamespaceResourceAllocation{
                CPUCores:  cpu_cores,
                MemoryMiB: memory_MiB,
                GpuConfig: gpuConfig,
        }

        ns := &amp;models.V1ClusterNamespaceResourceInputEntity{
                Metadata: &amp;models.V1ObjectMetaUpdateEntity{
                        Name: m["name"].(string),
                },
                Spec: &amp;models.V1ClusterNamespaceSpec{
                        IsRegex:            IsRegex(m["name"].(string)),
                        ResourceAllocation: resource_alloc,
                },
        }

        return ns</span>
}

func flattenClusterNamespaces(items []*models.V1ClusterNamespaceResource) []interface{} <span class="cov0" title="0">{
        result := make([]interface{}, 0)
        for _, namespace := range items </span><span class="cov0" title="0">{
                flattenNamespace := make(map[string]interface{})
                flattenNamespace["name"] = namespace.Metadata.Name

                flattenResourceAllocation := make(map[string]interface{})
                flattenResourceAllocation["cpu_cores"] = strconv.Itoa(int(math.Round(namespace.Spec.ResourceAllocation.CPUCores)))
                flattenResourceAllocation["memory_MiB"] = strconv.Itoa(int(math.Round(namespace.Spec.ResourceAllocation.MemoryMiB)))

                // Only set GPU fields if GpuConfig exists and has meaningful values
                if namespace.Spec.ResourceAllocation.GpuConfig != nil &amp;&amp; namespace.Spec.ResourceAllocation.GpuConfig.Limit &gt; 0 </span><span class="cov0" title="0">{
                        flattenResourceAllocation["gpu_limit"] = strconv.Itoa(int(namespace.Spec.ResourceAllocation.GpuConfig.Limit))
                        if namespace.Spec.ResourceAllocation.GpuConfig.Provider != nil </span><span class="cov0" title="0">{
                                flattenResourceAllocation["gpu_provider"] = *namespace.Spec.ResourceAllocation.GpuConfig.Provider
                        }</span> else<span class="cov0" title="0"> {
                                flattenResourceAllocation["gpu_provider"] = "nvidia"
                        }</span>
                }

                <span class="cov0" title="0">flattenNamespace["resource_allocation"] = flattenResourceAllocation
                result = append(result, flattenNamespace)</span>
        }
        <span class="cov0" title="0">return result</span>
}

func updateClusterNamespaces(c *client.V1Client, d *schema.ResourceData) error <span class="cov0" title="0">{
        if namespaces := toClusterNamespaces(d); namespaces != nil </span><span class="cov0" title="0">{
                clusterContext := d.Get("context").(string)
                err := ValidateContext(clusterContext)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return c.ApplyClusterNamespaceConfig(d.Id(), namespaces)</span>
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package spectrocloud

import (
        "fmt"
        "time"

        "github.com/hashicorp/go-cty/cty"
        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/robfig/cron"
        "github.com/spectrocloud/palette-sdk-go/api/models"
        "github.com/spectrocloud/palette-sdk-go/client"
)

func updateClusterOsPatchConfig(c *client.V1Client, d *schema.ResourceData) error <span class="cov0" title="0">{
        machineConfig := toMachineManagementConfig(d)
        clusterContext := d.Get("context").(string)
        err := ValidateContext(clusterContext)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if machineConfig.OsPatchConfig != nil </span><span class="cov0" title="0">{
                return c.UpdateClusterOsPatchConfig(d.Id(), toUpdateOsPatchEntityClusterRbac(machineConfig.OsPatchConfig))
        }</span> else<span class="cov0" title="0"> {
                return c.UpdateClusterOsPatchConfig(d.Id(), toUpdateOsPatchEntityClusterRbac(getDefaultOsPatchConfig().OsPatchConfig))
        }</span>
}

func getDefaultOsPatchConfig() *models.V1MachineManagementConfig <span class="cov0" title="0">{
        return &amp;models.V1MachineManagementConfig{
                OsPatchConfig: &amp;models.V1OsPatchConfig{
                        PatchOnBoot:      false,
                        RebootIfRequired: false,
                },
        }
}</span>

func toUpdateOsPatchEntityClusterRbac(config *models.V1OsPatchConfig) *models.V1OsPatchEntity <span class="cov0" title="0">{
        return &amp;models.V1OsPatchEntity{
                OsPatchConfig: config,
        }
}</span>

func toOsPatchConfig(d *schema.ResourceData) *models.V1OsPatchConfig <span class="cov0" title="0">{
        osPatchOnBoot := false
        _, isOsPatchOnBoot := d.GetOk("os_patch_on_boot")
        _, isOsPatchOnSchedule := d.GetOk("os_patch_schedule")
        _, isOsPatchAfter := d.GetOk("os_patch_after")
        if isOsPatchOnBoot || isOsPatchOnSchedule || isOsPatchAfter </span><span class="cov0" title="0">{
                if d.Get("os_patch_on_boot") != nil </span><span class="cov0" title="0">{
                        osPatchOnBoot = d.Get("os_patch_on_boot").(bool)
                }</span>
                <span class="cov0" title="0">osPatchOnSchedule := d.Get("os_patch_schedule").(string)
                osPatchAfter := d.Get("os_patch_after").(string)
                if osPatchOnBoot || len(osPatchOnSchedule) &gt; 0 || len(osPatchAfter) &gt; 0 </span><span class="cov0" title="0">{
                        osPatchConfig := &amp;models.V1OsPatchConfig{}
                        if osPatchOnBoot </span><span class="cov0" title="0">{
                                osPatchConfig.PatchOnBoot = osPatchOnBoot
                        }</span>
                        <span class="cov0" title="0">if len(osPatchOnSchedule) &gt; 0 </span><span class="cov0" title="0">{
                                osPatchConfig.Schedule = osPatchOnSchedule
                        }</span>
                        <span class="cov0" title="0">if len(osPatchAfter) &gt; 0 </span><span class="cov0" title="0">{
                                patchAfter, _ := time.Parse(time.RFC3339, osPatchAfter)
                                osPatchConfig.OnDemandPatchAfter = models.V1Time(patchAfter)
                        }</span> else<span class="cov0" title="0"> {
                                //setting Zero time in request
                                zeroTime, _ := time.Parse(time.RFC3339, "0001-01-01T00:00:00.000Z")
                                osPatchConfig.OnDemandPatchAfter = models.V1Time(zeroTime)
                        }</span>
                        <span class="cov0" title="0">return osPatchConfig</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

func validateOsPatchSchedule(data interface{}, _ cty.Path) diag.Diagnostics <span class="cov0" title="0">{
        var diags diag.Diagnostics
        if data != nil </span><span class="cov0" title="0">{
                if _, err := cron.ParseStandard(data.(string)); err != nil </span><span class="cov0" title="0">{
                        wrappedErr := fmt.Errorf("os patch schedule is invalid. Please see https://en.wikipedia.org/wiki/Cron for valid cron syntax: %w", err)
                        return diag.FromErr(wrappedErr)
                }</span>
        }
        <span class="cov0" title="0">return diags</span>
}

func validateOsPatchOnDemandAfter(data interface{}, _ cty.Path) diag.Diagnostics <span class="cov0" title="0">{
        var diags diag.Diagnostics
        if data != nil </span><span class="cov0" title="0">{
                if patchTime, err := time.Parse(time.RFC3339, data.(string)); err != nil </span><span class="cov0" title="0">{
                        wrappedErr := fmt.Errorf("time for 'os_patch_after' is invalid. Please follow RFC3339 Date and Time Standards. Eg 2021-01-01T00:00:00.000Z : %w", err)
                        return diag.FromErr(wrappedErr)
                }</span> else<span class="cov0" title="0"> {
                        if time.Now().After(patchTime.Add(10 * time.Minute)) </span><span class="cov0" title="0">{
                                wrappedErr := fmt.Errorf("valid timestamp is timestamp which is 10 mins ahead of current timestamp. Eg any timestamp ahead of %v", time.Now().Add(10*time.Minute).Format(time.RFC3339))
                                return diag.FromErr(wrappedErr)
                        }</span>
                }
        }

        <span class="cov0" title="0">return diags</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package spectrocloud

import (
        "errors"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/spectrocloud/palette-sdk-go/api/models"
        "github.com/spectrocloud/palette-sdk-go/client"
        "strings"
)

func toPolicies(d *schema.ResourceData) *models.V1SpectroClusterPolicies <span class="cov0" title="0">{
        return &amp;models.V1SpectroClusterPolicies{
                BackupPolicy: toBackupPolicy(d),
                ScanPolicy:   toScanPolicy(d),
        }
}</span>

func toBackupPolicy(d *schema.ResourceData) *models.V1ClusterBackupConfig <span class="cov0" title="0">{
        if policies, found := d.GetOk("backup_policy"); found </span><span class="cov0" title="0">{
                policy := policies.([]interface{})[0].(map[string]interface{})

                namespaces := make([]string, 0)
                if policy["namespaces"] != nil </span><span class="cov0" title="0">{
                        if nss, ok := policy["namespaces"]; ok </span><span class="cov0" title="0">{
                                for _, ns := range nss.(*schema.Set).List() </span><span class="cov0" title="0">{
                                        namespaces = append(namespaces, ns.(string))
                                }</span>
                        }
                }

                // Extract and process the policy settings
                <span class="cov0" title="0">includeClusterResourceMode := models.V1IncludeClusterResourceMode("Auto") // Default value
                if policy["include_cluster_resources_mode"] != "" </span><span class="cov0" title="0">{
                        if v, ok := policy["include_cluster_resources_mode"].(string); ok </span><span class="cov0" title="0">{
                                includeClusterResourceMode = convertIncludeResourceMode(v)
                        }</span>
                } else<span class="cov0" title="0"> if policy["include_cluster_resources"] != nil </span><span class="cov0" title="0">{
                        if include, ok := policy["include_cluster_resources"].(bool); ok </span><span class="cov0" title="0">{
                                if include </span><span class="cov0" title="0">{
                                        includeClusterResourceMode = convertIncludeResourceMode("Always")
                                }</span> else<span class="cov0" title="0"> {
                                        includeClusterResourceMode = convertIncludeResourceMode("Never")
                                }</span>
                        }
                }

                <span class="cov0" title="0">return &amp;models.V1ClusterBackupConfig{
                        BackupLocationUID:          policy["backup_location_id"].(string),
                        BackupPrefix:               policy["prefix"].(string),
                        DurationInHours:            int64(policy["expiry_in_hour"].(int)),
                        IncludeAllDisks:            policy["include_disks"].(bool),
                        IncludeClusterResourceMode: includeClusterResourceMode,
                        Namespaces:                 namespaces,
                        Schedule: &amp;models.V1ClusterFeatureSchedule{
                                ScheduledRunTime: policy["schedule"].(string),
                        },
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func convertIncludeResourceMode(m string) (mode models.V1IncludeClusterResourceMode) <span class="cov0" title="0">{
        switch strings.ToLower(m) </span>{
        case "always":<span class="cov0" title="0">
                return models.V1IncludeClusterResourceMode("Always")</span>
        case "never":<span class="cov0" title="0">
                return models.V1IncludeClusterResourceMode("Never")</span>
        case "auto":<span class="cov0" title="0">
                return models.V1IncludeClusterResourceMode("Auto")</span>
        }
        <span class="cov0" title="0">return ""</span>
}

func flattenBackupPolicy(policy *models.V1ClusterBackupConfig, d *schema.ResourceData) []interface{} <span class="cov0" title="0">{
        result := make([]interface{}, 0, 1)
        data := make(map[string]interface{})
        data["schedule"] = policy.Schedule.ScheduledRunTime
        data["backup_location_id"] = policy.BackupLocationUID
        data["prefix"] = policy.BackupPrefix
        data["namespaces"] = policy.Namespaces
        data["expiry_in_hour"] = policy.DurationInHours
        data["include_disks"] = policy.IncludeAllDisks

        if policies, found := d.GetOk("backup_policy"); found </span><span class="cov0" title="0">{
                bPolicy := policies.([]interface{})[0].(map[string]interface{})
                if bPolicy["include_cluster_resources_mode"] != "" </span><span class="cov0" title="0">{
                        data["include_cluster_resources_mode"] = strings.ToLower(string(policy.IncludeClusterResourceMode))
                        data["include_cluster_resources"] = true
                }</span> else<span class="cov0" title="0"> {
                        data["include_cluster_resources"] = flattenIncludeResourceMode(policy.IncludeClusterResourceMode)
                }</span>
        }
        <span class="cov0" title="0">result = append(result, data)
        return result</span>
}

func flattenIncludeResourceMode(m models.V1IncludeClusterResourceMode) bool <span class="cov0" title="0">{
        return m == models.V1IncludeClusterResourceMode("Always")
}</span>

func updateBackupPolicy(c *client.V1Client, d *schema.ResourceData) error <span class="cov0" title="0">{
        if policy := toBackupPolicy(d); policy != nil </span><span class="cov0" title="0">{
                //clusterContext := d.Get("context").(string)
                return c.ApplyClusterBackupConfig(d.Id(), policy)
        }</span> else<span class="cov0" title="0"> {
                return errors.New("backup policy validation: The backup policy cannot be destroyed. To disable it, set the schedule to an empty string")
        }</span>
}

func toScanPolicy(d *schema.ResourceData) *models.V1ClusterComplianceScheduleConfig <span class="cov0" title="0">{
        if profiles, found := d.GetOk("scan_policy"); found </span><span class="cov0" title="0">{
                config := &amp;models.V1ClusterComplianceScheduleConfig{}
                policy := profiles.([]interface{})[0].(map[string]interface{})
                if policy["configuration_scan_schedule"] != nil </span><span class="cov0" title="0">{
                        config.KubeBench = &amp;models.V1ClusterComplianceScanKubeBenchScheduleConfig{
                                Schedule: &amp;models.V1ClusterFeatureSchedule{
                                        ScheduledRunTime: policy["configuration_scan_schedule"].(string),
                                },
                        }
                }</span>
                <span class="cov0" title="0">if policy["penetration_scan_schedule"] != nil </span><span class="cov0" title="0">{
                        config.KubeHunter = &amp;models.V1ClusterComplianceScanKubeHunterScheduleConfig{
                                Schedule: &amp;models.V1ClusterFeatureSchedule{
                                        ScheduledRunTime: policy["penetration_scan_schedule"].(string),
                                },
                        }
                }</span>
                <span class="cov0" title="0">if policy["conformance_scan_schedule"] != nil </span><span class="cov0" title="0">{
                        config.Sonobuoy = &amp;models.V1ClusterComplianceScanSonobuoyScheduleConfig{
                                Schedule: &amp;models.V1ClusterFeatureSchedule{
                                        ScheduledRunTime: policy["conformance_scan_schedule"].(string),
                                },
                        }
                }</span>
                <span class="cov0" title="0">return config</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func flattenScanPolicy(driverSpec map[string]models.V1ComplianceScanDriverSpec) []interface{} <span class="cov0" title="0">{
        result := make([]interface{}, 0, 1)
        data := map[string]interface{}{
                "configuration_scan_schedule": "",
                "penetration_scan_schedule":   "",
                "conformance_scan_schedule":   "",
        }

        if v, found := driverSpec["kube-bench"]; found </span><span class="cov0" title="0">{
                if v.Config.Schedule.ScheduledRunTime == "" </span><span class="cov0" title="0">{
                        data["configuration_scan_schedule"] = ""
                }</span> else<span class="cov0" title="0"> {
                        data["configuration_scan_schedule"] = v.Config.Schedule.ScheduledRunTime
                }</span>
        }
        <span class="cov0" title="0">if v, found := driverSpec["kube-hunter"]; found </span><span class="cov0" title="0">{
                if v.Config.Schedule.ScheduledRunTime == "" </span><span class="cov0" title="0">{
                        data["penetration_scan_schedule"] = ""
                }</span> else<span class="cov0" title="0"> {
                        data["penetration_scan_schedule"] = v.Config.Schedule.ScheduledRunTime
                }</span>
        }
        <span class="cov0" title="0">if v, found := driverSpec["sonobuoy"]; found </span><span class="cov0" title="0">{
                if v.Config.Schedule.ScheduledRunTime == "" </span><span class="cov0" title="0">{
                        data["conformance_scan_schedule"] = ""
                }</span> else<span class="cov0" title="0"> {
                        data["conformance_scan_schedule"] = v.Config.Schedule.ScheduledRunTime
                }</span>
        }
        <span class="cov0" title="0">if data["configuration_scan_schedule"] == "" &amp;&amp; data["penetration_scan_schedule"] == "" &amp;&amp; data["conformance_scan_schedule"] == "" </span><span class="cov0" title="0">{
                return result
        }</span> else<span class="cov0" title="0"> {
                result = append(result, data)
        }</span>
        <span class="cov0" title="0">return result</span>
}

func updateScanPolicy(c *client.V1Client, d *schema.ResourceData) error <span class="cov0" title="0">{
        if policy := toScanPolicy(d); policy != nil || d.HasChange("scan_policy") </span><span class="cov0" title="0">{
                //ClusterContext := d.Get("context").(string)
                if policy == nil </span><span class="cov0" title="0">{
                        policy = getEmptyScanPolicy()
                }</span>
                <span class="cov0" title="0">return c.ApplyClusterScanConfig(d.Id(), policy)</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func getEmptyScanPolicy() *models.V1ClusterComplianceScheduleConfig <span class="cov0" title="0">{
        scanPolicy := &amp;models.V1ClusterComplianceScheduleConfig{
                KubeBench:  &amp;models.V1ClusterComplianceScanKubeBenchScheduleConfig{Schedule: &amp;models.V1ClusterFeatureSchedule{ScheduledRunTime: ""}},
                KubeHunter: &amp;models.V1ClusterComplianceScanKubeHunterScheduleConfig{Schedule: &amp;models.V1ClusterFeatureSchedule{ScheduledRunTime: ""}},
                Sonobuoy:   &amp;models.V1ClusterComplianceScanSonobuoyScheduleConfig{Schedule: &amp;models.V1ClusterFeatureSchedule{ScheduledRunTime: ""}},
        }
        return scanPolicy
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package spectrocloud

import (
        "context"
        "errors"
        "fmt"
        "log"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

        "github.com/spectrocloud/palette-sdk-go/api/models"
        "github.com/spectrocloud/palette-sdk-go/client"

        "github.com/spectrocloud/terraform-provider-spectrocloud/types"
)

// validateProfileSource checks that only one of cluster_template or cluster_profile is specified
func validateProfileSource(d *schema.ResourceData) error <span class="cov0" title="0">{
        // cluster_template may not exist in all schemas (e.g., cluster_group)
        clusterTemplateRaw := d.Get("cluster_template")
        clusterProfileRaw := d.Get("cluster_profile")

        var clusterTemplate, clusterProfile []interface{}
        if clusterTemplateRaw != nil </span><span class="cov0" title="0">{
                clusterTemplate = clusterTemplateRaw.([]interface{})
        }</span>
        <span class="cov0" title="0">if clusterProfileRaw != nil </span><span class="cov0" title="0">{
                clusterProfile = clusterProfileRaw.([]interface{})
        }</span>

        <span class="cov0" title="0">if len(clusterTemplate) &gt; 0 &amp;&amp; len(clusterProfile) &gt; 0 </span><span class="cov0" title="0">{
                return errors.New("cannot specify both cluster_template and cluster_profile. Please use only one")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// extractProfilesFromTemplate extracts cluster_profile data from cluster_template schema
// and transforms it into the same structure as regular cluster_profile for processing
func extractProfilesFromTemplate(d *schema.ResourceData) ([]interface{}, error) <span class="cov0" title="0">{
        clusterTemplateRaw := d.Get("cluster_template")
        if clusterTemplateRaw == nil </span><span class="cov0" title="0">{
                return []interface{}{}, nil
        }</span>
        <span class="cov0" title="0">clusterTemplate := clusterTemplateRaw.([]interface{})
        if len(clusterTemplate) == 0 </span><span class="cov0" title="0">{
                return []interface{}{}, nil
        }</span>

        // cluster_template is a list with single item
        <span class="cov0" title="0">templateData := clusterTemplate[0].(map[string]interface{})

        // Extract cluster_profile set from template
        if clusterProfiles, ok := templateData["cluster_profile"]; ok &amp;&amp; clusterProfiles != nil </span><span class="cov0" title="0">{
                profilesSet := clusterProfiles.(*schema.Set)
                rawProfiles := profilesSet.List()

                // Filter out empty/invalid profiles
                validProfiles := make([]interface{}, 0)
                for _, profile := range rawProfiles </span><span class="cov0" title="0">{
                        if profile == nil </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">p, ok := profile.(map[string]interface{})
                        if !ok </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        // Skip profiles without an ID
                        <span class="cov0" title="0">profileID, hasID := p["id"]
                        if !hasID || profileID == nil || profileID == "" </span><span class="cov0" title="0">{
                                log.Printf("extractProfilesFromTemplate: skipping profile without ID")
                                continue</span>
                        }

                        <span class="cov0" title="0">validProfiles = append(validProfiles, profile)</span>
                }

                <span class="cov0" title="0">log.Printf("extractProfilesFromTemplate: extracted %d valid profiles (filtered from %d total)", len(validProfiles), len(rawProfiles))
                return validProfiles, nil</span>
        }

        <span class="cov0" title="0">return []interface{}{}, nil</span>
}

// extractProfilesFromTemplateData extracts cluster_profile data from raw cluster_template data
// This is used during updates when we have the new template data from d.GetChange()
func extractProfilesFromTemplateData(clusterTemplateData []interface{}) ([]interface{}, error) <span class="cov0" title="0">{
        if len(clusterTemplateData) == 0 </span><span class="cov0" title="0">{
                log.Printf("extractProfilesFromTemplateData: empty cluster template data")
                return []interface{}{}, nil
        }</span>

        // cluster_template is a list with single item
        <span class="cov0" title="0">templateData := clusterTemplateData[0].(map[string]interface{})

        // Extract cluster_profile set from template
        if clusterProfiles, ok := templateData["cluster_profile"]; ok &amp;&amp; clusterProfiles != nil </span><span class="cov0" title="0">{
                profilesSet := clusterProfiles.(*schema.Set)
                rawProfiles := profilesSet.List()

                // Filter out empty/invalid profiles
                validProfiles := make([]interface{}, 0)
                for _, profile := range rawProfiles </span><span class="cov0" title="0">{
                        if profile == nil </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">p, ok := profile.(map[string]interface{})
                        if !ok </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        // Skip profiles without an ID
                        <span class="cov0" title="0">profileID, hasID := p["id"]
                        if !hasID || profileID == nil || profileID == "" </span><span class="cov0" title="0">{
                                log.Printf("extractProfilesFromTemplateData: skipping profile without ID")
                                continue</span>
                        }

                        <span class="cov0" title="0">validProfiles = append(validProfiles, profile)</span>
                }

                <span class="cov0" title="0">log.Printf("extractProfilesFromTemplateData: extracted %d valid profiles (filtered from %d total)", len(validProfiles), len(rawProfiles))
                return validProfiles, nil</span>
        }

        <span class="cov0" title="0">log.Printf("extractProfilesFromTemplateData: no cluster_profile found in template data")
        return []interface{}{}, nil</span>
}

// resolveProfileSource determines which source to use and returns the profile data
// Returns: (profiles, source, error) where source is "cluster_template" or "cluster_profile"
func resolveProfileSource(d *schema.ResourceData) ([]interface{}, string, error) <span class="cov0" title="0">{
        // First validate mutual exclusivity
        if err := validateProfileSource(d); err != nil </span><span class="cov0" title="0">{
                return nil, "", err
        }</span>

        <span class="cov0" title="0">clusterTemplateRaw := d.Get("cluster_template")
        clusterProfileRaw := d.Get("cluster_profile")

        var clusterTemplate, clusterProfile []interface{}
        if clusterTemplateRaw != nil </span><span class="cov0" title="0">{
                clusterTemplate = clusterTemplateRaw.([]interface{})
        }</span>
        <span class="cov0" title="0">if clusterProfileRaw != nil </span><span class="cov0" title="0">{
                clusterProfile = clusterProfileRaw.([]interface{})
        }</span>

        // Check cluster_template first
        <span class="cov0" title="0">if len(clusterTemplate) &gt; 0 </span><span class="cov0" title="0">{
                profiles, err := extractProfilesFromTemplate(d)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, "", err
                }</span>
                <span class="cov0" title="0">log.Printf("Using profiles from cluster_template")
                return profiles, "cluster_template", nil</span>
        }

        // Fall back to cluster_profile
        <span class="cov0" title="0">if len(clusterProfile) &gt; 0 </span><span class="cov0" title="0">{
                log.Printf("Using profiles from cluster_profile")
                return clusterProfile, "cluster_profile", nil
        }</span>

        <span class="cov0" title="0">return []interface{}{}, "", nil</span>
}

func toProfiles(c *client.V1Client, d *schema.ResourceData, clusterContext string) ([]*models.V1SpectroClusterProfileEntity, error) <span class="cov0" title="0">{
        return toProfilesCommon(c, d, d.Id(), clusterContext)
}</span>

func toAddonDeplProfiles(c *client.V1Client, d *schema.ResourceData) ([]*models.V1SpectroClusterProfileEntity, error) <span class="cov0" title="0">{
        clusterUid := ""
        clusterContext := ""
        // handling cluster attachment flow for cluster created outside terraform and attaching addon profile to it
        if uid, ok := d.GetOk("cluster_uid"); ok &amp;&amp; uid != nil </span><span class="cov0" title="0">{
                clusterUid = uid.(string) //d.Get("cluster_uid").(string)
        }</span>
        // handling cluster day 2 addon profile operation flow
        <span class="cov0" title="0">if clusterUid == "" </span><span class="cov0" title="0">{
                clusterUid = d.Id()
        }</span>
        <span class="cov0" title="0">if ct, ok := d.GetOk("context"); ok &amp;&amp; c != nil </span><span class="cov0" title="0">{
                clusterContext = ct.(string)
        }</span>
        <span class="cov0" title="0">err := ValidateContext(clusterContext)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return toProfilesCommon(c, d, clusterUid, clusterContext)</span>
}

func toProfilesCommon(c *client.V1Client, d *schema.ResourceData, clusterUID, context string) ([]*models.V1SpectroClusterProfileEntity, error) <span class="cov0" title="0">{
        var cluster *models.V1SpectroCluster
        var err error
        if clusterUID != "" </span><span class="cov0" title="0">{
                cluster, err = c.GetClusterWithoutStatus(clusterUID)
                if err != nil || cluster == nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("cluster %s cannot be retrieved in context %s", clusterUID, context)
                }</span>
        }

        <span class="cov0" title="0">resp := make([]*models.V1SpectroClusterProfileEntity, 0)

        // Resolve profile source (cluster_template or cluster_profile)
        profiles, source, err := resolveProfileSource(d)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if len(profiles) &gt; 0 </span><span class="cov0" title="0">{
                for _, profile := range profiles </span><span class="cov0" title="0">{
                        p := profile.(map[string]interface{})
                        // Profile Variables handling
                        pVars := make([]*models.V1SpectroClusterVariable, 0)
                        if pv, ok := p["variables"]; ok &amp;&amp; pv != nil </span><span class="cov0" title="0">{
                                variables := p["variables"].(map[string]interface{})
                                for key, value := range variables </span><span class="cov0" title="0">{
                                        pVars = append(pVars, &amp;models.V1SpectroClusterVariable{
                                                Name:  StringPtr(key),
                                                Value: value.(string),
                                        })
                                }</span>
                        }

                        <span class="cov0" title="0">packValues := make([]*models.V1PackValuesEntity, 0)
                        // Pack values only exist in cluster_profile, not in cluster_template
                        if source == "cluster_profile" </span><span class="cov0" title="0">{
                                if packs, ok := p["pack"]; ok &amp;&amp; packs != nil </span><span class="cov0" title="0">{
                                        for _, pack := range p["pack"].([]interface{}) </span><span class="cov0" title="0">{
                                                p := toPack(cluster, pack)
                                                packValues = append(packValues, p)
                                        }</span>
                                }
                        }

                        <span class="cov0" title="0">resp = append(resp, &amp;models.V1SpectroClusterProfileEntity{
                                UID:        p["id"].(string),
                                PackValues: packValues,
                                Variables:  pVars,
                        })</span>
                }
        }

        <span class="cov0" title="0">return resp, nil</span>
}

func toSpcApplySettings(d *schema.ResourceData) (*models.V1SpcApplySettings, error) <span class="cov0" title="0">{
        if d.Get("apply_setting") != nil </span><span class="cov0" title="0">{
                setting := d.Get("apply_setting").(string)
                if setting != "" </span><span class="cov0" title="0">{
                        return &amp;models.V1SpcApplySettings{
                                ActionType: setting,
                        }, nil
                }</span>
        }

        <span class="cov0" title="0">return nil, nil</span>
}

func toPack(cluster *models.V1SpectroCluster, pSrc interface{}) *models.V1PackValuesEntity <span class="cov0" title="0">{
        p := pSrc.(map[string]interface{})

        pack := &amp;models.V1PackValuesEntity{
                Name: types.Ptr(p["name"].(string)),
        }

        setPackValues(pack, p)
        setPackTag(pack, p)
        setPackType(pack, p)
        setPackManifests(pack, p, cluster)

        return pack
}</span>

func setPackValues(pack *models.V1PackValuesEntity, p map[string]interface{}) <span class="cov0" title="0">{
        if val, found := p["values"]; found &amp;&amp; len(val.(string)) &gt; 0 </span><span class="cov0" title="0">{
                pack.Values = val.(string)
        }</span>
}

func setPackTag(pack *models.V1PackValuesEntity, p map[string]interface{}) <span class="cov0" title="0">{
        if val, found := p["tag"]; found &amp;&amp; len(val.(string)) &gt; 0 </span><span class="cov0" title="0">{
                pack.Tag = val.(string)
        }</span>
}

func setPackType(pack *models.V1PackValuesEntity, p map[string]interface{}) <span class="cov0" title="0">{
        if val, found := p["type"]; found &amp;&amp; len(val.(string)) &gt; 0 </span><span class="cov0" title="0">{
                pack.Type = types.Ptr(models.V1PackType(val.(string)))
        }</span>
}

func setPackManifests(pack *models.V1PackValuesEntity, p map[string]interface{}, cluster *models.V1SpectroCluster) <span class="cov0" title="0">{
        if val, found := p["manifest"]; found &amp;&amp; len(val.([]interface{})) &gt; 0 </span><span class="cov0" title="0">{
                manifestsData := val.([]interface{})
                manifests := make([]*models.V1ManifestRefUpdateEntity, len(manifestsData))
                for i := 0; i &lt; len(manifestsData); i++ </span><span class="cov0" title="0">{
                        data := manifestsData[i].(map[string]interface{})
                        uid := ""
                        if cluster != nil </span><span class="cov0" title="0">{
                                packs := make([]*models.V1PackRef, 0)
                                for _, profile := range cluster.Spec.ClusterProfileTemplates </span><span class="cov0" title="0">{
                                        packs = append(packs, profile.Packs...)
                                }</span>
                                <span class="cov0" title="0">uid = getManifestUID(data["name"].(string), packs)</span>
                        }
                        <span class="cov0" title="0">manifests[i] = &amp;models.V1ManifestRefUpdateEntity{
                                Name:    types.Ptr(data["name"].(string)),
                                Content: data["content"].(string),
                                UID:     uid,
                        }</span>
                }
                <span class="cov0" title="0">pack.Manifests = manifests</span>
        }
}

// setReplaceWithProfileForExisting sets the ReplaceWithProfile field for each profile
// that already exists on the cluster. This is necessary when using PATCH to update
// profiles - without ReplaceWithProfile, PATCH would add duplicates instead of updating.
// It matches profiles by name: if a profile with the same name is already attached to
// the cluster, ReplaceWithProfile is set to that existing profile's UID.
func setReplaceWithProfileForExisting(c *client.V1Client, cluster *models.V1SpectroCluster, profiles []*models.V1SpectroClusterProfileEntity) error <span class="cov0" title="0">{
        if cluster == nil || len(profiles) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">for _, profile := range profiles </span><span class="cov0" title="0">{
                if profile == nil || profile.UID == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Get the cluster profile to find its name
                <span class="cov0" title="0">clusterProfile, err := c.GetClusterProfile(profile.UID)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get cluster profile %s: %w", profile.UID, err)
                }</span>
                <span class="cov0" title="0">if clusterProfile == nil || clusterProfile.Metadata == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Check if a profile with the same name is already attached to the cluster
                <span class="cov0" title="0">existingUID := findAttachedProfileByName(cluster, clusterProfile.Metadata.Name)
                if existingUID != "" &amp;&amp; existingUID != profile.UID </span><span class="cov0" title="0">{
                        // Only set ReplaceWithProfile if the existing profile has a DIFFERENT UID
                        // If the UIDs match, the profile is already attached and doesn't need replacement
                        log.Printf("Profile %s (name: %s) will replace existing attached profile %s",
                                profile.UID, clusterProfile.Metadata.Name, existingUID)
                        profile.ReplaceWithProfile = existingUID
                }</span> else<span class="cov0" title="0"> if existingUID == profile.UID </span><span class="cov0" title="0">{
                        log.Printf("Profile %s (name: %s) is already attached with same UID, no replacement needed",
                                profile.UID, clusterProfile.Metadata.Name)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// findAttachedProfileByName finds a profile attached to the cluster by its name.
// Returns the UID of the attached profile if found, empty string otherwise.
func findAttachedProfileByName(cluster *models.V1SpectroCluster, profileName string) string <span class="cov0" title="0">{
        if cluster == nil || cluster.Spec == nil || profileName == "" </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">for _, template := range cluster.Spec.ClusterProfileTemplates </span><span class="cov0" title="0">{
                if template != nil &amp;&amp; template.Name == profileName </span><span class="cov0" title="0">{
                        return template.UID
                }</span>
        }

        <span class="cov0" title="0">return ""</span>
}

// getProfilesToDelete compares old and new cluster_profile state and returns
// the UIDs of profiles that need to be deleted (profiles in old state but not in new state).
// This is necessary when using PATCH since it doesn't automatically remove profiles.
// Important: This compares by profile NAME, not just ID. If a profile ID changes but the
// name stays the same (version upgrade), it's NOT a deletion - it's handled by ReplaceWithProfile.
func getProfilesToDelete(c *client.V1Client, d *schema.ResourceData) []string <span class="cov0" title="0">{
        oldProfilesRaw, newProfilesRaw := d.GetChange("cluster_profile")

        // Build a set of new profile NAMES (not just IDs)
        // This is important: version upgrades change the ID but keep the same name
        newProfileNames := make(map[string]bool)
        if newProfilesRaw != nil </span><span class="cov0" title="0">{
                for _, p := range newProfilesRaw.([]interface{}) </span><span class="cov0" title="0">{
                        if p == nil </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">profile := p.(map[string]interface{})
                        if id, ok := profile["id"].(string); ok &amp;&amp; id != "" </span><span class="cov0" title="0">{
                                // Get the profile name from the API
                                clusterProfile, err := c.GetClusterProfile(id)
                                if err != nil </span><span class="cov0" title="0">{
                                        log.Printf("Warning: could not get profile %s to check name: %v", id, err)
                                        continue</span>
                                }
                                <span class="cov0" title="0">if clusterProfile != nil &amp;&amp; clusterProfile.Metadata != nil </span><span class="cov0" title="0">{
                                        newProfileNames[clusterProfile.Metadata.Name] = true
                                }</span>
                        }
                }
        }

        // Find profiles in old state whose NAME is not in new state
        // Only these are actual deletions; ID changes with same name are version upgrades
        <span class="cov0" title="0">var profilesToDelete []string
        if oldProfilesRaw != nil </span><span class="cov0" title="0">{
                for _, p := range oldProfilesRaw.([]interface{}) </span><span class="cov0" title="0">{
                        if p == nil </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">profile := p.(map[string]interface{})
                        if id, ok := profile["id"].(string); ok &amp;&amp; id != "" </span><span class="cov0" title="0">{
                                // Get the old profile name from the API
                                clusterProfile, err := c.GetClusterProfile(id)
                                if err != nil </span><span class="cov0" title="0">{
                                        log.Printf("Warning: could not get old profile %s to check name: %v", id, err)
                                        continue</span>
                                }
                                <span class="cov0" title="0">if clusterProfile != nil &amp;&amp; clusterProfile.Metadata != nil </span><span class="cov0" title="0">{
                                        profileName := clusterProfile.Metadata.Name
                                        if !newProfileNames[profileName] </span><span class="cov0" title="0">{
                                                // This profile name is not in the new state - it's a real deletion
                                                log.Printf("Profile %s (name: %s) will be deleted (name removed from cluster_profile)", id, profileName)
                                                profilesToDelete = append(profilesToDelete, id)
                                        }</span> else<span class="cov0" title="0"> {
                                                log.Printf("Profile %s (name: %s) ID changed but name still exists - version upgrade, not deletion", id, profileName)
                                        }</span>
                                }
                        }
                }
        }

        <span class="cov0" title="0">return profilesToDelete</span>
}

func updateProfiles(c *client.V1Client, d *schema.ResourceData) error <span class="cov0" title="0">{
        log.Printf("Updating cluster_profile (not cluster_template)")

        // Capture old cluster_profile value at the start to restore on any error
        // This prevents Terraform state from getting out of sync with API when updates fail
        oldProfile, _ := d.GetChange("cluster_profile")
        restoreOldProfile := func() </span><span class="cov0" title="0">{
                _ = d.Set("cluster_profile", oldProfile)
        }</span>

        <span class="cov0" title="0">profiles, err := toAddonDeplProfiles(c, d)
        var variableEntity []*models.V1SpectroClusterVariableUpdateEntity
        if err != nil </span><span class="cov0" title="0">{
                // Restore old value on error
                restoreOldProfile()
                return err
        }</span>
        <span class="cov0" title="0">settings, err := toSpcApplySettings(d)
        if err != nil </span><span class="cov0" title="0">{
                restoreOldProfile()
                return err
        }</span>

        // Get the current cluster state to find existing profile UIDs for replacement
        <span class="cov0" title="0">cluster, err := c.GetCluster(d.Id())
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get cluster for profile update: %w", err)
        }</span>

        // Handle profile deletions: find profiles that were in old state but not in new state
        // These need to be explicitly deleted since PATCH doesn't remove profiles
        <span class="cov0" title="0">if d.HasChange("cluster_profile") </span><span class="cov0" title="0">{
                profilesToDelete := getProfilesToDelete(c, d)
                if len(profilesToDelete) &gt; 0 </span><span class="cov0" title="0">{
                        log.Printf("Deleting %d profiles that were removed from cluster_profile", len(profilesToDelete))
                        deleteBody := &amp;models.V1SpectroClusterProfilesDeleteEntity{
                                ProfileUids: profilesToDelete,
                        }
                        if err := c.DeleteAddonDeployment(d.Id(), deleteBody); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to delete removed profiles: %w", err)
                        }</span>
                }
        }

        // If there are no profiles to add/update, we're done
        <span class="cov0" title="0">if len(profiles) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Set ReplaceWithProfile for profiles that already exist on the cluster
        // This ensures PATCH updates existing profiles instead of adding duplicates
        <span class="cov0" title="0">if err := setReplaceWithProfileForExisting(c, cluster, profiles); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to resolve profile replacements: %w", err)
        }</span>

        <span class="cov0" title="0">body := &amp;models.V1SpectroClusterProfiles{
                Profiles:         profiles,
                SpcApplySettings: settings,
        }
        clusterContext := d.Get("context").(string)
        // Use PATCH instead of PUT to preserve add-on profiles attached via spectrocloud_addon_deployment
        if err := c.PatchClusterProfileValues(d.Id(), body); err != nil </span><span class="cov0" title="0">{
                // Restore old value on API error (e.g., DuplicateClusterPacksForbidden)
                // This ensures Terraform state stays in sync with actual API state
                restoreOldProfile()
                return err
        }</span>

        <span class="cov0" title="0">if _, found := toTags(d)["skip_apply"]; found </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">ctx := context.Background()
        if err := waitForProfileDownload(ctx, c, clusterContext, d.Id(), d.Timeout(schema.TimeoutUpdate)); err != nil </span><span class="cov0" title="0">{
                restoreOldProfile()
                return err
        }</span>

        // Profile Variable Handling - only for cluster_profile
        <span class="cov0" title="0">var newProfiles []interface{}
        if d.HasChange("cluster_profile") </span><span class="cov0" title="0">{
                _, newProfilesRaw := d.GetChange("cluster_profile")
                newProfiles = newProfilesRaw.([]interface{})
        }</span>

        <span class="cov0" title="0">for _, newProfile := range newProfiles </span><span class="cov0" title="0">{
                if newProfile == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">p := newProfile.(map[string]interface{})

                // Skip profiles without an ID
                profileID, hasID := p["id"]
                if !hasID || profileID == nil || profileID.(string) == "" </span><span class="cov0" title="0">{
                        log.Printf("Skipping profile without ID during variable update")
                        continue</span>
                }

                <span class="cov0" title="0">pVars := make([]*models.V1SpectroClusterVariable, 0)
                if pv, ok := p["variables"]; ok &amp;&amp; pv != nil </span><span class="cov0" title="0">{
                        variables := p["variables"].(map[string]interface{})
                        for key, value := range variables </span><span class="cov0" title="0">{
                                if key != "" &amp;&amp; value != nil </span><span class="cov0" title="0">{
                                        pVars = append(pVars, &amp;models.V1SpectroClusterVariable{
                                                Name:  StringPtr(key),
                                                Value: value.(string),
                                        })
                                }</span>
                        }
                }

                // Only add to variableEntity if there are variables to update
                <span class="cov0" title="0">if len(pVars) != 0 </span><span class="cov0" title="0">{
                        log.Printf("Updating variables for profile: %s with %d variables", profileID.(string), len(pVars))
                        variableEntity = append(variableEntity, &amp;models.V1SpectroClusterVariableUpdateEntity{
                                ProfileUID: StringPtr(p["id"].(string)),
                                Variables:  pVars,
                        })
                }</span>
        }
        // Patching cluster profiles Variables
        <span class="cov0" title="0">if len(variableEntity) != 0 </span><span class="cov0" title="0">{
                err = c.UpdateClusterProfileVariableInCluster(d.Id(), variableEntity)
                if err != nil </span><span class="cov0" title="0">{
                        restoreOldProfile()
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func flattenClusterProfileForImport(c *client.V1Client, d *schema.ResourceData) ([]interface{}, error) <span class="cov0" title="0">{
        //clusterContext := "project"
        //if v, ok := d.GetOk("context"); ok {
        //        clusterContext = v.(string)
        //}
        clusterProfiles := make([]interface{}, 0)
        cluster, err := c.GetCluster(d.Id())
        if err != nil </span><span class="cov0" title="0">{
                return clusterProfiles, err
        }</span>
        <span class="cov0" title="0">for _, profileTemplate := range cluster.Spec.ClusterProfileTemplates </span><span class="cov0" title="0">{
                profile := make(map[string]interface{})
                profile["id"] = profileTemplate.UID
                clusterProfiles = append(clusterProfiles, profile)
        }</span>
        <span class="cov0" title="0">return clusterProfiles, nil</span>
}

// toClusterTemplateReference extracts cluster template reference from ResourceData
// Returns nil if cluster_template is not specified
func toClusterTemplateReference(d *schema.ResourceData) *models.V1ClusterTemplateRef <span class="cov0" title="0">{
        clusterTemplateRaw := d.Get("cluster_template")
        if clusterTemplateRaw == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">clusterTemplate := clusterTemplateRaw.([]interface{})
        if len(clusterTemplate) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">templateData := clusterTemplate[0].(map[string]interface{})
        templateID := templateData["id"].(string)

        return &amp;models.V1ClusterTemplateRef{
                UID: templateID,
        }</span>
}

// updateClusterTemplateVariables handles variable updates for cluster_template using the variables API
// This is a separate flow from updateProfiles and only patches variables without triggering full cluster update
func updateClusterTemplateVariables(c *client.V1Client, d *schema.ResourceData) error <span class="cov0" title="0">{
        log.Printf("Updating cluster_template variables using variables API")

        _, newTemplateData := d.GetChange("cluster_template")
        if len(newTemplateData.([]interface{})) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Extract profiles with variables from the new template data
        <span class="cov0" title="0">profiles, err := extractProfilesFromTemplateData(newTemplateData.([]interface{}))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Build variable update entities
        <span class="cov0" title="0">variableEntity := make([]*models.V1SpectroClusterVariableUpdateEntity, 0)
        for _, profile := range profiles </span><span class="cov0" title="0">{
                if profile == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">p := profile.(map[string]interface{})
                profileID, hasID := p["id"]
                if !hasID || profileID == nil || profileID.(string) == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Extract variables
                <span class="cov0" title="0">pVars := make([]*models.V1SpectroClusterVariable, 0)
                if pv, ok := p["variables"]; ok &amp;&amp; pv != nil </span><span class="cov0" title="0">{
                        variables := p["variables"].(map[string]interface{})
                        for key, value := range variables </span><span class="cov0" title="0">{
                                if key != "" &amp;&amp; value != nil </span><span class="cov0" title="0">{
                                        pVars = append(pVars, &amp;models.V1SpectroClusterVariable{
                                                Name:  StringPtr(key),
                                                Value: value.(string),
                                        })
                                }</span>
                        }
                }

                // Only add if there are variables to update
                <span class="cov0" title="0">if len(pVars) &gt; 0 </span><span class="cov0" title="0">{
                        log.Printf("Updating variables for profile: %s with %d variables", profileID.(string), len(pVars))
                        variableEntity = append(variableEntity, &amp;models.V1SpectroClusterVariableUpdateEntity{
                                ProfileUID: StringPtr(profileID.(string)),
                                Variables:  pVars,
                        })
                }</span>
        }

        // Patch variables using the variables API (not full cluster update)
        <span class="cov0" title="0">if len(variableEntity) &gt; 0 </span><span class="cov0" title="0">{
                log.Printf("Patching %d profile variables using variables API", len(variableEntity))
                err = c.UpdateClusterProfileVariableInCluster(d.Id(), variableEntity)
                if err != nil </span><span class="cov0" title="0">{
                        // Rollback on error
                        oldTemplate, _ := d.GetChange("cluster_template")
                        _ = d.Set("cluster_template", oldTemplate)
                        return err
                }</span>

                // Refresh variables from API after update
                <span class="cov0" title="0">log.Printf("Refreshing cluster_template variables after update")
                if err := flattenClusterTemplateVariables(c, d, d.Id()); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Warning: Failed to refresh variables after update: %v", err)
                        // Don't fail the update if refresh fails
                }</span>
        } else<span class="cov0" title="0"> {
                log.Printf("No variables to update for cluster_template")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// flattenClusterTemplateVariables reads variables from the cluster and updates only the variables
// in the cluster_template state, keeping the profile IDs from config
func flattenClusterTemplateVariables(c *client.V1Client, d *schema.ResourceData, clusterUID string) error <span class="cov0" title="0">{
        // Only process if cluster_template is used
        clusterTemplateRaw := d.Get("cluster_template")
        if clusterTemplateRaw == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">clusterTemplate := clusterTemplateRaw.([]interface{})
        if len(clusterTemplate) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Get variables from cluster using the variables API
        <span class="cov0" title="0">clusterVars, err := c.GetClusterVariables(clusterUID)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error fetching cluster variables: %v", err)
                // Don't fail read if variables API fails, just skip variable updates
                return nil
        }</span>

        // Build a map of profileUID -&gt; variables
        <span class="cov0" title="0">profileVariablesMap := make(map[string]map[string]string)
        for _, clusterVar := range clusterVars </span><span class="cov0" title="0">{
                if clusterVar.ProfileUID != nil &amp;&amp; clusterVar.Variables != nil </span><span class="cov0" title="0">{
                        vars := make(map[string]string)
                        for _, v := range clusterVar.Variables </span><span class="cov0" title="0">{
                                if v.Name != nil &amp;&amp; v.Value != "" </span><span class="cov0" title="0">{
                                        vars[*v.Name] = v.Value
                                }</span>
                        }
                        <span class="cov0" title="0">if len(vars) &gt; 0 </span><span class="cov0" title="0">{
                                profileVariablesMap[*clusterVar.ProfileUID] = vars
                        }</span>
                }
        }

        // Get configured profile IDs from current state
        <span class="cov0" title="0">templateData := clusterTemplate[0].(map[string]interface{})
        templateID := templateData["id"].(string)
        configuredProfileIDs := make(map[string]bool)

        // Build updated profile set with variables from API
        updatedProfileSet := schema.NewSet(schema.HashResource(&amp;schema.Resource{
                Schema: map[string]*schema.Schema{
                        "id": {
                                Type: schema.TypeString,
                        },
                        "variables": {
                                Type: schema.TypeMap,
                                Elem: &amp;schema.Schema{
                                        Type: schema.TypeString,
                                },
                        },
                },
        }), []interface{}{})

        // Update only the profiles that were in config with latest variables from API
        if clusterProfiles, ok := templateData["cluster_profile"]; ok &amp;&amp; clusterProfiles != nil </span><span class="cov0" title="0">{
                profilesSet := clusterProfiles.(*schema.Set)
                for _, profile := range profilesSet.List() </span><span class="cov0" title="0">{
                        p := profile.(map[string]interface{})
                        profileID := p["id"].(string)
                        configuredProfileIDs[profileID] = true

                        // Get configured variable names from config
                        configuredVarNames := make(map[string]bool)
                        if configVars, hasVars := p["variables"]; hasVars &amp;&amp; configVars != nil </span><span class="cov0" title="0">{
                                configVarsMap := configVars.(map[string]interface{})
                                for varName := range configVarsMap </span><span class="cov0" title="0">{
                                        configuredVarNames[varName] = true
                                }</span>
                        }

                        // Create updated profile with variables from API
                        <span class="cov0" title="0">updatedProfile := make(map[string]interface{})
                        updatedProfile["id"] = profileID

                        // Get variables from API response - only include variables that are in config
                        if apiVars, ok := profileVariablesMap[profileID]; ok &amp;&amp; len(apiVars) &gt; 0 </span><span class="cov0" title="0">{
                                // Convert map[string]string to map[string]interface{} for Set compatibility
                                // Only include variables that were in the original config
                                variablesInterface := make(map[string]interface{})
                                for k, v := range apiVars </span><span class="cov0" title="0">{
                                        if configuredVarNames[k] </span><span class="cov0" title="0">{
                                                variablesInterface[k] = v
                                        }</span>
                                }
                                <span class="cov0" title="0">if len(variablesInterface) &gt; 0 </span><span class="cov0" title="0">{
                                        updatedProfile["variables"] = variablesInterface
                                }</span>
                        }

                        <span class="cov0" title="0">updatedProfileSet.Add(updatedProfile)</span>
                }
        }

        <span class="cov0" title="0">log.Printf("flattenClusterTemplateVariables: updated %d profiles with variables (filtered to match config)", len(configuredProfileIDs))

        // Update cluster_template in state with refreshed variables
        updatedTemplate := []interface{}{
                map[string]interface{}{
                        "id":              templateID,
                        "cluster_profile": updatedProfileSet,
                },
        }

        return d.Set("cluster_template", updatedTemplate)</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package spectrocloud

import (
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

        "github.com/spectrocloud/palette-sdk-go/api/models"
        "github.com/spectrocloud/palette-sdk-go/client"
)

func toClusterRBACsInputEntities(d *schema.ResourceData) []*models.V1ClusterRbacInputEntity <span class="cov0" title="0">{
        rbacs := toRbacInputEntities(toClusterRbac(GetBindings(d)))
        return rbacs
}</span>

func GetBindings(d *schema.ResourceData) []*models.V1ClusterRbacBinding <span class="cov0" title="0">{
        bindings := make([]*models.V1ClusterRbacBinding, 0)

        if d.Get("cluster_rbac_binding") == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">for _, clusterRbac := range d.Get("cluster_rbac_binding").([]interface{}) </span><span class="cov0" title="0">{
                bindings = append(bindings, toClusterRBACBindings(clusterRbac)...)
        }</span>
        <span class="cov0" title="0">return bindings</span>
}

func toClusterRbac(bindings []*models.V1ClusterRbacBinding) *models.V1ClusterRbac <span class="cov0" title="0">{
        return &amp;models.V1ClusterRbac{
                Spec: &amp;models.V1ClusterRbacSpec{
                        Bindings: bindings,
                },
        }
}</span>

func toRbacInputEntities(config *models.V1ClusterRbac) []*models.V1ClusterRbacInputEntity <span class="cov0" title="0">{
        rbacs := make([]*models.V1ClusterRbacInputEntity, 0)

        clusterRoleBindings := make([]*models.V1ClusterRbacBinding, 0)
        roleBindings := make([]*models.V1ClusterRbacBinding, 0)

        for _, binding := range config.Spec.Bindings </span><span class="cov0" title="0">{
                switch binding.Type </span>{
                case "ClusterRoleBinding":<span class="cov0" title="0">
                        clusterRoleBindings = append(clusterRoleBindings, binding)</span>
                case "RoleBinding":<span class="cov0" title="0">
                        roleBindings = append(roleBindings, binding)</span>
                }
        }

        <span class="cov0" title="0">if len(clusterRoleBindings) &gt; 0 </span><span class="cov0" title="0">{
                rbacs = append(rbacs, &amp;models.V1ClusterRbacInputEntity{
                        Spec: &amp;models.V1ClusterRbacSpec{
                                Bindings: clusterRoleBindings,
                        },
                })
        }</span>

        <span class="cov0" title="0">if len(roleBindings) &gt; 0 </span><span class="cov0" title="0">{
                rbacs = append(rbacs, &amp;models.V1ClusterRbacInputEntity{
                        Spec: &amp;models.V1ClusterRbacSpec{
                                Bindings: roleBindings,
                        },
                })
        }</span>
        <span class="cov0" title="0">return rbacs</span>
}

func toClusterRBACBindings(clusterRbacBinding interface{}) []*models.V1ClusterRbacBinding <span class="cov0" title="0">{
        m := clusterRbacBinding.(map[string]interface{})

        role, _ := m["role"].(map[string]interface{})

        namespace := m["namespace"].(string)
        bindings := make([]*models.V1ClusterRbacBinding, 0)
        subjects := make([]*models.V1ClusterRbacSubjects, 0)

        for _, val := range m["subjects"].([]interface{}) </span><span class="cov0" title="0">{
                subjectValue := val.(map[string]interface{})
                var subjectType string
                if subjectValue["type"] != nil </span><span class="cov0" title="0">{
                        subjectType = subjectValue["type"].(string)
                }</span>
                <span class="cov0" title="0">subject := &amp;models.V1ClusterRbacSubjects{
                        Name:      subjectValue["name"].(string),
                        Namespace: subjectValue["namespace"].(string),
                        Type:      subjectType,
                }
                subjects = append(subjects, subject)</span>
        }
        <span class="cov0" title="0">roleRef := &amp;models.V1ClusterRoleRef{}
        if v, ok := role["kind"]; ok </span><span class="cov0" title="0">{
                roleRef.Kind = v.(string)
        }</span>
        <span class="cov0" title="0">if v, ok := role["name"]; ok </span><span class="cov0" title="0">{
                roleRef.Name = v.(string)
        }</span>
        <span class="cov0" title="0">bindings = append(bindings, &amp;models.V1ClusterRbacBinding{
                Type:      m["type"].(string),
                Role:      roleRef,
                Namespace: namespace,
                Subjects:  subjects,
        })
        return bindings</span>
}

func flattenClusterRBAC(items []*models.V1ClusterRbac) []interface{} <span class="cov0" title="0">{
        result := make([]interface{}, 0)
        for _, rbac := range items </span><span class="cov0" title="0">{
                for _, binding := range rbac.Spec.Bindings </span><span class="cov0" title="0">{
                        flattenRbac := make(map[string]interface{})
                        flattenRbac["type"] = binding.Type
                        flattenRbac["namespace"] = binding.Namespace

                        flattenRole := make(map[string]interface{})
                        flattenRole["kind"] = binding.Role.Kind
                        flattenRole["name"] = binding.Role.Name
                        flattenRbac["role"] = flattenRole

                        subjects := make([]interface{}, 0)
                        for _, subject := range binding.Subjects </span><span class="cov0" title="0">{
                                flattenSubject := make(map[string]interface{})
                                flattenSubject["type"] = subject.Type
                                flattenSubject["name"] = subject.Name
                                flattenSubject["namespace"] = subject.Namespace
                                subjects = append(subjects, flattenSubject)
                        }</span>

                        <span class="cov0" title="0">flattenRbac["subjects"] = subjects

                        result = append(result, flattenRbac)</span>
                }
        }
        <span class="cov0" title="0">return result</span>
}

func updateClusterRBAC(c *client.V1Client, d *schema.ResourceData) error <span class="cov0" title="0">{
        clusterContext := d.Get("context").(string)
        err := ValidateContext(clusterContext)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if rbacs := toClusterRBACsInputEntities(d); rbacs != nil </span><span class="cov0" title="0">{
                return c.ApplyClusterRbacConfig(d.Id(), rbacs)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package spectrocloud

import (
        "fmt"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "strings"
)

func toTags(d *schema.ResourceData) map[string]string <span class="cov10" title="12">{
        tags := make(map[string]string)
        if d.Get("tags") != nil </span><span class="cov10" title="12">{
                for _, t := range d.Get("tags").(*schema.Set).List() </span><span class="cov8" title="7">{
                        tag := t.(string)
                        if strings.Contains(tag, ":") </span><span class="cov8" title="7">{
                                tags[strings.Split(tag, ":")[0]] = strings.Split(tag, ":")[1]
                        }</span> else<span class="cov0" title="0"> {
                                tags[tag] = "spectro__tag"
                        }</span>
                }
                <span class="cov10" title="12">return tags</span>
        } else<span class="cov0" title="0"> {
                return nil
        }</span>
}

func flattenTags(labels map[string]string) []interface{} <span class="cov6" title="5">{
        tags := make([]interface{}, 0)
        if len(labels) &gt; 0 </span><span class="cov6" title="5">{
                for k, v := range labels </span><span class="cov8" title="7">{
                        if v == "spectro__tag" </span><span class="cov0" title="0">{
                                tags = append(tags, k)
                        }</span> else<span class="cov8" title="7"> {
                                tags = append(tags, fmt.Sprintf("%s:%s", k, v))
                        }</span>
                }
                <span class="cov6" title="5">return tags</span>
        } else<span class="cov0" title="0"> {
                return nil
        }</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package spectrocloud

import (
        "github.com/spectrocloud/palette-sdk-go/api/models"
)

func toClusterTaints(m map[string]interface{}) []*models.V1Taint <span class="cov0" title="0">{
        clusterTaints := make([]*models.V1Taint, 0)
        if m["taints"] == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">for _, clusterTaint := range m["taints"].([]interface{}) </span><span class="cov0" title="0">{
                b := toClusterTaint(clusterTaint)
                clusterTaints = append(clusterTaints, b)
        }</span>

        <span class="cov0" title="0">return clusterTaints</span>
}

func toClusterTaint(clusterTaint interface{}) *models.V1Taint <span class="cov0" title="0">{
        m := clusterTaint.(map[string]interface{})

        key, _ := m["key"].(string)
        value, _ := m["value"].(string)
        effect, _ := m["effect"].(string)

        ret := &amp;models.V1Taint{
                Effect: effect,
                Key:    key,
                Value:  value,
        }

        return ret
}</span>

func flattenClusterTaints(items []*models.V1Taint) []interface{} <span class="cov0" title="0">{
        result := make([]interface{}, 0)
        for _, taint := range items </span><span class="cov0" title="0">{
                flattenTaint := make(map[string]interface{})

                flattenTaint["key"] = taint.Key
                flattenTaint["value"] = taint.Value
                flattenTaint["effect"] = taint.Effect

                result = append(result, flattenTaint)
        }</span>
        <span class="cov0" title="0">return result</span>
}

func FlattenAdditionalLabelsAndTaints(labels map[string]string, intaints []*models.V1Taint, oi map[string]interface{}) <span class="cov0" title="0">{
        if len(labels) == 0 </span><span class="cov0" title="0">{
                oi["additional_labels"] = make(map[string]interface{})
        }</span> else<span class="cov0" title="0"> {
                oi["additional_labels"] = labels
        }</span>

        <span class="cov0" title="0">taints := flattenClusterTaints(intaints)
        if len(taints) &gt; 0 </span><span class="cov0" title="0">{
                oi["taints"] = taints
        }</span>
}

func FlattenAdditionalLabelsAnnotationsAndTaints(labels map[string]string, annotations map[string]string, intaints []*models.V1Taint, oi map[string]interface{}) <span class="cov0" title="0">{
        if len(labels) == 0 </span><span class="cov0" title="0">{
                oi["additional_labels"] = make(map[string]interface{})
        }</span> else<span class="cov0" title="0"> {
                oi["additional_labels"] = labels
        }</span>

        <span class="cov0" title="0">if len(annotations) == 0 </span><span class="cov0" title="0">{
                oi["additional_annotations"] = make(map[string]interface{})
        }</span> else<span class="cov0" title="0"> {
                oi["additional_annotations"] = annotations
        }</span>

        <span class="cov0" title="0">taints := flattenClusterTaints(intaints)
        if len(taints) &gt; 0 </span><span class="cov0" title="0">{
                oi["taints"] = taints
        }</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package spectrocloud

import (
        "github.com/spectrocloud/palette-sdk-go/api/models"
)

// getUpdateStrategy returns the update strategy string from the machine pool configuration.
// This is a simple helper to extract the update_strategy field.
func getUpdateStrategy(m map[string]interface{}) string <span class="cov0" title="0">{
        if updateStrategy, ok := m["update_strategy"].(string); ok &amp;&amp; updateStrategy != "" </span><span class="cov0" title="0">{
                return updateStrategy
        }</span>
        <span class="cov0" title="0">return "RollingUpdateScaleOut"</span> // Default value
}

// toUpdateStrategy builds the V1UpdateStrategy model from the machine pool configuration.
// Handles both simple update_strategy and OverrideScaling with maxSurge and maxUnavailable.
func toUpdateStrategy(m map[string]interface{}) *models.V1UpdateStrategy <span class="cov0" title="0">{
        strategy := &amp;models.V1UpdateStrategy{
                Type: getUpdateStrategy(m),
        }

        // If using OverrideScaling, populate maxSurge and maxUnavailable from override_scaling
        if strategy.Type == "OverrideScaling" </span><span class="cov0" title="0">{
                if overrideScaling, ok := m["override_scaling"].([]interface{}); ok &amp;&amp; len(overrideScaling) &gt; 0 </span><span class="cov0" title="0">{
                        scalingConfig := overrideScaling[0].(map[string]interface{})
                        if maxSurge, ok := scalingConfig["max_surge"].(string); ok </span><span class="cov0" title="0">{
                                strategy.MaxSurge = maxSurge
                        }</span>
                        <span class="cov0" title="0">if maxUnavailable, ok := scalingConfig["max_unavailable"].(string); ok </span><span class="cov0" title="0">{
                                strategy.MaxUnavailable = maxUnavailable
                        }</span>
                }
        }

        <span class="cov0" title="0">return strategy</span>
}

// flattenUpdateStrategy flattens the SDK UpdateStrategy to Terraform state.
// Sets the update_strategy field from the API response.
func flattenUpdateStrategy(updateStrategy *models.V1UpdateStrategy, oi map[string]interface{}) <span class="cov0" title="0">{
        if updateStrategy != nil &amp;&amp; updateStrategy.Type != "" </span><span class="cov0" title="0">{
                oi["update_strategy"] = updateStrategy.Type
        }</span> else<span class="cov0" title="0"> {
                // Set default if no strategy is provided
                oi["update_strategy"] = "RollingUpdateScaleOut"
        }</span>
}

// flattenOverrideScaling flattens the MaxSurge and MaxUnavailable values from V1UpdateStrategy
// to the override_scaling Terraform field.
func flattenOverrideScaling(updateStrategy *models.V1UpdateStrategy, oi map[string]interface{}) <span class="cov0" title="0">{
        if updateStrategy != nil &amp;&amp; updateStrategy.Type == "OverrideScaling" </span><span class="cov0" title="0">{
                if updateStrategy.MaxSurge != "" || updateStrategy.MaxUnavailable != "" </span><span class="cov0" title="0">{
                        overrideScaling := make(map[string]interface{})
                        overrideScaling["max_surge"] = updateStrategy.MaxSurge
                        overrideScaling["max_unavailable"] = updateStrategy.MaxUnavailable
                        oi["override_scaling"] = []interface{}{overrideScaling}
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package spectrocloud

import (
        "context"
        "fmt"
        "github.com/spectrocloud/palette-sdk-go/api/apiutil/transport"
        "github.com/spectrocloud/palette-sdk-go/api/models"
        "strings"
        "time"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/spectrocloud/palette-sdk-go/client"
)

var resourceVirtualMachineCreatePendingStates = []string{
        "Stopped",
        "Starting",
        "Creating",
        "Provisioning",
        "Created",
        "WaitingForVolumeBinding",
        "Running",
        // Restart|Stop
        "Stopping",
        // Pause
        "Pausing",
        // Migration
        "Migrating",
        //Deleting VM
        "Terminating",
        "Deleted",
}

func waitForVirtualMachineToTargetState(ctx context.Context, d *schema.ResourceData, clusterUid, vmName, namespace string, diags diag.Diagnostics, c *client.V1Client, state, targetState string) (diag.Diagnostics, bool) <span class="cov0" title="0">{
        vm, err := c.GetVirtualMachine(clusterUid, namespace, vmName)
        if err != nil </span><span class="cov0" title="0">{
                return diags, true
        }</span>
        <span class="cov0" title="0">if vm == nil </span><span class="cov0" title="0">{
                return diag.FromErr(fmt.Errorf("virtual machine not found when waiting for state %s, %s, %s", clusterUid, namespace, vmName)), true
        }</span>

        <span class="cov0" title="0">if _, found := vm.Metadata.Labels["skip_vms"]; found </span><span class="cov0" title="0">{
                return diags, true
        }</span>

        <span class="cov0" title="0">stateConf := &amp;retry.StateChangeConf{
                Pending:    resourceVirtualMachineCreatePendingStates,
                Target:     []string{targetState},
                Refresh:    resourceVirtualMachineStateRefreshFunc(c, clusterUid, vmName, namespace),
                Timeout:    d.Timeout(state) - 1*time.Minute,
                MinTimeout: 10 * time.Second,
                Delay:      30 * time.Second,
        }

        // Wait, catching any errors
        _, err = stateConf.WaitForStateContext(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err), true
        }</span>
        <span class="cov0" title="0">return nil, false</span>
}

func resourceVirtualMachineStateRefreshFunc(c *client.V1Client, clusterUid, vmName, vmNamespace string) retry.StateRefreshFunc <span class="cov0" title="0">{
        return func() (interface{}, string, error) </span><span class="cov0" title="0">{
                vm, err := c.GetVirtualMachine(clusterUid, vmNamespace, vmName)
                if err != nil </span><span class="cov0" title="0">{
                        if transportErr, ok := err.(*transport.TransportError); ok </span><span class="cov0" title="0">{
                                if transportErr.HttpCode == 500 &amp;&amp; strings.Contains(transportErr.Payload.Message, fmt.Sprintf("Failed to get virtual machine '%s'", vmName)) </span><span class="cov0" title="0">{
                                        emptyVM := &amp;models.V1ClusterVirtualMachine{}
                                        return emptyVM, "Deleted", nil
                                }</span> else<span class="cov0" title="0"> {
                                        return nil, "", err
                                }</span>
                        }
                        <span class="cov0" title="0">return nil, "", err</span>
                }

                <span class="cov0" title="0">if vm == nil </span><span class="cov0" title="0">{
                        emptyVM := &amp;models.V1ClusterVirtualMachine{}
                        return emptyVM, "", nil
                }</span>

                <span class="cov0" title="0">return vm, vm.Status.PrintableStatus, nil</span>
        }
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package spectrocloud

import (
        "context"
        "fmt"
        "log"
        "time"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/spectrocloud/palette-sdk-go/api/models"
        "github.com/spectrocloud/palette-sdk-go/client"
)

var NodeMaintenanceLifecycleStates = []string{
        "Completed",
        "InProgress",
        "Initiated",
        "Failed",
}

type GetMaintenanceStatus func(string, string, string) (*models.V1MachineMaintenanceStatus, error)

type GetNodeStatusMap func(string, string) (map[string]models.V1CloudMachineStatus, error)

func waitForNodeMaintenanceCompleted(c *client.V1Client, ctx context.Context, fn GetMaintenanceStatus, ConfigUID, MachineName, NodeId string) (error, bool) <span class="cov0" title="0">{
        stateConf := &amp;retry.StateChangeConf{
                Delay:      30 * time.Second,
                Pending:    NodeMaintenanceLifecycleStates,
                Target:     []string{"Completed"},
                Refresh:    resourceClusterNodeMaintenanceRefreshFunc(c, fn, ConfigUID, MachineName, NodeId),
                Timeout:    30 * time.Minute,
                MinTimeout: 10 * time.Second,
        }

        // Wait, catching any errors
        _, err := stateConf.WaitForStateContext(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err, true
        }</span>
        <span class="cov0" title="0">return nil, false</span>
}

func resourceClusterNodeMaintenanceRefreshFunc(c *client.V1Client, fn GetMaintenanceStatus, ConfigUID, MachineName, NodeId string) retry.StateRefreshFunc <span class="cov0" title="0">{
        return func() (interface{}, string, error) </span><span class="cov0" title="0">{
                nmStatus, err := c.GetNodeMaintenanceStatus(client.GetMaintenanceStatus(fn), ConfigUID, MachineName, NodeId)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, "", err
                }</span>

                <span class="cov0" title="0">state := nmStatus.State
                log.Printf("Node maintenance state (%s): %s", NodeId, state)

                return nmStatus, state, nil</span>
        }
}

func resourceNodeAction(c *client.V1Client, ctx context.Context, newMachinePool interface{}, fn GetMaintenanceStatus, CloudType, ConfigUID, MachineName string) error <span class="cov0" title="0">{
        newNodes := newMachinePool.(map[string]interface{})["node"]
        if newNodes != nil </span><span class="cov0" title="0">{
                for _, n := range newNodes.([]interface{}) </span><span class="cov0" title="0">{
                        node := n.(map[string]interface{})
                        nodeMaintenanceStatus, err := c.GetNodeMaintenanceStatus(client.GetMaintenanceStatus(fn), ConfigUID, MachineName, node["node_id"].(string))
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if node["action"] != nodeMaintenanceStatus.Action </span><span class="cov0" title="0">{
                                nm := &amp;models.V1MachineMaintenance{
                                        Action: node["action"].(string),
                                }
                                err := c.ToggleMaintenanceOnNode(nm, CloudType, ConfigUID, MachineName, node["node_id"].(string))
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov0" title="0">err, isError := waitForNodeMaintenanceCompleted(c, ctx, fn, ConfigUID, MachineName, node["node_id"].(string))
                                if isError </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                }
        }
        <span class="cov0" title="0">return nil</span>
}

func flattenNodeMaintenanceStatus(c *client.V1Client, d *schema.ResourceData, fn GetNodeStatusMap, mPools []interface{}, cloudConfigId string) ([]interface{}, error) <span class="cov0" title="0">{
        _, n := d.GetChange("machine_pool")
        nsMap := make(map[string]interface{})
        machinePoolsList, i, err := getMachinePoolList(n)
        if err != nil </span><span class="cov0" title="0">{
                return i, err
        }</span>

        <span class="cov0" title="0">for _, mp := range machinePoolsList </span><span class="cov0" title="0">{
                machinePool := mp.(map[string]interface{})
                nsMap[machinePool["name"].(string)] = machinePool
        }</span>

        <span class="cov0" title="0">for i, mp := range mPools </span><span class="cov0" title="0">{
                m := mp.(map[string]interface{})
                // For handling unit test
                if _, ok := nsMap[m["name"].(string)]; !ok </span><span class="cov0" title="0">{
                        return mPools, nil
                }</span>

                <span class="cov0" title="0">newNodeList := nsMap[m["name"].(string)].(map[string]interface{})["node"].([]interface{})
                if len(newNodeList) &gt; 0 </span><span class="cov0" title="0">{
                        var nodes []interface{}
                        nodesStatus, err := fn(cloudConfigId, m["name"].(string))
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">for key, value := range nodesStatus </span><span class="cov0" title="0">{
                                for _, newNode := range newNodeList </span><span class="cov0" title="0">{
                                        if newNode.(map[string]interface{})["node_id"] == key </span><span class="cov0" title="0">{
                                                nodes = append(nodes, getNodeValue(key, value.MaintenanceStatus.Action))
                                        }</span>
                                }
                        }
                        <span class="cov0" title="0">if nodes != nil </span><span class="cov0" title="0">{
                                mPools[i].(map[string]interface{})["node"] = nodes
                        }</span>
                }
        }
        <span class="cov0" title="0">return mPools, nil</span>
}

func getMachinePoolList(n interface{}) ([]interface{}, []interface{}, error) <span class="cov0" title="0">{
        var machinePoolsList []interface{}

        // Check if n is of type *schema.Set
        if set, ok := n.(*schema.Set); ok </span><span class="cov0" title="0">{
                machinePoolsList = set.List()
        }</span> else<span class="cov0" title="0"> if list, ok := n.([]interface{}); ok </span><span class="cov0" title="0">{
                // If n is already a slice of interfaces
                machinePoolsList = list
        }</span> else<span class="cov0" title="0"> {
                // Handle error: n is neither *schema.Set nor []interface{}
                return nil, nil, fmt.Errorf("unexpected type for n: %T", n)
        }</span>
        <span class="cov0" title="0">return machinePoolsList, nil, nil</span>
}

func getNodeValue(nodeId, action string) map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "node_id": nodeId,
                "action":  action,
        }
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">package spectrocloud

import (
        "context"
        "log"
        "strconv"
        "time"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"
        "github.com/spectrocloud/palette-sdk-go/client"
)

var resourceClusterProfileUpdatePendingStates = []string{
        "false",
}

func waitForProfileDownload(ctx context.Context, c *client.V1Client, scope, id string, timeout time.Duration) error <span class="cov0" title="0">{
        stateConf := &amp;retry.StateChangeConf{
                Pending:    resourceClusterProfileUpdatePendingStates,
                Target:     []string{"true"}, // canBeApplied=true
                Refresh:    resourceClusterProfileStateRefreshFunc(c, id),
                Timeout:    timeout,
                MinTimeout: 10 * time.Second,
                Delay:      30 * time.Second,
        }

        _, err := stateConf.WaitForStateContext(ctx)

        return err
}</span>

func resourceClusterProfileStateRefreshFunc(c *client.V1Client, id string) retry.StateRefreshFunc <span class="cov0" title="0">{
        return func() (interface{}, string, error) </span><span class="cov0" title="0">{
                cluster, err := c.GetCluster(id)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, "", err
                }</span> else<span class="cov0" title="0"> if cluster == nil </span><span class="cov0" title="0">{
                        return nil, "Cluster deleted", nil
                }</span>

                <span class="cov0" title="0">state := strconv.FormatBool(cluster.Status.SpcApply.CanBeApplied)
                log.Printf("Cluster SpcApply state (%s): %s", id, state)

                return cluster, state, nil</span>
        }
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package common

const maxUint32 = 0xFFFFFFFF

// SafeUint32 converts int to uint32 with bounds checking to prevent overflow
func SafeUint32(value int) uint32 <span class="cov0" title="0">{
        if value &lt; 0 </span><span class="cov0" title="0">{
                return 0
        }</span>
        // On 32-bit systems, int max is smaller than uint32 max, so no overflow possible
        // On 64-bit systems, we need to check against uint32 max
        <span class="cov0" title="0">if ^uint(0)&gt;&gt;32 == 0 </span><span class="cov0" title="0">{
                // 32-bit system: int and uint32 have same size, no overflow possible
                if value &gt;= 0 </span><span class="cov0" title="0">{
                        return uint32(value)
                }</span>
                <span class="cov0" title="0">return 0</span>
        }
        // 64-bit system: check against uint32 max
        <span class="cov0" title="0">if uint64(value) &gt; maxUint32 </span><span class="cov0" title="0">{
                return maxUint32
        }</span>
        <span class="cov0" title="0">if value &gt;= 0 </span><span class="cov0" title="0">{
                return uint32(value)
        }</span>
        <span class="cov0" title="0">return 0</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package spectrocloud

import (
        "context"
        "fmt"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/spectrocloud/palette-sdk-go/api/models"
        "github.com/spectrocloud/palette-sdk-go/client"
)

func schemaValidationForLocationProvider(ctx context.Context, d *schema.ResourceDiff, meta interface{}) error <span class="cov0" title="0">{
        provider := d.Get("storage_provider").(string)
        if (provider == StorageProviderAWS || provider == StorageProviderMinio) &amp;&amp; (len(d.Get("s3").([]interface{})) == 0 || d.Get("bucket_name").(string) == "" || d.Get("region").(string) == "") </span><span class="cov0" title="0">{
                return fmt.Errorf("`s3, bucket_name &amp; region` is required when location provider set to 'aws' or 'minio'")
        }</span>
        <span class="cov0" title="0">if (provider == StorageProviderAWS || provider == StorageProviderMinio) &amp;&amp; (len(d.Get("azure_storage_config").([]interface{})) != 0 || (len(d.Get("gcp_storage_config").([]interface{}))) != 0) </span><span class="cov0" title="0">{
                return fmt.Errorf("`gcp_storage_config or azure_storage_config` are not allowed when location provider set to 'aws' or 'minio'")
        }</span>
        <span class="cov0" title="0">if (provider == StorageProviderGCP) &amp;&amp; (len(d.Get("gcp_storage_config").([]interface{})) == 0 || d.Get("bucket_name").(string) == "") </span><span class="cov0" title="0">{
                return fmt.Errorf("`gcp_storage_config &amp; bucket_name` is required when location provider set to 'gcp'")
        }</span>
        <span class="cov0" title="0">if (provider == StorageProviderAzure) &amp;&amp; len(d.Get("azure_storage_config").([]interface{})) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("`azure_storage_config` is required when location provider set to 'azure'")
        }</span>
        <span class="cov0" title="0">if provider == StorageProviderAzure &amp;&amp; (len(d.Get("s3").([]interface{})) != 0 || d.Get("bucket_name").(string) != "" || d.Get("region").(string) != "" || d.Get("ca_cert").(string) != "") </span><span class="cov0" title="0">{
                return fmt.Errorf("`s3, bucket_name, region &amp; ca_cert` are not allowed when location provider set to 'azure'")
        }</span>
        <span class="cov0" title="0">if (provider == StorageProviderGCP) &amp;&amp; (len(d.Get("azure_storage_config").([]interface{})) != 0 || len(d.Get("s3").([]interface{})) != 0 || d.Get("region").(string) != "" || d.Get("ca_cert").(string) != "") </span><span class="cov0" title="0">{
                return fmt.Errorf("`azure_storage_config, s3, region, ca_cert` are not allowed when location provider set to 'gcp'")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func S3BackupStorageLocationCreate(d *schema.ResourceData, c *client.V1Client) diag.Diagnostics <span class="cov0" title="0">{
        var diags diag.Diagnostics

        bsl, bslCred := toS3BackupStorageLocation(d)
        if err := c.ValidateS3BackupStorageLocation(bslCred); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">uid, err := c.CreateS3BackupStorageLocation(bsl)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">d.SetId(uid)

        return diags</span>
}

func MinioBackupStorageLocationCreate(d *schema.ResourceData, c *client.V1Client) diag.Diagnostics <span class="cov0" title="0">{
        var diags diag.Diagnostics

        bsl, _ := toMinioBackupStorageLocation(d)
        // No credential validation required for minio
        uid, err := c.CreateMinioBackupStorageLocation(bsl)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">d.SetId(uid)

        return diags</span>
}

func GcpBackupStorageLocationCreate(d *schema.ResourceData, c *client.V1Client) diag.Diagnostics <span class="cov0" title="0">{
        var diags diag.Diagnostics

        bsl, bslCred := toGcpBackupStorageLocation(d)
        if err := c.ValidateGcpBackupStorageLocation(bslCred); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">uid, err := c.CreateGcpBackupStorageLocation(bsl)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">d.SetId(uid)

        return diags</span>
}

func AzureBackupStorageLocationCreate(d *schema.ResourceData, c *client.V1Client) diag.Diagnostics <span class="cov0" title="0">{
        var diags diag.Diagnostics

        bsl, bslCred := toAzureBackupStorageLocation(d)
        if err := c.ValidateAzureBackupStorageLocation(bslCred); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">uid, err := c.CreateAzureBackupStorageLocation(bsl)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">d.SetId(uid)

        return diags</span>
}

func S3BackupStorageLocationRead(d *schema.ResourceData, c *client.V1Client) diag.Diagnostics <span class="cov0" title="0">{
        var diags diag.Diagnostics

        bsl, err := c.GetBackupStorageLocation(d.Id())
        if err != nil </span><span class="cov0" title="0">{
                return handleReadError(d, err, diags)
        }</span> else<span class="cov0" title="0"> if bsl == nil </span><span class="cov0" title="0">{
                // Deleted - Terraform will recreate it
                d.SetId("")
                return diags
        }</span>

        <span class="cov0" title="0">if err := d.Set("name", bsl.Metadata.Name); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">if err := d.Set("is_default", bsl.Spec.IsDefault); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">if *bsl.Spec.Storage == models.V1LocationTypeS3 </span><span class="cov0" title="0">{
                s3Bsl, err := c.GetS3BackupStorageLocation(d.Id())
                if err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span> else<span class="cov0" title="0"> if s3Bsl == nil </span><span class="cov0" title="0">{
                        // Deleted - Terraform will recreate it
                        d.SetId("")
                        return diags
                }</span>
                <span class="cov0" title="0">if len(s3Bsl.Spec.Config.CaCert) &gt; 0 </span><span class="cov0" title="0">{
                        if err := d.Set("ca_cert", s3Bsl.Spec.Config.CaCert); err != nil </span><span class="cov0" title="0">{
                                return diag.FromErr(err)
                        }</span>
                }
                <span class="cov0" title="0">if err := d.Set("region", *s3Bsl.Spec.Config.Region); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
                <span class="cov0" title="0">if err := d.Set("bucket_name", *s3Bsl.Spec.Config.BucketName); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>

                <span class="cov0" title="0">s3 := make(map[string]interface{})
                if len(s3Bsl.Spec.Config.S3URL) &gt; 0 </span><span class="cov0" title="0">{
                        s3["s3_url"] = s3Bsl.Spec.Config.S3URL
                }</span>

                <span class="cov0" title="0">if s3Bsl.Spec.Config.S3ForcePathStyle != nil </span><span class="cov0" title="0">{
                        s3["s3_force_path_style"] = *s3Bsl.Spec.Config.S3ForcePathStyle
                }</span>
                <span class="cov0" title="0">s3["credential_type"] = string(*s3Bsl.Spec.Config.Credentials.CredentialType)
                if *s3Bsl.Spec.Config.Credentials.CredentialType == models.V1AwsCloudAccountCredentialTypeSecret </span><span class="cov0" title="0">{
                        s3["access_key"] = s3Bsl.Spec.Config.Credentials.AccessKey
                        // Preserve the existing secret_key from state to avoid drift detection when API returns masked values
                        if currentS3Config := d.Get("s3").([]interface{}); len(currentS3Config) &gt; 0 </span><span class="cov0" title="0">{
                                if currentS3 := currentS3Config[0].(map[string]interface{}); currentS3 != nil </span><span class="cov0" title="0">{
                                        if secretKey, exists := currentS3["secret_key"]; exists </span><span class="cov0" title="0">{
                                                s3["secret_key"] = secretKey
                                        }</span>
                                }
                        }
                } else<span class="cov0" title="0"> {
                        s3["arn"] = s3Bsl.Spec.Config.Credentials.Sts.Arn
                        if len(s3Bsl.Spec.Config.Credentials.Sts.ExternalID) &gt; 0 </span><span class="cov0" title="0">{
                                s3["external_id"] = s3Bsl.Spec.Config.Credentials.Sts.ExternalID
                        }</span>
                }
                <span class="cov0" title="0">s3Config := make([]interface{}, 0, 1)
                s3Config = append(s3Config, s3)
                if err := d.Set("s3", s3Config); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
        }

        <span class="cov0" title="0">return diags</span>
}

func MinioBackupStorageLocationRead(d *schema.ResourceData, c *client.V1Client) diag.Diagnostics <span class="cov0" title="0">{
        var diags diag.Diagnostics

        bsl, err := c.GetBackupStorageLocation(d.Id())
        if err != nil </span><span class="cov0" title="0">{
                return handleReadError(d, err, diags)
        }</span> else<span class="cov0" title="0"> if bsl == nil </span><span class="cov0" title="0">{
                // Deleted - Terraform will recreate it
                d.SetId("")
                return diags
        }</span>

        <span class="cov0" title="0">if err := d.Set("name", bsl.Metadata.Name); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">if err := d.Set("is_default", bsl.Spec.IsDefault); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">if *bsl.Spec.Storage == models.V1LocationTypeMinio </span><span class="cov0" title="0">{
                s3Bsl, err := c.GetMinioBackupStorageLocation(d.Id())
                if err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span> else<span class="cov0" title="0"> if s3Bsl == nil </span><span class="cov0" title="0">{
                        // Deleted - Terraform will recreate it
                        d.SetId("")
                        return diags
                }</span>
                <span class="cov0" title="0">if len(s3Bsl.Spec.Config.CaCert) &gt; 0 </span><span class="cov0" title="0">{
                        if err := d.Set("ca_cert", s3Bsl.Spec.Config.CaCert); err != nil </span><span class="cov0" title="0">{
                                return diag.FromErr(err)
                        }</span>
                }
                <span class="cov0" title="0">if err := d.Set("region", *s3Bsl.Spec.Config.Region); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
                <span class="cov0" title="0">if err := d.Set("bucket_name", *s3Bsl.Spec.Config.BucketName); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>

                <span class="cov0" title="0">s3 := make(map[string]interface{})
                if len(s3Bsl.Spec.Config.S3URL) &gt; 0 </span><span class="cov0" title="0">{
                        s3["s3_url"] = s3Bsl.Spec.Config.S3URL
                }</span>

                <span class="cov0" title="0">if s3Bsl.Spec.Config.S3ForcePathStyle != nil </span><span class="cov0" title="0">{
                        s3["s3_force_path_style"] = *s3Bsl.Spec.Config.S3ForcePathStyle
                }</span>
                // Minio only supports secret type credentials
                <span class="cov0" title="0">s3["credential_type"] = string(*s3Bsl.Spec.Config.Credentials.CredentialType)
                if *s3Bsl.Spec.Config.Credentials.CredentialType == models.V1AwsCloudAccountCredentialTypeSecret </span><span class="cov0" title="0">{
                        s3["access_key"] = s3Bsl.Spec.Config.Credentials.AccessKey
                        // Preserve the existing secret_key from state to avoid drift detection when API returns masked values
                        if currentS3Config := d.Get("s3").([]interface{}); len(currentS3Config) &gt; 0 </span><span class="cov0" title="0">{
                                if currentS3 := currentS3Config[0].(map[string]interface{}); currentS3 != nil </span><span class="cov0" title="0">{
                                        if secretKey, exists := currentS3["secret_key"]; exists </span><span class="cov0" title="0">{
                                                s3["secret_key"] = secretKey
                                        }</span>
                                }
                        }
                }
                <span class="cov0" title="0">s3Config := make([]interface{}, 0, 1)
                s3Config = append(s3Config, s3)
                if err := d.Set("s3", s3Config); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
        }

        <span class="cov0" title="0">return diags</span>
}

func GcpBackupStorageLocationRead(d *schema.ResourceData, c *client.V1Client) diag.Diagnostics <span class="cov0" title="0">{
        var diags diag.Diagnostics

        bsl, err := c.GetBackupStorageLocation(d.Id())
        if err != nil </span><span class="cov0" title="0">{
                return handleReadError(d, err, diags)
        }</span> else<span class="cov0" title="0"> if bsl == nil </span><span class="cov0" title="0">{
                // Deleted - Terraform will recreate it
                d.SetId("")
                return diags
        }</span>
        <span class="cov0" title="0">if err := d.Set("name", bsl.Metadata.Name); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">if err := d.Set("is_default", bsl.Spec.IsDefault); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">if *bsl.Spec.Storage == models.V1LocationTypeGcp </span><span class="cov0" title="0">{
                gcpBsl, err := c.GetGCPBackupStorageLocation(d.Id())
                if err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span> else<span class="cov0" title="0"> if gcpBsl == nil </span><span class="cov0" title="0">{
                        // Deleted - Terraform will recreate it
                        d.SetId("")
                        return diags
                }</span>
                <span class="cov0" title="0">if err := d.Set("bucket_name", *gcpBsl.Spec.Config.BucketName); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
                <span class="cov0" title="0">gcpConfig := make([]interface{}, 0)
                if err := d.Set("bucket_name", *gcpBsl.Spec.Config.BucketName); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
                <span class="cov0" title="0">gcpConfigMap := map[string]interface{}{
                        "project_id": gcpBsl.Spec.Config.ProjectID,
                }

                // Preserve the existing gcp_json_credentials from state to avoid drift detection when API returns masked values
                if currentGcpConfig := d.Get("gcp_storage_config").([]interface{}); len(currentGcpConfig) &gt; 0 </span><span class="cov0" title="0">{
                        if currentGcp := currentGcpConfig[0].(map[string]interface{}); currentGcp != nil </span><span class="cov0" title="0">{
                                if jsonCreds, exists := currentGcp["gcp_json_credentials"]; exists </span><span class="cov0" title="0">{
                                        gcpConfigMap["gcp_json_credentials"] = jsonCreds
                                }</span>
                        }
                }

                <span class="cov0" title="0">gcpConfig = append(gcpConfig, gcpConfigMap)
                if err := d.Set("gcp_storage_config", gcpConfig); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
        }
        <span class="cov0" title="0">return diags</span>
}

func AzureBackupStorageLocationRead(d *schema.ResourceData, c *client.V1Client) diag.Diagnostics <span class="cov0" title="0">{
        var diags diag.Diagnostics

        bsl, err := c.GetBackupStorageLocation(d.Id())
        if err != nil </span><span class="cov0" title="0">{
                return handleReadError(d, err, diags)
        }</span> else<span class="cov0" title="0"> if bsl == nil </span><span class="cov0" title="0">{
                // Deleted - Terraform will recreate it
                d.SetId("")
                return diags
        }</span>
        <span class="cov0" title="0">if err := d.Set("name", bsl.Metadata.Name); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">if err := d.Set("is_default", bsl.Spec.IsDefault); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">azureBsl, err := c.GetAzureBackupStorageLocation(d.Id())
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span> else<span class="cov0" title="0"> if azureBsl == nil </span><span class="cov0" title="0">{
                // Deleted - Terraform will recreate it
                d.SetId("")
                return diags
        }</span>
        <span class="cov0" title="0">azConfig := make([]interface{}, 0)
        azConfigMap := map[string]interface{}{
                "container_name":     azureBsl.Spec.Config.ContainerName,
                "storage_name":       azureBsl.Spec.Config.StorageName,
                "stock_keeping_unit": azureBsl.Spec.Config.Sku,
                "resource_group":     azureBsl.Spec.Config.ResourceGroup,
                "azure_tenant_id":    azureBsl.Spec.Config.Credentials.TenantID,
                "azure_client_id":    azureBsl.Spec.Config.Credentials.ClientID,
                "subscription_id":    azureBsl.Spec.Config.Credentials.SubscriptionID,
        }

        // Preserve the existing azure_client_secret from state to avoid drift detection when API returns masked values
        if currentAzureConfig := d.Get("azure_storage_config").([]interface{}); len(currentAzureConfig) &gt; 0 </span><span class="cov0" title="0">{
                if currentAzure := currentAzureConfig[0].(map[string]interface{}); currentAzure != nil </span><span class="cov0" title="0">{
                        if clientSecret, exists := currentAzure["azure_client_secret"]; exists </span><span class="cov0" title="0">{
                                azConfigMap["azure_client_secret"] = clientSecret
                        }</span>
                }
        }

        <span class="cov0" title="0">azConfig = append(azConfig, azConfigMap)
        if err := d.Set("azure_storage_config", azConfig); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">return diags</span>
}

func S3BackupStorageLocationUpdate(d *schema.ResourceData, c *client.V1Client) diag.Diagnostics <span class="cov0" title="0">{
        var diags diag.Diagnostics
        bsl, bslCred := toS3BackupStorageLocation(d)
        if err := c.ValidateS3BackupStorageLocation(bslCred); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">err := c.UpdateS3BackupStorageLocation(d.Id(), bsl)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">return diags</span>
}

func MinioBackupStorageLocationUpdate(d *schema.ResourceData, c *client.V1Client) diag.Diagnostics <span class="cov0" title="0">{
        var diags diag.Diagnostics
        bsl, _ := toMinioBackupStorageLocation(d)
        // No credential validation required for minio
        err := c.UpdateMinioBackupStorageLocation(d.Id(), bsl)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">return diags</span>
}

func GcpBackupStorageLocationUpdate(d *schema.ResourceData, c *client.V1Client) diag.Diagnostics <span class="cov0" title="0">{
        var diags diag.Diagnostics
        bsl, bslCred := toGcpBackupStorageLocation(d)
        if err := c.ValidateGcpBackupStorageLocation(bslCred); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">err := c.UpdateGcpBackupStorageLocation(d.Id(), bsl)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">return diags</span>
}

func AzureBackupStorageLocationUpdate(d *schema.ResourceData, c *client.V1Client) diag.Diagnostics <span class="cov0" title="0">{
        var diags diag.Diagnostics
        bsl, bslCred := toAzureBackupStorageLocation(d)
        if err := c.ValidateAzureBackupStorageLocation(bslCred); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">err := c.UpdateAzureBackupStorageLocation(d.Id(), bsl)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">return diags</span>
}

func toS3BackupStorageLocation(d *schema.ResourceData) (*models.V1UserAssetsLocationS3, *models.V1AwsS3BucketCredentials) <span class="cov0" title="0">{
        bucketName := d.Get("bucket_name").(string)
        region := d.Get("region").(string)
        s3config := d.Get("s3").([]interface{})[0].(map[string]interface{})
        s3ForcePathStyle := s3config["s3_force_path_style"].(bool)
        bslEntity := &amp;models.V1UserAssetsLocationS3{
                Metadata: &amp;models.V1ObjectMetaInputEntity{
                        Name: d.Get("name").(string),
                },
                Spec: &amp;models.V1UserAssetsLocationS3Spec{
                        Config: &amp;models.V1S3StorageConfig{
                                BucketName:       &amp;bucketName,
                                CaCert:           d.Get("ca_cert").(string),
                                Credentials:      toAwsAccountCredential(s3config),
                                Region:           &amp;region,
                                S3ForcePathStyle: &amp;s3ForcePathStyle,
                                S3URL:            s3config["s3_url"].(string),
                                UseRestic:        nil,
                        },
                        IsDefault: d.Get("is_default").(bool),
                },
        }
        bslCredEntity := &amp;models.V1AwsS3BucketCredentials{
                Bucket:      bslEntity.Spec.Config.BucketName,
                Credentials: bslEntity.Spec.Config.Credentials,
                Folder:      bslEntity.Spec.Config.S3URL,
                Region:      bslEntity.Spec.Config.Region,
        }
        return bslEntity, bslCredEntity
}</span>

func toMinioBackupStorageLocation(d *schema.ResourceData) (*models.V1UserAssetsLocationS3, *models.V1AwsS3BucketCredentials) <span class="cov0" title="0">{
        bucketName := d.Get("bucket_name").(string)
        region := d.Get("region").(string)
        s3config := d.Get("s3").([]interface{})[0].(map[string]interface{})
        s3ForcePathStyle := s3config["s3_force_path_style"].(bool)
        bslEntity := &amp;models.V1UserAssetsLocationS3{
                Metadata: &amp;models.V1ObjectMetaInputEntity{
                        Name: d.Get("name").(string),
                },
                Spec: &amp;models.V1UserAssetsLocationS3Spec{
                        Config: &amp;models.V1S3StorageConfig{
                                BucketName:       &amp;bucketName,
                                CaCert:           d.Get("ca_cert").(string),
                                Credentials:      toAwsAccountCredential(s3config),
                                Region:           &amp;region,
                                S3ForcePathStyle: &amp;s3ForcePathStyle,
                                S3URL:            s3config["s3_url"].(string),
                                UseRestic:        nil,
                        },
                        IsDefault: d.Get("is_default").(bool),
                },
        }
        bslCredEntity := &amp;models.V1AwsS3BucketCredentials{
                Bucket:      bslEntity.Spec.Config.BucketName,
                Credentials: bslEntity.Spec.Config.Credentials,
                Folder:      bslEntity.Spec.Config.S3URL,
                Region:      bslEntity.Spec.Config.Region,
        }
        return bslEntity, bslCredEntity
}</span>

func toGcpBackupStorageLocation(d *schema.ResourceData) (*models.V1UserAssetsLocationGcp, *models.V1GcpAccountNameValidateSpec) <span class="cov0" title="0">{
        var account *models.V1UserAssetsLocationGcp
        gcpCred := d.Get("gcp_storage_config").([]interface{})[0].(map[string]interface{})
        if len(gcpCred) &gt; 0 </span><span class="cov0" title="0">{
                bslName := d.Get("name").(string)
                isDefault := d.Get("is_default").(bool)
                bucketName := d.Get("bucket_name").(string)
                projectId := gcpCred["project_id"].(string)
                jsonCred := gcpCred["gcp_json_credentials"].(string)
                account = &amp;models.V1UserAssetsLocationGcp{
                        Metadata: &amp;models.V1ObjectMetaInputEntity{
                                Annotations: nil,
                                Labels:      nil,
                                Name:        bslName,
                        },
                        Spec: &amp;models.V1UserAssetsLocationGcpSpec{
                                Config: &amp;models.V1GcpStorageConfig{
                                        BucketName: &amp;bucketName,
                                        Credentials: &amp;models.V1GcpAccountEntitySpec{
                                                JSONCredentials: jsonCred,
                                        },
                                        ProjectID: projectId,
                                },
                                IsDefault: isDefault,
                                Type:      StorageProviderGCP,
                        },
                }
                accountCredSpec := &amp;models.V1GcpAccountNameValidateSpec{
                        BucketName: account.Spec.Config.BucketName,
                        Credentials: &amp;models.V1GcpAccountValidateSpec{
                                JSONCredentials: account.Spec.Config.Credentials.JSONCredentials,
                        },
                        ProjectID: account.Spec.Config.ProjectID,
                }
                return account, accountCredSpec
        }</span>

        <span class="cov0" title="0">return nil, nil</span>
}

func toAzureBackupStorageLocation(d *schema.ResourceData) (*models.V1UserAssetsLocationAzure, *models.V1AzureCloudAccount) <span class="cov0" title="0">{
        var account *models.V1UserAssetsLocationAzure
        azureCred := d.Get("azure_storage_config").([]interface{})[0].(map[string]interface{})
        if len(azureCred) &gt; 0 </span><span class="cov0" title="0">{
                bslName := d.Get("name").(string)
                isDefault := d.Get("is_default").(bool)
                containerName := azureCred["container_name"].(string)
                storageName := azureCred["storage_name"].(string)
                sku := azureCred["stock_keeping_unit"].(string)
                resourceGroup := azureCred["resource_group"].(string)
                azTenantId := azureCred["azure_tenant_id"].(string)
                azClientId := azureCred["azure_client_id"].(string)
                azClientSecret := azureCred["azure_client_secret"].(string)
                subId := azureCred["subscription_id"].(string)
                account = &amp;models.V1UserAssetsLocationAzure{
                        Metadata: &amp;models.V1ObjectMetaInputEntity{
                                Name: bslName,
                        },
                        Spec: &amp;models.V1UserAssetsLocationAzureSpec{
                                Config: &amp;models.V1AzureStorageConfig{
                                        ContainerName: &amp;containerName,
                                        Credentials: &amp;models.V1AzureAccountEntitySpec{
                                                ClientCloud:    StringPtr("public"),
                                                ClientID:       azClientId,
                                                ClientSecret:   azClientSecret,
                                                SubscriptionID: subId,
                                                TenantID:       azTenantId,
                                        },
                                        ResourceGroup: &amp;resourceGroup,
                                        Sku:           sku,
                                        StorageName:   &amp;storageName,
                                },
                                IsDefault: isDefault,
                                Type:      StorageProviderAzure,
                        },
                }
                accountCredSpec := &amp;models.V1AzureCloudAccount{
                        AzureEnvironment: StringPtr("AzurePublicCloud"),
                        ClientID:         &amp;account.Spec.Config.Credentials.ClientID,
                        ClientSecret:     &amp;account.Spec.Config.Credentials.ClientSecret,
                        Settings:         nil,
                        TenantID:         &amp;account.Spec.Config.Credentials.TenantID,
                }
                return account, accountCredSpec
        }</span>
        <span class="cov0" title="0">return nil, nil</span>
}

func toAwsAccountCredential(s3cred map[string]interface{}) *models.V1AwsCloudAccount <span class="cov0" title="0">{
        account := &amp;models.V1AwsCloudAccount{}
        if len(s3cred["credential_type"].(string)) == 0 || s3cred["credential_type"].(string) == "secret" </span><span class="cov0" title="0">{
                account.CredentialType = models.V1AwsCloudAccountCredentialTypeSecret.Pointer()
                account.AccessKey = s3cred["access_key"].(string)
                account.SecretKey = s3cred["secret_key"].(string)
        }</span> else<span class="cov0" title="0"> if s3cred["credential_type"].(string) == "sts" </span><span class="cov0" title="0">{
                account.CredentialType = models.V1AwsCloudAccountCredentialTypeSts.Pointer()
                account.Sts = &amp;models.V1AwsStsCredentials{
                        Arn:        s3cred["arn"].(string),
                        ExternalID: s3cred["external_id"].(string),
                }
        }</span>
        <span class="cov0" title="0">return account</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package spectrocloud

import (
        "fmt"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/spectrocloud/palette-sdk-go/api/models"
        "github.com/spectrocloud/palette-sdk-go/client"
)

func flattenPacksWithRegistryMaps(c *client.V1Client, diagPacks []*models.V1PackManifestEntity, packs []*models.V1PackRef, manifestContent map[string]map[string]string, registryNameMap map[string]bool, registryUIDMap map[string]bool) ([]interface{}, error) <span class="cov0" title="0">{
        if packs == nil </span><span class="cov0" title="0">{
                return make([]interface{}, 0), nil
        }</span>

        <span class="cov0" title="0">ps := make([]interface{}, len(packs))
        for i, pack := range packs </span><span class="cov0" title="0">{
                p := make(map[string]interface{})

                p["uid"] = pack.PackUID

                // Get the registry UID from the API response
                registryUID := c.GetPackRegistry(pack.PackUID, pack.Type)

                // Determine what the user originally provided in their config
                usesRegistryName := registryNameMap != nil &amp;&amp; registryNameMap[*pack.Name]
                usesRegistryUID := registryUIDMap != nil &amp;&amp; registryUIDMap[*pack.Name]

                if usesRegistryName </span><span class="cov0" title="0">{
                        // User originally specified registry_name, resolve UID back to name
                        if registryUID != "" </span><span class="cov0" title="0">{
                                registryName, err := resolveRegistryUIDToName(c, registryUID)
                                if err == nil &amp;&amp; registryName != "" </span><span class="cov0" title="0">{
                                        p["registry_name"] = registryName
                                        // Do NOT set registry_uid - user didn't provide it
                                }</span> else<span class="cov0" title="0"> {
                                        // Fallback to UID if name resolution fails
                                        p["registry_uid"] = registryUID
                                }</span>
                        }
                } else<span class="cov0" title="0"> if usesRegistryUID </span><span class="cov0" title="0">{
                        // User originally specified registry_uid, set registry_uid
                        if registryUID != "" </span><span class="cov0" title="0">{
                                p["registry_uid"] = registryUID
                        }</span>
                        // Do NOT set registry_name - user didn't provide it
                }
                // else: User didn't specify either registry_uid or registry_name
                // (they probably used uid directly), so don't set either in state

                <span class="cov0" title="0">p["name"] = *pack.Name
                p["tag"] = pack.Tag
                p["values"] = pack.Values
                p["type"] = pack.Type

                if _, ok := manifestContent[pack.PackUID]; ok </span><span class="cov0" title="0">{
                        ma := make([]interface{}, len(pack.Manifests))
                        for j, m := range pack.Manifests </span><span class="cov0" title="0">{
                                mj := make(map[string]interface{})
                                mj["name"] = m.Name
                                mj["uid"] = m.UID
                                mj["content"] = manifestContent[pack.PackUID][m.Name]

                                ma[j] = mj
                        }</span>

                        <span class="cov0" title="0">p["manifest"] = ma</span>
                }
                <span class="cov0" title="0">ps[i] = p</span>
        }

        <span class="cov0" title="0">return ps, nil</span>
}

// buildPackRegistryNameMap creates a map indicating which packs use registry_name
// by directly checking the resource data
func buildPackRegistryNameMap(d *schema.ResourceData) map[string]bool <span class="cov0" title="0">{
        registryNameMap := make(map[string]bool)
        if packs, ok := d.GetOk("pack"); ok </span><span class="cov0" title="0">{
                for _, packInterface := range packs.([]interface{}) </span><span class="cov0" title="0">{
                        pack := packInterface.(map[string]interface{})
                        packName := pack["name"].(string)
                        if registryName, ok := pack["registry_name"]; ok &amp;&amp; registryName != nil &amp;&amp; registryName.(string) != "" </span><span class="cov0" title="0">{
                                registryNameMap[packName] = true
                        }</span>
                }
        }
        <span class="cov0" title="0">return registryNameMap</span>
}

// buildPackRegistryUIDMap creates a map indicating which packs use registry_uid
// by directly checking the resource data
func buildPackRegistryUIDMap(d *schema.ResourceData) map[string]bool <span class="cov0" title="0">{
        registryUIDMap := make(map[string]bool)
        if packs, ok := d.GetOk("pack"); ok </span><span class="cov0" title="0">{
                for _, packInterface := range packs.([]interface{}) </span><span class="cov0" title="0">{
                        pack := packInterface.(map[string]interface{})
                        packName := pack["name"].(string)
                        if registryUID, ok := pack["registry_uid"]; ok &amp;&amp; registryUID != nil &amp;&amp; registryUID.(string) != "" </span><span class="cov0" title="0">{
                                registryUIDMap[packName] = true
                        }</span>
                }
        }
        <span class="cov0" title="0">return registryUIDMap</span>
}

// resolveRegistryNameToUID resolves a registry name to its UID
func resolveRegistryNameToUID(c *client.V1Client, registryName string, registryType string) (string, error) <span class="cov0" title="0">{
        if registryName == "" </span><span class="cov0" title="0">{
                return "", nil
        }</span>
        <span class="cov0" title="0">switch registryType </span>{
        case "oci":<span class="cov0" title="0">
                registry, err := c.GetOciRegistryByName(registryName)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov0" title="0">return registry.Metadata.UID, nil</span>
        case "helm":<span class="cov0" title="0">
                registry, err := c.GetHelmRegistryByName(registryName)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov0" title="0">return registry.Metadata.UID, nil</span>
        case "spectro":<span class="cov0" title="0">
                registry, err := c.GetPackRegistryByName(registryName)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov0" title="0">return registry.Metadata.UID, nil</span>
        default:<span class="cov0" title="0">
                if registryType != "manifest" </span><span class="cov0" title="0">{
                        registry, err := c.GetPackRegistryCommonByName(registryName)
                        if err != nil </span><span class="cov0" title="0">{
                                return "", err
                        }</span>
                        <span class="cov0" title="0">return registry.UID, nil</span>
                }
        }
        <span class="cov0" title="0">return "", nil</span>
}

// resolveRegistryUIDToName resolves a registry UID to its name
func resolveRegistryUIDToName(c *client.V1Client, registryUID string) (string, error) <span class="cov0" title="0">{
        if registryUID == "" </span><span class="cov0" title="0">{
                return "", nil
        }</span>
        <span class="cov0" title="0">registries, err := c.SearchPackRegistryCommon()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to search registries: %w", err)
        }</span>
        <span class="cov0" title="0">for _, registry := range registries </span><span class="cov0" title="0">{
                if registry.UID == registryUID </span><span class="cov0" title="0">{
                        return registry.Name, nil
                }</span>
        }
        <span class="cov0" title="0">return "", fmt.Errorf("registry with UID '%s' not found", registryUID)</span>
}

func getPacksContent(packs []*models.V1PackRef, c *client.V1Client, d *schema.ResourceData) (map[string]map[string]string, diag.Diagnostics, bool) <span class="cov0" title="0">{
        packManifests := make(map[string]map[string]string)
        for _, p := range packs </span><span class="cov0" title="0">{
                if len(p.Manifests) &gt; 0 </span><span class="cov0" title="0">{
                        content, err := c.GetClusterProfileManifestPack(d.Id(), *p.Name)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, diag.FromErr(err), true
                        }</span>

                        <span class="cov0" title="0">if len(content) &gt; 0 </span><span class="cov0" title="0">{
                                c := make(map[string]string)
                                for _, co := range content </span><span class="cov0" title="0">{
                                        c[co.Metadata.Name] = co.Spec.Published.Content
                                }</span>
                                <span class="cov0" title="0">packManifests[p.PackUID] = c</span>
                        }
                }
        }
        <span class="cov0" title="0">return packManifests, nil, false</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package spectrocloud

import (
        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/spectrocloud/palette-sdk-go/client"
        "github.com/spectrocloud/palette-sdk-go/client/herr"
        "log"
)

func getV1ClientWithResourceContext(m interface{}, resourceContext string) *client.V1Client <span class="cov10" title="21">{
        c := m.(*client.V1Client)
        switch resourceContext </span>{
        case "project":<span class="cov1" title="1">
                if ProviderInitProjectUid != "" </span><span class="cov1" title="1">{
                        client.WithScopeProject(ProviderInitProjectUid)(c)
                }</span>
                <span class="cov1" title="1">return c</span>
        case "tenant":<span class="cov0" title="0">
                client.WithScopeTenant()(c)
                return c</span>
        default:<span class="cov9" title="20">
                if ProviderInitProjectUid != "" </span><span class="cov9" title="20">{
                        client.WithScopeProject(ProviderInitProjectUid)(c)
                }</span>
                <span class="cov9" title="20">return c</span>
        }
}

func handleReadError(d *schema.ResourceData, err error, diags diag.Diagnostics) diag.Diagnostics <span class="cov3" title="2">{
        if herr.IsNotFound(err) </span><span class="cov0" title="0">{
                d.SetId("")
                return diags
        }</span>
        <span class="cov3" title="2">log.Printf("[DEBUG] Received error: %#v", err)
        return diag.FromErr(err)</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package convert

import (
        "encoding/base64"
        "errors"

        "github.com/go-openapi/strfmt"
        "github.com/spectrocloud/palette-sdk-go/api/models"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/types"
        kubevirtapiv1 "kubevirt.io/api/core/v1"
)

func ToKubevirtVM(hapiVM *models.V1ClusterVirtualMachine) (*kubevirtapiv1.VirtualMachine, error) <span class="cov0" title="0">{
        if hapiVM == nil </span><span class="cov0" title="0">{
                return nil, errors.New("hapiVM is nil")
        }</span>

        <span class="cov0" title="0">Spec, err := ToKubevirtVMSpecM(hapiVM.Spec)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">Status, err := ToKubevirtVMStatusM(hapiVM.Status)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">OwnerReferences, err := ToKubevirtVMOwnerReferences(hapiVM.Metadata.OwnerReferences)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">ManagedFields, err := ToKubevirtVMManagedFields(hapiVM.Metadata.ManagedFields)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">kubevirtVM := &amp;kubevirtapiv1.VirtualMachine{
                TypeMeta: metav1.TypeMeta{
                        Kind:       hapiVM.Kind,
                        APIVersion: hapiVM.APIVersion,
                },
                ObjectMeta: metav1.ObjectMeta{
                        Name:                       hapiVM.Metadata.Name,
                        GenerateName:               hapiVM.Metadata.GenerateName,
                        Namespace:                  hapiVM.Metadata.Namespace,
                        UID:                        types.UID(hapiVM.Metadata.UID),
                        ResourceVersion:            hapiVM.Metadata.ResourceVersion,
                        Generation:                 hapiVM.Metadata.Generation,
                        DeletionGracePeriodSeconds: &amp;hapiVM.Metadata.DeletionGracePeriodSeconds,
                        Labels:                     hapiVM.Metadata.Labels,
                        Annotations:                hapiVM.Metadata.Annotations,
                        OwnerReferences:            OwnerReferences,
                        Finalizers:                 hapiVM.Metadata.Finalizers,
                        ManagedFields:              ManagedFields,
                },
                Spec:   Spec,
                Status: Status,
        }
        return kubevirtVM, nil</span>
}

func ToKubevirtVMOwnerReferences(references []*models.V1VMOwnerReference) ([]metav1.OwnerReference, error) <span class="cov0" title="0">{
        ret := make([]metav1.OwnerReference, len(references))
        for i, reference := range references </span><span class="cov0" title="0">{
                ret[i] = metav1.OwnerReference{
                        APIVersion:         *reference.APIVersion,
                        BlockOwnerDeletion: &amp;reference.BlockOwnerDeletion,
                        Controller:         &amp;reference.Controller,
                        Kind:               *reference.Kind,
                        Name:               *reference.Name,
                        UID:                types.UID(*reference.UID),
                }
        }</span>

        <span class="cov0" title="0">return ret, nil</span>
}

func ToKubevirtVMManagedFields(fields []*models.V1VMManagedFieldsEntry) ([]metav1.ManagedFieldsEntry, error) <span class="cov0" title="0">{
        ret := make([]metav1.ManagedFieldsEntry, len(fields))
        for i, field := range fields </span><span class="cov0" title="0">{
                FieldsV1, err := ToKvVmFieldsV1(field.FieldsV1)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">ret[i] = metav1.ManagedFieldsEntry{
                        APIVersion: field.APIVersion,
                        FieldsType: field.FieldsType,
                        FieldsV1:   FieldsV1,
                        Manager:    field.Manager,
                        Operation:  ToKvVmManagedFieldsOperationType(field.Operation),
                        // TODO: Time:       ToKubevirtTime(field.Time),
                }</span>
        }

        <span class="cov0" title="0">return ret, nil</span>
}

func ToKvVmFieldsV1(v1 *models.V1VMFieldsV1) (*metav1.FieldsV1, error) <span class="cov0" title="0">{
        Raw, err := StrfmtBase64ToByte(v1.Raw)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">Fields := &amp;metav1.FieldsV1{
                Raw: Raw,
        }

        return Fields, nil</span>
}

func StrfmtBase64ToByte(raw []strfmt.Base64) ([]byte, error) <span class="cov0" title="0">{
        var res []byte
        for _, s := range raw </span><span class="cov0" title="0">{
                decoded, err := base64.StdEncoding.DecodeString(string(s))
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">res = append(res, decoded...)</span>
        }
        <span class="cov0" title="0">return res, nil</span>
}

func ToKvVmManagedFieldsOperationType(operation string) metav1.ManagedFieldsOperationType <span class="cov0" title="0">{
        switch operation </span>{
        case "Apply":<span class="cov0" title="0">
                return metav1.ManagedFieldsOperationApply</span>
        case "Update":<span class="cov0" title="0">
                return metav1.ManagedFieldsOperationUpdate</span>
        }
        <span class="cov0" title="0">return metav1.ManagedFieldsOperationApply</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package convert

import (
        "encoding/json"
        "fmt"

        "github.com/spectrocloud/palette-sdk-go/api/models"
        kubevirtapiv1 "kubevirt.io/api/core/v1"
)

func ToKubevirtVMSpecM(vm *models.V1ClusterVirtualMachineSpec) (kubevirtapiv1.VirtualMachineSpec, error) <span class="cov0" title="0">{
        var kubevirtVMSpec kubevirtapiv1.VirtualMachineSpec

        // Marshal the input spec to JSON
        hapiClusterVMSpecJSON, err := json.Marshal(vm)
        if err != nil </span><span class="cov0" title="0">{
                return kubevirtVMSpec, fmt.Errorf("failed to marshal models.V1ClusterVirtualMachineSpec to JSON: %v", err)
        }</span>

        // Unmarshal the JSON to the desired Kubevirt VM spec
        <span class="cov0" title="0">err = json.Unmarshal(hapiClusterVMSpecJSON, &amp;kubevirtVMSpec)
        if err != nil </span><span class="cov0" title="0">{
                return kubevirtVMSpec, fmt.Errorf("failed to unmarshal JSON to kubevirtapiv1.VirtualMachineSpec: %v", err)
        }</span>

        <span class="cov0" title="0">return kubevirtVMSpec, nil</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package convert

import (
        "encoding/json"
        "fmt"
        "github.com/spectrocloud/palette-sdk-go/api/models"
        "github.com/spectrocloud/terraform-provider-spectrocloud/types"
        k8sv1 "k8s.io/api/core/v1"
        kubevirtapiv1 "kubevirt.io/api/core/v1"
)

func ToKubevirtVMStatusM(status *models.V1ClusterVirtualMachineStatus) (kubevirtapiv1.VirtualMachineStatus, error) <span class="cov0" title="0">{
        var kubevirtVMStatus kubevirtapiv1.VirtualMachineStatus

        // Marshal the input spec to JSON
        hapiClusterVMSpecJSON, err := json.Marshal(status)
        if err != nil </span><span class="cov0" title="0">{
                return kubevirtVMStatus, fmt.Errorf("failed to marshal models.V1ClusterVirtualMachineSpec to JSON: %v", err)
        }</span>

        // Unmarshal the JSON to the desired Kubevirt VM spec
        <span class="cov0" title="0">err = json.Unmarshal(hapiClusterVMSpecJSON, &amp;kubevirtVMStatus)
        if err != nil </span><span class="cov0" title="0">{
                return kubevirtVMStatus, fmt.Errorf("failed to unmarshal JSON to kubevirtapiv1.VirtualMachineSpec: %v", err)
        }</span>

        <span class="cov0" title="0">return kubevirtVMStatus, nil</span>
}

func ToKubevirtVMStatus(status *models.V1ClusterVirtualMachineStatus) kubevirtapiv1.VirtualMachineStatus <span class="cov0" title="0">{
        var PrintableStatus kubevirtapiv1.VirtualMachinePrintableStatus
        if status.PrintableStatus != "" </span><span class="cov0" title="0">{
                PrintableStatus = kubevirtapiv1.VirtualMachinePrintableStatus(status.PrintableStatus)
        }</span>

        <span class="cov0" title="0">return kubevirtapiv1.VirtualMachineStatus{
                SnapshotInProgress:     types.Ptr(status.SnapshotInProgress),
                RestoreInProgress:      types.Ptr(status.RestoreInProgress),
                Created:                status.Created,
                Ready:                  status.Ready,
                PrintableStatus:        PrintableStatus,
                Conditions:             ToKvVmStatusConditions(status.Conditions),
                StateChangeRequests:    nil,
                VolumeRequests:         nil,
                VolumeSnapshotStatuses: nil,
                StartFailure:           nil,
                MemoryDumpRequest:      nil,
        }</span>
}

func ToKvVmStatusConditions(conditions []*models.V1VMVirtualMachineCondition) []kubevirtapiv1.VirtualMachineCondition <span class="cov0" title="0">{
        var kvConditions []kubevirtapiv1.VirtualMachineCondition
        for _, condition := range conditions </span><span class="cov0" title="0">{
                kvConditions = append(kvConditions, ToKvVmStatusCondition(condition))
        }</span>
        <span class="cov0" title="0">return kvConditions</span>
}

func ToKvVmStatusCondition(condition *models.V1VMVirtualMachineCondition) kubevirtapiv1.VirtualMachineCondition <span class="cov0" title="0">{
        if condition == nil </span><span class="cov0" title="0">{
                return kubevirtapiv1.VirtualMachineCondition{}
        }</span>

        <span class="cov0" title="0">var VirtualMachineConditionType kubevirtapiv1.VirtualMachineConditionType
        if condition.Type != nil </span><span class="cov0" title="0">{
                VirtualMachineConditionType = kubevirtapiv1.VirtualMachineConditionType(*condition.Type)
        }</span>

        <span class="cov0" title="0">var ConditionStatus k8sv1.ConditionStatus
        if condition.Status != nil </span><span class="cov0" title="0">{
                ConditionStatus = k8sv1.ConditionStatus(*condition.Status)
        }</span>

        <span class="cov0" title="0">return kubevirtapiv1.VirtualMachineCondition{
                Type:   VirtualMachineConditionType,
                Status: ConditionStatus,
                // TODO: LastProbeTime:      condition.LastProbeTime,
                // TODO: LastTransitionTime: condition.LastTransitionTime,
                Reason:  condition.Reason,
                Message: condition.Message,
        }</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package convert

import (
        "encoding/base64"

        "github.com/go-openapi/strfmt"
        "github.com/spectrocloud/palette-sdk-go/api/models"
        "k8s.io/apimachinery/pkg/api/resource"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        kubevirtapiv1 "kubevirt.io/api/core/v1"

        "github.com/spectrocloud/terraform-provider-spectrocloud/types"
)

func ToHapiVm(vm *kubevirtapiv1.VirtualMachine) (*models.V1ClusterVirtualMachine, error) <span class="cov0" title="0">{
        var GracePeriodSeconds int64
        if vm.DeletionGracePeriodSeconds != nil </span><span class="cov0" title="0">{
                GracePeriodSeconds = *vm.DeletionGracePeriodSeconds
        }</span>

        <span class="cov0" title="0">Spec, err := ToHapiVmSpecM(vm.Spec)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">Status, err := ToHapiVmStatusM(vm.Status)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">hapiVM := &amp;models.V1ClusterVirtualMachine{
                Metadata: &amp;models.V1VMObjectMeta{
                        Annotations:                vm.Annotations,
                        DeletionGracePeriodSeconds: GracePeriodSeconds,
                        Finalizers:                 vm.Finalizers,
                        GenerateName:               vm.GenerateName,
                        Generation:                 vm.Generation,
                        Labels:                     vm.Labels,
                        ManagedFields:              ToHapiVmManagedFields(vm.ManagedFields),
                        Name:                       vm.Name,
                        Namespace:                  vm.Namespace,
                        OwnerReferences:            ToHapiVmOwnerReferences(vm.OwnerReferences),
                        ResourceVersion:            vm.ResourceVersion,
                        UID:                        string(vm.UID),
                },
                Spec:   Spec,
                Status: Status,
        }
        return hapiVM, nil</span>
}

func ToHapiVmOwnerReferences(references []metav1.OwnerReference) []*models.V1VMOwnerReference <span class="cov0" title="0">{
        ret := make([]*models.V1VMOwnerReference, len(references))
        for i, reference := range references </span><span class="cov0" title="0">{
                ret[i] = &amp;models.V1VMOwnerReference{
                        APIVersion:         types.Ptr(reference.APIVersion),
                        BlockOwnerDeletion: *reference.BlockOwnerDeletion,
                        Controller:         *reference.Controller,
                        Kind:               types.Ptr(reference.Kind),
                        Name:               types.Ptr(reference.Name),
                        UID:                types.Ptr(string(reference.UID)),
                }
        }</span>

        <span class="cov0" title="0">return ret</span>
}

func ToHapiVmManagedFields(fields []metav1.ManagedFieldsEntry) []*models.V1VMManagedFieldsEntry <span class="cov0" title="0">{
        ret := make([]*models.V1VMManagedFieldsEntry, len(fields))
        for i, field := range fields </span><span class="cov0" title="0">{
                ret[i] = &amp;models.V1VMManagedFieldsEntry{
                        APIVersion: field.APIVersion,
                        FieldsType: field.FieldsType,
                        FieldsV1:   ToHapiVmFieldsV1(field.FieldsV1),
                        Manager:    field.Manager,
                        Operation:  string(field.Operation),
                        // TODO: Time:       ToHapiV1Time(field.Time),
                }
        }</span>

        <span class="cov0" title="0">return ret</span>
}

func ToHapiV1Time(t metav1.Time) models.V1Time <span class="cov0" title="0">{
        return models.V1Time(t.Time)
}</span>

func ToHapiVmFieldsV1(v1 *metav1.FieldsV1) *models.V1VMFieldsV1 <span class="cov0" title="0">{
        return &amp;models.V1VMFieldsV1{
                Raw: ByteToStrfmtBase64(v1.Raw),
        }
}</span>

func ByteToStrfmtBase64(raw []byte) []strfmt.Base64 <span class="cov0" title="0">{
        var res []strfmt.Base64
        encoded := base64.StdEncoding.EncodeToString(raw)
        res = append(res, strfmt.Base64(encoded))
        return res
}</span>

func ToHapiVmQuantityDivisor(divisor resource.Quantity) models.V1VMQuantity <span class="cov0" title="0">{
        return models.V1VMQuantity(divisor.String())
}</span>
</pre>
		
		<pre class="file" id="file31" style="display: none">package convert

import (
        "fmt"

        "encoding/json"

        "github.com/spectrocloud/palette-sdk-go/api/models"
        kubevirtapiv1 "kubevirt.io/api/core/v1"
)

func ToHapiVmSpecM(spec kubevirtapiv1.VirtualMachineSpec) (*models.V1ClusterVirtualMachineSpec, error) <span class="cov0" title="0">{
        var hapiVmSpec models.V1ClusterVirtualMachineSpec

        // Marshal the input spec to JSON
        specJson, err := json.Marshal(spec)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal kubevirtapiv1.VirtualMachineSpec to JSON: %v", err)
        }</span>

        // Unmarshal the JSON to the desired HAPI VM spec
        <span class="cov0" title="0">err = json.Unmarshal(specJson, &amp;hapiVmSpec)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal JSON to models.V1ClusterVirtualMachineSpec: %v", err)
        }</span>

        <span class="cov0" title="0">return &amp;hapiVmSpec, nil</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package convert

import (
        "encoding/json"
        "fmt"

        "github.com/spectrocloud/palette-sdk-go/api/models"
        kubevirtapiv1 "kubevirt.io/api/core/v1"
)

func ToHapiVmStatusM(status kubevirtapiv1.VirtualMachineStatus) (*models.V1ClusterVirtualMachineStatus, error) <span class="cov0" title="0">{
        var hapiVmStatus models.V1ClusterVirtualMachineStatus

        // Marshal the input spec to JSON
        specJson, err := json.Marshal(status)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal kubevirtapiv1.VirtualMachineSpec to JSON: %v", err)
        }</span>

        // Unmarshal the JSON to the desired HAPI VM spec
        <span class="cov0" title="0">err = json.Unmarshal(specJson, &amp;hapiVmStatus)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal JSON to models.V1ClusterVirtualMachineSpec: %v", err)
        }</span>

        <span class="cov0" title="0">return &amp;hapiVmStatus, nil</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package convert

import (
        "encoding/json"
        "fmt"

        "github.com/spectrocloud/palette-sdk-go/api/models"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/types"
        cdiv1 "kubevirt.io/containerized-data-importer-api/pkg/apis/core/v1beta1"
)

func FromHapiVolume(hapiVolume *models.V1VMAddVolumeEntity) (*cdiv1.DataVolume, error) <span class="cov0" title="0">{
        var GracePeriodSeconds *int64
        if hapiVolume.DataVolumeTemplate.Metadata.DeletionGracePeriodSeconds != 0 </span><span class="cov0" title="0">{
                GracePeriodSeconds = &amp;hapiVolume.DataVolumeTemplate.Metadata.DeletionGracePeriodSeconds
        }</span>

        <span class="cov0" title="0">Spec, err := FromHapiVolumeSpecM(hapiVolume.DataVolumeTemplate.Spec)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">volume := &amp;cdiv1.DataVolume{
                ObjectMeta: metav1.ObjectMeta{
                        Annotations:                hapiVolume.DataVolumeTemplate.Metadata.Annotations,
                        DeletionGracePeriodSeconds: GracePeriodSeconds,
                        Finalizers:                 hapiVolume.DataVolumeTemplate.Metadata.Finalizers,
                        GenerateName:               hapiVolume.DataVolumeTemplate.Metadata.GenerateName,
                        Generation:                 hapiVolume.DataVolumeTemplate.Metadata.Generation,
                        Labels:                     hapiVolume.DataVolumeTemplate.Metadata.Labels,
                        Name:                       hapiVolume.DataVolumeTemplate.Metadata.Name,
                        Namespace:                  hapiVolume.DataVolumeTemplate.Metadata.Namespace,
                        ResourceVersion:            hapiVolume.DataVolumeTemplate.Metadata.ResourceVersion,
                        UID:                        types.UID(hapiVolume.DataVolumeTemplate.Metadata.UID),
                },
                Spec: *Spec,
        }
        return volume, nil</span>
}

func FromHapiVolumeSpecM(hapiVolumeSpec *models.V1VMDataVolumeSpec) (*cdiv1.DataVolumeSpec, error) <span class="cov0" title="0">{
        var spec cdiv1.DataVolumeSpec

        // Marshal the input hapiVolumeSpec to JSON
        specJson, err := json.Marshal(hapiVolumeSpec)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal models.V1VMDataVolumeSpec to JSON: %v", err)
        }</span>

        // Unmarshal the JSON to the desired DataVolumeSpec
        <span class="cov0" title="0">err = json.Unmarshal(specJson, &amp;spec)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal JSON to cdiv1.DataVolumeSpec: %v", err)
        }</span>

        <span class="cov0" title="0">return &amp;spec, nil</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package convert

import (
        "encoding/json"
        "fmt"

        "github.com/spectrocloud/palette-sdk-go/api/models"
        cdiv1 "kubevirt.io/containerized-data-importer-api/pkg/apis/core/v1beta1"
)

func ToHapiVolume(volume *cdiv1.DataVolume, addVolumeOptions *models.V1VMAddVolumeOptions) (*models.V1VMAddVolumeEntity, error) <span class="cov0" title="0">{
        var GracePeriodSeconds int64
        if volume.DeletionGracePeriodSeconds != nil </span><span class="cov0" title="0">{
                GracePeriodSeconds = *volume.DeletionGracePeriodSeconds
        }</span>

        <span class="cov0" title="0">Spec, err := ToHapiVolumeSpecM(volume.Spec)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">hapiVolume := &amp;models.V1VMAddVolumeEntity{
                AddVolumeOptions: addVolumeOptions,
                DataVolumeTemplate: &amp;models.V1VMDataVolumeTemplateSpec{
                        Metadata: &amp;models.V1VMObjectMeta{
                                Annotations:                volume.Annotations,
                                DeletionGracePeriodSeconds: GracePeriodSeconds,
                                Finalizers:                 volume.Finalizers,
                                GenerateName:               volume.GenerateName,
                                Generation:                 volume.Generation,
                                Labels:                     volume.Labels,
                                ManagedFields:              ToHapiVmManagedFields(volume.ManagedFields),
                                Name:                       volume.Name,
                                Namespace:                  volume.Namespace,
                                OwnerReferences:            ToHapiVmOwnerReferences(volume.OwnerReferences),
                                ResourceVersion:            volume.ResourceVersion,
                                UID:                        string(volume.UID),
                        },
                        Spec: Spec,
                },
                Persist: true,
        }
        return hapiVolume, nil</span>
}

func ToHapiVolumeSpecM(spec cdiv1.DataVolumeSpec) (*models.V1VMDataVolumeSpec, error) <span class="cov0" title="0">{
        var hapiVolumeSpec models.V1VMDataVolumeSpec

        // Marshal the input spec to JSON
        specJson, err := json.Marshal(spec)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal kubevirtapiv1.VirtualMachineSpec to JSON: %v", err)
        }</span>

        // Unmarshal the JSON to the desired HAPI VM spec
        <span class="cov0" title="0">err = json.Unmarshal(specJson, &amp;hapiVolumeSpec)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal JSON to models.V1ClusterVirtualMachineSpec: %v", err)
        }</span>

        <span class="cov0" title="0">return &amp;hapiVolumeSpec, nil</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package spectrocloud

import (
        "context"
        "github.com/spectrocloud/palette-sdk-go/api/models"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
)

const APPLIANCE_STATUS_DESC = "The status of the appliance. Supported values are: 'ready', 'in-use', and 'unpaired'. "
const APPLIANCE_HEALTH_DESC = "The health of the appliance. Supported values are: 'healthy', and 'unhealthy'. "
const ARCH_DESC = "The architecture of the appliance. Supported values are: 'amd64', and  'arm64'. "

func dataSourceAppliance() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                ReadContext: dataSourceApplianceRead,

                Description: "Provides details about a single appliance used for Edge Native cluster provisioning.",
                Schema: map[string]*schema.Schema{
                        "id": {
                                Type:         schema.TypeString,
                                Description:  "ID of the appliance registered in Palette.",
                                Optional:     true,
                                Computed:     true,
                                ForceNew:     true,
                                ExactlyOneOf: []string{"id", "name"},
                        },
                        "name": {
                                Type:        schema.TypeString,
                                Optional:    true,
                                ForceNew:    true,
                                Description: "The name of the appliance. ",
                        },
                        "tags": {
                                Type:     schema.TypeMap,
                                Computed: true,
                                Elem: &amp;schema.Schema{
                                        Type: schema.TypeString,
                                },
                                Description: "The tags of the appliance.",
                        },
                        "status": {
                                Type:        schema.TypeString,
                                Computed:    true,
                                Description: APPLIANCE_STATUS_DESC,
                        },
                        "health": {
                                Type:        schema.TypeString,
                                Computed:    true,
                                Description: APPLIANCE_HEALTH_DESC,
                        },
                        "architecture": {
                                Type:        schema.TypeString,
                                Computed:    true,
                                Description: ARCH_DESC,
                        },
                },
        }
}</span>

func dataSourceApplianceRead(_ context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        c := getV1ClientWithResourceContext(m, "")
        var diags diag.Diagnostics
        var err error
        var appliance *models.V1EdgeHostDevice
        if id, okId := d.GetOk("id"); okId </span><span class="cov0" title="0">{
                appliance, err = c.GetAppliance(id.(string))
                if err != nil </span><span class="cov0" title="0">{
                        return handleReadError(d, err, diags)
                }</span>
        }
        <span class="cov0" title="0">if name, okName := d.GetOk("name"); okName </span><span class="cov0" title="0">{
                appliance, err = c.GetApplianceByName(name.(string), nil, "", "", "")
                if err != nil </span><span class="cov0" title="0">{
                        return handleReadError(d, err, diags)
                }</span>
        }
        <span class="cov0" title="0">if appliance != nil </span><span class="cov0" title="0">{
                d.SetId(appliance.Metadata.UID)
                err = d.Set("name", appliance.Metadata.Name)
                if err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
                <span class="cov0" title="0">err = d.Set("tags", appliance.Metadata.Labels)
                if err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>

                <span class="cov0" title="0">if appliance.Status != nil </span><span class="cov0" title="0">{
                        err = d.Set("status", appliance.Status.State)
                        if err != nil </span><span class="cov0" title="0">{
                                return diag.FromErr(err)
                        }</span>
                }

                <span class="cov0" title="0">if appliance.Status != nil &amp;&amp; appliance.Status.Health != nil </span><span class="cov0" title="0">{
                        err = d.Set("health", appliance.Status.Health.State)
                        if err != nil </span><span class="cov0" title="0">{
                                return diag.FromErr(err)
                        }</span>
                }

                <span class="cov0" title="0">if appliance.Spec != nil &amp;&amp; appliance.Spec.Device != nil &amp;&amp; appliance.Spec.Device.ArchType != nil </span><span class="cov0" title="0">{
                        err = d.Set("architecture", *appliance.Spec.Device.ArchType)
                        if err != nil </span><span class="cov0" title="0">{
                                return diag.FromErr(err)
                        }</span>
                }
        }
        <span class="cov0" title="0">return diags</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package spectrocloud

import (
        "context"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
)

func dataSourceAppliances() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                ReadContext: dataSourcesApplianceRead,

                Description: "Provides details about a set of appliances used for Edge Native cluster provisioning. " +
                        "Various attributes could be used to search for appliances like `tags`, `status`, `health`, and `architecture`.",

                Schema: map[string]*schema.Schema{
                        "ids": {
                                Type:        schema.TypeList,
                                Description: "The unique ids of the appliances. This is a computed field and is not required to be set.",
                                Computed:    true,
                                Elem:        &amp;schema.Schema{Type: schema.TypeString},
                        },
                        "context": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "project",
                                ValidateFunc: validation.StringInSlice([]string{"project", "tenant"}, false),
                                Description: "The context of the appliances. Allowed values are `project` or `tenant`. " +
                                        "Defaults to `project`." + PROJECT_NAME_NUANCE,
                        },
                        "tags": {
                                Type:        schema.TypeMap,
                                Description: "A list of tags to filter the appliances.",
                                Optional:    true,
                                Elem: &amp;schema.Schema{
                                        Type: schema.TypeString,
                                },
                        },
                        "status": {
                                Type:        schema.TypeString,
                                Description: APPLIANCE_STATUS_DESC + " If not specified, all appliances are returned.",
                                Optional:    true,
                        },
                        "health": {
                                Type:        schema.TypeString,
                                Description: APPLIANCE_HEALTH_DESC + " If not specified, all appliances are returned.",
                                Optional:    true,
                        },
                        "architecture": {
                                Type:        schema.TypeString,
                                Description: ARCH_DESC + " If not specified, all appliances are returned.",
                                Optional:    true,
                        },
                },
        }
}</span>

func dataSourcesApplianceRead(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        resourceContext := d.Get("context").(string)
        var diags diag.Diagnostics
        c := getV1ClientWithResourceContext(m, resourceContext)

        // Initialize tags if present
        var tags map[string]string
        if v, ok := d.Get("tags").(map[string]interface{}); ok &amp;&amp; len(v) &gt; 0 </span><span class="cov0" title="0">{
                tags = expandStringMap(v)
        }</span>

        <span class="cov0" title="0">status := d.Get("status").(string)
        health := d.Get("health").(string)
        architecture := d.Get("architecture").(string)

        // Read appliances using the new GetAppliances method
        appliances, err := c.GetAppliances(tags, status, health, architecture)
        if err != nil </span><span class="cov0" title="0">{
                return handleReadError(d, err, diags)
        }</span>

        // Extract appliance IDs
        <span class="cov0" title="0">var applianceIDs []string
        for _, appliance := range appliances </span><span class="cov0" title="0">{
                applianceIDs = append(applianceIDs, appliance.Metadata.UID)
        }</span>

        // Set the resource ID and appliance IDs in the schema
        <span class="cov0" title="0">id := toDatasourcesId("appliance", tags)
        d.SetId(id) //need to set some id
        if err := d.Set("ids", applianceIDs); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package spectrocloud

import (
        "context"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
)

func dataSourceApplicationProfile() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                ReadContext: dataSourceApplicationProfileRead,
                Description: "Use this data source to get the details of an existing application profile.",

                Schema: map[string]*schema.Schema{
                        "name": {
                                Type:        schema.TypeString,
                                Required:    true,
                                ForceNew:    true,
                                Description: "Name of the application profile",
                        },
                        "version": {
                                Type:        schema.TypeString,
                                Computed:    true,
                                Optional:    true,
                                Description: "The version of the app profile. Default value is '1.0.0'.",
                        },
                },
        }
}</span>

func dataSourceApplicationProfileRead(_ context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        c := getV1ClientWithResourceContext(m, "")
        var diags diag.Diagnostics
        if name, okName := d.GetOk("name"); okName </span><span class="cov0" title="0">{
                version, okVersion := d.GetOk("version")
                if !okVersion || version == "" </span><span class="cov0" title="0">{
                        version = "1.0.0"
                }</span>
                <span class="cov0" title="0">applicationProfile, appUID, getVersion, err := c.GetApplicationProfileByNameAndVersion(name.(string), version.(string))
                if err != nil </span><span class="cov0" title="0">{
                        return handleReadError(d, err, diags)
                }</span>
                <span class="cov0" title="0">d.SetId(appUID)
                if err := d.Set("name", applicationProfile.Metadata.Name); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
                <span class="cov0" title="0">if err := d.Set("version", getVersion); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
        }
        <span class="cov0" title="0">return diags</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package spectrocloud

import (
        "context"
        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/spectrocloud/palette-sdk-go/api/models"
)

func dataSourceBackupStorageLocation() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                ReadContext: dataSourceBackupStorageLocationRead,

                Schema: map[string]*schema.Schema{
                        "id": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Computed:     true,
                                ExactlyOneOf: []string{"id", "name"},
                                Description:  "The unique ID of the backup storage location. This is an optional field, but if provided, it will be used to retrieve the specific backup storage location.",
                        },
                        "name": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Computed:     true,
                                ExactlyOneOf: []string{"id", "name"},
                                Description:  "The name of the backup storage location. This is an optional field, but if provided, it will be used to retrieve the specific backup storage location.",
                        },
                },
        }
}</span>

func dataSourceBackupStorageLocationRead(_ context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        c := getV1ClientWithResourceContext(m, "project")

        // Warning or errors can be collected in a slice type
        var diags diag.Diagnostics

        //projectScope := true

        bsls, err := c.ListBackupStorageLocation()
        if err != nil </span><span class="cov0" title="0">{
                return handleReadError(d, err, diags)
        }</span>

        <span class="cov0" title="0">var bsl *models.V1UserAssetsLocation
        for _, a := range bsls </span><span class="cov0" title="0">{
                if v, ok := d.GetOk("id"); ok &amp;&amp; v.(string) == a.Metadata.UID </span><span class="cov0" title="0">{
                        bsl = a
                        break</span>
                } else<span class="cov0" title="0"> if v, ok := d.GetOk("name"); ok &amp;&amp; v.(string) == a.Metadata.Name </span><span class="cov0" title="0">{
                        bsl = a
                        break</span>
                }
        }

        <span class="cov0" title="0">if bsl == nil </span><span class="cov0" title="0">{
                diags = append(diags, diag.Diagnostic{
                        Severity: diag.Error,
                        Summary:  "Unable to find backup storage location",
                        Detail:   "Unable to find the specified backup storage location",
                })
                return diags
        }</span>

        <span class="cov0" title="0">d.SetId(bsl.Metadata.UID)
        err = d.Set("name", bsl.Metadata.Name)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">return diags</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package spectrocloud

import (
        "context"
        "fmt"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
        "github.com/spectrocloud/palette-sdk-go/api/models"
)

func dataSourceCloudAccountApacheCloudStack() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                ReadContext: dataSourceCloudAccountApacheCloudStackRead,

                Schema: map[string]*schema.Schema{
                        "id": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Computed:     true,
                                ExactlyOneOf: []string{"id", "name"},
                                Description:  "The unique ID of the Apache CloudStack cloud account. Either `id` or `name` must be provided, but not both.",
                        },
                        "name": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Computed:     true,
                                ExactlyOneOf: []string{"id", "name"},
                                Description:  "The name of the Apache CloudStack cloud account. Either `id` or `name` must be provided, but not both.",
                        },
                        "context": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "",
                                ValidateFunc: validation.StringInSlice([]string{"", "project", "tenant"}, false),
                                Description:  "The context of the account. Allowed values are `project` or `tenant` or ``. ",
                        },
                },
        }
}</span>

func dataSourceCloudAccountApacheCloudStackRead(_ context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        c := getV1ClientWithResourceContext(m, "")

        var diags diag.Diagnostics

        accounts, err := c.GetCloudAccountsCloudStack()
        if err != nil </span><span class="cov0" title="0">{
                return handleReadError(d, err, diags)
        }</span>

        <span class="cov0" title="0">var account *models.V1CloudStackAccount
        filteredAccounts := make([]*models.V1CloudStackAccount, 0)
        for _, a := range accounts </span><span class="cov0" title="0">{
                if v, ok := d.GetOk("id"); ok &amp;&amp; v.(string) == a.Metadata.UID </span><span class="cov0" title="0">{
                        account = a
                        break</span>
                } else<span class="cov0" title="0"> if v, ok := d.GetOk("name"); ok &amp;&amp; v.(string) == a.Metadata.Name </span><span class="cov0" title="0">{
                        account = a
                        break</span>
                }
        }

        <span class="cov0" title="0">if len(filteredAccounts) &gt; 1 </span><span class="cov0" title="0">{
                if accContext, ok := d.GetOk("context"); ok &amp;&amp; accContext != "" </span><span class="cov0" title="0">{
                        for _, ac := range filteredAccounts </span><span class="cov0" title="0">{
                                if ac.Metadata.Annotations["scope"] == accContext </span><span class="cov0" title="0">{
                                        account = ac
                                        break</span>
                                }
                        }
                } else<span class="cov0" title="0"> {
                        diags = append(diags, diag.Diagnostic{
                                Severity: diag.Error,
                                Summary:  "Found multiple cloud accounts",
                                Detail:   fmt.Sprintf("more than 1 account found for name - '%s'. Kindly re-try with `context` set, Allowed value `project` or `tenant`", d.Get("name").(string)),
                        })
                        return diags
                }</span>
        } else<span class="cov0" title="0"> if len(filteredAccounts) == 1 </span><span class="cov0" title="0">{
                account = filteredAccounts[0]
        }</span>

        <span class="cov0" title="0">if account == nil </span><span class="cov0" title="0">{
                diags = append(diags, diag.Diagnostic{
                        Severity: diag.Error,
                        Summary:  "Unable to find Apache CloudStack cloud account",
                        Detail:   "Unable to find the specified Apache CloudStack cloud account",
                })
                return diags
        }</span>

        <span class="cov0" title="0">d.SetId(account.Metadata.UID)
        if err := d.Set("name", account.Metadata.Name); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">return diags</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package spectrocloud

import (
        "context"
        "fmt"
        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
        "github.com/spectrocloud/palette-sdk-go/api/models"
)

func dataSourceCloudAccountAws() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                ReadContext: dataSourceCloudAccountAwsRead,
                Description: "A data source for retrieving information about an AWS cloud account registered in Palette.",

                Schema: map[string]*schema.Schema{
                        "id": {
                                Type:         schema.TypeString,
                                Description:  "ID of the AWS cloud account registered in Palette.",
                                Optional:     true,
                                Computed:     true,
                                ExactlyOneOf: []string{"id", "name"},
                        },
                        "name": {
                                Type:         schema.TypeString,
                                Description:  "Name of the AWS cloud account registered in Palette.",
                                Optional:     true,
                                Computed:     true,
                                ExactlyOneOf: []string{"id", "name"},
                        },
                        "context": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "",
                                ValidateFunc: validation.StringInSlice([]string{"", "project", "tenant"}, false),
                                Description:  "The context of the cluster. Allowed values are `project` or `tenant` or ``. ",
                        },
                        "depends": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Computed:     true,
                                ExactlyOneOf: []string{"id", "name"},
                        },
                },
        }
}</span>

func dataSourceCloudAccountAwsRead(_ context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        c := getV1ClientWithResourceContext(m, "")

        // Warning or errors can be collected in a slice type
        var diags diag.Diagnostics

        accounts, err := c.GetCloudAccountsAws()
        if err != nil </span><span class="cov0" title="0">{
                return handleReadError(d, err, diags)
        }</span>
        <span class="cov0" title="0">var fAccount *models.V1AwsAccount
        filteredAccounts := make([]*models.V1AwsAccount, 0)
        for _, acc := range accounts </span><span class="cov0" title="0">{
                if v, ok := d.GetOk("id"); ok &amp;&amp; v.(string) == acc.Metadata.UID </span><span class="cov0" title="0">{
                        fAccount = acc
                        break</span>
                }
                <span class="cov0" title="0">if v, ok := d.GetOk("name"); ok &amp;&amp; v.(string) == acc.Metadata.Name </span><span class="cov0" title="0">{
                        filteredAccounts = append(filteredAccounts, acc)
                }</span>
        }
        <span class="cov0" title="0">if len(filteredAccounts) &gt; 1 </span><span class="cov0" title="0">{
                if accContext, ok := d.GetOk("context"); ok &amp;&amp; accContext != "" </span><span class="cov0" title="0">{
                        for _, ac := range filteredAccounts </span><span class="cov0" title="0">{
                                if ac.Metadata.Annotations["scope"] == accContext </span><span class="cov0" title="0">{
                                        fAccount = ac
                                        break</span>
                                }
                        }
                } else<span class="cov0" title="0"> {
                        diags = append(diags, diag.Diagnostic{
                                Severity: diag.Error,
                                Summary:  "Found more than 1 AWS account",
                                Detail:   fmt.Sprintf("more than 1 aws account found for name - '%s'. Kindly re-try with `context` set, Allowed value `project` or `tenant`", d.Get("name").(string)),
                        })
                        return diags
                }</span>
        } else<span class="cov0" title="0"> if len(filteredAccounts) == 1 </span><span class="cov0" title="0">{
                fAccount = filteredAccounts[0]
        }</span>

        <span class="cov0" title="0">if fAccount == nil </span><span class="cov0" title="0">{
                diags = append(diags, diag.Diagnostic{
                        Severity: diag.Error,
                        Summary:  "Unable to find aws cloud account",
                        Detail:   "Unable to find the specified aws cloud account",
                })
                return diags
        }</span>

        <span class="cov0" title="0">d.SetId(fAccount.Metadata.UID)
        err = d.Set("name", fAccount.Metadata.Name)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">return diags</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">package spectrocloud

import (
        "context"
        "fmt"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/spectrocloud/palette-sdk-go/api/models"
)

func dataSourceCloudAccountAzure() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                ReadContext: dataSourceCloudAccountAzureRead,
                Description: "A data source for retrieving information about an Azure cloud account registered in Palette.",

                Schema: map[string]*schema.Schema{
                        "azure_tenant_id": {
                                Type:        schema.TypeString,
                                Description: "The tenant ID of the Azure cloud account registered in Palette.",
                                Computed:    true,
                        },
                        "azure_client_id": {
                                Type:        schema.TypeString,
                                Description: "The unique client ID from Azure Management Portal.",
                                Computed:    true,
                        },
                        "id": {
                                Type:         schema.TypeString,
                                Description:  "ID of the Azure cloud account registered in Palette.",
                                Optional:     true,
                                Computed:     true,
                                ExactlyOneOf: []string{"id", "name"},
                        },
                        "name": {
                                Type:         schema.TypeString,
                                Description:  "Name of the Azure cloud account registered in Palette.",
                                Optional:     true,
                                Computed:     true,
                                ExactlyOneOf: []string{"id", "name"},
                        },
                        "tenant_name": {
                                Description: "The name of the Azure tenant.",
                                Type:        schema.TypeString,
                                Computed:    true,
                        },
                        "disable_properties_request": {
                                Type:        schema.TypeBool,
                                Description: "The status of the disable properties option.",
                                Computed:    true,
                        },
                        "context": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "",
                                ValidateFunc: validation.StringInSlice([]string{"", "project", "tenant"}, false),
                                Description:  "The context of the cluster. Allowed values are `project` or `tenant` or ``. ",
                        },
                },
        }
}</span>

func dataSourceCloudAccountAzureRead(_ context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        c := getV1ClientWithResourceContext(m, "")

        // Warning or errors can be collected in a slice type
        var diags diag.Diagnostics

        accounts, err := c.GetCloudAccountsAzure()
        if err != nil </span><span class="cov0" title="0">{
                return handleReadError(d, err, diags)
        }</span>

        <span class="cov0" title="0">var account *models.V1AzureAccount
        filteredAccounts := make([]*models.V1AzureAccount, 0)
        for _, a := range accounts </span><span class="cov0" title="0">{
                if v, ok := d.GetOk("id"); ok &amp;&amp; v.(string) == a.Metadata.UID </span><span class="cov0" title="0">{
                        account = a
                        break</span>
                } else<span class="cov0" title="0"> if v, ok := d.GetOk("name"); ok &amp;&amp; v.(string) == a.Metadata.Name </span><span class="cov0" title="0">{
                        filteredAccounts = append(filteredAccounts, a)
                }</span>
        }

        <span class="cov0" title="0">if len(filteredAccounts) &gt; 1 </span><span class="cov0" title="0">{
                if accContext, ok := d.GetOk("context"); ok &amp;&amp; accContext != "" </span><span class="cov0" title="0">{
                        for _, ac := range filteredAccounts </span><span class="cov0" title="0">{
                                if ac.Metadata.Annotations["scope"] == accContext </span><span class="cov0" title="0">{
                                        account = ac
                                        break</span>
                                }
                        }
                } else<span class="cov0" title="0"> {
                        diags = append(diags, diag.Diagnostic{
                                Severity: diag.Error,
                                Summary:  "Found multiple cloud accounts",
                                Detail:   fmt.Sprintf("more than 1 account found for name - '%s'. Kindly re-try with `context` set, Allowed value `project` or `tenant`", d.Get("name").(string)),
                        })
                        return diags
                }</span>
        } else<span class="cov0" title="0"> if len(filteredAccounts) == 1 </span><span class="cov0" title="0">{
                account = filteredAccounts[0]
        }</span>

        <span class="cov0" title="0">if account == nil </span><span class="cov0" title="0">{
                diags = append(diags, diag.Diagnostic{
                        Severity: diag.Error,
                        Summary:  "Unable to find azure cloud account",
                        Detail:   "Unable to find the specified azure cloud account",
                })
                return diags
        }</span>

        <span class="cov0" title="0">d.SetId(account.Metadata.UID)
        if err := d.Set("name", account.Metadata.Name); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">if err := d.Set("azure_tenant_id", *account.Spec.TenantID); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">if err := d.Set("azure_client_id", *account.Spec.ClientID); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">return diags</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">package spectrocloud

import (
        "context"
        "fmt"
        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
        "github.com/spectrocloud/palette-sdk-go/api/models"
)

func dataSourceCloudAccountCustom() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                ReadContext: dataSourceCloudAccountCustomRead,

                Schema: map[string]*schema.Schema{
                        "id": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Computed:     true,
                                ExactlyOneOf: []string{"id", "name"},
                                Description:  "The unique identifier of the cloud account. Either `id` or `name` must be provided.",
                        },
                        "name": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Computed:     true,
                                ExactlyOneOf: []string{"id", "name"},
                                Description:  "The name of the cloud account. Either `id` or `name` must be provided.",
                        },
                        "cloud": {
                                Type:        schema.TypeString,
                                Required:    true,
                                Description: "The custom cloud provider name (e.g., `nutanix`).",
                        },
                        "context": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "",
                                ValidateFunc: validation.StringInSlice([]string{"", "project", "tenant"}, false),
                                Description:  "The context of the cluster. Allowed values are `project` or `tenant` or ``. ",
                        },
                },
        }
}</span>

func dataSourceCloudAccountCustomRead(_ context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        c := getV1ClientWithResourceContext(m, "")
        // Warning or errors can be collected in a slice type
        var diags diag.Diagnostics
        cloudType := d.Get("cloud").(string)

        accounts, err := c.GetCustomCloudAccountList(cloudType)
        if err != nil </span><span class="cov0" title="0">{
                return handleReadError(d, err, diags)
        }</span>
        <span class="cov0" title="0">var account *models.V1CustomAccount
        filteredAccounts := make([]*models.V1CustomAccount, 0)
        for _, a := range accounts </span><span class="cov0" title="0">{
                if v, ok := d.GetOk("id"); ok &amp;&amp; v.(string) == a.Metadata.UID </span><span class="cov0" title="0">{
                        account = a
                        break</span>
                } else<span class="cov0" title="0"> if v, ok := d.GetOk("name"); ok &amp;&amp; v.(string) == a.Metadata.Name </span><span class="cov0" title="0">{
                        filteredAccounts = append(filteredAccounts, a)
                }</span>
        }

        <span class="cov0" title="0">if len(filteredAccounts) &gt; 1 </span><span class="cov0" title="0">{
                if accContext, ok := d.GetOk("context"); ok &amp;&amp; accContext != "" </span><span class="cov0" title="0">{
                        for _, ac := range filteredAccounts </span><span class="cov0" title="0">{
                                if ac.Metadata.Annotations["scope"] == accContext </span><span class="cov0" title="0">{
                                        account = ac
                                        break</span>
                                }
                        }
                } else<span class="cov0" title="0"> {
                        diags = append(diags, diag.Diagnostic{
                                Severity: diag.Error,
                                Summary:  "Found multiple cloud accounts",
                                Detail:   fmt.Sprintf("more than 1 account found for name - '%s'. Kindly re-try with `context` set, Allowed value `project` or `tenant`", d.Get("name").(string)),
                        })
                        return diags
                }</span>
        } else<span class="cov0" title="0"> if len(filteredAccounts) == 1 </span><span class="cov0" title="0">{
                account = filteredAccounts[0]
        }</span>

        <span class="cov0" title="0">if account == nil </span><span class="cov0" title="0">{
                diags = append(diags, diag.Diagnostic{
                        Severity: diag.Error,
                        Summary:  "Unable to find cloud account",
                        Detail:   "Unable to find the specified aws cloud account",
                })
                return diags
        }</span>

        <span class="cov0" title="0">d.SetId(account.Metadata.UID)
        err = d.Set("name", account.Metadata.Name)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">return diags</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">package spectrocloud

import (
        "context"
        "fmt"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/spectrocloud/palette-sdk-go/api/models"
)

func dataSourceCloudAccountGcp() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                ReadContext: dataSourceCloudAccountGcpRead,
                Description: "A data source for retrieving information about a GCP cloud account registered in Palette.",

                Schema: map[string]*schema.Schema{
                        "id": {
                                Type:         schema.TypeString,
                                Description:  "ID of the GCP cloud account registered in Palette.",
                                Optional:     true,
                                Computed:     true,
                                ExactlyOneOf: []string{"id", "name"},
                        },
                        "name": {
                                Type:         schema.TypeString,
                                Description:  "Name of the GCP cloud account registered in Palette.",
                                Optional:     true,
                                Computed:     true,
                                ExactlyOneOf: []string{"id", "name"},
                        },
                        "context": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "",
                                ValidateFunc: validation.StringInSlice([]string{"", "project", "tenant"}, false),
                                Description:  "The context of the cluster. Allowed values are `project` or `tenant` or ``. ",
                        },
                },
        }
}</span>

func dataSourceCloudAccountGcpRead(_ context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        c := getV1ClientWithResourceContext(m, "")

        // Warning or errors can be collected in a slice type
        var diags diag.Diagnostics

        accounts, err := c.GetCloudAccountsGcp()
        if err != nil </span><span class="cov0" title="0">{
                return handleReadError(d, err, diags)
        }</span>

        <span class="cov0" title="0">var account *models.V1GcpAccount
        filteredAccounts := make([]*models.V1GcpAccount, 0)
        for _, a := range accounts </span><span class="cov0" title="0">{
                if v, ok := d.GetOk("id"); ok &amp;&amp; v.(string) == a.Metadata.UID </span><span class="cov0" title="0">{
                        account = a
                        break</span>
                } else<span class="cov0" title="0"> if v, ok := d.GetOk("name"); ok &amp;&amp; v.(string) == a.Metadata.Name </span><span class="cov0" title="0">{
                        filteredAccounts = append(filteredAccounts, a)
                }</span>
        }

        <span class="cov0" title="0">if len(filteredAccounts) &gt; 1 </span><span class="cov0" title="0">{
                if accContext, ok := d.GetOk("context"); ok &amp;&amp; accContext != "" </span><span class="cov0" title="0">{
                        for _, ac := range filteredAccounts </span><span class="cov0" title="0">{
                                if ac.Metadata.Annotations["scope"] == accContext </span><span class="cov0" title="0">{
                                        account = ac
                                        break</span>
                                }
                        }
                } else<span class="cov0" title="0"> {
                        diags = append(diags, diag.Diagnostic{
                                Severity: diag.Error,
                                Summary:  "Found multiple cloud accounts",
                                Detail:   fmt.Sprintf("more than 1 account found for name - '%s'. Kindly re-try with `context` set, Allowed value `project` or `tenant`", d.Get("name").(string)),
                        })
                        return diags
                }</span>
        } else<span class="cov0" title="0"> if len(filteredAccounts) == 1 </span><span class="cov0" title="0">{
                account = filteredAccounts[0]
        }</span>

        <span class="cov0" title="0">if account == nil </span><span class="cov0" title="0">{
                diags = append(diags, diag.Diagnostic{
                        Severity: diag.Error,
                        Summary:  "Unable to find gcp cloud account",
                        Detail:   "Unable to find the specified gcp cloud account",
                })
                return diags
        }</span>

        <span class="cov0" title="0">d.SetId(account.Metadata.UID)
        if err := d.Set("name", account.Metadata.Name); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">return diags</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">package spectrocloud

import (
        "context"
        "fmt"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/spectrocloud/palette-sdk-go/api/models"
)

func dataSourceCloudAccountMaas() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                ReadContext: dataSourceCloudAccountMaasRead,

                Schema: map[string]*schema.Schema{
                        "maas_api_endpoint": {
                                Type:        schema.TypeString,
                                Computed:    true,
                                Description: "The API endpoint of the MaaS account. This value is computed based on the cloud account's configuration and is used for interaction with the MaaS service.",
                        },
                        "maas_api_key": {
                                Type:        schema.TypeString,
                                Computed:    true,
                                Description: "The API key associated with the MaaS account. This is used to authenticate API requests to the MaaS service and is computed from the cloud account's credentials.",
                        },
                        "id": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Computed:     true,
                                ExactlyOneOf: []string{"id", "name"},
                                Description:  "The unique ID of the cloud account. Either `id` or `name` must be provided, but not both.",
                        },
                        "name": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Computed:     true,
                                ExactlyOneOf: []string{"id", "name"},
                                Description:  "The name of the cloud account. This can be used instead of `id` to retrieve the account details. Only one of `id` or `name` can be specified.",
                        },
                        "context": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "",
                                ValidateFunc: validation.StringInSlice([]string{"", "project", "tenant"}, false),
                                Description:  "The context of the cluster. Allowed values are `project` or `tenant` or ``. ",
                        },
                },
        }
}</span>

func dataSourceCloudAccountMaasRead(_ context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        c := getV1ClientWithResourceContext(m, "")

        // Warning or errors can be collected in a slice type
        var diags diag.Diagnostics

        accounts, err := c.GetCloudAccountsMaas()
        if err != nil </span><span class="cov0" title="0">{
                return handleReadError(d, err, diags)
        }</span>

        <span class="cov0" title="0">var account *models.V1MaasAccount
        filteredAccounts := make([]*models.V1MaasAccount, 0)
        for _, a := range accounts </span><span class="cov0" title="0">{
                if v, ok := d.GetOk("id"); ok &amp;&amp; v.(string) == a.Metadata.UID </span><span class="cov0" title="0">{
                        account = a
                        break</span>
                } else<span class="cov0" title="0"> if v, ok := d.GetOk("name"); ok &amp;&amp; v.(string) == a.Metadata.Name </span><span class="cov0" title="0">{
                        account = a
                        break</span>
                }
        }

        <span class="cov0" title="0">if len(filteredAccounts) &gt; 1 </span><span class="cov0" title="0">{
                if accContext, ok := d.GetOk("context"); ok &amp;&amp; accContext != "" </span><span class="cov0" title="0">{
                        for _, ac := range filteredAccounts </span><span class="cov0" title="0">{
                                if ac.Metadata.Annotations["scope"] == accContext </span><span class="cov0" title="0">{
                                        account = ac
                                        break</span>
                                }
                        }
                } else<span class="cov0" title="0"> {
                        diags = append(diags, diag.Diagnostic{
                                Severity: diag.Error,
                                Summary:  "Found multiple cloud accounts",
                                Detail:   fmt.Sprintf("more than 1 account found for name - '%s'. Kindly re-try with `context` set, Allowed value `project` or `tenant`", d.Get("name").(string)),
                        })
                        return diags
                }</span>
        } else<span class="cov0" title="0"> if len(filteredAccounts) == 1 </span><span class="cov0" title="0">{
                account = filteredAccounts[0]
        }</span>

        <span class="cov0" title="0">if account == nil </span><span class="cov0" title="0">{
                diags = append(diags, diag.Diagnostic{
                        Severity: diag.Error,
                        Summary:  "Unable to find maas cloud account",
                        Detail:   "Unable to find the specified maas cloud account",
                })
                return diags
        }</span>

        <span class="cov0" title="0">d.SetId(account.Metadata.UID)
        err = d.Set("name", account.Metadata.Name)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">err = d.Set("maas_api_endpoint", account.Spec.APIEndpoint)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">err = d.Set("maas_api_key", account.Spec.APIKey)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">return diags</span>
}
</pre>
		
		<pre class="file" id="file45" style="display: none">package spectrocloud

import (
        "context"
        "fmt"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/spectrocloud/palette-sdk-go/api/models"
)

func dataSourceCloudAccountOpenStack() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                ReadContext: dataSourceCloudAccountOpenStackRead,

                Schema: map[string]*schema.Schema{
                        "id": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Computed:     true,
                                ExactlyOneOf: []string{"id", "name"},
                                Description:  "The unique ID of the OpenStack cloud account. Either `id` or `name` must be provided, but not both.",
                        },
                        "name": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Computed:     true,
                                ExactlyOneOf: []string{"id", "name"},
                                Description:  "The name of the OpenStack cloud account. Either `id` or `name` must be provided, but not both.",
                        },
                        "context": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "",
                                ValidateFunc: validation.StringInSlice([]string{"", "project", "tenant"}, false),
                                Description:  "The context of the cluster. Allowed values are `project` or `tenant` or ``. ",
                        },
                },
        }
}</span>

func dataSourceCloudAccountOpenStackRead(_ context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        c := getV1ClientWithResourceContext(m, "")

        // Warning or errors can be collected in a slice type
        var diags diag.Diagnostics

        accounts, err := c.GetCloudAccountsOpenStack()
        if err != nil </span><span class="cov0" title="0">{
                return handleReadError(d, err, diags)
        }</span>

        <span class="cov0" title="0">var account *models.V1OpenStackAccount
        filteredAccounts := make([]*models.V1OpenStackAccount, 0)
        for _, a := range accounts </span><span class="cov0" title="0">{
                if v, ok := d.GetOk("id"); ok &amp;&amp; v.(string) == a.Metadata.UID </span><span class="cov0" title="0">{
                        account = a
                        break</span>
                } else<span class="cov0" title="0"> if v, ok := d.GetOk("name"); ok &amp;&amp; v.(string) == a.Metadata.Name </span><span class="cov0" title="0">{
                        account = a
                        break</span>
                }
        }

        <span class="cov0" title="0">if len(filteredAccounts) &gt; 1 </span><span class="cov0" title="0">{
                if accContext, ok := d.GetOk("context"); ok &amp;&amp; accContext != "" </span><span class="cov0" title="0">{
                        for _, ac := range filteredAccounts </span><span class="cov0" title="0">{
                                if ac.Metadata.Annotations["scope"] == accContext </span><span class="cov0" title="0">{
                                        account = ac
                                        break</span>
                                }
                        }
                } else<span class="cov0" title="0"> {
                        diags = append(diags, diag.Diagnostic{
                                Severity: diag.Error,
                                Summary:  "Found multiple cloud accounts",
                                Detail:   fmt.Sprintf("more than 1 account found for name - '%s'. Kindly re-try with `context` set, Allowed value `project` or `tenant`", d.Get("name").(string)),
                        })
                        return diags
                }</span>
        } else<span class="cov0" title="0"> if len(filteredAccounts) == 1 </span><span class="cov0" title="0">{
                account = filteredAccounts[0]
        }</span>

        <span class="cov0" title="0">if account == nil </span><span class="cov0" title="0">{
                diags = append(diags, diag.Diagnostic{
                        Severity: diag.Error,
                        Summary:  "Unable to find openstack cloud account",
                        Detail:   "Unable to find the specified openstack cloud account",
                })
                return diags
        }</span>

        <span class="cov0" title="0">d.SetId(account.Metadata.UID)
        if err := d.Set("name", account.Metadata.Name); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">return diags</span>
}
</pre>
		
		<pre class="file" id="file46" style="display: none">package spectrocloud

import (
        "context"
        "fmt"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/spectrocloud/palette-sdk-go/api/models"
)

func dataSourceCloudAccountVsphere() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                ReadContext: dataSourceCloudAccountVsphereRead,

                Schema: map[string]*schema.Schema{
                        "id": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Computed:     true,
                                ExactlyOneOf: []string{"id", "name"},
                                Description:  "The unique ID of the vSphere cloud account. Either `id` or `name` must be provided, but not both.",
                        },
                        "name": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Computed:     true,
                                ExactlyOneOf: []string{"id", "name"},
                                Description:  "The name of the vSphere cloud account. Either `id` or `name` must be provided, but not both.",
                        },
                        "context": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "",
                                ValidateFunc: validation.StringInSlice([]string{"", "project", "tenant"}, false),
                                Description:  "The context of the cluster. Allowed values are `project` or `tenant` or ``. ",
                        },
                },
        }
}</span>

func dataSourceCloudAccountVsphereRead(_ context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        c := getV1ClientWithResourceContext(m, "")

        // Warning or errors can be collected in a slice type
        var diags diag.Diagnostics

        accounts, err := c.GetCloudAccountsVsphere()
        if err != nil </span><span class="cov0" title="0">{
                return handleReadError(d, err, diags)
        }</span>

        <span class="cov0" title="0">var account *models.V1VsphereAccount
        filteredAccounts := make([]*models.V1VsphereAccount, 0)
        for _, a := range accounts </span><span class="cov0" title="0">{
                if v, ok := d.GetOk("id"); ok &amp;&amp; v.(string) == a.Metadata.UID </span><span class="cov0" title="0">{
                        account = a
                        break</span>
                } else<span class="cov0" title="0"> if v, ok := d.GetOk("name"); ok &amp;&amp; v.(string) == a.Metadata.Name </span><span class="cov0" title="0">{
                        account = a
                        break</span>
                }
        }

        <span class="cov0" title="0">if len(filteredAccounts) &gt; 1 </span><span class="cov0" title="0">{
                if accContext, ok := d.GetOk("context"); ok &amp;&amp; accContext != "" </span><span class="cov0" title="0">{
                        for _, ac := range filteredAccounts </span><span class="cov0" title="0">{
                                if ac.Metadata.Annotations["scope"] == accContext </span><span class="cov0" title="0">{
                                        account = ac
                                        break</span>
                                }
                        }
                } else<span class="cov0" title="0"> {
                        diags = append(diags, diag.Diagnostic{
                                Severity: diag.Error,
                                Summary:  "Found multiple cloud accounts",
                                Detail:   fmt.Sprintf("more than 1 account found for name - '%s'. Kindly re-try with `context` set, Allowed value `project` or `tenant`", d.Get("name").(string)),
                        })
                        return diags
                }</span>
        } else<span class="cov0" title="0"> if len(filteredAccounts) == 1 </span><span class="cov0" title="0">{
                account = filteredAccounts[0]
        }</span>

        <span class="cov0" title="0">if account == nil </span><span class="cov0" title="0">{
                diags = append(diags, diag.Diagnostic{
                        Severity: diag.Error,
                        Summary:  "Unable to find vsphere cloud account",
                        Detail:   "Unable to find the specified vsphere cloud account",
                })
                return diags
        }</span>

        <span class="cov0" title="0">d.SetId(account.Metadata.UID)
        if err := d.Set("name", account.Metadata.Name); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">return diags</span>
}
</pre>
		
		<pre class="file" id="file47" style="display: none">package spectrocloud

import (
        "context"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
)

func dataSourceCluster() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                ReadContext: dataSourceClusterRead,

                Schema: map[string]*schema.Schema{
                        "name": {
                                Type:        schema.TypeString,
                                Required:    true,
                                ForceNew:    true,
                                Description: "The name of the cluster.",
                        },
                        "admin_kube_config": {
                                Type:        schema.TypeString,
                                Computed:    true,
                                Description: "The admin kubeconfig file for accessing the cluster. This is computed automatically.",
                        },
                        "kube_config": {
                                Type:        schema.TypeString,
                                Computed:    true,
                                Description: "The kubeconfig file for accessing the cluster as a non-admin user. This is computed automatically.",
                        },
                        "context": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "project",
                                ValidateFunc: validation.StringInSlice([]string{"project", "tenant"}, false),
                                Description: "The context of the cluster. Allowed values are `project` or `tenant`. " +
                                        "Defaults to `project`." + PROJECT_NAME_NUANCE,
                        },
                        "virtual": {
                                Type:        schema.TypeBool,
                                Optional:    true,
                                Default:     false,
                                Description: "If set to true, the cluster will treated as a virtual cluster. Defaults to `false`.",
                        },
                        "state": {
                                Type:        schema.TypeString,
                                Computed:    true,
                                Description: "The current state of the cluster. This is computed automatically.",
                        },
                        "health": {
                                Type:        schema.TypeString,
                                Computed:    true,
                                Description: "The current health status of the cluster. This is computed automatically.",
                        },
                        "cluster_timezone": {
                                Type:        schema.TypeString,
                                Computed:    true,
                                Description: "The time zone used by this cluster to interpret scheduled operations. Maintenance tasks like upgrades follow this time zone to ensure they run at the appropriate local time for the cluster. Value is in IANA timezone format (e.g., 'America/New_York', 'Asia/Kolkata').",
                        },
                },
        }
}</span>

func dataSourceClusterRead(_ context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        resourceContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, resourceContext)
        var diags diag.Diagnostics
        if name, okName := d.GetOk("name"); okName </span><span class="cov0" title="0">{
                cluster, err := c.GetClusterByName(name.(string), d.Get("virtual").(bool))
                if err != nil </span><span class="cov0" title="0">{
                        return handleReadError(d, err, diags)
                }</span>
                <span class="cov0" title="0">if cluster != nil </span><span class="cov0" title="0">{
                        d.SetId(cluster.Metadata.UID)
                        kubeConfig, _ := c.GetClusterClientKubeConfig(cluster.Metadata.UID)
                        if err := d.Set("kube_config", kubeConfig); err != nil </span><span class="cov0" title="0">{
                                return diag.FromErr(err)
                        }</span>
                        <span class="cov0" title="0">adminKubeConfig, _ := c.GetClusterAdminKubeConfig(cluster.Metadata.UID)
                        if adminKubeConfig != "" </span><span class="cov0" title="0">{
                                if err := d.Set("admin_kube_config", adminKubeConfig); err != nil </span><span class="cov0" title="0">{
                                        return diag.FromErr(err)
                                }</span>
                        }
                        <span class="cov0" title="0">d.SetId(cluster.Metadata.UID)
                        if err := d.Set("name", cluster.Metadata.Name); err != nil </span><span class="cov0" title="0">{
                                return diag.FromErr(err)
                        }</span>

                        // Set cluster state
                        <span class="cov0" title="0">if cluster.Status != nil &amp;&amp; cluster.Status.State != "" </span><span class="cov0" title="0">{
                                if err := d.Set("state", cluster.Status.State); err != nil </span><span class="cov0" title="0">{
                                        return diag.FromErr(err)
                                }</span>
                        }

                        // Set cluster health
                        <span class="cov0" title="0">clusterSummary, summaryErr := c.GetClusterOverview(cluster.Metadata.UID)
                        if summaryErr == nil &amp;&amp; clusterSummary.Status.Health != nil &amp;&amp; clusterSummary.Status.Health.State != "" </span><span class="cov0" title="0">{
                                if err := d.Set("health", clusterSummary.Status.Health.State); err != nil </span><span class="cov0" title="0">{
                                        return diag.FromErr(err)
                                }</span>
                        }

                        // Set cluster timezone if available
                        <span class="cov0" title="0">if cluster.Spec != nil &amp;&amp; cluster.Spec.ClusterConfig != nil &amp;&amp; cluster.Spec.ClusterConfig.Timezone != "" </span><span class="cov0" title="0">{
                                if err := d.Set("cluster_timezone", cluster.Spec.ClusterConfig.Timezone); err != nil </span><span class="cov0" title="0">{
                                        return diag.FromErr(err)
                                }</span>
                        }
                }
        }
        <span class="cov0" title="0">return diags</span>
}
</pre>
		
		<pre class="file" id="file48" style="display: none">package spectrocloud

import (
        "context"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
        "github.com/spectrocloud/palette-sdk-go/api/models"
)

func dataSourceClusterConfigPolicy() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                ReadContext: dataSourceClusterConfigPolicyRead,
                Description: "Data source for retrieving information about a cluster config policy (maintenance policy).",
                Schema: map[string]*schema.Schema{
                        "name": {
                                Type:        schema.TypeString,
                                Required:    true,
                                Description: "The name of the cluster config policy.",
                        },
                        "context": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "project",
                                ValidateFunc: validation.StringInSlice([]string{"project", "tenant"}, false),
                                Description: "The context of the cluster config policy. Allowed values are `project` or `tenant`. " +
                                        "Default value is `project`. " + PROJECT_NAME_NUANCE,
                        },
                        "tags": {
                                Type:     schema.TypeSet,
                                Computed: true,
                                Set:      schema.HashString,
                                Elem: &amp;schema.Schema{
                                        Type: schema.TypeString,
                                },
                                Description: "Tags assigned to the cluster config policy.",
                        },
                        "schedules": {
                                Type:        schema.TypeList,
                                Computed:    true,
                                Description: "List of maintenance schedules for the policy.",
                                Elem: &amp;schema.Resource{
                                        Schema: map[string]*schema.Schema{
                                                "name": {
                                                        Type:        schema.TypeString,
                                                        Computed:    true,
                                                        Description: "Name of the upgrade schedule.",
                                                },
                                                "start_cron": {
                                                        Type:        schema.TypeString,
                                                        Computed:    true,
                                                        Description: "Cron expression for the start time of the schedule.",
                                                },
                                                "duration_hrs": {
                                                        Type:        schema.TypeInt,
                                                        Computed:    true,
                                                        Description: "Specifies the time window in hours during which the system is allowed to start upgrades on eligible clusters.",
                                                },
                                        },
                                },
                        },
                },
        }
}</span>

func dataSourceClusterConfigPolicyRead(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        c := getV1ClientWithResourceContext(m, d.Get("context").(string))
        var diags diag.Diagnostics

        name := d.Get("name").(string)
        policySummary, err := c.GetClusterConfigPolicyByName(name)
        if err != nil </span><span class="cov0" title="0">{
                return handleReadError(d, err, diags)
        }</span>

        <span class="cov0" title="0">policy, err := c.GetClusterConfigPolicy(policySummary.Metadata.UID)
        if err != nil </span><span class="cov0" title="0">{
                return handleReadError(d, err, diags)
        }</span>

        <span class="cov0" title="0">d.SetId(policy.Metadata.UID)

        if err := d.Set("name", policy.Metadata.Name); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">if err := d.Set("tags", flattenTags(policy.Metadata.Labels)); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">if policy.Spec != nil </span><span class="cov0" title="0">{
                if err := d.Set("schedules", flattenClusterConfigPolicySchedulesForDataSource(policy.Spec.Schedules)); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
        }

        <span class="cov0" title="0">return diags</span>
}

// flattenClusterConfigPolicySchedulesForDataSource returns a slice for use with TypeList in data sources
func flattenClusterConfigPolicySchedulesForDataSource(schedules []*models.V1Schedule) []interface{} <span class="cov0" title="0">{
        if schedules == nil </span><span class="cov0" title="0">{
                return []interface{}{}
        }</span>

        <span class="cov0" title="0">result := make([]interface{}, len(schedules))
        for i, schedule := range schedules </span><span class="cov0" title="0">{
                m := map[string]interface{}{}
                if schedule.Name != nil </span><span class="cov0" title="0">{
                        m["name"] = *schedule.Name
                }</span>
                <span class="cov0" title="0">if schedule.StartCron != nil </span><span class="cov0" title="0">{
                        m["start_cron"] = *schedule.StartCron
                }</span>
                <span class="cov0" title="0">if schedule.DurationHrs != nil </span><span class="cov0" title="0">{
                        m["duration_hrs"] = int(*schedule.DurationHrs)
                }</span>
                <span class="cov0" title="0">result[i] = m</span>
        }

        <span class="cov0" title="0">return result</span>
}
</pre>
		
		<pre class="file" id="file49" style="display: none">package spectrocloud

import (
        "context"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
)

func dataSourceClusterConfigTemplate() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                ReadContext: dataSourceClusterConfigTemplateRead,
                Description: "Data source for retrieving information about a cluster config template. **Tech Preview**: This data source is in tech preview and may undergo changes.",
                Schema: map[string]*schema.Schema{
                        "name": {
                                Type:        schema.TypeString,
                                Required:    true,
                                Description: "The name of the cluster config template.",
                        },
                        "context": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "project",
                                ValidateFunc: validation.StringInSlice([]string{"project", "tenant"}, false),
                                Description: "The context of the cluster config template. Allowed values are `project` or `tenant`. " +
                                        "Default value is `project`. " + PROJECT_NAME_NUANCE,
                        },
                        "description": {
                                Type:        schema.TypeString,
                                Computed:    true,
                                Description: "The description of the cluster config template.",
                        },
                        "tags": {
                                Type:     schema.TypeSet,
                                Computed: true,
                                Set:      schema.HashString,
                                Elem: &amp;schema.Schema{
                                        Type: schema.TypeString,
                                },
                                Description: "Tags assigned to the cluster config template.",
                        },
                        "cloud_type": {
                                Type:        schema.TypeString,
                                Computed:    true,
                                Description: "The cloud type for the cluster template.",
                        },
                        "cluster_profile": {
                                Type:        schema.TypeSet,
                                Computed:    true,
                                Description: "Set of cluster profile references.",
                                Elem: &amp;schema.Resource{
                                        Schema: map[string]*schema.Schema{
                                                "id": {
                                                        Type:        schema.TypeString,
                                                        Computed:    true,
                                                        Description: "ID of the cluster profile.",
                                                },
                                                "variables": {
                                                        Type:        schema.TypeSet,
                                                        Computed:    true,
                                                        Description: "Set of profile variable values and assignment strategies.",
                                                        Elem: &amp;schema.Resource{
                                                                Schema: map[string]*schema.Schema{
                                                                        "name": {
                                                                                Type:        schema.TypeString,
                                                                                Computed:    true,
                                                                                Description: "Name of the variable.",
                                                                        },
                                                                        "value": {
                                                                                Type:        schema.TypeString,
                                                                                Computed:    true,
                                                                                Description: "Value of the variable to be applied to all clusters launched from this template.",
                                                                        },
                                                                        "assign_strategy": {
                                                                                Type:        schema.TypeString,
                                                                                Computed:    true,
                                                                                Description: "Assignment strategy for the variable. Possible values: `all` or `cluster`.",
                                                                        },
                                                                },
                                                        },
                                                },
                                        },
                                },
                        },
                        "policy": {
                                Type:        schema.TypeList,
                                Computed:    true,
                                Description: "List of policy references.",
                                Elem: &amp;schema.Resource{
                                        Schema: map[string]*schema.Schema{
                                                "id": {
                                                        Type:        schema.TypeString,
                                                        Computed:    true,
                                                        Description: "ID of the policy.",
                                                },
                                                "kind": {
                                                        Type:        schema.TypeString,
                                                        Computed:    true,
                                                        Description: "Kind of the policy.",
                                                },
                                        },
                                },
                        },
                        "attached_cluster": {
                                Type:        schema.TypeList,
                                Computed:    true,
                                Description: "List of clusters attached to this template.",
                                Elem: &amp;schema.Resource{
                                        Schema: map[string]*schema.Schema{
                                                "cluster_uid": {
                                                        Type:        schema.TypeString,
                                                        Computed:    true,
                                                        Description: "UID of the attached cluster.",
                                                },
                                                "name": {
                                                        Type:        schema.TypeString,
                                                        Computed:    true,
                                                        Description: "Name of the attached cluster.",
                                                },
                                        },
                                },
                        },
                        "execution_state": {
                                Type:        schema.TypeString,
                                Computed:    true,
                                Description: "Current execution state of the cluster template. Possible values: `Pending`, `Applied`, `Failed`, `PartiallyApplied`.",
                        },
                },
        }
}</span>

func dataSourceClusterConfigTemplateRead(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        c := getV1ClientWithResourceContext(m, d.Get("context").(string))
        var diags diag.Diagnostics

        name := d.Get("name").(string)
        templateSummary, err := c.GetClusterConfigTemplateByName(name)
        if err != nil </span><span class="cov0" title="0">{
                return handleReadError(d, err, diags)
        }</span>

        <span class="cov0" title="0">template, err := c.GetClusterConfigTemplate(templateSummary.Metadata.UID)
        if err != nil </span><span class="cov0" title="0">{
                return handleReadError(d, err, diags)
        }</span>

        <span class="cov0" title="0">d.SetId(template.Metadata.UID)

        if err := d.Set("name", template.Metadata.Name); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">if err := d.Set("tags", flattenTags(template.Metadata.Labels)); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        // Get description from annotations if it exists
        <span class="cov0" title="0">if template.Metadata.Annotations != nil </span><span class="cov0" title="0">{
                if description, found := template.Metadata.Annotations["description"]; found </span><span class="cov0" title="0">{
                        if err := d.Set("description", description); err != nil </span><span class="cov0" title="0">{
                                return diag.FromErr(err)
                        }</span>
                }
        }

        <span class="cov0" title="0">if template.Spec != nil </span><span class="cov0" title="0">{
                if err := d.Set("cloud_type", template.Spec.CloudType); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>

                <span class="cov0" title="0">if err := d.Set("cluster_profile", flattenClusterTemplateProfiles(template.Spec.Profiles)); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>

                <span class="cov0" title="0">if err := d.Set("policy", flattenClusterTemplatePolicies(template.Spec.Policies)); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>

                // Set attached clusters
                <span class="cov0" title="0">if err := d.Set("attached_cluster", flattenAttachedClusters(template.Spec.Clusters)); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
        }

        // Set execution state from status
        <span class="cov0" title="0">if template.Status != nil </span><span class="cov0" title="0">{
                if err := d.Set("execution_state", template.Status.State); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
        }

        <span class="cov0" title="0">return diags</span>
}
</pre>
		
		<pre class="file" id="file50" style="display: none">package spectrocloud

import (
        "context"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
)

func dataSourceClusterGroup() *schema.Resource <span class="cov10" title="2">{
        return &amp;schema.Resource{
                ReadContext: dataSourceClusterGroupRead,

                Schema: map[string]*schema.Schema{
                        "name": {
                                Type:        schema.TypeString,
                                Required:    true,
                                ForceNew:    true,
                                Description: "The name of the cluster group.",
                        },
                        "context": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "tenant",
                                ValidateFunc: validation.StringInSlice([]string{"", "tenant", "system", "project"}, false),
                                Description: "The context of where the cluster group is located. " +
                                        "Allowed values  are `system` or `tenant`. Defaults to `tenant`." + PROJECT_NAME_NUANCE,
                        },
                },
        }
}</span>

func dataSourceClusterGroupRead(_ context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov1" title="1">{
        GroupContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, GroupContext)
        var diags diag.Diagnostics
        if name, okName := d.GetOk("name"); okName </span><span class="cov1" title="1">{
                switch GroupContext </span>{
                case "system", "tenant":<span class="cov0" title="0">
                        group, err := c.GetClusterGroupScopeMetadataByName(name.(string))
                        if err != nil </span><span class="cov0" title="0">{
                                return handleReadError(d, err, diags)
                        }</span>
                        <span class="cov0" title="0">if group != nil </span><span class="cov0" title="0">{
                                d.SetId(group.UID)
                                if err := d.Set("name", group.Name); err != nil </span><span class="cov0" title="0">{
                                        return diag.FromErr(err)
                                }</span>
                        }
                case "project":<span class="cov1" title="1">
                        group, err := c.GetClusterGroupSummaryByName(name.(string))
                        if err != nil </span><span class="cov0" title="0">{
                                return handleReadError(d, err, diags)
                        }</span>
                        <span class="cov1" title="1">if group != nil </span><span class="cov1" title="1">{
                                d.SetId(group.Metadata.UID)
                                if err := d.Set("name", group.Metadata.Name); err != nil </span><span class="cov0" title="0">{
                                        return diag.FromErr(err)
                                }</span>
                        }
                }
        }
        <span class="cov1" title="1">return diags</span>
}
</pre>
		
		<pre class="file" id="file51" style="display: none">package spectrocloud

import (
        "context"
        "fmt"
        "strings"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
        "github.com/spectrocloud/palette-sdk-go/api/models"
        "github.com/spectrocloud/palette-sdk-go/client"
)

func dataSourceClusterProfile() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                ReadContext: dataSourceClusterProfileRead,

                Schema: map[string]*schema.Schema{
                        "id": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Computed:     true,
                                ExactlyOneOf: []string{"id", "name"},
                                Description:  "The unique ID of the cluster profile. Either `id` or `name` must be provided, but not both.",
                        },
                        "name": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Computed:     true,
                                ExactlyOneOf: []string{"id", "name"},
                                Description:  "The name of the cluster profile. Either `id` or `name` must be provided, but not both.",
                        },
                        "version": {
                                Type:        schema.TypeString,
                                Optional:    true,
                                Computed:    true,
                                Description: "The version of the cluster profile.",
                        },
                        "context": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "project",
                                ValidateFunc: validation.StringInSlice([]string{"", "project", "tenant", "system"}, false),
                                Description: "Cluster profile context. Allowed values are `project` or `tenant`. " +
                                        "Defaults to `project`." + PROJECT_NAME_NUANCE,
                        },
                        "pack": {
                                Type:     schema.TypeList,
                                Computed: true,
                                Elem: &amp;schema.Resource{
                                        Schema: map[string]*schema.Schema{
                                                "type": {
                                                        Type:        schema.TypeString,
                                                        Optional:    true,
                                                        Default:     "spectro",
                                                        Description: "The type of pack. Defaults to `spectro`.",
                                                },
                                                "registry_uid": {
                                                        Type:        schema.TypeString,
                                                        Optional:    true,
                                                        Description: "The UID of the registry associated with the pack.",
                                                },
                                                "uid": {
                                                        Type:        schema.TypeString,
                                                        Computed:    true,
                                                        Optional:    true,
                                                        Description: "The unique identifier for the pack.",
                                                },
                                                "name": {
                                                        Type:        schema.TypeString,
                                                        Required:    true,
                                                        Description: "The name of the pack.",
                                                },
                                                "manifest": {
                                                        Type:     schema.TypeList,
                                                        Optional: true,
                                                        Elem: &amp;schema.Resource{
                                                                Schema: map[string]*schema.Schema{
                                                                        "uid": {
                                                                                Type:        schema.TypeString,
                                                                                Computed:    true,
                                                                                Description: "The unique ID of the manifest.",
                                                                        },
                                                                        "name": {
                                                                                Type:        schema.TypeString,
                                                                                Required:    true,
                                                                                Description: "The name of the manifest.",
                                                                        },
                                                                        "content": {
                                                                                Type:     schema.TypeString,
                                                                                Required: true,
                                                                                DiffSuppressFunc: func(k, old, new string, d *schema.ResourceData) bool </span><span class="cov0" title="0">{
                                                                                        return strings.TrimSpace(old) == strings.TrimSpace(new)
                                                                                }</span>,
                                                                                Description: "The content of the manifest.",
                                                                        },
                                                                },
                                                        },
                                                },
                                                "tag": {
                                                        Type:        schema.TypeString,
                                                        Optional:    true,
                                                        Description: "The tag associated with the pack.",
                                                },
                                                "values": {
                                                        Type:     schema.TypeString,
                                                        Optional: true,
                                                        DiffSuppressFunc: func(k, old, new string, d *schema.ResourceData) bool <span class="cov0" title="0">{
                                                                // UI strips the trailing newline on save
                                                                return strings.TrimSpace(old) == strings.TrimSpace(new)
                                                        }</span>,
                                                        Description: "The YAML values associated with the pack.",
                                                },
                                        },
                                },
                        },
                },
        }
}

func dataSourceClusterProfileRead(_ context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        ProjectContext := "project"
        if Pcontext, ok_context := d.GetOk("context"); ok_context </span><span class="cov0" title="0">{
                ProjectContext = Pcontext.(string)
        }</span>
        <span class="cov0" title="0">c := getV1ClientWithResourceContext(m, ProjectContext)

        // Warning or errors can be collected in a slice type
        var diags diag.Diagnostics
        profiles, err := c.GetClusterProfiles()
        if err != nil </span><span class="cov0" title="0">{
                return handleReadError(d, err, diags)
        }</span>

        <span class="cov0" title="0">version := "1.0.0" //default
        if ver, ok_version := d.GetOk("version"); ok_version </span><span class="cov0" title="0">{
                version = ver.(string)
        }</span>

        <span class="cov0" title="0">profile, err := getProfile(profiles, d, version, ProjectContext, c)
        if err != nil </span><span class="cov0" title="0">{
                return handleReadError(d, err, diags)
        }</span>

        <span class="cov0" title="0">if profile == nil || profile.Metadata == nil </span><span class="cov0" title="0">{
                diags = append(diags, diag.Diagnostic{
                        Severity: diag.Error,
                        Summary:  "Unable to find cluster profile",
                        Detail:   fmt.Sprintf("Unable to find the specified cluster profile name: %s, version: %s", d.Get("name").(string), version),
                })
                return diags
        }</span>

        <span class="cov0" title="0">d.SetId(profile.Metadata.UID)
        if err := d.Set("name", profile.Metadata.Name); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">if err := d.Set("version", profile.Spec.Version); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">if err := d.Set("context", profile.Metadata.Annotations["scope"]); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">if profile.Spec.Published != nil &amp;&amp; len(profile.Spec.Published.Packs) &gt; 0 </span><span class="cov0" title="0">{
                packManifests, d2, done2 := getPacksContent(profile.Spec.Published.Packs, c, d)
                if done2 </span><span class="cov0" title="0">{
                        return d2
                }</span>

                <span class="cov0" title="0">diagPacks, diagnostics, done := GetDiagPacks(d, err)
                if done </span><span class="cov0" title="0">{
                        return diagnostics
                }</span>
                // Build registry maps to track which packs use registry_name or registry_uid
                <span class="cov0" title="0">registryNameMap := buildPackRegistryNameMap(d)
                registryUIDMap := buildPackRegistryUIDMap(d)
                packs, err := flattenPacksWithRegistryMaps(c, diagPacks, profile.Spec.Published.Packs, packManifests, registryNameMap, registryUIDMap)
                if err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
                <span class="cov0" title="0">if err := d.Set("pack", packs); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
        }

        <span class="cov0" title="0">return diags</span>
}

func GetDiagPacks(d *schema.ResourceData, err error) ([]*models.V1PackManifestEntity, diag.Diagnostics, bool) <span class="cov0" title="0">{
        diagPacks := make([]*models.V1PackManifestEntity, 0)
        for _, pack := range d.Get("pack").([]interface{}) </span><span class="cov0" title="0">{
                if p, e := toClusterProfilePackCreate(pack); e != nil </span><span class="cov0" title="0">{
                        return nil, diag.FromErr(err), true
                }</span> else<span class="cov0" title="0"> {
                        diagPacks = append(diagPacks, p)
                }</span>
        }
        <span class="cov0" title="0">return diagPacks, nil, false</span>
}

func getProfile(profiles []*models.V1ClusterProfileMetadata, d *schema.ResourceData, version, ProfileContext string, c *client.V1Client) (*models.V1ClusterProfile, error) <span class="cov0" title="0">{
        for _, p := range profiles </span><span class="cov0" title="0">{
                if v, ok := d.GetOk("id"); ok &amp;&amp; v.(string) == p.Metadata.UID </span><span class="cov0" title="0">{
                        fullProfile, err := c.GetClusterProfile(p.Metadata.UID)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">return fullProfile, nil</span>
                } else<span class="cov0" title="0"> if v, ok := d.GetOk("name"); ok &amp;&amp; v.(string) == p.Metadata.Name </span><span class="cov0" title="0">{
                        if p.Spec.Version == version || (p.Spec.Version == "" &amp;&amp; version == "1.0.0") </span><span class="cov0" title="0">{
                                fullProfile, err := c.GetClusterProfile(p.Metadata.UID)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                                <span class="cov0" title="0">if ProfileContext == fullProfile.Metadata.Annotations["scope"] </span><span class="cov0" title="0">{
                                        return fullProfile, nil
                                }</span>
                        }
                }
        }
        <span class="cov0" title="0">return nil, fmt.Errorf("cluster profile not found: name: %s, version: %s, context: %s", d.Get("name").(string), version, ProfileContext)</span>
}
</pre>
		
		<pre class="file" id="file52" style="display: none">package spectrocloud

import (
        "bytes"
        "fmt"
        "sort"
)

func toDatasourcesId(prefix string, labels map[string]string) string <span class="cov0" title="0">{
        var buf bytes.Buffer
        buf.WriteString(prefix)

        keys := make([]string, 0, len(labels))
        for k := range labels </span><span class="cov0" title="0">{
                keys = append(keys, k)
        }</span>
        <span class="cov0" title="0">sort.Strings(keys)

        for _, k := range keys </span><span class="cov0" title="0">{
                buf.WriteString(fmt.Sprintf("-%s-%s", k, labels[k]))
        }</span>

        <span class="cov0" title="0">id := buf.String()
        return id</span>
}
</pre>
		
		<pre class="file" id="file53" style="display: none">package spectrocloud

import (
        "context"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
)

func dataSourceFilter() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                ReadContext: dataSourceFilterRead,
                Schema: map[string]*schema.Schema{
                        "name": {
                                Type:        schema.TypeString,
                                Required:    true,
                                Description: "The name of the filter.",
                        },
                        "metadata": {
                                Type:     schema.TypeList,
                                Computed: true,
                                Elem: &amp;schema.Resource{
                                        Schema: map[string]*schema.Schema{
                                                "name": {
                                                        Type:        schema.TypeString,
                                                        Computed:    true,
                                                        Description: "The name of the filter.",
                                                },
                                                "annotations": {
                                                        Type:        schema.TypeMap,
                                                        Computed:    true,
                                                        Elem:        &amp;schema.Schema{Type: schema.TypeString},
                                                        Description: "Annotations related to the filter, represented as key-value pairs.",
                                                },
                                                "labels": {
                                                        Type:        schema.TypeMap,
                                                        Computed:    true,
                                                        Elem:        &amp;schema.Schema{Type: schema.TypeString},
                                                        Description: "Labels associated with the filter, represented as key-value pairs.",
                                                },
                                        },
                                },
                        },
                        "spec": {
                                Type:     schema.TypeList,
                                Computed: true,
                                Elem: &amp;schema.Resource{
                                        Schema: map[string]*schema.Schema{
                                                "filter_group": {
                                                        Type:     schema.TypeList,
                                                        Computed: true,
                                                        Elem: &amp;schema.Resource{
                                                                Schema: map[string]*schema.Schema{
                                                                        "conjunction": {
                                                                                Type:        schema.TypeString,
                                                                                Computed:    true,
                                                                                Description: "The conjunction used to combine filter groups. Common values: `AND`, `OR`.",
                                                                        },
                                                                        "filters": {
                                                                                Type:     schema.TypeList,
                                                                                Computed: true,
                                                                                Elem: &amp;schema.Resource{
                                                                                        Schema: map[string]*schema.Schema{
                                                                                                "key": {
                                                                                                        Type:        schema.TypeString,
                                                                                                        Computed:    true,
                                                                                                        Description: "The key for the filter condition.",
                                                                                                },
                                                                                                "negation": {
                                                                                                        Type:        schema.TypeBool,
                                                                                                        Computed:    true,
                                                                                                        Description: "A flag indicating whether the filter is negated.",
                                                                                                },
                                                                                                "operator": {
                                                                                                        Type:        schema.TypeString,
                                                                                                        Computed:    true,
                                                                                                        Description: "The operator used in the filter condition. Examples: `=`, `!=`.",
                                                                                                },
                                                                                                "values": {
                                                                                                        Type:        schema.TypeList,
                                                                                                        Computed:    true,
                                                                                                        Elem:        &amp;schema.Schema{Type: schema.TypeString},
                                                                                                        Description: "A list of values to compare against in the filter condition.",
                                                                                                },
                                                                                        },
                                                                                },
                                                                        },
                                                                },
                                                        },
                                                },
                                        },
                                },
                        },
                },
        }
}</span>

func dataSourceFilterRead(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        c := getV1ClientWithResourceContext(m, "")
        var diags diag.Diagnostics

        name := d.Get("name").(string)
        filter, err := c.GetTagFilterByName(name)
        if err != nil </span><span class="cov0" title="0">{
                return handleReadError(d, err, diags)
        }</span>

        <span class="cov0" title="0">FilterSummary, err := c.GetTagFilter(filter.Metadata.UID)
        if err != nil </span><span class="cov0" title="0">{
                return handleReadError(d, err, diags)
        }</span>

        <span class="cov0" title="0">d.SetId(FilterSummary.Metadata.UID)
        err = d.Set("metadata", []interface{}{map[string]interface{}{
                "name":        FilterSummary.Metadata.Name,
                "annotations": FilterSummary.Metadata.Annotations,
                "labels":      FilterSummary.Metadata.Labels,
        }})
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">err = d.Set("spec", []interface{}{map[string]interface{}{
                "filter_group": flattenFilterGroup(FilterSummary.Spec.FilterGroup),
        }})
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">return diags</span>
}
</pre>
		
		<pre class="file" id="file54" style="display: none">package spectrocloud

import (
        "context"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
)

func dataSourceRegistryHelm() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                ReadContext: dataSourceRegistryHelmRead,

                Schema: map[string]*schema.Schema{
                        "id": {
                                Type:     schema.TypeString,
                                Computed: true,
                                Optional: true,
                        },
                        "name": {
                                Type:     schema.TypeString,
                                Required: true,
                                ForceNew: true,
                        },
                },
        }
}</span>

func dataSourceRegistryHelmRead(_ context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        c := getV1ClientWithResourceContext(m, "")
        var diags diag.Diagnostics
        if v, ok := d.GetOk("name"); ok </span><span class="cov0" title="0">{
                registry, err := c.GetHelmRegistryByName(v.(string))
                if err != nil </span><span class="cov0" title="0">{
                        return handleReadError(d, err, diags)
                }</span>
                <span class="cov0" title="0">d.SetId(registry.Metadata.UID)
                if err := d.Set("name", registry.Metadata.Name); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
        }
        <span class="cov0" title="0">return diags</span>
}
</pre>
		
		<pre class="file" id="file55" style="display: none">package spectrocloud

import (
        "context"
        "fmt"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
        "github.com/spectrocloud/palette-sdk-go/api/models"
)

func dataSourceMacros() *schema.Resource <span class="cov10" title="2">{
        return &amp;schema.Resource{
                ReadContext: dataSourceMacrosRead,
                Description: "Use this data source to get the ID of a macros resource for use with terraform import.",

                Schema: map[string]*schema.Schema{
                        "context": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "tenant",
                                Description:  "The context to retrieve macros from. Valid values are `project` or `tenant`. Defaults to `tenant`.",
                                ValidateFunc: validation.StringInSlice([]string{"project", "tenant"}, false),
                        },
                        "macros_map": {
                                Type:     schema.TypeMap,
                                Computed: true,
                                Elem: &amp;schema.Schema{
                                        Type: schema.TypeString,
                                },
                                Description: "Map of macros where the key is the macro name and the value is the macro value. ",
                        },
                        "macro_name": {
                                Type:        schema.TypeString,
                                Optional:    true,
                                Description: "The name of the macros resource. If specified, the data source will return the macros with this name.",
                        },
                        "macro_value": {
                                Type:        schema.TypeString,
                                Computed:    true,
                                Description: "The value of the macros resource. This will be set if `macro_name` is specified.",
                        },
                        "id": {
                                Type:        schema.TypeString,
                                Computed:    true,
                                Description: "unique identifier for the macros resource, which is the UID of the project or tenant.",
                        },
                },
        }
}</span>

func dataSourceMacrosRead(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov1" title="1">{
        macroContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, "")
        var diags diag.Diagnostics
        var err error

        var uid string
        var macros []*models.V1Macro

        if macroContext == "project" </span><span class="cov1" title="1">{
                uid = ProviderInitProjectUid
                macros, err = c.GetMacros(uid)
                if err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
        } else<span class="cov0" title="0"> {
                uid, _ = c.GetTenantUID()
                macros, err = c.GetMacros("")
                if err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
        }

        <span class="cov1" title="1">if len(macros) == 0 </span><span class="cov0" title="0">{
                return diag.FromErr(fmt.Errorf("no macros found for context '%s'", macroContext))
        }</span>

        // Convert macros to map
        <span class="cov1" title="1">macroName := d.Get("macro_name").(string)
        macroMap := make(map[string]interface{})
        for _, macro := range macros </span><span class="cov10" title="2">{
                macroMap[macro.Name] = macro.Value
                if macroName != "" &amp;&amp; macro.Name == macroName </span><span class="cov0" title="0">{
                        err := d.Set("macro_value", macro.Value)
                        if err != nil </span><span class="cov0" title="0">{
                                return diag.FromErr(err)
                        }</span>
                }
        }
        <span class="cov1" title="1">if macroName != "" &amp;&amp; macroMap[macroName] == nil </span><span class="cov0" title="0">{
                return diag.FromErr(fmt.Errorf("macro with name '%s' not found", macroName))
        }</span>

        <span class="cov1" title="1">if err := d.Set("macros_map", macroMap); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        // Use the UID as the ID
        <span class="cov1" title="1">uid, _ = c.GetMacrosID(uid)
        d.SetId(uid)

        return diags</span>
}
</pre>
		
		<pre class="file" id="file56" style="display: none">package spectrocloud

import (
        "context"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
)

func dataSourceRegistryOci() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                ReadContext: dataSourceRegistryOciRead,

                Schema: map[string]*schema.Schema{
                        "id": {
                                Type:        schema.TypeString,
                                Computed:    true,
                                Optional:    true,
                                Description: "The unique identifier of the OCI registry.",
                        },
                        "name": {
                                Type:        schema.TypeString,
                                Required:    true,
                                ForceNew:    true,
                                Description: "The name of the OCI registry.",
                        },
                },
        }
}</span>

func dataSourceRegistryOciRead(_ context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        c := getV1ClientWithResourceContext(m, "")
        var diags diag.Diagnostics
        if v, ok := d.GetOk("name"); ok </span><span class="cov0" title="0">{
                registry, err := c.GetOciRegistryByName(v.(string))
                if err != nil </span><span class="cov0" title="0">{
                        return handleReadError(d, err, diags)
                }</span>
                <span class="cov0" title="0">d.SetId(registry.Metadata.UID)
                err = d.Set("name", registry.Metadata.Name)
                if err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
        }
        <span class="cov0" title="0">return diags</span>
}
</pre>
		
		<pre class="file" id="file57" style="display: none">package spectrocloud

import (
        "context"
        "fmt"
        "sort"
        "strings"

        "github.com/Masterminds/semver/v3"
        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
        "github.com/spectrocloud/palette-sdk-go/api/models"
        "github.com/spectrocloud/palette-sdk-go/client"
        "github.com/spectrocloud/terraform-provider-spectrocloud/types"
)

var AllowedPackLayers = []string{
        string(models.V1PackLayerKernel),
        string(models.V1PackLayerOs),
        string(models.V1PackLayerK8s),
        string(models.V1PackLayerCni),
        string(models.V1PackLayerCsi),
        string(models.V1PackLayerAddon),
}

var AllowedAddonType = []string{"load balancer", "ingress", "logging", "monitoring", "security", "authentication",
        "servicemesh", "system app", "app services", "registry", "csi", "cni", "integration", ""}

var AllowedEnvs = []string{
        "all", "aws", "eks", "gcp", "gke", "vsphere",
        "maas", "openstack", "edge-native", "aks", "azure",
}

var AllowedPackType = []string{string(models.V1PackTypeSpectro), string(models.V1PackTypeHelm), string(models.V1PackTypeManifest), string(models.V1PackTypeOci)}

func dataSourcePack() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                ReadContext: dataSourcePackRead,
                Description: "This data resource provides the ability to search for a pack in the Palette registries. It supports more advanced search criteria than the `pack_simple` data source.",

                Schema: map[string]*schema.Schema{
                        "filters": {
                                Type:          schema.TypeString,
                                Optional:      true,
                                Description:   "Filters to apply when searching for a pack. This is a string of the form 'key1=value1' with 'AND', 'OR` operators. Refer to the Palette API [pack search API endpoint documentation](https://docs.spectrocloud.com/api/v1/v-1-packs-search/) for filter examples. The filter attribute will be deprecated soon; use `advance_filter` instead.",
                                ConflictsWith: []string{"id", "cloud", "name", "version", "registry_uid"},
                        },
                        "advance_filters": {
                                Type:          schema.TypeList,
                                Optional:      true,
                                MaxItems:      1,
                                Description:   "A set of advanced filters to refine the selection of packs. These filters allow users to specify criteria such as pack type, add-on type, pack layer, and environment.",
                                ConflictsWith: []string{"id", "cloud", "filters"},
                                Elem: &amp;schema.Resource{
                                        Schema: map[string]*schema.Schema{
                                                "pack_type": {
                                                        Type:        schema.TypeSet,
                                                        Optional:    true,
                                                        Description: "Specify the type of pack. Allowed values are `helm`, `spectro`, `oci`, and `manifest`. If not specified, all options will be set by default.",
                                                        Elem: &amp;schema.Schema{
                                                                Type:         schema.TypeString,
                                                                ValidateFunc: validation.StringInSlice(AllowedPackType, false),
                                                        },
                                                },
                                                "addon_type": {
                                                        Type:        schema.TypeSet,
                                                        Optional:    true,
                                                        Description: "Defines the type of add-on pack. Allowed values are `load balancer`, `ingress`, `logging`, `monitoring`, `security`, `authentication`, `servicemesh`, `system app`, `app services`, `registry` and `integration`. If not specified, all options will be set by default. For `storage` and `network` addon_type set `csi` or `cni` respectively in pack_layer",
                                                        Elem: &amp;schema.Schema{
                                                                Type:         schema.TypeString,
                                                                ValidateFunc: validation.StringInSlice(AllowedAddonType, false),
                                                        },
                                                },
                                                "pack_layer": {
                                                        Type:        schema.TypeSet,
                                                        Optional:    true,
                                                        Description: "Indicates the pack layer, such as `kernel`, `os`, `k8s`, `cni`, `csi`, or `addon`. If not specified, all options will be set by default.",
                                                        Elem: &amp;schema.Schema{
                                                                Type:         schema.TypeString,
                                                                ValidateFunc: validation.StringInSlice(AllowedPackLayers, false),
                                                        },
                                                },
                                                "environment": {
                                                        Type:        schema.TypeSet,
                                                        Optional:    true,
                                                        Description: "Defines the environment where the pack will be deployed. Options include `all`, `aws`, `eks`, `azure`, `aks`, `gcp`, `gke`, `vsphere`, `maas`, `openstack` and `edge-native`. If not specified, all options will be set by default.",
                                                        Elem: &amp;schema.Schema{
                                                                Type:         schema.TypeString,
                                                                ValidateFunc: validation.StringInSlice(AllowedEnvs, false),
                                                        },
                                                },
                                                "is_fips": {
                                                        Type:        schema.TypeBool,
                                                        Optional:    true,
                                                        Default:     false,
                                                        Description: "Indicates whether the pack is FIPS-compliant. If `true`, only FIPS-compliant components will be used.",
                                                },
                                                "pack_source": {
                                                        Type:        schema.TypeSet,
                                                        Optional:    true,
                                                        Description: "Specify the source of the pack. Allowed values are `spectrocloud` and `community`. If not specified, all options will be set by default.",
                                                        Elem: &amp;schema.Schema{
                                                                Type:         schema.TypeString,
                                                                ValidateFunc: validation.StringInSlice([]string{"spectrocloud", "community"}, false),
                                                        },
                                                },
                                        },
                                },
                        },
                        "id": {
                                Type:          schema.TypeString,
                                Computed:      true,
                                Optional:      true,
                                Description:   "The UID of the pack returned.",
                                ConflictsWith: []string{"filters", "cloud", "name", "version", "registry_uid"},
                        },
                        "name": {
                                Type:        schema.TypeString,
                                Description: "The name of the pack to search for.",
                                Computed:    true,
                                Optional:    true,
                        },
                        "cloud": {
                                Type:        schema.TypeSet,
                                Optional:    true,
                                Computed:    true,
                                Description: "Filter results by cloud type. If not provided, all cloud types are returned.",
                                Set:         schema.HashString,
                                Elem: &amp;schema.Schema{
                                        Type: schema.TypeString,
                                },
                        },
                        "version": {
                                Type:        schema.TypeString,
                                Description: "Specify the version of the pack to search for. If not set, the latest available version from the specified registry will be used.",
                                Computed:    true,
                                Optional:    true,
                        },
                        "registry_uid": {
                                Type:        schema.TypeString,
                                Description: "The unique identifier (UID) of the registry where the pack is located. Specify `registry_uid` to search within a specific registry.",
                                Computed:    true,
                                Optional:    true,
                        },
                        "type": {
                                Type:        schema.TypeString,
                                Description: "The type of pack to search for. Supported values are `helm`, `manifest`, `container`, `operator-instance`.",
                                Computed:    true,
                                Optional:    true,
                        },
                        "values": {
                                Type:        schema.TypeString,
                                Description: "The YAML values of the pack returned as string.",
                                Computed:    true,
                        },
                },
        }
}</span>

func dataSourcePackRead(_ context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        c := getV1ClientWithResourceContext(m, "")
        var packName = ""
        var err error
        var advancePacksResult []*models.V1PackMetadata
        var packs []*models.V1PackSummary
        // Warning or errors can be collected in a slice type
        var diags diag.Diagnostics
        var advanceFilterSpec *models.V1PackFilterSpec
        if v, ok := d.GetOk("type"); ok </span><span class="cov0" title="0">{
                if v.(string) == "manifest" </span><span class="cov0" title="0">{
                        return diags
                }</span>
                <span class="cov0" title="0">if v.(string) == "helm" </span><span class="cov0" title="0">{
                        if regUID, ok := d.GetOk("registry_uid"); ok </span><span class="cov0" title="0">{
                                registry, err := c.GetHelmRegistry(regUID.(string))
                                if err != nil </span><span class="cov0" title="0">{
                                        return handleReadError(d, err, diags)
                                }</span>
                                <span class="cov0" title="0">if registry.Spec.IsPrivate </span><span class="cov0" title="0">{
                                        return diags
                                }</span>
                        }
                }
                <span class="cov0" title="0">if v.(string) == "oci" </span><span class="cov0" title="0">{
                        if _, ok := d.GetOk("registry_uid"); ok </span><span class="cov0" title="0">{
                                // we don't have provision to get all helm chart/packs from oci basic type registry, hence skipping validation
                                // we will move registry validation in profile creation (TBU)
                                return diags
                        }</span>
                }
        }

        <span class="cov0" title="0">filters := make([]string, 0)
        registryUID := ""
        if v, ok := d.GetOk("filters"); ok </span><span class="cov0" title="0">{
                filters = append(filters, v.(string))
        }</span> else<span class="cov0" title="0"> if v, ok := d.GetOk("id"); ok </span><span class="cov0" title="0">{
                filters = append(filters, fmt.Sprintf("metadata.uid=%s", v.(string)))
        }</span> else<span class="cov0" title="0"> if v, ok := d.GetOk("advance_filters"); ok </span><span class="cov0" title="0">{
                if v, ok := d.GetOk("name"); ok </span><span class="cov0" title="0">{
                        packName = v.(string)
                }</span>
                <span class="cov0" title="0">if v, ok := d.GetOk("registry_uid"); ok </span><span class="cov0" title="0">{
                        registryUID = v.(string)
                }</span>
                <span class="cov0" title="0">advanceFilter := v.([]interface{})[0].(map[string]interface{})
                var registryList []string
                if registryUID != "" </span><span class="cov0" title="0">{
                        registryList = []string{registryUID}
                }</span>
                <span class="cov0" title="0">packTypeValues := convertToV1PackType(advanceFilter["pack_type"].(*schema.Set)) // returns []models.V1PackType
                var packTypePtr []*models.V1PackType
                for i := range packTypeValues </span><span class="cov0" title="0">{
                        packTypePtr = append(packTypePtr, &amp;packTypeValues[i])
                }</span>
                <span class="cov0" title="0">advanceFilterSpec = &amp;models.V1PackFilterSpec{
                        Name: &amp;models.V1FilterString{
                                Eq: StringPtr(packName),
                        },
                        Type:        packTypePtr,
                        Layer:       convertToV1PackLayer(advanceFilter["pack_layer"].(*schema.Set)),
                        Environment: convertToStringSlice(advanceFilter["environment"].(*schema.Set).List()),
                        AddOnType:   convertToAddOnType(advanceFilter["addon_type"].(*schema.Set).List(), advanceFilter["pack_layer"].(*schema.Set)),
                        RegistryUID: registryList,
                        IsFips:      advanceFilter["is_fips"].(bool),
                        Source:      convertToStringSlice(advanceFilter["pack_source"].(*schema.Set).List()),
                }</span>
        } else<span class="cov0" title="0"> {
                if v, ok := d.GetOk("name"); ok </span><span class="cov0" title="0">{
                        /*
                                Cluster profile now supports packs duplication, but pack name has to be unique and will be double dashed
                                and first part would be any random name to make overall pack name unique and 2nd part is actual pack name.
                                Thus, splitting pack name with '--' to get the correct pack name to find pack uuid
                        */

                        if strings.Contains(v.(string), "--") </span><span class="cov0" title="0">{
                                v = strings.Split(v.(string), "--")[1]
                        }</span>
                        <span class="cov0" title="0">packName = v.(string)
                        filters = append(filters, fmt.Sprintf("spec.name=%s", v.(string)))</span>
                }
                <span class="cov0" title="0">if v, ok := d.GetOk("registry_uid"); ok </span><span class="cov0" title="0">{
                        registryUID = v.(string)
                }</span>
                <span class="cov0" title="0">if v, ok := d.GetOk("version"); ok </span><span class="cov0" title="0">{
                        filters = append(filters, fmt.Sprintf("spec.version=%s", v.(string)))
                }</span> else<span class="cov0" title="0"> {
                        latestVersion := setLatestPackVersionToFilters(packName, registryUID, c)
                        if latestVersion != "" </span><span class="cov0" title="0">{
                                filters = append(filters, fmt.Sprintf("spec.version=%s", latestVersion))
                        }</span>
                }
                <span class="cov0" title="0">if v, ok := d.GetOk("cloud"); ok </span><span class="cov0" title="0">{
                        clouds := expandStringList(v.(*schema.Set).List())
                        if !stringContains(clouds, "all") </span><span class="cov0" title="0">{
                                clouds = append(clouds, "all")
                        }</span>
                        <span class="cov0" title="0">filters = append(filters, fmt.Sprintf("spec.cloudTypes_in_%s", strings.Join(clouds, ",")))</span>
                }
        }

        <span class="cov0" title="0">if _, ok := d.GetOk("advance_filters"); ok </span><span class="cov0" title="0">{
                advancePacksResult, err = c.SearchPacks(advanceFilterSpec, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>

                <span class="cov0" title="0">resultCount := len(advancePacksResult)
                if resultCount == 0 </span><span class="cov0" title="0">{
                        return diag.Diagnostics{{
                                Severity: diag.Error,
                                Summary:  "no matching packs for advance_filters",
                                Detail:   "No packs matching criteria found",
                        }}
                }</span>

                <span class="cov0" title="0">if resultCount &gt; 1 </span><span class="cov0" title="0">{
                        return diag.Diagnostics{{
                                Severity: diag.Error,
                                Summary:  "multiple packs returned for specified advance_filter",
                                Detail:   fmt.Sprintf("Found %d matching packs. Restrict packs criteria to a single match.", resultCount),
                        }}
                }</span>

                <span class="cov0" title="0">registries := advancePacksResult[0].Spec.Registries
                registryCount := len(registries)

                if registryCount == 0 </span><span class="cov0" title="0">{
                        return diag.Diagnostics{{
                                Severity: diag.Error,
                                Summary:  "no matching packs for advance_filters",
                                Detail:   "No packs matching criteria found",
                        }}
                }</span>

                <span class="cov0" title="0">if registryCount &gt; 1 </span><span class="cov0" title="0">{
                        return diag.Diagnostics{{
                                Severity: diag.Error,
                                Summary:  "packs available in multiple registries for given advance_filter",
                                Detail:   fmt.Sprintf("Packs found in %d registries. Restrict packs criteria to a single match.", registryCount),
                        }}
                }</span>

                // Exactly one registry
                //if ver, ok := d.GetOk("version"); ok {
                <span class="cov0" title="0">supportedVersionList, err := c.GetPacksByNameAndRegistry(packName, registryUID)
                if err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
                <span class="cov0" title="0">if ver, ok := d.GetOk("version"); ok </span><span class="cov0" title="0">{
                        for _, v := range supportedVersionList.Tags </span><span class="cov0" title="0">{
                                if ver == v.Version </span><span class="cov0" title="0">{
                                        filters = []string{fmt.Sprintf("metadata.uid=%s", v.PackUID)}
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if len(filters) == 0 </span><span class="cov0" title="0">{
                                return diag.Diagnostics{{
                                        Severity: diag.Error,
                                        Summary:  "no matching packs for advance_filters",
                                        Detail:   "No packs matching criteria found",
                                }}
                        }</span>
                } else<span class="cov0" title="0"> {
                        if supportedVersionList != nil </span><span class="cov0" title="0">{
                                latest, _ := GetLatestPackTag(supportedVersionList.Tags)
                                if latest != nil </span><span class="cov0" title="0">{
                                        filters = []string{fmt.Sprintf("metadata.uid=%s", latest.PackUID)}
                                }</span> else<span class="cov0" title="0"> {
                                        filters = []string{fmt.Sprintf("metadata.uid=%s", supportedVersionList.Tags[len(supportedVersionList.Tags)-1].PackUID)}
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">packs, err = c.GetPacks(filters, registryUID)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">packName = "unknown"
        if v, ok := d.GetOk("name"); ok </span><span class="cov0" title="0">{
                packName = v.(string)
        }</span>

        <span class="cov0" title="0">if len(packs) == 0 </span><span class="cov0" title="0">{
                diags = append(diags, diag.Diagnostic{
                        Severity: diag.Error,
                        Summary:  fmt.Sprintf("%s: no matching packs", packName),
                        Detail:   "No packs matching criteria found",
                })
                return diags
        }</span> else<span class="cov0" title="0"> if len(packs) &gt; 1 </span><span class="cov0" title="0">{
                packs_map := make(map[string]string, 0)
                for _, pack := range packs </span><span class="cov0" title="0">{
                        packs_map[pack.Spec.RegistryUID] = pack.Spec.Name
                }</span>
                <span class="cov0" title="0">diags = append(diags, diag.Diagnostic{
                        Severity: diag.Error,
                        Summary:  fmt.Sprintf("%s: Multiple packs returned", packName),
                        Detail:   fmt.Sprintf("Found %d matching packs. Restrict packs criteria to a single match. %s", len(packs), packs_map),
                })
                return diags</span>
        }

        <span class="cov0" title="0">pack := packs[0]

        clouds := make([]string, 0)
        for _, cloudType := range pack.Spec.CloudTypes </span><span class="cov0" title="0">{
                clouds = append(clouds, string(cloudType))
        }</span>

        <span class="cov0" title="0">d.SetId(pack.Metadata.UID)
        err = d.Set("name", pack.Spec.Name)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">err = d.Set("cloud", clouds)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">err = d.Set("version", pack.Spec.Version)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">err = d.Set("registry_uid", pack.Spec.RegistryUID)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">err = d.Set("values", pack.Spec.Values)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">return diags</span>
}

func setLatestPackVersionToFilters(packName string, registryUID string, c *client.V1Client) string <span class="cov0" title="0">{
        var packLayers = []models.V1PackLayer{models.V1PackLayerKernel, models.V1PackLayerOs, models.V1PackLayerK8s, models.V1PackLayerCni, models.V1PackLayerCsi, models.V1PackLayerAddon}

        var packTypes = []*models.V1PackType{
                types.Ptr(models.V1PackTypeSpectro),
                types.Ptr(models.V1PackTypeHelm),
                types.Ptr(models.V1PackTypeManifest),
                types.Ptr(models.V1PackTypeOci),
        }

        newFilter := &amp;models.V1PackFilterSpec{
                Name: &amp;models.V1FilterString{
                        Eq: StringPtr(packName),
                },
                Type:        packTypes,
                Layer:       packLayers,
                Environment: []string{"all"},
                AddOnType:   AllowedAddonType,
        }
        if registryUID != "" </span><span class="cov0" title="0">{
                newFilter.RegistryUID = []string{registryUID}
        }</span>
        <span class="cov0" title="0">var newSort []*models.V1PackSortSpec
        latestVersion := ""
        packsResults, _ := c.SearchPacks(newFilter, newSort)
        if len(packsResults) == 1 </span><span class="cov0" title="0">{
                latestVersion, _ = getLatestVersion(packsResults[0].Spec.Registries)
                return latestVersion
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// getLatestVersion returns the latest version from a list of version strings.
func getLatestVersion(versions []*models.V1RegistryPackMetadata) (string, error) <span class="cov0" title="0">{
        if len(versions) == 0 </span><span class="cov0" title="0">{
                return "", fmt.Errorf("no versions provided")
        }</span>
        <span class="cov0" title="0">semverVersions := make([]*semver.Version, len(versions))
        for i, v := range versions </span><span class="cov0" title="0">{
                ver, err := semver.NewVersion(v.LatestVersion)
                if err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("invalid version %q: %w", v, err)
                }</span>
                <span class="cov0" title="0">semverVersions[i] = ver</span>
        }
        <span class="cov0" title="0">sort.Sort(semver.Collection(semverVersions))

        return semverVersions[len(semverVersions)-1].Original(), nil</span>
}

func convertToV1PackType(set *schema.Set) []models.V1PackType <span class="cov0" title="0">{
        var result []models.V1PackType
        for _, v := range set.List() </span><span class="cov0" title="0">{
                if str, ok := v.(string); ok </span><span class="cov0" title="0">{
                        result = append(result, models.V1PackType(str))
                }</span>
        }
        <span class="cov0" title="0">return result</span>
}

func convertToV1PackLayer(set *schema.Set) []models.V1PackLayer <span class="cov0" title="0">{
        var result []models.V1PackLayer
        for _, v := range set.List() </span><span class="cov0" title="0">{
                if str, ok := v.(string); ok </span><span class="cov0" title="0">{
                        result = append(result, models.V1PackLayer(str))
                }</span>
        }
        <span class="cov0" title="0">return result</span>
}

func convertToAddOnType(input []interface{}, packLayer *schema.Set) []string <span class="cov0" title="0">{
        result := make([]string, len(input))
        for i, v := range input </span><span class="cov0" title="0">{
                if str, ok := v.(string); ok </span><span class="cov0" title="0">{
                        result[i] = str
                }</span>
        }
        <span class="cov0" title="0">if len(result) == 0 </span><span class="cov0" title="0">{
                pl := convertToV1PackLayer(packLayer)
                for _, v := range pl </span><span class="cov0" title="0">{
                        if v == "addon" </span><span class="cov0" title="0">{
                                result = AllowedAddonType
                        }</span>
                }
        }
        <span class="cov0" title="0">return result</span>
}

func convertToStringSlice(input []interface{}) []string <span class="cov0" title="0">{
        result := make([]string, len(input))
        for i, v := range input </span><span class="cov0" title="0">{
                if str, ok := v.(string); ok </span><span class="cov0" title="0">{
                        result[i] = str
                }</span>
        }
        <span class="cov0" title="0">return result</span>
}

func GetLatestPackTag(tags []*models.V1PackTags) (*models.V1PackTags, error) <span class="cov0" title="0">{
        var latest *models.V1PackTags
        var latestVersion *semver.Version

        for _, tag := range tags </span><span class="cov0" title="0">{
                if tag == nil || tag.Version == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">v, err := semver.NewVersion(tag.Version)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid version: %s (%v)", tag.Version, err)
                }</span>

                <span class="cov0" title="0">if latestVersion == nil || v.GreaterThan(latestVersion) </span><span class="cov0" title="0">{
                        latest = tag
                        latestVersion = v
                }</span>
        }

        <span class="cov0" title="0">if latest == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no valid versions found")
        }</span>

        <span class="cov0" title="0">return latest, nil</span>
}
</pre>
		
		<pre class="file" id="file58" style="display: none">package spectrocloud

import (
        "context"
        "fmt"
        "strings"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
)

func dataSourcePackSimple() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                ReadContext: dataSourcePackReadSimple,
                Description: "This data resource provides a simpler user experience for searching for a pack in Palette registries.",

                Schema: map[string]*schema.Schema{
                        "name": {
                                Type:        schema.TypeString,
                                Required:    true,
                                Description: "The name of the pack.",
                        },
                        "version": {
                                Type:        schema.TypeString,
                                Optional:    true,
                                Description: "The version of the pack.",
                        },
                        "context": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "project",
                                ValidateFunc: validation.StringInSlice([]string{"system", "project", "tenant"}, false),
                                Description: "Indicates in which context registry should be searched for the pack values. " +
                                        "Allowed values are `system`, `project` or `tenant`. Defaults to `project`." + PROJECT_NAME_NUANCE,
                        },
                        "registry_uid": {
                                Type:        schema.TypeString,
                                Optional:    true,
                                Description: "The unique identifier (UID) of the registry where the pack is located. Specify `registry_uid` to search within a specific registry.",
                        },
                        "type": {
                                Type:         schema.TypeString,
                                Required:     true,
                                ValidateFunc: validation.StringInSlice([]string{"helm", "manifest", "container", "operator-instance"}, false),
                                Description:  "The type of Pack. Allowed values are `helm`, `manifest`, `container` or `operator-instance`.",
                        },
                        "values": {
                                Type:        schema.TypeString,
                                Computed:    true,
                                Description: "This is a stringified YAML object containing the pack configuration details. ",
                        },
                },
        }
}</span>

func dataSourcePackReadSimple(_ context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        resourceContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, resourceContext)

        // Warning or errors can be collected in a slice type
        var diags diag.Diagnostics

        //packContext := d.Get("context").(string)
        packName := ""
        registryUID := ""
        if v, ok := d.GetOk("type"); ok </span><span class="cov0" title="0">{
                if v.(string) == "manifest" </span><span class="cov0" title="0">{
                        return diags
                }</span> else<span class="cov0" title="0"> {
                        if regUID, ok := d.GetOk("registry_uid"); ok </span><span class="cov0" title="0">{
                                registryUID = regUID.(string)
                                registry, err := c.GetHelmRegistry(regUID.(string))
                                if err != nil </span><span class="cov0" title="0">{
                                        return handleReadError(d, err, diags)
                                }</span>
                                <span class="cov0" title="0">if registry.Spec.IsPrivate </span><span class="cov0" title="0">{
                                        return diags
                                }</span>
                        } else<span class="cov0" title="0"> {
                                diags = append(diags, diag.Diagnostic{
                                        Severity: diag.Error,
                                        Summary:  "No registry uid provided.",
                                        Detail:   fmt.Sprintf("Registry uid is required for pack name:%s, type:%s ", d.Get("name").(string), d.Get("type").(string)),
                                })
                                return diags
                        }</span>
                }
        }

        <span class="cov0" title="0">if v, ok := d.GetOk("name"); ok </span><span class="cov0" title="0">{
                /*
                        Cluster profile now supports packs duplication, but pack name has to be unique and will be double dashed
                        and first part would be any random name to make overall pack name unique and 2nd part is actual pack name.
                        Thus, splitting pack name with '--' to get the correct pack name to find pack uuid
                */
                if strings.Contains(v.(string), "--") </span><span class="cov0" title="0">{
                        v = strings.Split(v.(string), "--")[1]
                }</span>
                <span class="cov0" title="0">packName = v.(string)</span>
        }

        <span class="cov0" title="0">pack, err := c.GetPacksByNameAndRegistry(packName, registryUID)
        if err != nil </span><span class="cov0" title="0">{
                return handleReadError(d, err, diags)
        }</span>

        <span class="cov0" title="0">version := "1.0.0"
        if v, ok := d.GetOk("version"); ok </span><span class="cov0" title="0">{
                version = v.(string)
        }</span>
        <span class="cov0" title="0">for _, tag := range pack.Tags </span><span class="cov0" title="0">{
                if tag.Version == version </span><span class="cov0" title="0">{
                        d.SetId(tag.PackUID)
                        err = d.Set("name", pack.Name)
                        if err != nil </span><span class="cov0" title="0">{
                                return diag.FromErr(err)
                        }</span>
                        <span class="cov0" title="0">err = d.Set("version", tag.Version)
                        if err != nil </span><span class="cov0" title="0">{
                                return diag.FromErr(err)
                        }</span>
                        <span class="cov0" title="0">err = d.Set("registry_uid", pack.RegistryUID)
                        if err != nil </span><span class="cov0" title="0">{
                                return diag.FromErr(err)
                        }</span>
                        <span class="cov0" title="0">for _, value := range pack.PackValues </span><span class="cov0" title="0">{
                                if value.PackUID == tag.PackUID </span><span class="cov0" title="0">{
                                        err = d.Set("values", value.Values)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return diag.FromErr(err)
                                        }</span>
                                        <span class="cov0" title="0">return diags</span>
                                }
                        }
                        <span class="cov0" title="0">diags = append(diags, diag.Diagnostic{
                                Severity: diag.Error,
                                Summary:  "No values for pack found.",
                                Detail:   fmt.Sprintf("Values not found for pack name:%s, version:%s ", d.Get("name").(string), d.Get("version").(string)),
                        })
                        return diags</span>
                }
        }

        <span class="cov0" title="0">diags = append(diags, diag.Diagnostic{
                Severity: diag.Error,
                Summary:  "No version for pack found.",
                Detail:   fmt.Sprintf("Version not found for pack name:%s, version:%s ", d.Get("name").(string), d.Get("version").(string)),
        })
        return diags</span>
}
</pre>
		
		<pre class="file" id="file59" style="display: none">package spectrocloud

import (
        "context"
        "fmt"
        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/spectrocloud/palette-sdk-go/api/models"
)

func dataSourcePrivateCloudGatewayDNSMap() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                ReadContext: dataSourceDNSMapRead,

                Schema: map[string]*schema.Schema{
                        "search_domain_name": {
                                Type:        schema.TypeString,
                                Required:    true,
                                Description: "The domain name used for DNS search queries within the private cloud.",
                        },
                        "network": {
                                Type:        schema.TypeString,
                                Optional:    true,
                                Computed:    true,
                                Description: "The network to which the private cloud gateway is mapped.",
                        },
                        "data_center": {
                                Type:        schema.TypeString,
                                Computed:    true,
                                Description: "The data center in which the private cloud resides.",
                        },
                        "private_cloud_gateway_id": {
                                Type:        schema.TypeString,
                                Required:    true,
                                Description: "The ID of the private cloud gateway.",
                        },
                },
        }
}</span>

func dataSourceDNSMapRead(_ context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        var diags diag.Diagnostics

        c := getV1ClientWithResourceContext(m, "tenant")
        pcgUID := d.Get("private_cloud_gateway_id").(string)
        name := d.Get("search_domain_name").(string)
        network := d.Get("network").(string)

        DNSMappings, err := c.GetVsphereDNSMappingsByPCGId(pcgUID)
        if err != nil </span><span class="cov0" title="0">{
                return handleReadError(d, err, diags)
        }</span>
        <span class="cov0" title="0">if len(DNSMappings.Items) == 0 </span><span class="cov0" title="0">{
                err := fmt.Errorf("ResourceNotFound: No DNS Mapping identified in private_cloud_gateway_id - `%s`", name)
                return handleReadError(d, err, diags)
        }</span>
        <span class="cov0" title="0">matchDNSMap := &amp;models.V1VsphereDNSMappings{}
        for _, dnsMap := range DNSMappings.Items </span><span class="cov0" title="0">{
                if name == *dnsMap.Spec.DNSName </span><span class="cov0" title="0">{
                        if network != "" </span><span class="cov0" title="0">{
                                if network == *dnsMap.Spec.Network </span><span class="cov0" title="0">{
                                        matchDNSMap.Items = append(matchDNSMap.Items, dnsMap)
                                }</span>
                        } else<span class="cov0" title="0"> {
                                matchDNSMap.Items = append(matchDNSMap.Items, dnsMap)
                        }</span>
                }
        }
        <span class="cov0" title="0">if len(matchDNSMap.Items) == 0 </span><span class="cov0" title="0">{
                err := fmt.Errorf("error: No DNS Map identified for name `%s` and network `%s`. Kindly re-try with up valid `name` and `network`", name, network)
                return diag.FromErr(err)
        }</span> else<span class="cov0" title="0"> if len(matchDNSMap.Items) == 1 </span><span class="cov0" title="0">{
                err := setBackDNSMap(matchDNSMap.Items[0], d)
                if err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
        } else<span class="cov0" title="0"> if len(matchDNSMap.Items) &gt; 1 </span><span class="cov0" title="0">{
                if network == "" </span><span class="cov0" title="0">{
                        err := fmt.Errorf("error: more than 1 DNS Mapping identified for name `%s`. Kindly try setting up `network` and try again", name)
                        return diag.FromErr(err)
                }</span> else<span class="cov0" title="0"> {
                        for _, dns := range matchDNSMap.Items </span><span class="cov0" title="0">{
                                if network == *dns.Spec.Network </span><span class="cov0" title="0">{
                                        err = setBackDNSMap(dns, d)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return diag.FromErr(err)
                                        }</span>
                                }
                        }
                }
        }
        <span class="cov0" title="0">return diags</span>
}

func setBackDNSMap(dnsMap *models.V1VsphereDNSMapping, d *schema.ResourceData) error <span class="cov0" title="0">{
        d.SetId(dnsMap.Metadata.UID)
        err := d.Set("private_cloud_gateway_id", dnsMap.Spec.PrivateGatewayUID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">err = d.Set("search_domain_name", dnsMap.Spec.DNSName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">err = d.Set("network", dnsMap.Spec.Network)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">err = d.Set("data_center", dnsMap.Spec.Datacenter)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file60" style="display: none">package spectrocloud

import (
        "context"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
)

func dataSourcePrivateCloudGatewayIpPool() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                ReadContext: dataSourceIpPoolRead,

                Schema: map[string]*schema.Schema{
                        "name": {
                                Type:        schema.TypeString,
                                Required:    true,
                                Description: "The name of the IP pool.",
                        },
                        "private_cloud_gateway_id": {
                                Type:        schema.TypeString,
                                Required:    true,
                                Description: "The ID of the private cloud gateway.",
                        },
                },
        }
}</span>

func dataSourceIpPoolRead(_ context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        var diags diag.Diagnostics

        c := getV1ClientWithResourceContext(m, "")
        pcgUID := d.Get("private_cloud_gateway_id").(string)
        name := d.Get("name").(string)

        pool, err := c.GetIPPoolByName(pcgUID, name)
        if err != nil </span><span class="cov0" title="0">{
                return handleReadError(d, err, diags)
        }</span>

        <span class="cov0" title="0">d.SetId(pool.Metadata.UID)
        err = d.Set("private_cloud_gateway_id", pcgUID)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">err = d.Set("name", pool.Metadata.Name)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">return diags</span>
}
</pre>
		
		<pre class="file" id="file61" style="display: none">package spectrocloud

import (
        "context"
        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
        "github.com/spectrocloud/palette-sdk-go/client"
        "strings"
)

func dataSourcePermission() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                ReadContext: dataSourcePermissionRead,

                Schema: map[string]*schema.Schema{
                        "id": {
                                Type:     schema.TypeString,
                                Computed: true,
                        },
                        "scope": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "project",
                                ValidateFunc: validation.StringInSlice([]string{"project", "tenant", "resource"}, false),
                                Description: "Permission scope. Allowed permission levels are `project` or `tenant` or `resource` . " +
                                        "Defaults to `project`.",
                        },
                        "name": {
                                Type:        schema.TypeString,
                                Required:    true,
                                Description: "Name of the permissions. eg: `App Deployment`.",
                        },
                        "permissions": {
                                Type:     schema.TypeSet,
                                Computed: true,
                                Set:      schema.HashString,
                                Elem: &amp;schema.Schema{
                                        Type: schema.TypeString,
                                },
                                Description: "List of permissions associated with the permission name. ",
                        },
                },
        }
}</span>

func dataSourcePermissionRead(_ context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        c := getV1ClientWithResourceContext(m, "")
        var diags diag.Diagnostics

        scope := d.Get("scope").(string)
        if v, ok := d.GetOk("name"); ok </span><span class="cov0" title="0">{
                permission, err := c.GetPermissionByName(v.(string), client.PermissionScope(scope))
                if err != nil </span><span class="cov0" title="0">{
                        return handleReadError(d, err, diags)
                }</span>
                <span class="cov0" title="0">if permission != nil &amp;&amp; len(permission.Permissions) &gt; 0 </span><span class="cov0" title="0">{
                        d.SetId(strings.Trim(permission.Name, " "))
                        if err := d.Set("name", permission.Name); err != nil </span><span class="cov0" title="0">{
                                return diag.FromErr(err)
                        }</span>
                        <span class="cov0" title="0">if err := d.Set("permissions", permission.Permissions); err != nil </span><span class="cov0" title="0">{
                                return diag.FromErr(err)
                        }</span>
                }
        }
        <span class="cov0" title="0">return diags</span>
}
</pre>
		
		<pre class="file" id="file62" style="display: none">package spectrocloud

import (
        "context"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
)

func dataSourcePCG() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                ReadContext: dataSourcePCGRead,
                Description: "A data resource to get the ID or name of Private Cloud Gateway.",

                Schema: map[string]*schema.Schema{
                        "id": {
                                Type:          schema.TypeString,
                                Computed:      true,
                                Optional:      true,
                                ConflictsWith: []string{"name"},
                                Description:   "The ID of Private Cloud Gateway.",
                        },
                        "name": {
                                Type:        schema.TypeString,
                                Computed:    true,
                                Optional:    true,
                                Description: "The name of Private Cloud Gateway.",
                        },
                },
        }
}</span>

func dataSourcePCGRead(_ context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        c := getV1ClientWithResourceContext(m, "")
        var diags diag.Diagnostics
        if v, ok := d.GetOk("name"); ok </span><span class="cov0" title="0">{
                name := v.(string)
                namePointer := &amp;name
                uid, err := c.GetPCGId(namePointer)
                if err != nil </span><span class="cov0" title="0">{
                        return handleReadError(d, err, diags)
                }</span>
                <span class="cov0" title="0">d.SetId(uid)
                if err := d.Set("name", v.(string)); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
        }
        <span class="cov0" title="0">return diags</span>
}
</pre>
		
		<pre class="file" id="file63" style="display: none">package spectrocloud

import (
        "context"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
)

func dataSourceProject() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                ReadContext: dataSourceProjectRead,

                Schema: map[string]*schema.Schema{
                        "id": {
                                Type:          schema.TypeString,
                                Computed:      true,
                                Optional:      true,
                                ConflictsWith: []string{"name"},
                        },
                        "name": {
                                Type:     schema.TypeString,
                                Computed: true,
                                Optional: true,
                        },
                },
        }
}</span>

func dataSourceProjectRead(_ context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov8" title="1">{
        c := getV1ClientWithResourceContext(m, "")
        var diags diag.Diagnostics
        if v, ok := d.GetOk("name"); ok </span><span class="cov8" title="1">{
                uid, err := c.GetProjectUID(v.(string))
                if err != nil </span><span class="cov0" title="0">{
                        return handleReadError(d, err, diags)
                }</span>
                <span class="cov8" title="1">d.SetId(uid)
                if err := d.Set("name", v.(string)); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
        }
        <span class="cov8" title="1">return diags</span>
}
</pre>
		
		<pre class="file" id="file64" style="display: none">package spectrocloud

import (
        "context"
        "fmt"
        "github.com/go-openapi/strfmt"
        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/spectrocloud/palette-sdk-go/api/models"
        "time"
)

func dataSourceRegistrationToken() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                ReadContext: dataSourceRegistrationTokenRead,

                Schema: map[string]*schema.Schema{
                        "id": {
                                Type:          schema.TypeString,
                                Computed:      true,
                                Optional:      true,
                                Description:   "The UID of the registration token.",
                                ConflictsWith: []string{"name"},
                        },
                        "name": {
                                Type:         schema.TypeString,
                                Description:  "The name of the registration token.",
                                Optional:     true,
                                AtLeastOneOf: []string{"name", "id"},
                        },
                        "project_uid": {
                                Type:        schema.TypeString,
                                Computed:    true,
                                Description: "The unique identifier of the project associated with the registration token.",
                        },
                        "expiry_date": {
                                Type:        schema.TypeString,
                                Computed:    true,
                                Description: "The expiration date of the registration token in `YYYY-MM-DD` format.",
                        },
                        "status": {
                                Type:        schema.TypeString,
                                Computed:    true,
                                Description: "The status of the registration token. Allowed values are `active` or `inactive`. Default is `active`.",
                        },
                        "token": {
                                Type:        schema.TypeString,
                                Computed:    true,
                                Description: "The registration token",
                        },
                },
        }
}</span>

func dataSourceRegistrationTokenRead(_ context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        c := getV1ClientWithResourceContext(m, tenantString)
        var diags diag.Diagnostics
        var err error
        var tokenEntity *models.V1EdgeToken
        if name, okName := d.GetOk("name"); okName </span><span class="cov0" title="0">{
                tokenEntity, err = c.GetRegistrationTokenByName(name.(string))
                if err != nil </span><span class="cov0" title="0">{
                        return handleReadError(d, err, diags)
                }</span>
        } else<span class="cov0" title="0"> if id, okId := d.GetOk("id"); okId </span><span class="cov0" title="0">{
                tokenEntity, err = c.GetRegistrationTokenByUID(id.(string))
                if err != nil </span><span class="cov0" title="0">{
                        return handleReadError(d, err, diags)
                }</span>
        }
        <span class="cov0" title="0">if tokenEntity != nil </span><span class="cov0" title="0">{
                d.SetId(tokenEntity.Metadata.UID)
                if err := d.Set("name", tokenEntity.Metadata.Name); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>

                <span class="cov0" title="0">if tokenEntity.Spec.DefaultProject != nil </span><span class="cov0" title="0">{
                        if err := d.Set("project_uid", tokenEntity.Spec.DefaultProject.UID); err != nil </span><span class="cov0" title="0">{
                                return diag.FromErr(err)
                        }</span>
                }

                <span class="cov0" title="0">dt := strfmt.DateTime(tokenEntity.Spec.Expiry)
                expDate := time.Time(dt).Format("2006-01-02")
                if err := d.Set("expiry_date", expDate); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
                <span class="cov0" title="0">if err := d.Set("token", tokenEntity.Spec.Token); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
                <span class="cov0" title="0">if err := d.Set("status", StateConvertBool(tokenEntity.Status.IsActive)); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
        } else<span class="cov0" title="0"> {
                return diag.FromErr(fmt.Errorf("could not find registration token: %v", diags))
        }</span>

        <span class="cov0" title="0">return diags</span>
}
</pre>
		
		<pre class="file" id="file65" style="display: none">package spectrocloud

import (
        "context"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
)

func dataSourceRegistry() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                ReadContext: dataSourceRegistryRead,

                Schema: map[string]*schema.Schema{
                        "id": {
                                Type:     schema.TypeString,
                                Computed: true,
                                Optional: true,
                        },
                        "name": {
                                Type:     schema.TypeString,
                                Required: true,
                                ForceNew: true,
                        },
                        "type": {
                                Type:         schema.TypeString,
                                Default:      "",
                                Optional:     true,
                                Description:  "The type of the registry. Possible values are 'oci', 'helm', or 'spectro'. If not provided, the registry type will be inferred from the registry name.",
                                ValidateFunc: validation.StringInSlice([]string{"", "oci", "helm", "spectro"}, false),
                        },
                        "sync_status": {
                                Type:        schema.TypeString,
                                Computed:    true,
                                Description: "The synchronization status of the registry. Possible values: 'Completed', 'InProgress', 'Failed', 'Error', etc. Available for Helm registries only.",
                        },
                },
        }
}</span>

func dataSourceRegistryRead(_ context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        c := getV1ClientWithResourceContext(m, "")
        var diags diag.Diagnostics

        name, ok := d.GetOk("name")
        if !ok </span><span class="cov0" title="0">{
                return diags
        }</span>

        <span class="cov0" title="0">registryType := d.Get("type").(string)

        var uid, registryName string
        var err error

        switch registryType </span>{
        case "oci":<span class="cov0" title="0">
                registry, e := c.GetOciRegistryByName(name.(string))
                if e != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(e)
                }</span>
                <span class="cov0" title="0">uid = registry.Metadata.UID
                registryName = registry.Metadata.Name</span>
        case "helm":<span class="cov0" title="0">
                registry, e := c.GetHelmRegistryByName(name.(string))
                if e != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(e)
                }</span>
                <span class="cov0" title="0">uid = registry.Metadata.UID
                registryName = registry.Metadata.Name

                // Fetch sync status for Helm registries
                syncStatus, syncErr := c.GetHelmRegistrySyncStatus(uid)
                if syncErr == nil &amp;&amp; syncStatus != nil </span><span class="cov0" title="0">{
                        if err = d.Set("sync_status", syncStatus.Status); err != nil </span><span class="cov0" title="0">{
                                return diag.FromErr(err)
                        }</span>
                }
        default:<span class="cov0" title="0"> // "" or "spectro"
                registry, e := c.GetPackRegistryCommonByName(name.(string))
                if e != nil </span><span class="cov0" title="0">{
                        return handleReadError(d, e, diags)
                }</span>
                <span class="cov0" title="0">uid = registry.UID
                registryName = registry.Name</span>
        }

        <span class="cov0" title="0">d.SetId(uid)
        if err = d.Set("name", registryName); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">return diags</span>
}
</pre>
		
		<pre class="file" id="file66" style="display: none">package spectrocloud

import (
        "context"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
)

func dataSourceRegistryPack() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                ReadContext: dataSourceRegistryPackRead,

                Schema: map[string]*schema.Schema{
                        "id": {
                                Type:     schema.TypeString,
                                Computed: true,
                                Optional: true,
                        },
                        "name": {
                                Type:     schema.TypeString,
                                Required: true,
                                ForceNew: true,
                        },
                },
        }
}</span>

func dataSourceRegistryPackRead(_ context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        c := getV1ClientWithResourceContext(m, "")
        var diags diag.Diagnostics
        if v, ok := d.GetOk("name"); ok </span><span class="cov0" title="0">{
                registry, err := c.GetPackRegistryCommonByName(v.(string))
                if err != nil </span><span class="cov0" title="0">{
                        return handleReadError(d, err, diags)
                }</span>
                <span class="cov0" title="0">d.SetId(registry.UID)
                if err := d.Set("name", registry.Name); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
        }
        <span class="cov0" title="0">return diags</span>
}
</pre>
		
		<pre class="file" id="file67" style="display: none">package spectrocloud

import (
        "context"
        "github.com/spectrocloud/palette-sdk-go/api/models"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
)

func dataSourceRole() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                ReadContext: dataSourceRoleRead,

                Schema: map[string]*schema.Schema{
                        "id": {
                                Type:          schema.TypeString,
                                Computed:      true,
                                Optional:      true,
                                ConflictsWith: []string{"name"},
                        },
                        "name": {
                                Type:     schema.TypeString,
                                Computed: true,
                                Optional: true,
                        },
                        "permissions": {
                                Type:     schema.TypeSet,
                                Computed: true,
                                Set:      schema.HashString,
                                Elem: &amp;schema.Schema{
                                        Type: schema.TypeString,
                                },
                                Description: "List of permissions associated with the role. ",
                        },
                },
        }
}</span>

func dataSourceRoleRead(_ context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        c := getV1ClientWithResourceContext(m, "")
        var diags diag.Diagnostics
        var role *models.V1Role
        var err error
        if i, ok := d.GetOk("id"); ok </span><span class="cov0" title="0">{
                role, err = c.GetRoleByID(i.(string))
                if err != nil </span><span class="cov0" title="0">{
                        return handleReadError(d, err, diags)
                }</span>
        }
        <span class="cov0" title="0">if v, ok := d.GetOk("name"); ok </span><span class="cov0" title="0">{
                role, err = c.GetRole(v.(string))
                if err != nil </span><span class="cov0" title="0">{
                        return handleReadError(d, err, diags)
                }</span>
        }
        <span class="cov0" title="0">if role != nil </span><span class="cov0" title="0">{
                d.SetId(role.Metadata.UID)
                if err := d.Set("name", role.Metadata.Name); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
                <span class="cov0" title="0">if err := d.Set("permissions", role.Spec.Permissions); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
        }
        <span class="cov0" title="0">return diags</span>
}
</pre>
		
		<pre class="file" id="file68" style="display: none">package spectrocloud

import (
        "context"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
        "github.com/spectrocloud/palette-sdk-go/api/models"
)

func dataSourceSSHKey() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                ReadContext: dataSourceSSHKeyRead,
                Description: "The SSH key data source allows you to retrieve information about SSH keys in Palette.",

                Schema: map[string]*schema.Schema{
                        "id": {
                                Type:          schema.TypeString,
                                Computed:      true,
                                Optional:      true,
                                ConflictsWith: []string{"name"},
                                Description:   "The Id of the SSH key resource.",
                        },
                        "name": {
                                Type:        schema.TypeString,
                                Computed:    true,
                                Optional:    true,
                                Description: "The name of the SSH key resource.",
                        },
                        "ssh_key": {
                                Type:        schema.TypeString,
                                Computed:    true,
                                Sensitive:   true,
                                Description: "The SSH key value. This is the public key that was uploaded to Palette.",
                        },
                        "context": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "project",
                                ValidateFunc: validation.StringInSlice([]string{"project", "tenant"}, false),
                                Description: "The context of the cluster profile. Allowed values are `project` or `tenant`. " +
                                        "Default value is `project`. " + PROJECT_NAME_NUANCE,
                        },
                },
        }
}</span>

func dataSourceSSHKeyRead(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        sshKeyContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, sshKeyContext)
        var diags diag.Diagnostics
        id := d.Get("id").(string)
        name := d.Get("name").(string)
        var sshKey *models.V1UserAssetSSH
        var err error
        if id != "" </span><span class="cov0" title="0">{
                sshKey, err = c.GetSSHKey(d.Id())
                if err != nil </span><span class="cov0" title="0">{
                        return handleReadError(d, err, diags)
                }</span>
        } else<span class="cov0" title="0"> if name != "" </span><span class="cov0" title="0">{
                sshKey, err = c.GetSSHKeyByName(name)
                if err != nil </span><span class="cov0" title="0">{
                        return handleReadError(d, err, diags)
                }</span>
        }
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">d.SetId(sshKey.Metadata.UID)
        err = d.Set("name", sshKey.Metadata.Name)
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">err = d.Set("ssh_key", sshKey.Spec.PublicKey)
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return diags</span>
}
</pre>
		
		<pre class="file" id="file69" style="display: none">package spectrocloud

import (
        "context"
        "github.com/spectrocloud/palette-sdk-go/api/models"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
)

func dataSourceTeam() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                ReadContext: dataSourceTeamRead,

                Schema: map[string]*schema.Schema{
                        "id": {
                                Type:          schema.TypeString,
                                Computed:      true,
                                Optional:      true,
                                ConflictsWith: []string{"name"},
                                Description:   "The unique ID of the team. If provided, `name` cannot be used.",
                        },
                        "name": {
                                Type:        schema.TypeString,
                                Optional:    true,
                                Description: "The name of the team. If provided, `id` cannot be used.",
                        },
                        "role_ids": {
                                Type:        schema.TypeList,
                                Computed:    true,
                                Elem:        &amp;schema.Schema{Type: schema.TypeString},
                                Description: "The roles id's assigned to the team.",
                        },
                },
        }
}</span>

func dataSourceTeamRead(_ context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        c := getV1ClientWithResourceContext(m, "")
        var diags diag.Diagnostics
        var team *models.V1Team
        var err error
        if v, ok := d.GetOk("name"); ok </span><span class="cov0" title="0">{
                team, err = c.GetTeamWithName(v.(string))
                if err != nil </span><span class="cov0" title="0">{
                        return handleReadError(d, err, diags)
                }</span>
        } else<span class="cov0" title="0"> {
                if val, okay := d.GetOk("id"); okay &amp;&amp; val != "" </span><span class="cov0" title="0">{
                        team, err = c.GetTeam(val.(string))
                        if err != nil </span><span class="cov0" title="0">{
                                return handleReadError(d, err, diags)
                        }</span>
                }
        }
        <span class="cov0" title="0">if team != nil </span><span class="cov0" title="0">{
                d.SetId(team.Metadata.UID)
                if err := d.Set("name", team.Metadata.Name); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
                <span class="cov0" title="0">if err := d.Set("role_ids", team.Spec.Roles); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
        }
        <span class="cov0" title="0">return diags</span>
}
</pre>
		
		<pre class="file" id="file70" style="display: none">package spectrocloud

import (
        "context"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
)

func dataSourceUser() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                ReadContext: dataSourceUserRead,

                Schema: map[string]*schema.Schema{
                        "id": {
                                Type:          schema.TypeString,
                                Computed:      true,
                                Optional:      true,
                                ConflictsWith: []string{"email"},
                                Description:   "The unique ID of the user. If provided, `email` cannot be used.",
                        },
                        "email": {
                                Type:        schema.TypeString,
                                Optional:    true,
                                Description: "The email address of the user. If provided, `id` cannot be used.",
                        },
                },
        }
}</span>

func dataSourceUserRead(_ context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        c := getV1ClientWithResourceContext(m, "")
        var diags diag.Diagnostics

        if v, ok := d.GetOk("email"); ok </span><span class="cov0" title="0">{
                user, err := c.GetUserByEmail(v.(string))
                if err != nil </span><span class="cov0" title="0">{
                        return handleReadError(d, err, diags)
                }</span>
                <span class="cov0" title="0">d.SetId(user.Metadata.UID)
                if err := d.Set("email", user.Spec.EmailID); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
        }
        <span class="cov0" title="0">return diags</span>
}
</pre>
		
		<pre class="file" id="file71" style="display: none">package spectrocloud

import (
        "context"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
)

func dataSourceWorkspace() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                ReadContext: dataSourceWorkspaceRead,

                Schema: map[string]*schema.Schema{
                        "name": {
                                Type:     schema.TypeString,
                                Required: true,
                                ForceNew: true,
                        },
                },
        }
}</span>

func dataSourceWorkspaceRead(_ context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        c := getV1ClientWithResourceContext(m, "")
        var diags diag.Diagnostics
        if name, okName := d.GetOk("name"); okName </span><span class="cov0" title="0">{
                workspace, err := c.GetWorkspaceByName(name.(string))
                if err != nil </span><span class="cov0" title="0">{
                        return handleReadError(d, err, diags)
                }</span>
                <span class="cov0" title="0">if workspace != nil </span><span class="cov0" title="0">{
                        d.SetId(workspace.Metadata.UID)
                        if err := d.Set("name", workspace.Metadata.Name); err != nil </span><span class="cov0" title="0">{
                                return diag.FromErr(err)
                        }</span>
                }
        }
        <span class="cov0" title="0">return diags</span>
}
</pre>
		
		<pre class="file" id="file72" style="display: none">package spectrocloud

import (
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/spectrocloud/palette-sdk-go/api/models"
)

func expandMetadata(list []interface{}) *models.V1ObjectMetaInputEntity <span class="cov0" title="0">{
        if len(list) == 0 || list[0] == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">m := list[0].(map[string]interface{})

        return &amp;models.V1ObjectMetaInputEntity{
                Name: m["name"].(string),
        }</span>
}

func expandSpec(list []interface{}) *models.V1TagFilterSpec <span class="cov0" title="0">{
        if len(list) == 0 || list[0] == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">m := list[0].(map[string]interface{})
        filterGroup := m["filter_group"].([]interface{})

        return &amp;models.V1TagFilterSpec{
                FilterGroup: expandFilterGroup(filterGroup),
        }</span>
}

func expandFilterGroup(list []interface{}) *models.V1TagFilterGroup <span class="cov0" title="0">{
        if len(list) == 0 || list[0] == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">m := list[0].(map[string]interface{})

        // Handle both TypeSet and TypeList for backward compatibility
        var filtersList []interface{}
        if filtersRaw, ok := m["filters"]; ok &amp;&amp; filtersRaw != nil </span><span class="cov0" title="0">{
                if filtersSet, ok := filtersRaw.(*schema.Set); ok </span><span class="cov0" title="0">{
                        filtersList = filtersSet.List()
                }</span> else<span class="cov0" title="0"> if filtersListRaw, ok := filtersRaw.([]interface{}); ok </span><span class="cov0" title="0">{
                        // Fallback for backward compatibility during migration
                        filtersList = filtersListRaw
                }</span>
        }

        // filters := m["filters"].([]interface{})

        <span class="cov0" title="0">conjunction := models.V1SearchFilterConjunctionOperator(m["conjunction"].(string))

        return &amp;models.V1TagFilterGroup{
                Conjunction: &amp;conjunction,
                Filters:     expandFilters(filtersList),
        }</span>
}

func expandFilters(list []interface{}) []*models.V1TagFilterItem <span class="cov0" title="0">{
        filters := make([]*models.V1TagFilterItem, len(list))

        for i, item := range list </span><span class="cov0" title="0">{
                m := item.(map[string]interface{})
                var values []string
                if m["values"] != nil </span><span class="cov0" title="0">{
                        interfaceValues := m["values"].([]interface{})
                        for _, v := range interfaceValues </span><span class="cov0" title="0">{
                                values = append(values, v.(string))
                        }</span>
                }

                <span class="cov0" title="0">filters[i] = &amp;models.V1TagFilterItem{
                        Key:      m["key"].(string),
                        Negation: m["negation"].(bool),
                        Operator: models.V1SearchFilterKeyValueOperator(m["operator"].(string)),
                        Values:   values,
                }</span>
        }

        <span class="cov0" title="0">return filters</span>
}

func flattenMetadata(metadata *models.V1ObjectMeta) []interface{} <span class="cov0" title="0">{
        if metadata == nil </span><span class="cov0" title="0">{
                return []interface{}{}
        }</span>

        <span class="cov0" title="0">m := map[string]interface{}{
                "name": metadata.Name,
        }

        return []interface{}{m}</span>
}

func flattenSpec(spec *models.V1TagFilterSpec) []interface{} <span class="cov0" title="0">{
        if spec == nil </span><span class="cov0" title="0">{
                return []interface{}{}
        }</span>

        <span class="cov0" title="0">m := map[string]interface{}{
                "filter_group": flattenFilterGroup(spec.FilterGroup),
        }

        return []interface{}{m}</span>
}

func flattenFilters(filters []*models.V1TagFilterItem) []interface{} <span class="cov0" title="0">{
        if filters == nil </span><span class="cov0" title="0">{
                return []interface{}{}
        }</span>

        <span class="cov0" title="0">fs := make([]interface{}, len(filters))

        for i, filter := range filters </span><span class="cov0" title="0">{
                m := map[string]interface{}{
                        "key":      filter.Key,
                        "negation": filter.Negation,
                        "operator": string(filter.Operator),
                        "values":   filter.Values,
                }
                fs[i] = m
        }</span>

        <span class="cov0" title="0">return fs</span>
}

func flattenFilterGroup(filterGroup *models.V1TagFilterGroup) []interface{} <span class="cov0" title="0">{
        if filterGroup == nil </span><span class="cov0" title="0">{
                return []interface{}{}
        }</span>

        // Return filters as []interface{} - Terraform will handle conversion
        // to *schema.Set automatically if the schema is TypeSet
        <span class="cov0" title="0">var filtersList []interface{}
        if filterGroup.Filters != nil &amp;&amp; len(filterGroup.Filters) &gt; 0 </span><span class="cov0" title="0">{
                filtersList = make([]interface{}, len(filterGroup.Filters))
                for i, filter := range filterGroup.Filters </span><span class="cov0" title="0">{
                        filtersList[i] = map[string]interface{}{
                                "key":      filter.Key,
                                "negation": filter.Negation,
                                "operator": string(filter.Operator),
                                "values":   filter.Values,
                        }
                }</span>
        }

        <span class="cov0" title="0">conjunction := ""
        if filterGroup.Conjunction != nil </span><span class="cov0" title="0">{
                conjunction = string(*filterGroup.Conjunction)
        }</span>

        <span class="cov0" title="0">m := map[string]interface{}{
                "conjunction": conjunction,
                "filters":     filtersList, // Return []interface{} instead of *schema.Set
        }

        return []interface{}{m}</span>
}
</pre>
		
		<pre class="file" id="file73" style="display: none">package datavolume

import (
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        cdiv1 "kubevirt.io/containerized-data-importer-api/pkg/apis/core/v1beta1"

        "github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/kubevirt/schema/k8s"
)

func DataVolumeFields() map[string]*schema.Schema <span class="cov8" title="1">{
        return map[string]*schema.Schema{
                "cluster_uid": {
                        Type:        schema.TypeString,
                        Optional:    true,
                        Description: "The cluster UID to which the virtual machine belongs to.",
                },
                "cluster_context": {
                        Type:     schema.TypeString,
                        Required: true,
                },
                "vm_name": {
                        Type:        schema.TypeString,
                        Optional:    true,
                        Description: "The name of the virtual machine to which the data volume belongs to.",
                },
                "vm_namespace": {
                        Type:        schema.TypeString,
                        Optional:    true,
                        Description: "The namespace of the virtual machine to which the data volume belongs to.",
                },
                "add_volume_options": DataVolumeOptionsSchema(),
                "metadata":           k8s.NamespacedMetadataSchema("DataVolume", false),
                "spec":               DataVolumeSpecSchema(),
                "status":             dataVolumeStatusSchema(),
        }
}</span>

func FromResourceData(resourceData *schema.ResourceData) (*cdiv1.DataVolume, error) <span class="cov0" title="0">{
        result := &amp;cdiv1.DataVolume{}

        result.ObjectMeta = k8s.ExpandMetadata(resourceData.Get("metadata").([]interface{}))
        spec, err := ExpandDataVolumeSpec(resourceData.Get("spec").([]interface{}))
        if err != nil </span><span class="cov0" title="0">{
                return result, err
        }</span>
        <span class="cov0" title="0">result.Spec = spec
        result.Status = expandDataVolumeStatus(resourceData.Get("status").([]interface{}))

        return result, nil</span>
}

func ToResourceData(dv cdiv1.DataVolume, resourceData *schema.ResourceData) error <span class="cov0" title="0">{
        if err := resourceData.Set("metadata", k8s.FlattenMetadataDataVolume(dv.ObjectMeta)); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := resourceData.Set("spec", FlattenDataVolumeSpec(dv.Spec)); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := resourceData.Set("status", flattenDataVolumeStatus(dv.Status)); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file74" style="display: none">package datavolume

import (
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
)

func DataVolumeOptionsSchema() *schema.Schema <span class="cov8" title="1">{
        return &amp;schema.Schema{
                Type:        schema.TypeList,
                Description: "DataVolumeSpec defines our specification for a DataVolume type",
                Required:    true,
                MaxItems:    1,
                Elem: &amp;schema.Resource{
                        Schema: map[string]*schema.Schema{
                                "name": {
                                        Type:     schema.TypeString,
                                        Required: true,
                                },
                                "disk": {
                                        Type:     schema.TypeList,
                                        Required: true,
                                        MaxItems: 1,
                                        Elem: &amp;schema.Resource{
                                                Schema: map[string]*schema.Schema{
                                                        "name": {
                                                                Type:     schema.TypeString,
                                                                Required: true,
                                                        },
                                                        "bus": {
                                                                Type:     schema.TypeString,
                                                                Required: true,
                                                        },
                                                },
                                        },
                                },
                                "volume_source": {
                                        Type:     schema.TypeList,
                                        Required: true,
                                        MaxItems: 1,
                                        Elem: &amp;schema.Resource{
                                                Schema: map[string]*schema.Schema{
                                                        "data_volume": {
                                                                Type:     schema.TypeList,
                                                                Required: true,
                                                                MaxItems: 1,
                                                                Elem: &amp;schema.Resource{
                                                                        Schema: map[string]*schema.Schema{
                                                                                "name": {
                                                                                        Type:     schema.TypeString,
                                                                                        Required: true,
                                                                                },
                                                                                "hotpluggable": {
                                                                                        Type:     schema.TypeBool,
                                                                                        Optional: true,
                                                                                        Default:  true,
                                                                                },
                                                                        },
                                                                },
                                                        },
                                                },
                                        },
                                },
                        },
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file75" style="display: none">package datavolume

import (
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        cdiv1 "kubevirt.io/containerized-data-importer-api/pkg/apis/core/v1beta1"

        "github.com/spectrocloud/terraform-provider-spectrocloud/types"
)

func dataVolumeSourceFields() map[string]*schema.Schema <span class="cov10" title="2">{
        return map[string]*schema.Schema{
                "blank":    dataVolumeSourceBlankSchema(),
                "http":     dataVolumeSourceHTTPSchema(),
                "pvc":      dataVolumeSourcePVCSchema(),
                "registry": dataVolumeSourceRegistrySchema(),
        }
}</span>

func dataVolumeSourceBlankSchema() *schema.Schema <span class="cov10" title="2">{
        return &amp;schema.Schema{
                Type:        schema.TypeList,
                Description: "DataVolumeSourceBlank provides the parameters to create a Data Volume from an empty source.",
                Optional:    true,
                MaxItems:    1,
                Elem: &amp;schema.Resource{
                        Schema: map[string]*schema.Schema{},
                },
        }
}</span>

func dataVolumeSourceSchema() *schema.Schema <span class="cov10" title="2">{
        fields := dataVolumeSourceFields()

        return &amp;schema.Schema{
                Type:        schema.TypeList,
                Description: "Source is the src of the data for the requested DataVolume.",
                Optional:    true,
                MaxItems:    1,
                Elem: &amp;schema.Resource{
                        Schema: fields,
                },
        }
}</span>

func dataVolumeSourceHTTPFields() map[string]*schema.Schema <span class="cov10" title="2">{
        return map[string]*schema.Schema{
                "url": {
                        Type:        schema.TypeString,
                        Description: "url is the URL of the http source.",
                        Optional:    true,
                },
                "secret_ref": {
                        Type:        schema.TypeString,
                        Description: "Secret_ref provides the secret reference needed to access the HTTP source.",
                        Optional:    true,
                },
                "cert_config_map": {
                        Type:        schema.TypeString,
                        Description: "Cert_config_map provides a reference to the Registry certs.",
                        Optional:    true,
                },
        }
}</span>

func dataVolumeSourceHTTPSchema() *schema.Schema <span class="cov10" title="2">{
        fields := dataVolumeSourceHTTPFields()

        return &amp;schema.Schema{
                Type:        schema.TypeList,
                Description: "DataVolumeSourceHTTP provides the parameters to create a Data Volume from an HTTP source.",
                Optional:    true,
                MaxItems:    1,
                Elem: &amp;schema.Resource{
                        Schema: fields,
                },
        }
}</span>

func dataVolumeSourcePVCFields() map[string]*schema.Schema <span class="cov10" title="2">{
        return map[string]*schema.Schema{
                "namespace": {
                        Type:        schema.TypeString,
                        Description: "The namespace which the PVC located in.",
                        Optional:    true,
                },
                "name": {
                        Type:        schema.TypeString,
                        Description: "The name of the PVC.",
                        Optional:    true,
                },
        }
}</span>

func dataVolumeSourceRegistryFields() map[string]*schema.Schema <span class="cov10" title="2">{
        return map[string]*schema.Schema{
                "image_url": {
                        Type:        schema.TypeString,
                        Description: "The registry URL of the image to download.",
                        Optional:    true,
                },
        }
}</span>

func dataVolumeSourcePVCSchema() *schema.Schema <span class="cov10" title="2">{
        fields := dataVolumeSourcePVCFields()

        return &amp;schema.Schema{
                Type:        schema.TypeList,
                Description: "DataVolumeSourcePVC provides the parameters to create a Data Volume from an existing PVC.",
                Optional:    true,
                MaxItems:    1,
                Elem: &amp;schema.Resource{
                        Schema: fields,
                },
        }
}</span>

func dataVolumeSourceRegistrySchema() *schema.Schema <span class="cov10" title="2">{
        fields := dataVolumeSourceRegistryFields()

        return &amp;schema.Schema{
                Type:        schema.TypeList,
                Description: "DataVolumeSourceRegistry provides the parameters to create a Data Volume from an existing PVC.",
                Optional:    true,
                MaxItems:    1,
                Elem: &amp;schema.Resource{
                        Schema: fields,
                },
        }
}</span>

// Expanders

func expandDataVolumeSource(dataVolumeSource []interface{}) *cdiv1.DataVolumeSource <span class="cov0" title="0">{
        result := &amp;cdiv1.DataVolumeSource{}

        if len(dataVolumeSource) == 0 || dataVolumeSource[0] == nil </span><span class="cov0" title="0">{
                return result
        }</span>

        <span class="cov0" title="0">in := dataVolumeSource[0].(map[string]interface{})

        if v, ok := in["blank"].([]interface{}); ok </span><span class="cov0" title="0">{
                result.Blank = expandDataVolumeSourceBlank(v)
        }</span>
        <span class="cov0" title="0">if v, ok := in["http"].([]interface{}); ok </span><span class="cov0" title="0">{
                result.HTTP = expandDataVolumeSourceHTTP(v)
        }</span>
        <span class="cov0" title="0">if v, ok := in["pvc"].([]interface{}); ok </span><span class="cov0" title="0">{
                result.PVC = expandDataVolumeSourcePVC(v)
        }</span>
        <span class="cov0" title="0">if v, ok := in["registry"].([]interface{}); ok </span><span class="cov0" title="0">{
                result.Registry = expandDataVolumeSourceRegistry(v)
        }</span>

        <span class="cov0" title="0">return result</span>
}

func expandDataVolumeSourceBlank(dataVolumeSourceBlank []interface{}) *cdiv1.DataVolumeBlankImage <span class="cov0" title="0">{
        if len(dataVolumeSourceBlank) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // When blank {} is present in Terraform config, we should return a DataVolumeBlankImage
        // even if the first element is nil or an empty map
        <span class="cov0" title="0">result := &amp;cdiv1.DataVolumeBlankImage{}

        return result</span>
}

func expandDataVolumeSourceHTTP(dataVolumeSourceHTTP []interface{}) *cdiv1.DataVolumeSourceHTTP <span class="cov0" title="0">{
        if len(dataVolumeSourceHTTP) == 0 || dataVolumeSourceHTTP[0] == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">result := &amp;cdiv1.DataVolumeSourceHTTP{}

        in := dataVolumeSourceHTTP[0].(map[string]interface{})

        if v, ok := in["url"].(string); ok </span><span class="cov0" title="0">{
                result.URL = v
        }</span>
        <span class="cov0" title="0">if v, ok := in["secret_ref"].(string); ok </span><span class="cov0" title="0">{
                result.SecretRef = v
        }</span>
        <span class="cov0" title="0">if v, ok := in["cert_config_map"].(string); ok </span><span class="cov0" title="0">{
                result.CertConfigMap = v
        }</span>

        <span class="cov0" title="0">return result</span>
}

func expandDataVolumeSourcePVC(dataVolumeSourcePVC []interface{}) *cdiv1.DataVolumeSourcePVC <span class="cov0" title="0">{
        if len(dataVolumeSourcePVC) == 0 || dataVolumeSourcePVC[0] == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">result := &amp;cdiv1.DataVolumeSourcePVC{}

        in := dataVolumeSourcePVC[0].(map[string]interface{})

        if v, ok := in["namespace"].(string); ok </span><span class="cov0" title="0">{
                result.Namespace = v
        }</span>
        <span class="cov0" title="0">if v, ok := in["name"].(string); ok </span><span class="cov0" title="0">{
                result.Name = v
        }</span>

        <span class="cov0" title="0">return result</span>
}

func expandDataVolumeSourceRegistry(dataVolumeSourceRegistry []interface{}) *cdiv1.DataVolumeSourceRegistry <span class="cov0" title="0">{
        if len(dataVolumeSourceRegistry) == 0 || dataVolumeSourceRegistry[0] == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">result := &amp;cdiv1.DataVolumeSourceRegistry{}

        in := dataVolumeSourceRegistry[0].(map[string]interface{})

        if v, ok := in["image_url"].(string); ok </span><span class="cov0" title="0">{
                result.URL = types.Ptr(v)
        }</span>

        <span class="cov0" title="0">return result</span>
}

// Flatteners

func flattenDataVolumeSource(in *cdiv1.DataVolumeSource) []interface{} <span class="cov0" title="0">{
        att := make(map[string]interface{})
        if in != nil </span><span class="cov0" title="0">{
                if in.Blank != nil </span><span class="cov0" title="0">{
                        att["blank"] = flattenDataVolumeSourceBlank()
                }</span>
                <span class="cov0" title="0">if in.HTTP != nil </span><span class="cov0" title="0">{
                        att["http"] = flattenDataVolumeSourceHTTP(*in.HTTP)
                }</span>
                <span class="cov0" title="0">if in.PVC != nil </span><span class="cov0" title="0">{
                        att["pvc"] = flattenDataVolumeSourcePVC(*in.PVC)
                }</span>
                <span class="cov0" title="0">if in.Registry != nil </span><span class="cov0" title="0">{
                        att["registry"] = flattenDataVolumeSourceRegistry(*in.Registry)
                }</span>

                <span class="cov0" title="0">return []interface{}{att}</span>
        }
        <span class="cov0" title="0">return []interface{}{}</span>
}

func flattenDataVolumeSourceBlank() []interface{} <span class="cov0" title="0">{
        att := map[string]interface{}{}
        return []interface{}{att}
}</span>

func flattenDataVolumeSourceHTTP(in cdiv1.DataVolumeSourceHTTP) []interface{} <span class="cov0" title="0">{
        att := map[string]interface{}{
                "url":             in.URL,
                "secret_ref":      in.SecretRef,
                "cert_config_map": in.CertConfigMap,
        }
        return []interface{}{att}
}</span>

func flattenDataVolumeSourcePVC(in cdiv1.DataVolumeSourcePVC) []interface{} <span class="cov0" title="0">{
        att := map[string]interface{}{
                "namespace": in.Namespace,
                "name":      in.Name,
        }
        return []interface{}{att}
}</span>

func flattenDataVolumeSourceRegistry(in cdiv1.DataVolumeSourceRegistry) []interface{} <span class="cov0" title="0">{
        att := map[string]interface{}{
                "image_url": in.URL,
        }
        return []interface{}{att}
}</span>
</pre>
		
		<pre class="file" id="file76" style="display: none">package datavolume

import (
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
        v1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        cdiv1 "kubevirt.io/containerized-data-importer-api/pkg/apis/core/v1beta1"

        "github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/kubevirt/schema/k8s"
        "github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/kubevirt/utils"
        "github.com/spectrocloud/terraform-provider-spectrocloud/types"
)

func dataVolumeSpecFields() map[string]*schema.Schema <span class="cov10" title="2">{
        return map[string]*schema.Schema{
                "source":  dataVolumeSourceSchema(),
                "pvc":     k8s.PersistentVolumeClaimSpecSchema(),
                "storage": dataVolumeStorageSchema(),
                "content_type": {
                        Type:        schema.TypeString,
                        Description: "ContentType options: \"kubevirt\", \"archive\".",
                        Optional:    true,
                        ValidateFunc: validation.StringInSlice([]string{
                                "kubevirt",
                                "archive",
                        }, false),
                },
        }
}</span>

func dataVolumeStorageSchema() *schema.Schema <span class="cov10" title="2">{
        return &amp;schema.Schema{
                Type:        schema.TypeList,
                Description: "Storage is the requested storage specification for the DataVolume.",
                Optional:    true,
                MaxItems:    1,
                Elem: &amp;schema.Resource{
                        Schema: map[string]*schema.Schema{
                                "access_modes": {
                                        Type:        schema.TypeSet,
                                        Description: "A set of the desired access modes the volume should have. More info: http://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1",
                                        Optional:    true,
                                        Elem: &amp;schema.Schema{
                                                Type: schema.TypeString,
                                                ValidateFunc: validation.StringInSlice([]string{
                                                        "ReadWriteOnce",
                                                        "ReadOnlyMany",
                                                        "ReadWriteMany",
                                                }, false),
                                        },
                                        Set: schema.HashString,
                                },
                                "resources": {
                                        Type:        schema.TypeList,
                                        Description: "A list of the minimum resources the volume should have. More info: http://kubernetes.io/docs/concepts/storage/persistent-volumes#resources",
                                        Optional:    true,
                                        MaxItems:    1,
                                        Elem: &amp;schema.Resource{
                                                Schema: map[string]*schema.Schema{
                                                        "limits": {
                                                                Type:        schema.TypeMap,
                                                                Description: "Map describing the maximum amount of compute resources allowed. More info: http://kubernetes.io/docs/user-guide/compute-resources/",
                                                                Optional:    true,
                                                        },
                                                        "requests": {
                                                                Type:        schema.TypeMap,
                                                                Description: "Map describing the minimum amount of compute resources required. If this is omitted for a container, it defaults to `limits` if that is explicitly specified, otherwise to an implementation-defined value. More info: http://kubernetes.io/docs/user-guide/compute-resources/",
                                                                Optional:    true,
                                                        },
                                                },
                                        },
                                },
                                "selector": {
                                        Type:        schema.TypeList,
                                        Description: "A label query over volumes to consider for binding.",
                                        Optional:    true,
                                        MaxItems:    1,
                                        Elem: &amp;schema.Resource{
                                                Schema: labelSelectorFields(),
                                        },
                                },
                                "volume_name": {
                                        Type:        schema.TypeString,
                                        Description: "The binding reference to the PersistentVolume backing this claim.",
                                        Optional:    true,
                                },
                                "storage_class_name": {
                                        Type:        schema.TypeString,
                                        Description: "Name of the storage class requested by the claim",
                                        Optional:    true,
                                },
                                "volume_mode": {
                                        Type:        schema.TypeString,
                                        Description: "volumeMode defines what type of volume is required by the claim. Value of Filesystem is implied when not included in claim spec.",
                                        Optional:    true,
                                        ValidateFunc: validation.StringInSlice([]string{
                                                "Block",
                                                "Filesystem",
                                        }, false),
                                },
                        },
                },
        }
}</span>

func labelSelectorFields() map[string]*schema.Schema <span class="cov10" title="2">{
        return map[string]*schema.Schema{
                "match_expressions": {
                        Type:        schema.TypeList,
                        Description: "A list of label selector requirements. The requirements are ANDed.",
                        Optional:    true,
                        Elem: &amp;schema.Resource{
                                Schema: map[string]*schema.Schema{
                                        "key": {
                                                Type:        schema.TypeString,
                                                Description: "The label key that the selector applies to.",
                                                Optional:    true,
                                        },
                                        "operator": {
                                                Type:        schema.TypeString,
                                                Description: "A key's relationship to a set of values. Valid operators are `In`, `NotIn`, `Exists` and `DoesNotExist`.",
                                                Optional:    true,
                                        },
                                        "values": {
                                                Type:        schema.TypeSet,
                                                Description: "An array of string values. If the operator is `In` or `NotIn`, the values array must be non-empty. If the operator is `Exists` or `DoesNotExist`, the values array must be empty.",
                                                Optional:    true,
                                                Elem:        &amp;schema.Schema{Type: schema.TypeString},
                                                Set:         schema.HashString,
                                        },
                                },
                        },
                },
                "match_labels": {
                        Type:        schema.TypeMap,
                        Description: "A map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of `match_expressions`, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\".",
                        Optional:    true,
                },
        }
}</span>

func DataVolumeSpecSchema() *schema.Schema <span class="cov10" title="2">{
        fields := dataVolumeSpecFields()

        return &amp;schema.Schema{
                Type:        schema.TypeList,
                Description: "DataVolumeSpec defines our specification for a DataVolume type",
                Required:    true,
                MaxItems:    1,
                Elem: &amp;schema.Resource{
                        Schema: fields,
                },
        }
}</span>

func ExpandDataVolumeSpec(dataVolumeSpec []interface{}) (cdiv1.DataVolumeSpec, error) <span class="cov0" title="0">{
        result := cdiv1.DataVolumeSpec{}

        if len(dataVolumeSpec) == 0 || dataVolumeSpec[0] == nil </span><span class="cov0" title="0">{
                return result, nil
        }</span>

        <span class="cov0" title="0">in := dataVolumeSpec[0].(map[string]interface{})

        result.Source = expandDataVolumeSource(in["source"].([]interface{}))

        if v, ok := in["pvc"].([]interface{}); ok &amp;&amp; len(v) &gt; 0 </span><span class="cov0" title="0">{
                p, err := k8s.ExpandPersistentVolumeClaimSpec(v)
                if err != nil </span><span class="cov0" title="0">{
                        return result, err
                }</span>
                <span class="cov0" title="0">result.PVC = p</span>
        }

        <span class="cov0" title="0">if v, ok := in["storage"].([]interface{}); ok &amp;&amp; len(v) &gt; 0 </span><span class="cov0" title="0">{
                storage, err := expandDataVolumeStorage(v)
                if err != nil </span><span class="cov0" title="0">{
                        return result, err
                }</span>
                <span class="cov0" title="0">result.Storage = storage</span>
        }

        <span class="cov0" title="0">if v, ok := in["content_type"].(string); ok </span><span class="cov0" title="0">{
                result.ContentType = cdiv1.DataVolumeContentType(v)
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

func expandDataVolumeStorage(storage []interface{}) (*cdiv1.StorageSpec, error) <span class="cov0" title="0">{
        if len(storage) == 0 || storage[0] == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">in := storage[0].(map[string]interface{})
        result := &amp;cdiv1.StorageSpec{}

        if v, ok := in["access_modes"].(*schema.Set); ok &amp;&amp; v.Len() &gt; 0 </span><span class="cov0" title="0">{
                result.AccessModes = expandPersistentVolumeAccessModes(v.List())
        }</span>

        <span class="cov0" title="0">if v, ok := in["resources"].([]interface{}); ok &amp;&amp; len(v) &gt; 0 </span><span class="cov0" title="0">{
                resources, err := expandResourceRequirements(v)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">result.Resources = v1.VolumeResourceRequirements{
                        Limits:   resources.Limits,
                        Requests: resources.Requests,
                }</span>
        }

        <span class="cov0" title="0">if v, ok := in["selector"].([]interface{}); ok &amp;&amp; len(v) &gt; 0 </span><span class="cov0" title="0">{
                result.Selector = expandLabelSelector(v)
        }</span>

        <span class="cov0" title="0">if v, ok := in["volume_name"].(string); ok &amp;&amp; v != "" </span><span class="cov0" title="0">{
                result.VolumeName = v
        }</span>

        <span class="cov0" title="0">if v, ok := in["storage_class_name"].(string); ok &amp;&amp; v != "" </span><span class="cov0" title="0">{
                result.StorageClassName = &amp;v
        }</span>

        <span class="cov0" title="0">if v, ok := in["volume_mode"].(string); ok &amp;&amp; v != "" </span><span class="cov0" title="0">{
                switch v </span>{
                case "Block":<span class="cov0" title="0">
                        result.VolumeMode = types.Ptr(v1.PersistentVolumeBlock)</span>
                case "Filesystem":<span class="cov0" title="0">
                        result.VolumeMode = types.Ptr(v1.PersistentVolumeFilesystem)</span>
                }
        }

        <span class="cov0" title="0">return result, nil</span>
}

func expandPersistentVolumeAccessModes(s []interface{}) []v1.PersistentVolumeAccessMode <span class="cov0" title="0">{
        out := make([]v1.PersistentVolumeAccessMode, len(s))
        for i, v := range s </span><span class="cov0" title="0">{
                out[i] = v1.PersistentVolumeAccessMode(v.(string))
        }</span>
        <span class="cov0" title="0">return out</span>
}

func expandResourceRequirements(l []interface{}) (*v1.ResourceRequirements, error) <span class="cov0" title="0">{
        obj := &amp;v1.ResourceRequirements{}
        if len(l) == 0 || l[0] == nil </span><span class="cov0" title="0">{
                return obj, nil
        }</span>
        <span class="cov0" title="0">in := l[0].(map[string]interface{})
        if v, ok := in["limits"].(map[string]interface{}); ok &amp;&amp; len(v) &gt; 0 </span><span class="cov0" title="0">{
                rl, err := utils.ExpandMapToResourceList(v)
                if err != nil </span><span class="cov0" title="0">{
                        return obj, err
                }</span>
                <span class="cov0" title="0">obj.Limits = *rl</span>
        }
        <span class="cov0" title="0">if v, ok := in["requests"].(map[string]interface{}); ok &amp;&amp; len(v) &gt; 0 </span><span class="cov0" title="0">{
                rq, err := utils.ExpandMapToResourceList(v)
                if err != nil </span><span class="cov0" title="0">{
                        return obj, err
                }</span>
                <span class="cov0" title="0">obj.Requests = *rq</span>
        }
        <span class="cov0" title="0">return obj, nil</span>
}

func expandLabelSelector(l []interface{}) *metav1.LabelSelector <span class="cov0" title="0">{
        if len(l) == 0 || l[0] == nil </span><span class="cov0" title="0">{
                return &amp;metav1.LabelSelector{}
        }</span>
        <span class="cov0" title="0">in := l[0].(map[string]interface{})
        obj := &amp;metav1.LabelSelector{}
        if v, ok := in["match_labels"].(map[string]interface{}); ok &amp;&amp; len(v) &gt; 0 </span><span class="cov0" title="0">{
                obj.MatchLabels = utils.ExpandStringMap(v)
        }</span>
        <span class="cov0" title="0">if v, ok := in["match_expressions"].([]interface{}); ok &amp;&amp; len(v) &gt; 0 </span><span class="cov0" title="0">{
                obj.MatchExpressions = expandLabelSelectorRequirement(v)
        }</span>
        <span class="cov0" title="0">return obj</span>
}

func expandLabelSelectorRequirement(l []interface{}) []metav1.LabelSelectorRequirement <span class="cov0" title="0">{
        if len(l) == 0 || l[0] == nil </span><span class="cov0" title="0">{
                return []metav1.LabelSelectorRequirement{}
        }</span>
        <span class="cov0" title="0">obj := make([]metav1.LabelSelectorRequirement, len(l))
        for i, n := range l </span><span class="cov0" title="0">{
                in := n.(map[string]interface{})
                obj[i] = metav1.LabelSelectorRequirement{
                        Key:      in["key"].(string),
                        Operator: metav1.LabelSelectorOperator(in["operator"].(string)),
                        Values:   utils.SliceOfString(in["values"].(*schema.Set).List()),
                }
        }</span>
        <span class="cov0" title="0">return obj</span>
}

func FlattenDataVolumeSpec(spec cdiv1.DataVolumeSpec) []interface{} <span class="cov0" title="0">{
        att := map[string]interface{}{
                "source":       flattenDataVolumeSource(spec.Source),
                "content_type": string(spec.ContentType),
        }

        if spec.PVC != nil </span><span class="cov0" title="0">{
                att["pvc"] = k8s.FlattenPersistentVolumeClaimSpec(*spec.PVC)
        }</span>

        <span class="cov0" title="0">if spec.Storage != nil </span><span class="cov0" title="0">{
                att["storage"] = flattenDataVolumeStorage(*spec.Storage)
        }</span>

        <span class="cov0" title="0">return []interface{}{att}</span>
}

func flattenDataVolumeStorage(in cdiv1.StorageSpec) []interface{} <span class="cov0" title="0">{
        att := make(map[string]interface{})

        if len(in.AccessModes) &gt; 0 </span><span class="cov0" title="0">{
                att["access_modes"] = flattenPersistentVolumeAccessModes(in.AccessModes)
        }</span>

        <span class="cov0" title="0">if len(in.Resources.Limits) &gt; 0 || len(in.Resources.Requests) &gt; 0 </span><span class="cov0" title="0">{
                att["resources"] = flattenResourceRequirements(v1.ResourceRequirements{
                        Limits:   in.Resources.Limits,
                        Requests: in.Resources.Requests,
                })
        }</span>

        <span class="cov0" title="0">if in.Selector != nil </span><span class="cov0" title="0">{
                att["selector"] = flattenLabelSelector(in.Selector)
        }</span>

        <span class="cov0" title="0">if in.VolumeName != "" </span><span class="cov0" title="0">{
                att["volume_name"] = in.VolumeName
        }</span>

        <span class="cov0" title="0">if in.StorageClassName != nil </span><span class="cov0" title="0">{
                att["storage_class_name"] = *in.StorageClassName
        }</span>

        <span class="cov0" title="0">if in.VolumeMode != nil </span><span class="cov0" title="0">{
                att["volume_mode"] = string(*in.VolumeMode)
        }</span>

        <span class="cov0" title="0">return []interface{}{att}</span>
}

func flattenPersistentVolumeAccessModes(in []v1.PersistentVolumeAccessMode) *schema.Set <span class="cov0" title="0">{
        var out = make([]interface{}, len(in))
        for i, v := range in </span><span class="cov0" title="0">{
                out[i] = string(v)
        }</span>
        <span class="cov0" title="0">return schema.NewSet(schema.HashString, out)</span>
}

func flattenResourceRequirements(in v1.ResourceRequirements) []interface{} <span class="cov0" title="0">{
        att := make(map[string]interface{})
        if len(in.Limits) &gt; 0 </span><span class="cov0" title="0">{
                att["limits"] = utils.FlattenStringMap(utils.FlattenResourceList(in.Limits))
        }</span>
        <span class="cov0" title="0">if len(in.Requests) &gt; 0 </span><span class="cov0" title="0">{
                att["requests"] = utils.FlattenStringMap(utils.FlattenResourceList(in.Requests))
        }</span>
        <span class="cov0" title="0">return []interface{}{att}</span>
}

func flattenLabelSelector(in *metav1.LabelSelector) []interface{} <span class="cov0" title="0">{
        att := make(map[string]interface{})
        if len(in.MatchLabels) &gt; 0 </span><span class="cov0" title="0">{
                att["match_labels"] = utils.FlattenStringMap(in.MatchLabels)
        }</span>
        <span class="cov0" title="0">if len(in.MatchExpressions) &gt; 0 </span><span class="cov0" title="0">{
                att["match_expressions"] = flattenLabelSelectorRequirement(in.MatchExpressions)
        }</span>
        <span class="cov0" title="0">return []interface{}{att}</span>
}

func flattenLabelSelectorRequirement(in []metav1.LabelSelectorRequirement) []interface{} <span class="cov0" title="0">{
        att := make([]interface{}, len(in))
        for i, n := range in </span><span class="cov0" title="0">{
                m := make(map[string]interface{})
                m["key"] = n.Key
                m["operator"] = n.Operator
                m["values"] = utils.NewStringSet(schema.HashString, n.Values)
                att[i] = m
        }</span>
        <span class="cov0" title="0">return att</span>
}
</pre>
		
		<pre class="file" id="file77" style="display: none">package datavolume

import (
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
        cdiv1 "kubevirt.io/containerized-data-importer-api/pkg/apis/core/v1beta1"

        "github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/kubevirt/utils"
)

func dataVolumeStatusFields() map[string]*schema.Schema <span class="cov8" title="1">{
        return map[string]*schema.Schema{
                "phase": {
                        Type:        schema.TypeString,
                        Description: "DataVolumePhase is the current phase of the DataVolume.",
                        Optional:    true,
                        Computed:    true,
                        ValidateFunc: validation.StringInSlice([]string{
                                "",
                                "Pending",
                                "PVCBound",
                                "ImportScheduled",
                                "ImportInProgress",
                                "CloneScheduled",
                                "CloneInProgress",
                                "SnapshotForSmartCloneInProgress",
                                "SmartClonePVCInProgress",
                                "UploadScheduled",
                                "UploadReady",
                                "Succeeded",
                                "Failed",
                                "Unknown",
                        }, false),
                },
                "progress": {
                        Type:             schema.TypeString,
                        Description:      "DataVolumePhase is the current phase of the DataVolume.",
                        Optional:         true,
                        Computed:         true,
                        ValidateDiagFunc: utils.StringIsIntInRange(0, 100),
                },
        }
}</span>

func dataVolumeStatusSchema() *schema.Schema <span class="cov8" title="1">{
        fields := dataVolumeStatusFields()

        return &amp;schema.Schema{
                Type:        schema.TypeList,
                Description: "DataVolumeStatus provides the parameters to store the phase of the Data Volume",
                Optional:    true,
                MaxItems:    1,
                Computed:    true,
                Elem: &amp;schema.Resource{
                        Schema: fields,
                },
        }
}</span>

func expandDataVolumeStatus(dataVolumeStatus []interface{}) cdiv1.DataVolumeStatus <span class="cov0" title="0">{
        result := cdiv1.DataVolumeStatus{}

        if len(dataVolumeStatus) == 0 || dataVolumeStatus[0] == nil </span><span class="cov0" title="0">{
                return result
        }</span>

        <span class="cov0" title="0">in := dataVolumeStatus[0].(map[string]interface{})

        if v, ok := in["phase"].(string); ok </span><span class="cov0" title="0">{
                result.Phase = cdiv1.DataVolumePhase(v)
        }</span>
        <span class="cov0" title="0">if v, ok := in["progress"].(string); ok </span><span class="cov0" title="0">{
                result.Progress = cdiv1.DataVolumeProgress(v)
        }</span>

        <span class="cov0" title="0">return result</span>
}

func flattenDataVolumeStatus(in cdiv1.DataVolumeStatus) []interface{} <span class="cov0" title="0">{
        att := map[string]interface{}{
                "phase":    string(in.Phase),
                "progress": string(in.Progress),
        }
        return []interface{}{att}
}</span>
</pre>
		
		<pre class="file" id="file78" style="display: none">package k8s

import (
        "math"
        "regexp"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
        v1 "k8s.io/api/core/v1"

        "github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/kubevirt/utils"
)

// safeInt32 converts int to int32 with bounds checking to prevent overflow
func safeInt32(value int) int32 <span class="cov0" title="0">{
        if value &gt; math.MaxInt32 </span><span class="cov0" title="0">{
                return math.MaxInt32
        }</span>
        <span class="cov0" title="0">if value &lt; math.MinInt32 </span><span class="cov0" title="0">{
                return math.MinInt32
        }</span>
        <span class="cov0" title="0">return int32(value)</span>
}

func affinityFields() map[string]*schema.Schema <span class="cov1" title="1">{
        return map[string]*schema.Schema{
                "node_affinity": {
                        Type:        schema.TypeList,
                        Description: "Node affinity scheduling rules for the pod.",
                        Optional:    true,
                        MaxItems:    1,
                        Elem: &amp;schema.Resource{
                                Schema: nodeAffinityFields(),
                        },
                },
                "pod_affinity": {
                        Type:        schema.TypeList,
                        Description: "Inter-pod topological affinity. rules that specify that certain pods should be placed in the same topological domain (e.g. same node, same rack, same zone, same power domain, etc.)",
                        Optional:    true,
                        MaxItems:    1,
                        Elem: &amp;schema.Resource{
                                Schema: podAffinityFields(),
                        },
                },
                "pod_anti_affinity": {
                        Type:        schema.TypeList,
                        Description: "Inter-pod topological affinity. rules that specify that certain pods should be placed in the same topological domain (e.g. same node, same rack, same zone, same power domain, etc.)",
                        Optional:    true,
                        MaxItems:    1,
                        Elem: &amp;schema.Resource{
                                Schema: podAffinityFields(),
                        },
                },
        }
}</span>

func AffinitySchema() *schema.Schema <span class="cov1" title="1">{
        fields := affinityFields()

        return &amp;schema.Schema{
                Type:        schema.TypeList,
                Optional:    true,
                MaxItems:    1,
                Description: "Optional pod scheduling constraints.",
                Elem: &amp;schema.Resource{
                        Schema: fields,
                },
        }
}</span>

func nodeAffinityFields() map[string]*schema.Schema <span class="cov1" title="1">{
        return map[string]*schema.Schema{
                "required_during_scheduling_ignored_during_execution": {
                        Type:        schema.TypeList,
                        Description: "If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a node label update), the system may or may not try to eventually evict the pod from its node.",
                        Optional:    true,
                        MaxItems:    1,
                        Elem: &amp;schema.Resource{
                                Schema: nodeSelectorFields(),
                        },
                },
                "preferred_during_scheduling_ignored_during_execution": {
                        Type:        schema.TypeList,
                        Description: "The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, RequiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding 'weight' to the sum if the node matches the corresponding MatchExpressions; the node(s) with the highest sum are the most preferred.",
                        Optional:    true,
                        Elem: &amp;schema.Resource{
                                Schema: preferredSchedulingTermFields(),
                        },
                },
        }
}</span>

func nodeSelectorFields() map[string]*schema.Schema <span class="cov1" title="1">{
        return map[string]*schema.Schema{
                "node_selector_term": {
                        Type:        schema.TypeList,
                        Description: "List of node selector terms. The terms are ORed.",
                        Optional:    true,
                        Elem: &amp;schema.Resource{
                                Schema: nodeSelectorRequirementsFields(),
                        },
                },
        }
}</span>

func preferredSchedulingTermFields() map[string]*schema.Schema <span class="cov1" title="1">{
        return map[string]*schema.Schema{
                "weight": {
                        Type:        schema.TypeInt,
                        Description: "weight is in the range 1-100",
                        Required:    true,
                },
                "preference": {
                        Type:        schema.TypeList,
                        Description: "A node selector term, associated with the corresponding weight.",
                        Required:    true,
                        MaxItems:    1,
                        Elem: &amp;schema.Resource{
                                Schema: nodeSelectorRequirementsFields(),
                        },
                },
        }
}</span>

func nodeSelectorRequirementsFields() map[string]*schema.Schema <span class="cov5" title="2">{
        return map[string]*schema.Schema{
                "match_expressions": {
                        Type:        schema.TypeList,
                        Description: "List of node selector requirements. The requirements are ANDed.",
                        Optional:    true,
                        Elem: &amp;schema.Resource{
                                Schema: map[string]*schema.Schema{
                                        "key": {
                                                Type:        schema.TypeString,
                                                Description: "The label key that the selector applies to.",
                                                Optional:    true,
                                        },
                                        "operator": {
                                                Type:         schema.TypeString,
                                                Description:  "Operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.",
                                                Optional:     true,
                                                ValidateFunc: validation.StringInSlice([]string{"In", "NotIn", "Exists", "DoesNotExist", "Gt", "Lt"}, false),
                                        },
                                        "values": {
                                                Type:        schema.TypeSet,
                                                Description: "Values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.",
                                                Optional:    true,
                                                Elem:        &amp;schema.Schema{Type: schema.TypeString},
                                                Set:         schema.HashString,
                                        },
                                },
                        },
                },
        }
}</span>

func podAffinityFields() map[string]*schema.Schema <span class="cov5" title="2">{
        return map[string]*schema.Schema{
                "required_during_scheduling_ignored_during_execution": {
                        Type:        schema.TypeList,
                        Description: "If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each PodAffinityTerm are intersected, i.e. all terms must be satisfied.",
                        Optional:    true,
                        Elem: &amp;schema.Resource{
                                Schema: podAffinityTermFields(),
                        },
                },
                "preferred_during_scheduling_ignored_during_execution": {
                        Type:        schema.TypeList,
                        Description: "The scheduler will prefer to schedule pods to nodes that satisfy the anti-affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, RequiredDuringScheduling anti-affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding 'weight' to the sum if the node matches the corresponding MatchExpressions; the node(s) with the highest sum are the most preferred.",
                        Optional:    true,
                        Elem: &amp;schema.Resource{
                                Schema: weightedPodAffinityTermFields(),
                        },
                },
        }
}</span>

func podAffinityTermFields() map[string]*schema.Schema <span class="cov10" title="4">{
        return map[string]*schema.Schema{
                "label_selector": {
                        Type:        schema.TypeList,
                        Description: "A label query over a set of resources, in this case pods.",
                        Optional:    true,
                        Elem: &amp;schema.Resource{
                                Schema: labelSelectorFields(true),
                        },
                },
                "namespaces": {
                        Type:        schema.TypeSet,
                        Description: "namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means 'this pod's namespace'",
                        Optional:    true,
                        Elem:        &amp;schema.Schema{Type: schema.TypeString},
                        Set:         schema.HashString,
                },
                "topology_key": {
                        Type:         schema.TypeString,
                        Description:  "empty topology key is interpreted by the scheduler as 'all topologies'",
                        Optional:     true,
                        ValidateFunc: validation.StringMatch(regexp.MustCompile(`^.+$`), "value cannot be empty"),
                },
        }
}</span>

func weightedPodAffinityTermFields() map[string]*schema.Schema <span class="cov5" title="2">{
        return map[string]*schema.Schema{
                "weight": {
                        Type:        schema.TypeInt,
                        Description: "weight associated with matching the corresponding podAffinityTerm, in the range 1-100",
                        Required:    true,
                },
                "pod_affinity_term": {
                        Type:        schema.TypeList,
                        Description: "A pod affinity term, associated with the corresponding weight",
                        Required:    true,
                        MaxItems:    1,
                        Elem: &amp;schema.Resource{
                                Schema: podAffinityTermFields(),
                        },
                },
        }
}</span>

// Flatteners

func FlattenAffinity(in *v1.Affinity) []interface{} <span class="cov0" title="0">{
        att := make(map[string]interface{})
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">if in.NodeAffinity != nil </span><span class="cov0" title="0">{
                att["node_affinity"] = flattenNodeAffinity(in.NodeAffinity)
        }</span>
        <span class="cov0" title="0">if in.PodAffinity != nil </span><span class="cov0" title="0">{
                att["pod_affinity"] = flattenPodAffinity(in.PodAffinity)
        }</span>
        <span class="cov0" title="0">if in.PodAntiAffinity != nil </span><span class="cov0" title="0">{
                att["pod_anti_affinity"] = flattenPodAntiAffinity(in.PodAntiAffinity)
        }</span>
        <span class="cov0" title="0">if len(att) &gt; 0 </span><span class="cov0" title="0">{
                return []interface{}{att}
        }</span>
        <span class="cov0" title="0">return []interface{}{}</span>
}

func flattenNodeAffinity(in *v1.NodeAffinity) []interface{} <span class="cov0" title="0">{
        att := make(map[string]interface{})
        if in.RequiredDuringSchedulingIgnoredDuringExecution != nil </span><span class="cov0" title="0">{
                att["required_during_scheduling_ignored_during_execution"] = flattenNodeSelector(in.RequiredDuringSchedulingIgnoredDuringExecution)
        }</span>
        <span class="cov0" title="0">if in.PreferredDuringSchedulingIgnoredDuringExecution != nil </span><span class="cov0" title="0">{
                att["preferred_during_scheduling_ignored_during_execution"] = flattenPreferredSchedulingTerm(in.PreferredDuringSchedulingIgnoredDuringExecution)
        }</span>
        <span class="cov0" title="0">if len(att) &gt; 0 </span><span class="cov0" title="0">{
                return []interface{}{att}
        }</span>
        <span class="cov0" title="0">return []interface{}{}</span>
}

func flattenPodAffinity(in *v1.PodAffinity) []interface{} <span class="cov0" title="0">{
        att := make(map[string]interface{})
        if len(in.RequiredDuringSchedulingIgnoredDuringExecution) &gt; 0 </span><span class="cov0" title="0">{
                att["required_during_scheduling_ignored_during_execution"] = flattenPodAffinityTerms(in.RequiredDuringSchedulingIgnoredDuringExecution)
        }</span>
        <span class="cov0" title="0">if len(in.PreferredDuringSchedulingIgnoredDuringExecution) &gt; 0 </span><span class="cov0" title="0">{
                att["preferred_during_scheduling_ignored_during_execution"] = flattenWeightedPodAffinityTerms(in.PreferredDuringSchedulingIgnoredDuringExecution)
        }</span>
        <span class="cov0" title="0">if len(att) &gt; 0 </span><span class="cov0" title="0">{
                return []interface{}{att}
        }</span>
        <span class="cov0" title="0">return []interface{}{}</span>
}

func flattenPodAntiAffinity(in *v1.PodAntiAffinity) []interface{} <span class="cov0" title="0">{
        att := make(map[string]interface{})
        if len(in.RequiredDuringSchedulingIgnoredDuringExecution) &gt; 0 </span><span class="cov0" title="0">{
                att["required_during_scheduling_ignored_during_execution"] = flattenPodAffinityTerms(in.RequiredDuringSchedulingIgnoredDuringExecution)
        }</span>
        <span class="cov0" title="0">if len(in.PreferredDuringSchedulingIgnoredDuringExecution) &gt; 0 </span><span class="cov0" title="0">{
                att["preferred_during_scheduling_ignored_during_execution"] = flattenWeightedPodAffinityTerms(in.PreferredDuringSchedulingIgnoredDuringExecution)
        }</span>
        <span class="cov0" title="0">if len(att) &gt; 0 </span><span class="cov0" title="0">{
                return []interface{}{att}
        }</span>
        <span class="cov0" title="0">return []interface{}{}</span>
}

func flattenNodeSelector(in *v1.NodeSelector) []interface{} <span class="cov0" title="0">{
        att := make(map[string]interface{})
        if len(in.NodeSelectorTerms) &gt; 0 </span><span class="cov0" title="0">{
                att["node_selector_term"] = flattenNodeSelectorTerms(in.NodeSelectorTerms)
        }</span>
        <span class="cov0" title="0">if len(att) &gt; 0 </span><span class="cov0" title="0">{
                return []interface{}{att}
        }</span>
        <span class="cov0" title="0">return []interface{}{}</span>
}

func flattenPreferredSchedulingTerm(in []v1.PreferredSchedulingTerm) []interface{} <span class="cov0" title="0">{
        att := make([]interface{}, len(in))
        for i, n := range in </span><span class="cov0" title="0">{
                m := make(map[string]interface{})
                m["weight"] = int(n.Weight)
                m["preference"] = flattenNodeSelectorTerm(n.Preference)
                att[i] = m
        }</span>
        <span class="cov0" title="0">return att</span>
}

func flattenPodAffinityTerms(in []v1.PodAffinityTerm) []interface{} <span class="cov0" title="0">{
        att := make([]interface{}, len(in))
        for i, n := range in </span><span class="cov0" title="0">{
                m := make(map[string]interface{})
                m["namespaces"] = utils.NewStringSet(schema.HashString, n.Namespaces)
                m["topology_key"] = n.TopologyKey
                if n.LabelSelector != nil </span><span class="cov0" title="0">{
                        m["label_selector"] = flattenLabelSelector(n.LabelSelector)
                }</span>
                <span class="cov0" title="0">att[i] = m</span>
        }
        <span class="cov0" title="0">return att</span>
}

func flattenWeightedPodAffinityTerms(in []v1.WeightedPodAffinityTerm) []interface{} <span class="cov0" title="0">{
        att := make([]interface{}, len(in))
        for i, n := range in </span><span class="cov0" title="0">{
                m := make(map[string]interface{})
                m["weight"] = int(n.Weight)
                m["pod_affinity_term"] = flattenPodAffinityTerms([]v1.PodAffinityTerm{n.PodAffinityTerm})
                att[i] = m
        }</span>
        <span class="cov0" title="0">return att</span>
}

func flattenNodeSelectorTerms(in []v1.NodeSelectorTerm) []interface{} <span class="cov0" title="0">{
        att := make([]interface{}, len(in))
        for i, n := range in </span><span class="cov0" title="0">{
                att[i] = flattenNodeSelectorTerm(n)[0]
        }</span>
        <span class="cov0" title="0">return att</span>
}

func flattenNodeSelectorTerm(in v1.NodeSelectorTerm) []interface{} <span class="cov0" title="0">{
        att := make(map[string]interface{})
        if len(in.MatchExpressions) &gt; 0 </span><span class="cov0" title="0">{
                att["match_expressions"] = flattenNodeSelectorRequirementList(in.MatchExpressions)
        }</span>
        <span class="cov0" title="0">if len(in.MatchFields) &gt; 0 </span><span class="cov0" title="0">{
                att["match_fields"] = flattenNodeSelectorRequirementList(in.MatchFields)
        }</span>
        <span class="cov0" title="0">return []interface{}{att}</span>
}

func flattenNodeSelectorRequirementList(in []v1.NodeSelectorRequirement) []interface{} <span class="cov0" title="0">{
        att := make([]interface{}, len(in))
        for i, v := range in </span><span class="cov0" title="0">{
                m := map[string]interface{}{}
                m["key"] = v.Key
                m["values"] = utils.NewStringSet(schema.HashString, v.Values)
                m["operator"] = string(v.Operator)
                att[i] = m
        }</span>
        <span class="cov0" title="0">return att</span>
}

// Expanders

func ExpandAffinity(a []interface{}) *v1.Affinity <span class="cov0" title="0">{
        if len(a) == 0 || a[0] == nil </span><span class="cov0" title="0">{
                return &amp;v1.Affinity{}
        }</span>
        <span class="cov0" title="0">in := a[0].(map[string]interface{})
        obj := v1.Affinity{}
        if v, ok := in["node_affinity"].([]interface{}); ok &amp;&amp; len(v) &gt; 0 </span><span class="cov0" title="0">{
                obj.NodeAffinity = expandNodeAffinity(v)
        }</span>
        <span class="cov0" title="0">if v, ok := in["pod_affinity"].([]interface{}); ok &amp;&amp; len(v) &gt; 0 </span><span class="cov0" title="0">{
                obj.PodAffinity = expandPodAffinity(v)
        }</span>
        <span class="cov0" title="0">if v, ok := in["pod_anti_affinity"].([]interface{}); ok &amp;&amp; len(v) &gt; 0 </span><span class="cov0" title="0">{
                obj.PodAntiAffinity = expandPodAntiAffinity(v)
        }</span>
        <span class="cov0" title="0">return &amp;obj</span>
}

func expandNodeAffinity(a []interface{}) *v1.NodeAffinity <span class="cov0" title="0">{
        if len(a) == 0 || a[0] == nil </span><span class="cov0" title="0">{
                return &amp;v1.NodeAffinity{}
        }</span>
        <span class="cov0" title="0">in := a[0].(map[string]interface{})
        obj := v1.NodeAffinity{}
        if v, ok := in["required_during_scheduling_ignored_during_execution"].([]interface{}); ok &amp;&amp; len(v) &gt; 0 </span><span class="cov0" title="0">{
                obj.RequiredDuringSchedulingIgnoredDuringExecution = expandNodeSelector(v)
        }</span>
        <span class="cov0" title="0">if v, ok := in["preferred_during_scheduling_ignored_during_execution"].([]interface{}); ok &amp;&amp; len(v) &gt; 0 </span><span class="cov0" title="0">{
                obj.PreferredDuringSchedulingIgnoredDuringExecution = expandPreferredSchedulingTerms(v)
        }</span>
        <span class="cov0" title="0">return &amp;obj</span>
}

func expandPodAffinity(a []interface{}) *v1.PodAffinity <span class="cov0" title="0">{
        if len(a) == 0 || a[0] == nil </span><span class="cov0" title="0">{
                return &amp;v1.PodAffinity{}
        }</span>
        <span class="cov0" title="0">in := a[0].(map[string]interface{})
        obj := v1.PodAffinity{}
        if v, ok := in["required_during_scheduling_ignored_during_execution"].([]interface{}); ok &amp;&amp; len(v) &gt; 0 </span><span class="cov0" title="0">{
                obj.RequiredDuringSchedulingIgnoredDuringExecution = expandPodAffinityTerms(v)
        }</span>
        <span class="cov0" title="0">if v, ok := in["preferred_during_scheduling_ignored_during_execution"].([]interface{}); ok &amp;&amp; len(v) &gt; 0 </span><span class="cov0" title="0">{
                obj.PreferredDuringSchedulingIgnoredDuringExecution = expandWeightedPodAffinityTerms(v)
        }</span>
        <span class="cov0" title="0">return &amp;obj</span>
}

func expandPodAntiAffinity(a []interface{}) *v1.PodAntiAffinity <span class="cov0" title="0">{
        if len(a) == 0 || a[0] == nil </span><span class="cov0" title="0">{
                return &amp;v1.PodAntiAffinity{}
        }</span>
        <span class="cov0" title="0">in := a[0].(map[string]interface{})
        obj := v1.PodAntiAffinity{}
        if v, ok := in["required_during_scheduling_ignored_during_execution"].([]interface{}); ok &amp;&amp; len(v) &gt; 0 </span><span class="cov0" title="0">{
                obj.RequiredDuringSchedulingIgnoredDuringExecution = expandPodAffinityTerms(v)
        }</span>
        <span class="cov0" title="0">if v, ok := in["preferred_during_scheduling_ignored_during_execution"].([]interface{}); ok &amp;&amp; len(v) &gt; 0 </span><span class="cov0" title="0">{
                obj.PreferredDuringSchedulingIgnoredDuringExecution = expandWeightedPodAffinityTerms(v)
        }</span>
        <span class="cov0" title="0">return &amp;obj</span>
}

func expandNodeSelector(s []interface{}) *v1.NodeSelector <span class="cov0" title="0">{
        if len(s) == 0 || s[0] == nil </span><span class="cov0" title="0">{
                return &amp;v1.NodeSelector{}
        }</span>
        <span class="cov0" title="0">in := s[0].(map[string]interface{})
        obj := v1.NodeSelector{}
        if v, ok := in["node_selector_term"].([]interface{}); ok &amp;&amp; len(v) &gt; 0 </span><span class="cov0" title="0">{
                obj.NodeSelectorTerms = expandNodeSelectorTerms(v)
        }</span>
        <span class="cov0" title="0">return &amp;obj</span>
}

func expandPreferredSchedulingTerms(t []interface{}) []v1.PreferredSchedulingTerm <span class="cov0" title="0">{
        if len(t) == 0 || t[0] == nil </span><span class="cov0" title="0">{
                return []v1.PreferredSchedulingTerm{}
        }</span>
        <span class="cov0" title="0">obj := make([]v1.PreferredSchedulingTerm, len(t))
        for i, n := range t </span><span class="cov0" title="0">{
                in := n.(map[string]interface{})
                if v, ok := in["weight"].(int); ok </span><span class="cov0" title="0">{
                        obj[i].Weight = safeInt32(v)
                }</span>
                <span class="cov0" title="0">if v, ok := in["preference"].([]interface{}); ok &amp;&amp; len(v) &gt; 0 </span><span class="cov0" title="0">{
                        obj[i].Preference = *expandNodeSelectorTerm(v)
                }</span>
        }
        <span class="cov0" title="0">return obj</span>
}

func expandPodAffinityTerms(t []interface{}) []v1.PodAffinityTerm <span class="cov0" title="0">{
        if len(t) == 0 || t[0] == nil </span><span class="cov0" title="0">{
                return []v1.PodAffinityTerm{}
        }</span>
        <span class="cov0" title="0">obj := make([]v1.PodAffinityTerm, len(t))
        for i, n := range t </span><span class="cov0" title="0">{
                in := n.(map[string]interface{})
                if v, ok := in["label_selector"].([]interface{}); ok &amp;&amp; len(v) &gt; 0 </span><span class="cov0" title="0">{
                        obj[i].LabelSelector = expandLabelSelector(v)
                }</span>
                <span class="cov0" title="0">if v, ok := in["namespaces"].(*schema.Set); ok </span><span class="cov0" title="0">{
                        obj[i].Namespaces = utils.SliceOfString(v.List())
                }</span>
                <span class="cov0" title="0">if v, ok := in["topology_key"].(string); ok </span><span class="cov0" title="0">{
                        obj[i].TopologyKey = v
                }</span>
        }
        <span class="cov0" title="0">return obj</span>
}

func expandWeightedPodAffinityTerms(t []interface{}) []v1.WeightedPodAffinityTerm <span class="cov0" title="0">{
        if len(t) == 0 || t[0] == nil </span><span class="cov0" title="0">{
                return []v1.WeightedPodAffinityTerm{}
        }</span>
        <span class="cov0" title="0">obj := make([]v1.WeightedPodAffinityTerm, len(t))
        for i, n := range t </span><span class="cov0" title="0">{
                in := n.(map[string]interface{})
                if v, ok := in["weight"].(int); ok </span><span class="cov0" title="0">{
                        obj[i].Weight = safeInt32(v)
                }</span>
                <span class="cov0" title="0">if v, ok := in["pod_affinity_term"].([]interface{}); ok &amp;&amp; len(v) &gt; 0 </span><span class="cov0" title="0">{
                        obj[i].PodAffinityTerm = expandPodAffinityTerms(v)[0]
                }</span>
        }
        <span class="cov0" title="0">return obj</span>
}

func expandNodeSelectorTerms(l []interface{}) []v1.NodeSelectorTerm <span class="cov0" title="0">{
        if len(l) == 0 || l[0] == nil </span><span class="cov0" title="0">{
                return []v1.NodeSelectorTerm{}
        }</span>
        <span class="cov0" title="0">obj := make([]v1.NodeSelectorTerm, len(l))
        for i, n := range l </span><span class="cov0" title="0">{
                obj[i] = *expandNodeSelectorTerm([]interface{}{n})
        }</span>
        <span class="cov0" title="0">return obj</span>
}

func expandNodeSelectorTerm(l []interface{}) *v1.NodeSelectorTerm <span class="cov0" title="0">{
        if len(l) == 0 || l[0] == nil </span><span class="cov0" title="0">{
                return &amp;v1.NodeSelectorTerm{}
        }</span>
        <span class="cov0" title="0">in := l[0].(map[string]interface{})
        obj := v1.NodeSelectorTerm{}
        if v, ok := in["match_expressions"].([]interface{}); ok &amp;&amp; len(v) &gt; 0 </span><span class="cov0" title="0">{
                obj.MatchExpressions = expandNodeSelectorRequirementList(v)
        }</span>
        <span class="cov0" title="0">if v, ok := in["match_fields"].([]interface{}); ok &amp;&amp; len(v) &gt; 0 </span><span class="cov0" title="0">{
                obj.MatchFields = expandNodeSelectorRequirementList(v)
        }</span>
        <span class="cov0" title="0">return &amp;obj</span>
}

func expandNodeSelectorRequirementList(in []interface{}) []v1.NodeSelectorRequirement <span class="cov0" title="0">{
        att := []v1.NodeSelectorRequirement{}
        if len(in) &lt; 1 </span><span class="cov0" title="0">{
                return att
        }</span>
        <span class="cov0" title="0">att = make([]v1.NodeSelectorRequirement, len(in))
        for i, c := range in </span><span class="cov0" title="0">{
                p := c.(map[string]interface{})
                att[i].Key = p["key"].(string)
                att[i].Operator = v1.NodeSelectorOperator(p["operator"].(string))
                att[i].Values = utils.ExpandStringSlice(p["values"].(*schema.Set).List())
        }</span>
        <span class="cov0" title="0">return att</span>
}
</pre>
		
		<pre class="file" id="file79" style="display: none">package k8s

import (
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"

        "github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/kubevirt/utils"
)

func labelSelectorFields(updatable bool) map[string]*schema.Schema <span class="cov10" title="6">{
        return map[string]*schema.Schema{
                "match_expressions": {
                        Type:        schema.TypeList,
                        Description: "A list of label selector requirements. The requirements are ANDed.",
                        Optional:    true,
                        ForceNew:    !updatable,
                        Elem: &amp;schema.Resource{
                                Schema: map[string]*schema.Schema{
                                        "key": {
                                                Type:        schema.TypeString,
                                                Description: "The label key that the selector applies to.",
                                                Optional:    true,
                                                ForceNew:    !updatable,
                                        },
                                        "operator": {
                                                Type:        schema.TypeString,
                                                Description: "A key's relationship to a set of values. Valid operators ard `In`, `NotIn`, `Exists` and `DoesNotExist`.",
                                                Optional:    true,
                                                ForceNew:    !updatable,
                                        },
                                        "values": {
                                                Type:        schema.TypeSet,
                                                Description: "An array of string values. If the operator is `In` or `NotIn`, the values array must be non-empty. If the operator is `Exists` or `DoesNotExist`, the values array must be empty. This array is replaced during a strategic merge patch.",
                                                Optional:    true,
                                                ForceNew:    !updatable,
                                                Elem:        &amp;schema.Schema{Type: schema.TypeString},
                                                Set:         schema.HashString,
                                        },
                                },
                        },
                },
                "match_labels": {
                        Type:        schema.TypeMap,
                        Description: "A map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of `match_expressions`, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                        Optional:    true,
                        ForceNew:    !updatable,
                },
        }
}</span>

// Flatteners

func flattenLabelSelector(in *metav1.LabelSelector) []interface{} <span class="cov0" title="0">{
        att := make(map[string]interface{})
        if len(in.MatchLabels) &gt; 0 </span><span class="cov0" title="0">{
                att["match_labels"] = utils.FlattenStringMap(in.MatchLabels)
        }</span>
        <span class="cov0" title="0">if len(in.MatchExpressions) &gt; 0 </span><span class="cov0" title="0">{
                att["match_expressions"] = flattenLabelSelectorRequirement(in.MatchExpressions)
        }</span>
        <span class="cov0" title="0">return []interface{}{att}</span>
}

func flattenLabelSelectorRequirement(in []metav1.LabelSelectorRequirement) []interface{} <span class="cov0" title="0">{
        att := make([]interface{}, len(in))
        for i, n := range in </span><span class="cov0" title="0">{
                m := make(map[string]interface{})
                m["key"] = n.Key
                m["operator"] = n.Operator
                m["values"] = utils.NewStringSet(schema.HashString, n.Values)
                att[i] = m
        }</span>
        <span class="cov0" title="0">return att</span>
}

// Expanders

func expandLabelSelector(l []interface{}) *metav1.LabelSelector <span class="cov0" title="0">{
        if len(l) == 0 || l[0] == nil </span><span class="cov0" title="0">{
                return &amp;metav1.LabelSelector{}
        }</span>
        <span class="cov0" title="0">in := l[0].(map[string]interface{})
        obj := &amp;metav1.LabelSelector{}
        if v, ok := in["match_labels"].(map[string]interface{}); ok &amp;&amp; len(v) &gt; 0 </span><span class="cov0" title="0">{
                obj.MatchLabels = utils.ExpandStringMap(v)
        }</span>
        <span class="cov0" title="0">if v, ok := in["match_expressions"].([]interface{}); ok &amp;&amp; len(v) &gt; 0 </span><span class="cov0" title="0">{
                obj.MatchExpressions = expandLabelSelectorRequirement(v)
        }</span>
        <span class="cov0" title="0">return obj</span>
}

func expandLabelSelectorRequirement(l []interface{}) []metav1.LabelSelectorRequirement <span class="cov0" title="0">{
        if len(l) == 0 || l[0] == nil </span><span class="cov0" title="0">{
                return []metav1.LabelSelectorRequirement{}
        }</span>
        <span class="cov0" title="0">obj := make([]metav1.LabelSelectorRequirement, len(l))
        for i, n := range l </span><span class="cov0" title="0">{
                in := n.(map[string]interface{})
                obj[i] = metav1.LabelSelectorRequirement{
                        Key:      in["key"].(string),
                        Operator: metav1.LabelSelectorOperator(in["operator"].(string)),
                        Values:   utils.SliceOfString(in["values"].(*schema.Set).List()),
                }
        }</span>
        <span class="cov0" title="0">return obj</span>
}
</pre>
		
		<pre class="file" id="file80" style="display: none">package k8s

import (
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        v1 "k8s.io/api/core/v1"
)

func localObjectReferenceFields() map[string]*schema.Schema <span class="cov10" title="4">{
        return map[string]*schema.Schema{
                "name": {
                        Type:        schema.TypeString,
                        Description: "Name of the referent.",
                        Required:    true,
                },
        }
}</span>

func LocalObjectReferenceSchema(description string) *schema.Schema <span class="cov10" title="4">{
        fields := localObjectReferenceFields()

        return &amp;schema.Schema{
                Type:        schema.TypeList,
                Optional:    true,
                Description: description,
                MaxItems:    1,
                Elem: &amp;schema.Resource{
                        Schema: fields,
                },
        }
}</span>

func ExpandLocalObjectReferences(localObjectReference []interface{}) *v1.LocalObjectReference <span class="cov0" title="0">{
        if len(localObjectReference) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">result := &amp;v1.LocalObjectReference{}

        in := localObjectReference[0].(map[string]interface{})

        if v, ok := in["name"].(string); ok </span><span class="cov0" title="0">{
                result.Name = v
        }</span>

        <span class="cov0" title="0">return result</span>
}

func FlattenLocalObjectReferences(localObjectReference v1.LocalObjectReference) []interface{} <span class="cov0" title="0">{
        att := make(map[string]interface{})

        att["name"] = localObjectReference.Name

        return []interface{}{att}
}</span>
</pre>
		
		<pre class="file" id="file81" style="display: none">package k8s

import (
        "fmt"
        "strings"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

        "github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/kubevirt/utils"

        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// filterSystemAnnotations removes system-managed annotations that should not be managed by Terraform
func filterSystemAnnotations(annotations map[string]string) map[string]string <span class="cov0" title="0">{
        if annotations == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">filtered := make(map[string]string)

        for key, value := range annotations </span><span class="cov0" title="0">{
                // Filter out all kubevirt.io/ system annotations
                if !strings.HasPrefix(key, "kubevirt.io/") </span><span class="cov0" title="0">{
                        filtered[key] = value
                }</span>
        }

        <span class="cov0" title="0">return filtered</span>
}

func metadataFields(objectName string) map[string]*schema.Schema <span class="cov10" title="2">{
        return map[string]*schema.Schema{
                "annotations": {
                        Type:         schema.TypeMap,
                        Description:  fmt.Sprintf("An unstructured key value map stored with the %s that may be used to store arbitrary metadata. More info: http://kubernetes.io/docs/user-guide/annotations", objectName),
                        Optional:     true,
                        Elem:         &amp;schema.Schema{Type: schema.TypeString},
                        ValidateFunc: utils.ValidateAnnotations,
                        Computed:     true,
                },
                "generation": {
                        Type:        schema.TypeInt,
                        Description: "A sequence number representing a specific generation of the desired state.",
                        Computed:    true,
                },
                "labels": {
                        Type:         schema.TypeMap,
                        Description:  fmt.Sprintf("Map of string keys and values that can be used to organize and categorize (scope and select) the %s. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels", objectName),
                        Optional:     true,
                        Elem:         &amp;schema.Schema{Type: schema.TypeString},
                        ValidateFunc: utils.ValidateLabels,
                },
                "name": {
                        Type:         schema.TypeString,
                        Description:  fmt.Sprintf("Name of the %s, must be unique. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names", objectName),
                        Optional:     true,
                        Computed:     true,
                        ForceNew:     true,
                        ValidateFunc: utils.ValidateName,
                },
                "resource_version": {
                        Type:        schema.TypeString,
                        Description: fmt.Sprintf("An opaque value that represents the internal version of this %s that can be used by clients to determine when %s has changed. Read more: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency", objectName, objectName),
                        Computed:    true,
                },
                "uid": {
                        Type:        schema.TypeString,
                        Description: fmt.Sprintf("The unique in time and space value for this %s. More info: http://kubernetes.io/docs/user-guide/identifiers#uids", objectName),
                        Computed:    true,
                },
        }
}</span>

func NamespacedMetadataSchema(objectName string, generatableName bool) *schema.Schema <span class="cov10" title="2">{
        return namespacedMetadataSchemaIsTemplate(objectName, generatableName, false)
}</span>

func namespacedMetadataSchemaIsTemplate(objectName string, generatableName, isTemplate bool) *schema.Schema <span class="cov10" title="2">{
        fields := metadataFields(objectName)
        fields["namespace"] = &amp;schema.Schema{
                Type:        schema.TypeString,
                Description: fmt.Sprintf("Namespace defines the space within which name of the %s must be unique.", objectName),
                Optional:    true,
                ForceNew:    true,
                Default: (func() interface{} </span><span class="cov10" title="2">{
                        if isTemplate </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                        <span class="cov10" title="2">return "default"</span>
                })(),
        }
        <span class="cov10" title="2">if generatableName </span><span class="cov0" title="0">{
                fields["generate_name"] = &amp;schema.Schema{
                        Type:          schema.TypeString,
                        Description:   "Prefix, used by the server, to generate a unique name ONLY IF the `name` field has not been provided. This value will also be combined with a unique suffix. Read more: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#idempotency",
                        Optional:      true,
                        ValidateFunc:  utils.ValidateGenerateName,
                        ConflictsWith: []string{"metadata.name"},
                }
                fields["name"].ConflictsWith = []string{"metadata.generate_name"}
        }</span>

        <span class="cov10" title="2">return &amp;schema.Schema{
                Type:        schema.TypeList,
                Description: fmt.Sprintf("Standard %s's metadata. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#metadata", objectName),
                Required:    true,
                MaxItems:    1,
                Elem: &amp;schema.Resource{
                        Schema: fields,
                },
        }</span>
}

func ConvertToBasicMetadata(d *schema.ResourceData) metav1.ObjectMeta <span class="cov0" title="0">{
        var meta []interface{}
        metaValues := make(map[string]interface{})
        if v, ok := d.GetOk("annotations"); ok &amp;&amp; len(v.(map[string]interface{})) &gt; 0 </span><span class="cov0" title="0">{
                metaValues["annotations"] = utils.ExpandStringMap(v.(map[string]interface{}))
        }</span>

        <span class="cov0" title="0">if v, ok := d.GetOk("labels"); ok &amp;&amp; len(v.(map[string]interface{})) &gt; 0 </span><span class="cov0" title="0">{
                metaValues["labels"] = utils.ExpandStringMap(v.(map[string]interface{}))
        }</span>

        <span class="cov0" title="0">if v, ok := d.GetOk("generate_name"); ok </span><span class="cov0" title="0">{
                metaValues["generate_name"] = v.(string)
        }</span>
        <span class="cov0" title="0">if v, ok := d.GetOk("name"); ok </span><span class="cov0" title="0">{
                metaValues["name"] = v.(string)
        }</span>
        <span class="cov0" title="0">if v, ok := d.GetOk("namespace"); ok </span><span class="cov0" title="0">{
                metaValues["namespace"] = v.(string)
        }</span>
        <span class="cov0" title="0">if v, ok := d.GetOk("resource_version"); ok </span><span class="cov0" title="0">{
                metaValues["resource_version"] = v.(string)
        }</span>
        <span class="cov0" title="0">meta = append(meta, metaValues)
        return ExpandMetadata(meta)</span>
}

func ExpandMetadata(in []interface{}) metav1.ObjectMeta <span class="cov0" title="0">{
        meta := metav1.ObjectMeta{}
        if len(in) &lt; 1 </span><span class="cov0" title="0">{
                return meta
        }</span>
        <span class="cov0" title="0">m := in[0].(map[string]interface{})

        if v, ok := m["annotations"].(map[string]string); ok &amp;&amp; len(v) &gt; 0 </span><span class="cov0" title="0">{
                meta.Annotations = m["annotations"].(map[string]string) //utils.ExpandStringMap(m["annotations"].(map[string]interface{}))
        }</span> else<span class="cov0" title="0"> if v, ok := m["annotations"].(map[string]interface{}); ok &amp;&amp; len(v) &gt; 0 </span><span class="cov0" title="0">{ // for supporting data volume templates annotations
                meta.Annotations = utils.ExpandStringMap(m["annotations"].(map[string]interface{}))
        }</span>

        <span class="cov0" title="0">if v, ok := m["labels"].(map[string]string); ok &amp;&amp; len(v) &gt; 0 </span><span class="cov0" title="0">{
                meta.Labels = m["labels"].(map[string]string) //utils.ExpandStringMap(m["labels"])
        }</span>

        <span class="cov0" title="0">if v, ok := m["generate_name"]; ok </span><span class="cov0" title="0">{
                meta.GenerateName = v.(string)
        }</span>
        <span class="cov0" title="0">if v, ok := m["name"]; ok </span><span class="cov0" title="0">{
                meta.Name = v.(string)
        }</span>
        <span class="cov0" title="0">if v, ok := m["namespace"]; ok </span><span class="cov0" title="0">{
                meta.Namespace = v.(string)
        }</span>
        <span class="cov0" title="0">if v, ok := m["resource_version"]; ok </span><span class="cov0" title="0">{
                meta.ResourceVersion = v.(string)
        }</span>

        <span class="cov0" title="0">return meta</span>
}

func FlattenMetadataDataVolume(meta metav1.ObjectMeta) []interface{} <span class="cov0" title="0">{
        m := make(map[string]interface{})
        // Filter out system-managed annotations for data volumes as well
        filteredAnnotations := filterSystemAnnotations(meta.Annotations)
        m["annotations"] = utils.FlattenStringMap(filteredAnnotations)
        if meta.GenerateName != "" </span><span class="cov0" title="0">{
                m["generate_name"] = meta.GenerateName
        }</span>
        <span class="cov0" title="0">m["labels"] = utils.FlattenStringMap(meta.Labels)
        m["name"] = meta.Name
        m["resource_version"] = meta.ResourceVersion
        m["uid"] = fmt.Sprintf("%v", meta.UID)
        m["generation"] = meta.Generation

        if meta.Namespace != "" </span><span class="cov0" title="0">{
                m["namespace"] = meta.Namespace
        }</span>

        <span class="cov0" title="0">return []interface{}{m}</span>
}

func FlattenMetadata(meta metav1.ObjectMeta, resourceData *schema.ResourceData) error <span class="cov0" title="0">{
        var err error
        if resourceData == nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // Filter out system-managed annotations before setting them in Terraform state
        <span class="cov0" title="0">filteredAnnotations := filterSystemAnnotations(meta.Annotations)
        if err = resourceData.Set("annotations", utils.FlattenStringMap(filteredAnnotations)); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err = resourceData.Set("labels", utils.FlattenStringMap(meta.Labels)); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err = resourceData.Set("name", meta.Name); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err = resourceData.Set("resource_version", meta.ResourceVersion); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err = resourceData.Set("uid", fmt.Sprintf("%v", meta.UID)); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err = resourceData.Set("generation", int(meta.Generation)); err != nil </span><span class="cov0" title="0">{ //fmt.Sprintf("%v", meta.Generation)
                return err
        }</span>
        <span class="cov0" title="0">if err = resourceData.Set("namespace", fmt.Sprintf("%v", meta.Namespace)); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return err</span>
}
</pre>
		
		<pre class="file" id="file82" style="display: none">package k8s

import (
        "fmt"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
        v1 "k8s.io/api/core/v1"

        "github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/kubevirt/utils"
        "github.com/spectrocloud/terraform-provider-spectrocloud/types"
)

func persistentVolumeClaimSpecFields() map[string]*schema.Schema <span class="cov10" title="2">{
        return map[string]*schema.Schema{
                "access_modes": {
                        Type:        schema.TypeSet,
                        Description: "A set of the desired access modes the volume should have. More info: http://kubernetes.io/docs/user-guide/persistent-volumes#access-modes-1",
                        Required:    true,
                        Elem: &amp;schema.Schema{
                                Type: schema.TypeString,
                                ValidateFunc: validation.StringInSlice([]string{
                                        "ReadWriteOnce",
                                        "ReadOnlyMany",
                                        "ReadWriteMany",
                                }, false),
                        },
                        Set: schema.HashString,
                },
                "resources": {
                        Type:        schema.TypeList,
                        Description: "A list of the minimum resources the volume should have. More info: http://kubernetes.io/docs/user-guide/persistent-volumes#resources",
                        Required:    true,
                        MaxItems:    1,
                        Elem: &amp;schema.Resource{
                                Schema: map[string]*schema.Schema{
                                        "limits": {
                                                Type:        schema.TypeMap,
                                                Description: "Map describing the maximum amount of compute resources allowed. More info: http://kubernetes.io/docs/user-guide/compute-resources/",
                                                Optional:    true,
                                                ForceNew:    true,
                                        },
                                        // This is the only field the API will allow modifying in-place, so ForceNew is not used.
                                        "requests": {
                                                Type:        schema.TypeMap,
                                                Description: "Map describing the minimum amount of compute resources required. If this is omitted for a container, it defaults to `limits` if that is explicitly specified, otherwise to an implementation-defined value. More info: http://kubernetes.io/docs/user-guide/compute-resources/",
                                                Optional:    true,
                                        },
                                },
                        },
                },
                "selector": {
                        Type:        schema.TypeList,
                        Description: "A label query over volumes to consider for binding.",
                        Optional:    true,
                        ForceNew:    true,
                        MaxItems:    1,
                        Elem: &amp;schema.Resource{
                                Schema: labelSelectorFields(false),
                        },
                },
                "volume_name": {
                        Type:        schema.TypeString,
                        Description: "The binding reference to the PersistentVolume backing this claim.",
                        Optional:    true,
                        ForceNew:    true,
                        Computed:    true,
                },
                "storage_class_name": {
                        Type:        schema.TypeString,
                        Description: "Name of the storage class requested by the claim",
                        Optional:    true,
                        Computed:    true,
                },
                "volume_mode": {
                        Type:        schema.TypeString,
                        Description: "volumeMode defines what type of volume is required by the claim. Value of Filesystem is implied when not included in claim spec.",
                        Optional:    true,
                        Computed:    true,
                },
        }
}</span>

func PersistentVolumeClaimSpecSchema() *schema.Schema <span class="cov10" title="2">{
        fields := persistentVolumeClaimSpecFields()

        return &amp;schema.Schema{
                Type:        schema.TypeList,
                Description: "PVC is a pointer to the PVC Spec we want to use.",
                Optional:    true,
                MaxItems:    1,
                Elem: &amp;schema.Resource{
                        Schema: fields,
                },
        }
}</span>

// Flatteners

func FlattenPersistentVolumeClaimSpec(in v1.PersistentVolumeClaimSpec) []interface{} <span class="cov0" title="0">{
        att := make(map[string]interface{})
        att["access_modes"] = flattenPersistentVolumeAccessModes(in.AccessModes)
        att["resources"] = flattenResourceRequirements(v1.ResourceRequirements{
                Limits:   in.Resources.Limits,
                Requests: in.Resources.Requests,
        })
        if in.Selector != nil </span><span class="cov0" title="0">{
                att["selector"] = flattenLabelSelector(in.Selector)
        }</span>
        <span class="cov0" title="0">if in.VolumeName != "" </span><span class="cov0" title="0">{
                att["volume_name"] = in.VolumeName
        }</span>
        <span class="cov0" title="0">if in.StorageClassName != nil </span><span class="cov0" title="0">{
                att["storage_class_name"] = *in.StorageClassName
        }</span>
        <span class="cov0" title="0">if in.VolumeMode != nil </span><span class="cov0" title="0">{
                att["volume_mode"] = *in.VolumeMode
        }</span>
        <span class="cov0" title="0">return []interface{}{att}</span>
}

func flattenResourceRequirements(in v1.ResourceRequirements) []interface{} <span class="cov0" title="0">{
        att := make(map[string]interface{})
        if len(in.Limits) &gt; 0 </span><span class="cov0" title="0">{
                att["limits"] = utils.FlattenStringMap(utils.FlattenResourceList(in.Limits))
        }</span>
        <span class="cov0" title="0">if len(in.Requests) &gt; 0 </span><span class="cov0" title="0">{
                att["requests"] = utils.FlattenStringMap(utils.FlattenResourceList(in.Requests))
        }</span>
        <span class="cov0" title="0">return []interface{}{att}</span>
}

// Expanders

func ExpandPersistentVolumeClaimSpec(l []interface{}) (*v1.PersistentVolumeClaimSpec, error) <span class="cov0" title="0">{
        obj := &amp;v1.PersistentVolumeClaimSpec{}
        if len(l) == 0 || l[0] == nil </span><span class="cov0" title="0">{
                return obj, nil
        }</span>
        <span class="cov0" title="0">in := l[0].(map[string]interface{})
        resourceRequirements, err := expandResourceRequirements(in["resources"].([]interface{}))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">obj.AccessModes = expandPersistentVolumeAccessModes(in["access_modes"].(*schema.Set).List())
        obj.Resources = v1.VolumeResourceRequirements{
                Limits:   resourceRequirements.Limits,
                Requests: resourceRequirements.Requests,
        }
        if v, ok := in["selector"].([]interface{}); ok &amp;&amp; len(v) &gt; 0 </span><span class="cov0" title="0">{
                obj.Selector = expandLabelSelector(v)
        }</span>
        <span class="cov0" title="0">if v, ok := in["volume_name"].(string); ok </span><span class="cov0" title="0">{
                obj.VolumeName = v
        }</span>
        <span class="cov0" title="0">if v, ok := in["storage_class_name"].(string); ok &amp;&amp; v != "" </span><span class="cov0" title="0">{
                obj.StorageClassName = utils.PtrToString(v)
        }</span>
        <span class="cov0" title="0">if v, ok := in["volume_mode"].(string); ok &amp;&amp; v != "" </span><span class="cov0" title="0">{
                switch v </span>{
                case string(v1.PersistentVolumeBlock):<span class="cov0" title="0">
                        obj.VolumeMode = types.Ptr(v1.PersistentVolumeBlock)</span>
                case string(v1.PersistentVolumeFilesystem):<span class="cov0" title="0">
                        obj.VolumeMode = types.Ptr(v1.PersistentVolumeFilesystem)</span>
                default:<span class="cov0" title="0">
                        return nil, fmt.Errorf("invalid volume mode: %s", v)</span>
                }
        }
        <span class="cov0" title="0">return obj, nil</span>
}

func expandResourceRequirements(l []interface{}) (*v1.ResourceRequirements, error) <span class="cov0" title="0">{
        obj := &amp;v1.ResourceRequirements{}
        if len(l) == 0 || l[0] == nil </span><span class="cov0" title="0">{
                return obj, nil
        }</span>
        <span class="cov0" title="0">in := l[0].(map[string]interface{})
        if v, ok := in["limits"].(map[string]interface{}); ok &amp;&amp; len(v) &gt; 0 </span><span class="cov0" title="0">{
                rl, err := utils.ExpandMapToResourceList(v)
                if err != nil </span><span class="cov0" title="0">{
                        return obj, err
                }</span>
                <span class="cov0" title="0">obj.Limits = *rl</span>
        }
        <span class="cov0" title="0">if v, ok := in["requests"].(map[string]interface{}); ok &amp;&amp; len(v) &gt; 0 </span><span class="cov0" title="0">{
                rq, err := utils.ExpandMapToResourceList(v)
                if err != nil </span><span class="cov0" title="0">{
                        return obj, err
                }</span>
                <span class="cov0" title="0">obj.Requests = *rq</span>
        }
        <span class="cov0" title="0">return obj, nil</span>
}

func expandPersistentVolumeAccessModes(s []interface{}) []v1.PersistentVolumeAccessMode <span class="cov0" title="0">{
        out := make([]v1.PersistentVolumeAccessMode, len(s))
        for i, v := range s </span><span class="cov0" title="0">{
                out[i] = v1.PersistentVolumeAccessMode(v.(string))
        }</span>
        <span class="cov0" title="0">return out</span>
}

func flattenPersistentVolumeAccessModes(in []v1.PersistentVolumeAccessMode) *schema.Set <span class="cov0" title="0">{
        var out = make([]interface{}, len(in))
        for i, v := range in </span><span class="cov0" title="0">{
                out[i] = string(v)
        }</span>
        <span class="cov0" title="0">return schema.NewSet(schema.HashString, out)</span>
}
</pre>
		
		<pre class="file" id="file83" style="display: none">package k8s

import (
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
        v1 "k8s.io/api/core/v1"

        "github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/kubevirt/utils"
)

func podDnsConfigFields() map[string]*schema.Schema <span class="cov8" title="1">{
        return map[string]*schema.Schema{
                "nameservers": {
                        Type:        schema.TypeList,
                        Description: "A list of DNS name server IP addresses. This will be appended to the base nameservers generated from DNSPolicy. Duplicated nameservers will be removed.",
                        Optional:    true,
                        Elem: &amp;schema.Schema{
                                Type:         schema.TypeString,
                                ValidateFunc: validation.IsIPAddress,
                        },
                },
                "option": {
                        Type:        schema.TypeList,
                        Description: "A list of DNS resolver options. This will be merged with the base options generated from DNSPolicy. Duplicated entries will be removed. Resolution options given in Options will override those that appear in the base DNSPolicy.",
                        Optional:    true,
                        Elem: &amp;schema.Resource{
                                Schema: map[string]*schema.Schema{
                                        "name": {
                                                Type:        schema.TypeString,
                                                Description: "Name of the option.",
                                                Required:    true,
                                        },
                                        "value": {
                                                Type:        schema.TypeString,
                                                Description: "Value of the option. Optional: Defaults to empty.",
                                                Optional:    true,
                                        },
                                },
                        },
                },
                "searches": {
                        Type:        schema.TypeList,
                        Description: "A list of DNS search domains for host-name lookup. This will be appended to the base search paths generated from DNSPolicy. Duplicated search paths will be removed.",
                        Optional:    true,
                        Elem: &amp;schema.Schema{
                                Type:         schema.TypeString,
                                ValidateFunc: utils.ValidateName,
                        },
                },
        }
}</span>

func PodDnsConfigSchema() *schema.Schema <span class="cov8" title="1">{
        fields := podDnsConfigFields()

        return &amp;schema.Schema{
                Type:        schema.TypeList,
                Optional:    true,
                MaxItems:    1,
                Description: "Specifies the DNS parameters of a pod. Parameters specified here will be merged to the generated DNS configuration based on DNSPolicy. Optional: Defaults to empty",
                Elem: &amp;schema.Resource{
                        Schema: fields,
                },
        }
}</span>

func ExpandPodDNSConfig(l []interface{}) (*v1.PodDNSConfig, error) <span class="cov0" title="0">{
        if len(l) == 0 || l[0] == nil </span><span class="cov0" title="0">{
                return &amp;v1.PodDNSConfig{}, nil
        }</span>
        <span class="cov0" title="0">in := l[0].(map[string]interface{})
        obj := &amp;v1.PodDNSConfig{}
        if v, ok := in["nameservers"].([]interface{}); ok </span><span class="cov0" title="0">{
                obj.Nameservers = utils.ExpandStringSlice(v)
        }</span>
        <span class="cov0" title="0">if v, ok := in["searches"].([]interface{}); ok </span><span class="cov0" title="0">{
                obj.Searches = utils.ExpandStringSlice(v)
        }</span>
        <span class="cov0" title="0">if v, ok := in["option"].([]interface{}); ok </span><span class="cov0" title="0">{
                opts, err := expandDNSConfigOptions(v)
                if err != nil </span><span class="cov0" title="0">{
                        return obj, err
                }</span>
                <span class="cov0" title="0">obj.Options = opts</span>
        }
        <span class="cov0" title="0">return obj, nil</span>
}

func expandDNSConfigOptions(options []interface{}) ([]v1.PodDNSConfigOption, error) <span class="cov0" title="0">{
        if len(options) == 0 </span><span class="cov0" title="0">{
                return []v1.PodDNSConfigOption{}, nil
        }</span>
        <span class="cov0" title="0">opts := make([]v1.PodDNSConfigOption, len(options))
        for i, c := range options </span><span class="cov0" title="0">{
                in := c.(map[string]interface{})
                opt := v1.PodDNSConfigOption{}
                if v, ok := in["name"].(string); ok </span><span class="cov0" title="0">{
                        opt.Name = v
                }</span>
                <span class="cov0" title="0">if v, ok := in["value"].(string); ok </span><span class="cov0" title="0">{
                        opt.Value = utils.PtrToString(v)
                }</span>
                <span class="cov0" title="0">opts[i] = opt</span>
        }

        <span class="cov0" title="0">return opts, nil</span>
}

func FlattenPodDNSConfig(in *v1.PodDNSConfig) []interface{} <span class="cov0" title="0">{
        att := make(map[string]interface{})

        if len(in.Nameservers) &gt; 0 </span><span class="cov0" title="0">{
                att["nameservers"] = in.Nameservers
        }</span>
        <span class="cov0" title="0">if len(in.Searches) &gt; 0 </span><span class="cov0" title="0">{
                att["searches"] = in.Searches
        }</span>
        <span class="cov0" title="0">if len(in.Options) &gt; 0 </span><span class="cov0" title="0">{
                att["option"] = flattenPodDNSConfigOptions(in.Options)
        }</span>

        <span class="cov0" title="0">if len(att) &gt; 0 </span><span class="cov0" title="0">{
                return []interface{}{att}
        }</span>
        <span class="cov0" title="0">return []interface{}{}</span>
}

func flattenPodDNSConfigOptions(options []v1.PodDNSConfigOption) []interface{} <span class="cov0" title="0">{
        att := make([]interface{}, len(options))
        for i, v := range options </span><span class="cov0" title="0">{
                obj := map[string]interface{}{}

                if v.Name != "" </span><span class="cov0" title="0">{
                        obj["name"] = v.Name
                }</span>
                <span class="cov0" title="0">if v.Value != nil </span><span class="cov0" title="0">{
                        obj["value"] = *v.Value
                }</span>
                <span class="cov0" title="0">att[i] = obj</span>
        }
        <span class="cov0" title="0">return att</span>
}
</pre>
		
		<pre class="file" id="file84" style="display: none">package k8s

import (
        "fmt"
        "log"
        "strconv"
        "strings"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
        v1 "k8s.io/api/core/v1"

        "github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/kubevirt/utils"
)

func tolerationFields() map[string]*schema.Schema <span class="cov8" title="1">{
        return map[string]*schema.Schema{
                "effect": {
                        Type:         schema.TypeString,
                        Description:  "Effect indicates the taint effect to match. Empty means match all taint effects. When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.",
                        Optional:     true,
                        ValidateFunc: validation.StringInSlice([]string{"NoSchedule", "PreferNoSchedule", "NoExecute"}, false),
                },
                "key": {
                        Type:        schema.TypeString,
                        Description: "Key is the taint key that the toleration applies to. Empty means match all taint keys. If the key is empty, operator must be Exists; this combination means to match all values and all keys.",
                        Optional:    true,
                },
                "operator": {
                        Type:         schema.TypeString,
                        Description:  "Operator represents a key's relationship to the value. Valid operators are Exists and Equal. Defaults to Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.",
                        Default:      "Equal",
                        Optional:     true,
                        ValidateFunc: validation.StringInSlice([]string{"Exists", "Equal"}, false),
                },
                "toleration_seconds": {
                        // Use TypeString to allow an "unspecified" value,
                        Type:         schema.TypeString,
                        Description:  "TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default, it is not set, which means tolerate the taint forever (do not evict). Zero and negative values will be treated as 0 (evict immediately) by the system.",
                        Optional:     true,
                        ValidateFunc: utils.ValidateTypeStringNullableInt,
                },
                "value": {
                        Type:        schema.TypeString,
                        Description: "Value is the taint value the toleration matches to. If the operator is Exists, the value should be empty, otherwise just a regular string.",
                        Optional:    true,
                },
        }
}</span>

func TolerationSchema() *schema.Schema <span class="cov8" title="1">{
        fields := tolerationFields()

        return &amp;schema.Schema{
                Type:        schema.TypeList,
                Optional:    true,
                Description: "If specified, the pod's toleration. Optional: Defaults to empty",
                Elem: &amp;schema.Resource{
                        Schema: fields,
                },
        }
}</span>

func ExpandTolerations(tolerations []interface{}) ([]v1.Toleration, error) <span class="cov0" title="0">{
        if len(tolerations) == 0 </span><span class="cov0" title="0">{
                return []v1.Toleration{}, nil
        }</span>
        <span class="cov0" title="0">ts := make([]v1.Toleration, len(tolerations))
        for i, t := range tolerations </span><span class="cov0" title="0">{
                m := t.(map[string]interface{})
                ts[i] = v1.Toleration{}

                if value, ok := m["effect"].(string); ok </span><span class="cov0" title="0">{
                        ts[i].Effect = v1.TaintEffect(value)
                }</span>
                <span class="cov0" title="0">if value, ok := m["key"].(string); ok </span><span class="cov0" title="0">{
                        ts[i].Key = value
                }</span>
                <span class="cov0" title="0">if value, ok := m["operator"].(string); ok </span><span class="cov0" title="0">{
                        ts[i].Operator = v1.TolerationOperator(value)
                }</span>
                <span class="cov0" title="0">if value, ok := m["toleration_seconds"].(string); ok &amp;&amp; value != "" </span><span class="cov0" title="0">{
                        seconds, err := strconv.ParseInt(value, 10, 64)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("invalid toleration_seconds must be int or \"\", got \"%s\"", value)
                        }</span>
                        <span class="cov0" title="0">ts[i].TolerationSeconds = utils.PtrToInt64(seconds)</span>
                }
                <span class="cov0" title="0">if value, ok := m["value"]; ok </span><span class="cov0" title="0">{
                        ts[i].Value = value.(string)
                }</span>
        }
        <span class="cov0" title="0">return ts, nil</span>
}

func FlattenTolerations(tolerations []v1.Toleration) []interface{} <span class="cov0" title="0">{
        att := []interface{}{}
        for _, v := range tolerations </span><span class="cov0" title="0">{
                // The API Server may automatically add several Tolerations to pods, strip these to avoid TF diff.
                if strings.Contains(v.Key, "node.kubernetes.io/") </span><span class="cov0" title="0">{
                        log.Printf("[INFO] ignoring toleration with key: %s", v.Key)
                        continue</span>
                }
                <span class="cov0" title="0">obj := map[string]interface{}{}

                if v.Effect != "" </span><span class="cov0" title="0">{
                        obj["effect"] = string(v.Effect)
                }</span>
                <span class="cov0" title="0">if v.Key != "" </span><span class="cov0" title="0">{
                        obj["key"] = v.Key
                }</span>
                <span class="cov0" title="0">if v.Operator != "" </span><span class="cov0" title="0">{
                        obj["operator"] = string(v.Operator)
                }</span>
                <span class="cov0" title="0">if v.TolerationSeconds != nil </span><span class="cov0" title="0">{
                        obj["toleration_seconds"] = strconv.FormatInt(*v.TolerationSeconds, 10)
                }</span>
                <span class="cov0" title="0">if v.Value != "" </span><span class="cov0" title="0">{
                        obj["value"] = v.Value
                }</span>
                <span class="cov0" title="0">att = append(att, obj)</span>
        }
        <span class="cov0" title="0">return att</span>
}
</pre>
		
		<pre class="file" id="file85" style="display: none">package virtualmachine

import (
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
        k8sv1 "k8s.io/api/core/v1"
        kubevirtapiv1 "kubevirt.io/api/core/v1"
)

func virtualMachineConditionsFields() map[string]*schema.Schema <span class="cov8" title="1">{
        return map[string]*schema.Schema{
                "type": {
                        Type:        schema.TypeString,
                        Description: "VirtualMachineConditionType represent the type of the VM as concluded from its VMi status.",
                        Optional:    true,
                        ValidateFunc: validation.StringInSlice([]string{
                                "Failure",
                                "Ready",
                                "Paused",
                                "RenameOperation",
                        }, false),
                },
                "status": {
                        Type:        schema.TypeString,
                        Description: "ConditionStatus represents the status of this VM condition, if the VM currently in the condition.",
                        Optional:    true,
                        ValidateFunc: validation.StringInSlice([]string{
                                "True",
                                "False",
                                "Unknown",
                        }, false),
                },
                // TODO nargaman -  Add following values
                // "last_probe_time": {
                //         Type:        schema.TypeString,
                //         Description: "Last probe time.",
                //         Optional:    true,
                // },
                // "last_transition_time": {
                //         Type:        schema.TypeString,
                //         Description: "Last transition time.",
                //         Optional:    true,
                // },
                "reason": {
                        Type:        schema.TypeString,
                        Description: "Condition reason.",
                        Optional:    true,
                },
                "message": {
                        Type:        schema.TypeString,
                        Description: "Condition message.",
                        Optional:    true,
                },
        }
}</span>

func virtualMachineConditionsSchema() *schema.Schema <span class="cov8" title="1">{
        fields := virtualMachineConditionsFields()

        return &amp;schema.Schema{
                Type: schema.TypeList,

                Description: "Hold the state information of the VirtualMachine and its VirtualMachineInstance.",
                Required:    true,
                Elem: &amp;schema.Resource{
                        Schema: fields,
                },
        }
}</span>

func expandVirtualMachineConditions(conditions []interface{}) ([]kubevirtapiv1.VirtualMachineCondition, error) <span class="cov0" title="0">{
        result := make([]kubevirtapiv1.VirtualMachineCondition, len(conditions))

        if len(conditions) == 0 || conditions[0] == nil </span><span class="cov0" title="0">{
                return result, nil
        }</span>

        <span class="cov0" title="0">for i, condition := range conditions </span><span class="cov0" title="0">{
                in := condition.(map[string]interface{})

                if v, ok := in["type"].(string); ok </span><span class="cov0" title="0">{
                        result[i].Type = kubevirtapiv1.VirtualMachineConditionType(v)
                }</span>
                <span class="cov0" title="0">if v, ok := in["status"].(string); ok </span><span class="cov0" title="0">{
                        result[i].Status = k8sv1.ConditionStatus(v)
                }</span>
                <span class="cov0" title="0">if v, ok := in["reason"].(string); ok </span><span class="cov0" title="0">{
                        result[i].Reason = v
                }</span>
                <span class="cov0" title="0">if v, ok := in["message"].(string); ok </span><span class="cov0" title="0">{
                        result[i].Message = v
                }</span>
        }

        <span class="cov0" title="0">return result, nil</span>
}

func flattenVirtualMachineConditions(in []kubevirtapiv1.VirtualMachineCondition) []interface{} <span class="cov0" title="0">{
        att := make([]interface{}, len(in))

        for i, v := range in </span><span class="cov0" title="0">{
                c := make(map[string]interface{})
                c["type"] = string(v.Type)
                c["status"] = string(v.Status)
                c["reason"] = v.Reason
                c["message"] = v.Message

                att[i] = c
        }</span>

        <span class="cov0" title="0">return att</span>
}
</pre>
		
		<pre class="file" id="file86" style="display: none">package virtualmachine

import (
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        kubevirtapiv1 "kubevirt.io/api/core/v1"

        "github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/kubevirt/schema/datavolume"
        "github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/kubevirt/schema/k8s"
)

func DataVolumeFields() map[string]*schema.Schema <span class="cov8" title="1">{
        return map[string]*schema.Schema{
                "metadata": k8s.NamespacedMetadataSchema("DataVolume", false),
                "spec":     datavolume.DataVolumeSpecSchema(),
        }
}</span>

func dataVolumeTemplatesSchema() *schema.Schema <span class="cov8" title="1">{
        fields := DataVolumeFields()

        return &amp;schema.Schema{
                Type:        schema.TypeList,
                Description: "dataVolumeTemplates is a list of dataVolumes that the VirtualMachineInstance template can reference.",
                Optional:    true,
                Elem: &amp;schema.Resource{
                        Schema: fields,
                },
        }
}</span>

func expandDataVolumeTemplates(dataVolumes []interface{}) ([]kubevirtapiv1.DataVolumeTemplateSpec, error) <span class="cov0" title="0">{
        result := make([]kubevirtapiv1.DataVolumeTemplateSpec, len(dataVolumes))

        if len(dataVolumes) == 0 || dataVolumes[0] == nil </span><span class="cov0" title="0">{
                return result, nil
        }</span>

        <span class="cov0" title="0">for i, dataVolume := range dataVolumes </span><span class="cov0" title="0">{
                in := dataVolume.(map[string]interface{})

                if v, ok := in["metadata"].([]interface{}); ok </span><span class="cov0" title="0">{
                        result[i].ObjectMeta = k8s.ExpandMetadata(v)
                }</span>
                <span class="cov0" title="0">if v, ok := in["spec"].([]interface{}); ok </span><span class="cov0" title="0">{
                        spec, err := datavolume.ExpandDataVolumeSpec(v)
                        if err != nil </span><span class="cov0" title="0">{
                                return result, err
                        }</span>
                        <span class="cov0" title="0">result[i].Spec = spec</span>
                }
        }

        <span class="cov0" title="0">return result, nil</span>
}

func flattenDataVolumeTemplates(in []kubevirtapiv1.DataVolumeTemplateSpec, resourceData *schema.ResourceData) []interface{} <span class="cov0" title="0">{
        att := make([]interface{}, len(in))

        for i, v := range in </span><span class="cov0" title="0">{
                c := make(map[string]interface{})
                c["metadata"] = k8s.FlattenMetadataDataVolume(v.ObjectMeta)
                c["spec"] = datavolume.FlattenDataVolumeSpec(v.Spec)
                att[i] = c
        }</span>

        <span class="cov0" title="0">return att</span>
}
</pre>
		
		<pre class="file" id="file87" style="display: none">package virtualmachine

import (
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        kubevirtapiv1 "kubevirt.io/api/core/v1"

        "github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/kubevirt/schema/virtualmachineinstance"
)

func ExpandVirtualMachineSpec(d *schema.ResourceData) (kubevirtapiv1.VirtualMachineSpec, error) <span class="cov0" title="0">{
        result := kubevirtapiv1.VirtualMachineSpec{}

        if v, ok := d.GetOk("run_strategy"); ok </span><span class="cov0" title="0">{
                if v.(string) != "" </span><span class="cov0" title="0">{
                        runStrategy := kubevirtapiv1.VirtualMachineRunStrategy(v.(string))
                        result.RunStrategy = &amp;runStrategy
                }</span>
        }

        <span class="cov0" title="0">if template, err := virtualmachineinstance.ExpandVirtualMachineInstanceTemplateSpec(d); err == nil &amp;&amp; template != nil </span><span class="cov0" title="0">{
                result.Template = template
        }</span> else<span class="cov0" title="0"> {
                return result, err
        }</span>

        <span class="cov0" title="0">if v, ok := d.GetOk("data_volume_templates"); ok </span><span class="cov0" title="0">{
                dataVolumeTemplates, err := expandDataVolumeTemplates(v.([]interface{}))
                if err != nil </span><span class="cov0" title="0">{
                        return result, err
                }</span>
                <span class="cov0" title="0">result.DataVolumeTemplates = dataVolumeTemplates</span>
        }

        <span class="cov0" title="0">return result, nil</span>
}

func FlattenVirtualMachineSpec(in kubevirtapiv1.VirtualMachineSpec, resourceData *schema.ResourceData) []interface{} <span class="cov0" title="0">{
        att := make(map[string]interface{})

        if in.RunStrategy != nil </span><span class="cov0" title="0">{
                att["run_strategy"] = string(*in.RunStrategy)
        }</span>
        <span class="cov0" title="0">if in.Template != nil </span><span class="cov0" title="0">{
                att["template"] = virtualmachineinstance.FlattenVirtualMachineInstanceTemplateSpec(*in.Template, resourceData)
        }</span> else<span class="cov0" title="0"> {
                att["template"] = []interface{}{} // Set to empty value
        }</span>
        <span class="cov0" title="0">if in.DataVolumeTemplates != nil </span><span class="cov0" title="0">{
                att["data_volume_templates"] = flattenDataVolumeTemplates(in.DataVolumeTemplates, resourceData)
        }</span> else<span class="cov0" title="0"> {
                att["data_volume_templates"] = []interface{}{} // Set to empty value
        }</span>

        <span class="cov0" title="0">return []interface{}{att}</span>
}

func FlattenVMMToSpectroSchema(in kubevirtapiv1.VirtualMachineSpec, resourceData *schema.ResourceData) error <span class="cov0" title="0">{
        VM := FlattenVirtualMachineSpec(in, resourceData)[0].(map[string]interface{})
        // template spec
        VMTemplate := VM["template"]
        VMTemplateSpec := VMTemplate.([]interface{})[0].(map[string]interface{})["spec"]
        VMTemplateSpecAttributes := VMTemplateSpec.([]interface{})[0].(map[string]interface{})

        // domain spec
        vmDomain := VMTemplateSpecAttributes["domain"].([]interface{})[0].(map[string]interface{})
        vmTolerations := VMTemplateSpecAttributes["tolerations"]
        resource := vmDomain["resources"]
        cpu := vmDomain["cpu"]
        memory := vmDomain["memory"]
        firmware := vmDomain["firmware"]
        features := vmDomain["features"]
        device := vmDomain["devices"].([]interface{})[0].(map[string]interface{})
        disks := device["disk"]
        interfaces := device["interface"]

        // Not checking key exist for all required attributes, this will be revamped. if needed.

        if err := resourceData.Set("run_strategy", VM["run_strategy"]); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := resourceData.Set("node_selector", VMTemplateSpecAttributes["node_selector"]); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := resourceData.Set("affinity", VMTemplateSpecAttributes["affinity"]); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := resourceData.Set("scheduler_name", VMTemplateSpecAttributes["scheduler_name"]); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := resourceData.Set("hostname", VMTemplateSpecAttributes["hostname"]); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := resourceData.Set("subdomain", VMTemplateSpecAttributes["subdomain"]); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := resourceData.Set("dns_policy", VMTemplateSpecAttributes["dns_policy"]); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := resourceData.Set("priority_class_name", VMTemplateSpecAttributes["priority_class_name"]); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := resourceData.Set("network", VMTemplateSpecAttributes["network"]); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := resourceData.Set("volume", VMTemplateSpecAttributes["volume"]); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := resourceData.Set("cpu", cpu); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := resourceData.Set("memory", memory); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := resourceData.Set("firmware", firmware); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := resourceData.Set("features", features); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := resourceData.Set("resources", resource); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := resourceData.Set("disk", disks); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := resourceData.Set("interface", interfaces); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := resourceData.Set("tolerations", vmTolerations); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // checking key exist for all optional attributes
        <span class="cov0" title="0">if v, ok := VMTemplateSpecAttributes["eviction_strategy"]; !ok </span><span class="cov0" title="0">{
                if err := resourceData.Set("eviction_strategy", v); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">if v, ok := VMTemplateSpecAttributes["termination_grace_period_seconds"]; !ok </span><span class="cov0" title="0">{
                if err := resourceData.Set("termination_grace_period_seconds", v); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">if v, ok := VMTemplateSpecAttributes["liveness_probe"]; !ok </span><span class="cov0" title="0">{
                if err := resourceData.Set("liveness_probe", v); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">if v, ok := VMTemplateSpecAttributes["readiness_probe"]; !ok </span><span class="cov0" title="0">{
                if err := resourceData.Set("readiness_probe", v); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">if v, ok := VMTemplateSpecAttributes["pod_dns_config"]; !ok </span><span class="cov0" title="0">{
                if err := resourceData.Set("pod_dns_config", v); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">if err := resourceData.Set("data_volume_templates", VM["data_volume_templates"]); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file88" style="display: none">package virtualmachine

import (
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
        k8stypes "k8s.io/apimachinery/pkg/types"
        kubevirtapiv1 "kubevirt.io/api/core/v1"

        "github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/kubevirt/utils"
)

func virtualMachineStateChangeRequestFields() map[string]*schema.Schema <span class="cov8" title="1">{
        return map[string]*schema.Schema{
                "action": {
                        Type:        schema.TypeString,
                        Description: "Indicates the type of action that is requested. e.g. Start or Stop.",
                        Optional:    true,
                        ValidateFunc: validation.StringInSlice([]string{
                                "Start",
                                "Stop",
                        }, false),
                },
                "data": {
                        Type:        schema.TypeMap,
                        Description: "Provides additional data in order to perform the Action.",
                        Optional:    true,
                        Elem:        &amp;schema.Schema{Type: schema.TypeString},
                },
                "uid": {
                        Type:        schema.TypeString,
                        Description: "Indicates the UUID of an existing Virtual Machine Instance that this change request applies to -- if applicable.",
                        Optional:    true,
                },
        }
}</span>

func virtualMachineStateChangeRequestsSchema() *schema.Schema <span class="cov8" title="1">{
        fields := virtualMachineStateChangeRequestFields()

        return &amp;schema.Schema{
                Type: schema.TypeList,

                Description: "StateChangeRequests indicates a list of actions that should be taken on a VMI.",
                Required:    true,
                Elem: &amp;schema.Resource{
                        Schema: fields,
                },
        }
}</span>

func expandVirtualMachineStateChangeRequests(virtualMachineStateChangeRequests []interface{}) []kubevirtapiv1.VirtualMachineStateChangeRequest <span class="cov0" title="0">{
        result := make([]kubevirtapiv1.VirtualMachineStateChangeRequest, len(virtualMachineStateChangeRequests))

        if len(virtualMachineStateChangeRequests) == 0 || virtualMachineStateChangeRequests[0] == nil </span><span class="cov0" title="0">{
                return result
        }</span>

        <span class="cov0" title="0">for i, virtualMachineStateChangeRequest := range virtualMachineStateChangeRequests </span><span class="cov0" title="0">{
                in := virtualMachineStateChangeRequest.(map[string]interface{})

                if v, ok := in["action"].(string); ok </span><span class="cov0" title="0">{
                        result[i].Action = kubevirtapiv1.StateChangeRequestAction(v)
                }</span>
                <span class="cov0" title="0">if v, ok := in["data"].(map[string]interface{}); ok &amp;&amp; len(v) &gt; 0 </span><span class="cov0" title="0">{
                        result[i].Data = utils.ExpandStringMap(v)
                }</span>
                <span class="cov0" title="0">if v, ok := in["uid"].(string); ok </span><span class="cov0" title="0">{
                        uid := k8stypes.UID(v)
                        result[i].UID = &amp;uid
                }</span>
        }

        <span class="cov0" title="0">return result</span>
}

func flattenVirtualMachineStateChangeRequests(in []kubevirtapiv1.VirtualMachineStateChangeRequest) []interface{} <span class="cov0" title="0">{
        att := make([]interface{}, len(in))

        for i, v := range in </span><span class="cov0" title="0">{
                c := make(map[string]interface{})

                c["action"] = string(v.Action)
                c["data"] = v.Data
                if v.UID != nil </span><span class="cov0" title="0">{
                        c["uid"] = string(*v.UID)
                }</span>

                <span class="cov0" title="0">att[i] = c</span>
        }

        <span class="cov0" title="0">return att</span>
}
</pre>
		
		<pre class="file" id="file89" style="display: none">package virtualmachine

import (
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        kubevirtapiv1 "kubevirt.io/api/core/v1"
)

func virtualMachineStatusFields() map[string]*schema.Schema <span class="cov8" title="1">{
        return map[string]*schema.Schema{
                "created": &amp;schema.Schema{
                        Type:        schema.TypeBool,
                        Description: "Created indicates if the virtual machine is created in the cluster.",
                        Optional:    true,
                },
                "ready": &amp;schema.Schema{
                        Type:        schema.TypeBool,
                        Description: "Ready indicates if the virtual machine is running and ready.",
                        Optional:    true,
                },
                "conditions":            virtualMachineConditionsSchema(),
                "state_change_requests": virtualMachineStateChangeRequestsSchema(),
        }
}</span>

func virtualMachineStatusSchema() *schema.Schema <span class="cov8" title="1">{
        fields := virtualMachineStatusFields()

        return &amp;schema.Schema{
                Type:        schema.TypeList,
                Computed:    true,
                Description: "VirtualMachineStatus represents the status returned by the controller to describe how the VirtualMachine is doing.",
                Optional:    true,
                MaxItems:    1,
                Elem: &amp;schema.Resource{
                        Schema: fields,
                },
        }
}</span>

func expandVirtualMachineStatus(virtualMachineStatus []interface{}) (kubevirtapiv1.VirtualMachineStatus, error) <span class="cov0" title="0">{
        result := kubevirtapiv1.VirtualMachineStatus{}

        if len(virtualMachineStatus) == 0 || virtualMachineStatus[0] == nil </span><span class="cov0" title="0">{
                return result, nil
        }</span>

        <span class="cov0" title="0">in := virtualMachineStatus[0].(map[string]interface{})

        if v, ok := in["created"].(bool); ok </span><span class="cov0" title="0">{
                result.Created = v
        }</span>
        <span class="cov0" title="0">if v, ok := in["ready"].(bool); ok </span><span class="cov0" title="0">{
                result.Ready = v
        }</span>
        <span class="cov0" title="0">if v, ok := in["conditions"].([]interface{}); ok </span><span class="cov0" title="0">{
                conditions, err := expandVirtualMachineConditions(v)
                if err != nil </span><span class="cov0" title="0">{
                        return result, err
                }</span>
                <span class="cov0" title="0">result.Conditions = conditions</span>
        }
        <span class="cov0" title="0">if v, ok := in["state_change_requests"].([]interface{}); ok </span><span class="cov0" title="0">{
                result.StateChangeRequests = expandVirtualMachineStateChangeRequests(v)
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

func flattenVirtualMachineStatus(in kubevirtapiv1.VirtualMachineStatus) []interface{} <span class="cov0" title="0">{
        att := make(map[string]interface{})

        att["created"] = in.Created
        att["ready"] = in.Ready
        att["conditions"] = flattenVirtualMachineConditions(in.Conditions)
        att["state_change_requests"] = flattenVirtualMachineStateChangeRequests(in.StateChangeRequests)

        return []interface{}{att}
}</span>
</pre>
		
		<pre class="file" id="file90" style="display: none">package virtualmachine

import (
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
        "github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/kubevirt/schema/k8s"
        "github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/kubevirt/schema/virtualmachineinstance"
        "github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/kubevirt/utils"

        kubevirtapiv1 "kubevirt.io/api/core/v1"
)

func VirtualMachineFields() map[string]*schema.Schema <span class="cov8" title="1">{
        return map[string]*schema.Schema{
                // Flatten metadata data attributes
                "name": {
                        Type:         schema.TypeString,
                        Description:  "Name of the virtual machine, must be unique. Cannot be updated.",
                        Required:     true,
                        ForceNew:     true,
                        ValidateFunc: utils.ValidateName,
                },
                "generate_name": {
                        Type:         schema.TypeString,
                        Description:  "Prefix, used by the server, to generate a unique name ONLY IF the `name` field has not been provided. This value will also be combined with a unique suffix. Read more: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#idempotency",
                        Optional:     true,
                        ValidateFunc: utils.ValidateGenerateName,
                },
                "namespace": {
                        Type:        schema.TypeString,
                        Description: "Namespace defines the space within, Name must be unique.",
                        Optional:    true,
                        ForceNew:    true,
                        Default:     "default",
                },
                "labels": {
                        Type:         schema.TypeMap,
                        Description:  "Map of string keys and values that can be used to organize and categorize (scope and select). May match selectors of replication controllers and services.",
                        Optional:     true,
                        Elem:         &amp;schema.Schema{Type: schema.TypeString},
                        ValidateFunc: utils.ValidateLabels,
                },
                "annotations": {
                        Type:         schema.TypeMap,
                        Description:  "An unstructured key value map stored with the VM that may be used to store arbitrary metadata.",
                        Optional:     true,
                        Elem:         &amp;schema.Schema{Type: schema.TypeString},
                        ValidateFunc: utils.ValidateAnnotations,
                        Computed:     true,
                },
                "generation": {
                        Type:        schema.TypeInt,
                        Description: "A sequence number representing a specific generation of the desired state.",
                        Computed:    true,
                },
                "resource_version": {
                        Type:        schema.TypeString,
                        Description: "An opaque value that represents the internal version of this VM that can be used by clients to determine when VM has changed.",
                        Computed:    true,
                },
                "self_link": {
                        Type:        schema.TypeString,
                        Description: "A URL representing this VM.",
                        Computed:    true,
                },

                "uid": {
                        Type:        schema.TypeString,
                        Description: "The unique in time and space value for this VM.",
                        Computed:    true,
                },

                "cluster_uid": {
                        Type:        schema.TypeString,
                        Required:    true,
                        ForceNew:    true,
                        Description: "The cluster UID to which the virtual machine belongs to.",
                },
                "cluster_context": {
                        Type:         schema.TypeString,
                        Optional:     true,
                        Default:      "project",
                        Description:  "Context of the cluster. Allowed values are `project`, `tenant`. Default value is `project`.",
                        ValidateFunc: validation.StringInSlice([]string{"", "project", "tenant"}, false),
                },
                "base_vm_name": {
                        Type:        schema.TypeString,
                        Optional:    true,
                        ForceNew:    true,
                        Description: "The name of the source virtual machine that a clone will be created of.",
                },
                "run_on_launch": {
                        Type:        schema.TypeBool,
                        Optional:    true,
                        Description: "If set to `true`, the virtual machine will be started when the cluster is launched. Default value is `true`.",
                },
                "vm_action": {
                        Type:         schema.TypeString,
                        Optional:     true,
                        ValidateFunc: validation.StringInSlice([]string{"", "start", "stop", "restart", "pause", "resume", "migrate"}, false),
                        Description:  "The action to be performed on the virtual machine. Valid values are: `start`, `stop`, `restart`, `pause`, `resume`, `migrate`. Default value is `start`.",
                },
                "data_volume_templates": dataVolumeTemplatesSchema(),
                "run_strategy": {
                        Type:         schema.TypeString,
                        Description:  "Running state indicates the requested running state of the VirtualMachineInstance, mutually exclusive with Running.",
                        ExactlyOneOf: []string{"run_strategy", "run_on_launch"},
                        Optional:     true,
                        ValidateFunc: validation.StringInSlice([]string{
                                "",
                                "Always",
                                "Halted",
                                "Manual",
                                "RerunOnFailure",
                        }, false),
                },
                "disk": {
                        Type:        schema.TypeList,
                        Description: "Disks describes disks, cdroms, floppy and luns which are connected to the vmi.",
                        Optional:    true,
                        Elem: &amp;schema.Resource{
                                Schema: map[string]*schema.Schema{
                                        "name": {
                                                Type:        schema.TypeString,
                                                Description: "Name is the device name",
                                                Required:    true,
                                        },
                                        "disk_device": {
                                                Type:        schema.TypeList,
                                                Description: "DiskDevice specifies as which device the disk should be added to the guest.",
                                                Required:    true,
                                                Elem: &amp;schema.Resource{
                                                        Schema: map[string]*schema.Schema{
                                                                "disk": {
                                                                        Type:        schema.TypeList,
                                                                        Description: "Attach a volume as a disk to the vmi.",
                                                                        Optional:    true,
                                                                        Elem: &amp;schema.Resource{
                                                                                Schema: map[string]*schema.Schema{
                                                                                        "bus": {
                                                                                                Type:        schema.TypeString,
                                                                                                Description: "Bus indicates the type of disk device to emulate.",
                                                                                                Required:    true,
                                                                                        },
                                                                                        "read_only": {
                                                                                                Type:        schema.TypeBool,
                                                                                                Description: "ReadOnly. Defaults to false.",
                                                                                                Optional:    true,
                                                                                        },
                                                                                        "pci_address": {
                                                                                                Type:        schema.TypeString,
                                                                                                Description: "If specified, the virtual disk will be placed on the guests pci address with the specified PCI address. For example: 0000:81:01.10",
                                                                                                Optional:    true,
                                                                                        },
                                                                                },
                                                                        },
                                                                },
                                                        },
                                                },
                                        },
                                        "serial": {
                                                Type:        schema.TypeString,
                                                Description: "Serial provides the ability to specify a serial number for the disk device.",
                                                Optional:    true,
                                        },
                                        "boot_order": {
                                                Type:        schema.TypeInt,
                                                Description: "BootOrder is an integer value &gt; 0, used to determine ordering of boot devices. Lower values take precedence.",
                                                Optional:    true,
                                        },
                                },
                        },
                },
                "interface": {
                        Type:        schema.TypeList,
                        Description: "Interfaces describe network interfaces which are added to the vmi.",
                        Optional:    true,
                        Elem: &amp;schema.Resource{
                                Schema: map[string]*schema.Schema{
                                        "name": {
                                                Type:        schema.TypeString,
                                                Description: "Logical name of the interface as well as a reference to the associated networks.",
                                                Required:    true,
                                        },
                                        "interface_binding_method": {
                                                Type: schema.TypeString,
                                                ValidateFunc: validation.StringInSlice([]string{
                                                        "InterfaceBridge",
                                                        "InterfaceSlirp",
                                                        "InterfaceMasquerade",
                                                        "InterfaceSRIOV",
                                                }, false),
                                                Description: "Represents the Interface model, One of: e1000, e1000e, ne2k_pci, pcnet, rtl8139, virtio. Defaults to virtio.",
                                                Required:    true,
                                        },
                                        "model": {
                                                Type:     schema.TypeString,
                                                Optional: true,
                                                ValidateFunc: validation.StringInSlice([]string{
                                                        "",
                                                        "e1000",
                                                        "e1000e",
                                                        "ne2k_pci",
                                                        "pcnet",
                                                        "rtl8139",
                                                        "virtio",
                                                }, false),
                                                Description: "Represents the method which will be used to connect the interface to the guest.",
                                        },
                                },
                        },
                },
                "resources": {
                        Type:        schema.TypeList,
                        Description: "Resources describes the Compute Resources required by this vmi.",
                        MaxItems:    1,
                        Required:    true,
                        Elem: &amp;schema.Resource{
                                Schema: map[string]*schema.Schema{
                                        "requests": {
                                                Type:        schema.TypeMap,
                                                Description: "Requests is a description of the initial vmi resources.",
                                                Optional:    true,
                                        },
                                        "limits": {
                                                Type:        schema.TypeMap,
                                                Description: "Requests is the maximum amount of compute resources allowed. Valid resource keys are \"memory\" and \"cpu\"",
                                                Optional:    true,
                                        },
                                        "over_commit_guest_overhead": {
                                                Type:        schema.TypeBool,
                                                Description: "Don't ask the scheduler to take the guest-management overhead into account. Instead put the overhead only into the container's memory limit. This can lead to crashes if all memory is in use on a node. Defaults to false.",
                                                Optional:    true,
                                        },
                                },
                        },
                },
                "cpu": {
                        Type:        schema.TypeList,
                        Description: "CPU allows to specifying the CPU topology. Valid resource keys are \"cores\" , \"sockets\" and \"threads\"",
                        MaxItems:    1,
                        Optional:    true,
                        Elem: &amp;schema.Resource{
                                Schema: map[string]*schema.Schema{
                                        "cores": {
                                                Type:        schema.TypeInt,
                                                Description: "Cores is the number of cores inside the vmi. Must be a value greater or equal 1",
                                                Optional:    true,
                                        },
                                        "sockets": {
                                                Type:        schema.TypeInt,
                                                Description: "Sockets is the number of sockets inside the vmi. Must be a value greater or equal 1.",
                                                Optional:    true,
                                        },
                                        "threads": {
                                                Type:        schema.TypeInt,
                                                Description: "Threads is the number of threads inside the vmi. Must be a value greater or equal 1.",
                                                Optional:    true,
                                        },
                                },
                        },
                },
                "memory": {
                        Type:        schema.TypeList,
                        Description: "Memory allows specifying the vmi memory features.",
                        MaxItems:    1,
                        Optional:    true,
                        Elem: &amp;schema.Resource{
                                Schema: map[string]*schema.Schema{
                                        "guest": {
                                                Type:        schema.TypeString,
                                                Description: "Guest is the amount of memory allocated to the vmi. This value must be less than or equal to the limit if specified.",
                                                Optional:    true,
                                        },
                                        "hugepages": {
                                                Type: schema.TypeString,
                                                // PageSize specifies the hugepage size, for x86_64 architecture valid values are 1Gi and 2Mi.
                                                Description: "Hugepages attribute specifies the hugepage size, for x86_64 architecture valid values are 1Gi and 2Mi.",
                                                Optional:    true,
                                        },
                                },
                        },
                },
                "firmware": {
                        Type:        schema.TypeList,
                        Description: "Firmware configuration for the virtual machine.",
                        MaxItems:    1,
                        Optional:    true,
                        Elem: &amp;schema.Resource{
                                Schema: map[string]*schema.Schema{
                                        "uuid": {
                                                Type:        schema.TypeString,
                                                Description: "UUID reported by the vmi bios. Defaults to a random generated uid.",
                                                Optional:    true,
                                                Computed:    true,
                                        },
                                        "serial": {
                                                Type:        schema.TypeString,
                                                Optional:    true,
                                                Computed:    true,
                                                Description: "The system-serial-number in SMBIOS.",
                                        },
                                        "bootloader": {
                                                Type:        schema.TypeList,
                                                Description: "Settings to control the bootloader that is used.",
                                                MaxItems:    1,
                                                Optional:    true,
                                                Elem: &amp;schema.Resource{
                                                        Schema: map[string]*schema.Schema{
                                                                "bios": {
                                                                        Type:        schema.TypeList,
                                                                        Description: "If set (default), BIOS will be used.",
                                                                        MaxItems:    1,
                                                                        Optional:    true,
                                                                        Elem: &amp;schema.Resource{
                                                                                Schema: map[string]*schema.Schema{
                                                                                        "use_serial": {
                                                                                                Type:        schema.TypeBool,
                                                                                                Description: "If set, the BIOS output will be transmitted over serial.",
                                                                                                Optional:    true,
                                                                                        },
                                                                                },
                                                                        },
                                                                },
                                                                "efi": {
                                                                        Type:        schema.TypeList,
                                                                        Description: "If set, EFI will be used instead of BIOS.",
                                                                        MaxItems:    1,
                                                                        Optional:    true,
                                                                        Elem: &amp;schema.Resource{
                                                                                Schema: map[string]*schema.Schema{
                                                                                        "secure_boot": {
                                                                                                Type:        schema.TypeBool,
                                                                                                Description: "If set, SecureBoot will be enabled and the OVMF roms will be swapped for SecureBoot-enabled ones. Requires SMM to be enabled. Defaults to true.",
                                                                                                Optional:    true,
                                                                                        },
                                                                                        "persistent": {
                                                                                                Type:        schema.TypeBool,
                                                                                                Description: "If set to true, Persistent will persist the EFI NVRAM across reboots. Defaults to false.",
                                                                                                Optional:    true,
                                                                                        },
                                                                                },
                                                                        },
                                                                },
                                                        },
                                                },
                                        },
                                },
                        },
                },
                "features": {
                        Type:        schema.TypeList,
                        Description: "Features allows to configure various virtualization features.",
                        MaxItems:    1,
                        Optional:    true,
                        Elem: &amp;schema.Resource{
                                Schema: map[string]*schema.Schema{
                                        "acpi": {
                                                Type:        schema.TypeList,
                                                Description: "ACPI enables/disables ACPI inside the guest. Defaults to enabled.",
                                                MaxItems:    1,
                                                Optional:    true,
                                                Elem: &amp;schema.Resource{
                                                        Schema: map[string]*schema.Schema{
                                                                "enabled": {
                                                                        Type:        schema.TypeBool,
                                                                        Description: "Enabled determines if the feature should be enabled or disabled on the guest. Defaults to true.",
                                                                        Optional:    true,
                                                                        Default:     true,
                                                                },
                                                        },
                                                },
                                        },
                                        "apic": {
                                                Type:        schema.TypeList,
                                                Description: "APIC enables/disables APIC inside the guest. Defaults to enabled.",
                                                MaxItems:    1,
                                                Optional:    true,
                                                Elem: &amp;schema.Resource{
                                                        Schema: map[string]*schema.Schema{
                                                                "enabled": {
                                                                        Type:        schema.TypeBool,
                                                                        Description: "Enabled determines if the feature should be enabled or disabled on the guest. Defaults to true.",
                                                                        Optional:    true,
                                                                        Default:     true,
                                                                },
                                                        },
                                                },
                                        },
                                        "smm": {
                                                Type:        schema.TypeList,
                                                Description: "SMM enables/disables System Management Mode. Required for Secure Boot with EFI.",
                                                MaxItems:    1,
                                                Optional:    true,
                                                Elem: &amp;schema.Resource{
                                                        Schema: map[string]*schema.Schema{
                                                                "enabled": {
                                                                        Type:        schema.TypeBool,
                                                                        Description: "Enabled determines if the feature should be enabled or disabled on the guest.",
                                                                        Optional:    true,
                                                                },
                                                        },
                                                },
                                        },
                                },
                        },
                },
                "network": virtualmachineinstance.NetworksSchema(),
                "volume":  virtualmachineinstance.VolumesSchema(),
                "priority_class_name": {
                        Type:        schema.TypeString,
                        Description: "If specified, indicates the pod's priority. If not specified, the pod priority will be default or zero if there is no default.",
                        Optional:    true,
                },
                "node_selector": {
                        Type:        schema.TypeMap,
                        Description: "NodeSelector is a selector which must be true for the vmi to fit on a node. Selector which must match a node's labels for the vmi to be scheduled on that node.",
                        Optional:    true,
                        Elem:        &amp;schema.Schema{Type: schema.TypeString},
                },
                "affinity": k8s.AffinitySchema(),
                "scheduler_name": {
                        Type:        schema.TypeString,
                        Description: "If specified, the VMI will be dispatched by specified scheduler. If not specified, the VMI will be dispatched by default scheduler.",
                        Optional:    true,
                },
                "tolerations": k8s.TolerationSchema(),
                "eviction_strategy": {
                        Type:        schema.TypeString,
                        Description: "EvictionStrategy can be set to \"LiveMigrate\" if the VirtualMachineInstance should be migrated instead of shut-off in case of a node drain.",
                        Optional:    true,
                        ValidateFunc: validation.StringInSlice([]string{
                                "LiveMigrate",
                        }, false),
                },
                "termination_grace_period_seconds": {
                        Type:        schema.TypeInt,
                        Description: "Grace period observed after signalling a VirtualMachineInstance to stop after which the VirtualMachineInstance is force terminated.",
                        Optional:    true,
                },
                "liveness_probe":  virtualmachineinstance.ProbeSchema(),
                "readiness_probe": virtualmachineinstance.ProbeSchema(),
                "hostname": {
                        Type:        schema.TypeString,
                        Description: "Specifies the hostname of the vmi.",
                        Optional:    true,
                },
                "subdomain": {
                        Type:        schema.TypeString,
                        Description: "If specified, the fully qualified vmi hostname will be \"&lt;hostname&gt;.&lt;subdomain&gt;.&lt;pod namespace&gt;.svc.&lt;cluster domain&gt;\".",
                        Optional:    true,
                },
                "dns_policy": {
                        Type:        schema.TypeString,
                        Description: "DNSPolicy defines how a pod's DNS will be configured.",
                        Optional:    true,
                        ValidateFunc: validation.StringInSlice([]string{
                                "ClusterFirstWithHostNet",
                                "ClusterFirst",
                                "Default",
                                "None",
                        }, false),
                },
                "pod_dns_config": k8s.PodDnsConfigSchema(),

                "status": virtualMachineStatusSchema(),
        }
}</span>

func FromResourceData(resourceData *schema.ResourceData) (*kubevirtapiv1.VirtualMachine, error) <span class="cov0" title="0">{
        result := &amp;kubevirtapiv1.VirtualMachine{}

        result.ObjectMeta = k8s.ConvertToBasicMetadata(resourceData)
        spec, err := ExpandVirtualMachineSpec(resourceData)
        if err != nil </span><span class="cov0" title="0">{
                return result, err
        }</span>
        <span class="cov0" title="0">result.Spec = spec
        status, err := expandVirtualMachineStatus(resourceData.Get("status").([]interface{}))
        if err != nil </span><span class="cov0" title="0">{
                return result, err
        }</span>
        <span class="cov0" title="0">result.Status = status

        return result, nil</span>
}

func ToResourceData(vm kubevirtapiv1.VirtualMachine, resourceData *schema.ResourceData) error <span class="cov0" title="0">{
        if err := k8s.FlattenMetadata(vm.ObjectMeta, resourceData); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := FlattenVMMToSpectroSchema(vm.Spec, resourceData); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := resourceData.Set("status", flattenVirtualMachineStatus(vm.Status)); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file91" style="display: none">package virtualmachineinstance

import (
        "fmt"
        "math"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "k8s.io/apimachinery/pkg/api/resource"
        "k8s.io/apimachinery/pkg/types"
        kubevirtapiv1 "kubevirt.io/api/core/v1"

        "github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/common"
        "github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/kubevirt/utils"
)

func ExpandDomainSpec(d *schema.ResourceData) (kubevirtapiv1.DomainSpec, error) <span class="cov0" title="0">{
        result := kubevirtapiv1.DomainSpec{}

        if v, ok := d.GetOk("resources"); ok </span><span class="cov0" title="0">{
                resources, err := expandResources(v.([]interface{}))
                if err != nil </span><span class="cov0" title="0">{
                        return result, err
                }</span>
                <span class="cov0" title="0">result.Resources = resources</span>
        }
        <span class="cov0" title="0">if devices, err := expandDevices(d); err == nil </span><span class="cov0" title="0">{
                result.Devices = devices
        }</span> else<span class="cov0" title="0"> {
                return result, err
        }</span>
        <span class="cov0" title="0">if v, ok := d.GetOk("cpu"); ok </span><span class="cov0" title="0">{
                cpu, err := expandCPU(v.([]interface{})[0].(map[string]interface{}))
                if err != nil </span><span class="cov0" title="0">{
                        return result, err
                }</span>
                <span class="cov0" title="0">result.CPU = &amp;cpu</span>
        }
        <span class="cov0" title="0">if v, ok := d.GetOk("memory"); ok </span><span class="cov0" title="0">{
                memory, err := expandMemory(v.([]interface{}))
                if err != nil </span><span class="cov0" title="0">{
                        return result, err
                }</span>
                <span class="cov0" title="0">result.Memory = &amp;memory</span>
        }
        <span class="cov0" title="0">if v, ok := d.GetOk("firmware"); ok </span><span class="cov0" title="0">{
                firmware, err := expandFirmware(v.([]interface{}))
                if err != nil </span><span class="cov0" title="0">{
                        return result, err
                }</span>
                <span class="cov0" title="0">result.Firmware = firmware</span>
        }
        <span class="cov0" title="0">if v, ok := d.GetOk("features"); ok </span><span class="cov0" title="0">{
                features, err := expandFeatures(v.([]interface{}))
                if err != nil </span><span class="cov0" title="0">{
                        return result, err
                }</span>
                <span class="cov0" title="0">result.Features = features</span>
        }

        <span class="cov0" title="0">return result, nil</span>
}

func expandResources(resources []interface{}) (kubevirtapiv1.ResourceRequirements, error) <span class="cov0" title="0">{
        result := kubevirtapiv1.ResourceRequirements{}

        if len(resources) == 0 || resources[0] == nil </span><span class="cov0" title="0">{
                return result, nil
        }</span>

        <span class="cov0" title="0">in := resources[0].(map[string]interface{})

        if v, ok := in["requests"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                requests, err := utils.ExpandMapToResourceList(v)
                if err != nil </span><span class="cov0" title="0">{
                        return result, err
                }</span>
                <span class="cov0" title="0">result.Requests = *requests</span>
        }
        <span class="cov0" title="0">if v, ok := in["limits"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                limits, err := utils.ExpandMapToResourceList(v)
                if err != nil </span><span class="cov0" title="0">{
                        return result, err
                }</span>
                <span class="cov0" title="0">result.Limits = *limits</span>
        }
        <span class="cov0" title="0">if v, ok := in["over_commit_guest_overhead"].(bool); ok </span><span class="cov0" title="0">{
                result.OvercommitGuestOverhead = v
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

func expandDevices(d *schema.ResourceData) (kubevirtapiv1.Devices, error) <span class="cov0" title="0">{
        result := kubevirtapiv1.Devices{}

        if v, ok := d.GetOk("disk"); ok </span><span class="cov0" title="0">{
                result.Disks = ExpandDisks(v.([]interface{}))
        }</span>
        <span class="cov0" title="0">if v, ok := d.GetOk("interface"); ok </span><span class="cov0" title="0">{
                result.Interfaces = ExpandInterfaces(v.([]interface{}))
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

func expandCPU(cpu map[string]interface{}) (kubevirtapiv1.CPU, error) <span class="cov0" title="0">{
        result := kubevirtapiv1.CPU{}

        if len(cpu) == 0 </span><span class="cov0" title="0">{
                return result, nil
        }</span>

        <span class="cov0" title="0">if v, ok := cpu["cores"].(int); ok </span><span class="cov0" title="0">{
                if v &lt; 0 </span><span class="cov0" title="0">{
                        return result, fmt.Errorf("cores value %d cannot be negative", v)
                }</span>
                <span class="cov0" title="0">if v &gt; math.MaxInt </span><span class="cov0" title="0">{ // Cap to max representable int on this architecture
                        return result, fmt.Errorf("cores value %d is out of range for uint32", v)
                }</span>
                <span class="cov0" title="0">result.Cores = common.SafeUint32(v)</span>
        }
        <span class="cov0" title="0">if v, ok := cpu["sockets"].(int); ok </span><span class="cov0" title="0">{
                if v &lt; 0 </span><span class="cov0" title="0">{
                        return result, fmt.Errorf("sockets value %d cannot be negative", v)
                }</span>
                <span class="cov0" title="0">if v &gt; math.MaxInt </span><span class="cov0" title="0">{ // Cap to max representable int on this architecture
                        return result, fmt.Errorf("sockets value %d is out of range for uint32", v)
                }</span>
                <span class="cov0" title="0">result.Sockets = common.SafeUint32(v)</span>
        }
        <span class="cov0" title="0">if v, ok := cpu["threads"].(int); ok </span><span class="cov0" title="0">{
                if v &lt; 0 </span><span class="cov0" title="0">{
                        return result, fmt.Errorf("threads value %d cannot be negative", v)
                }</span>
                <span class="cov0" title="0">if v &gt; math.MaxInt </span><span class="cov0" title="0">{ // Cap to max representable int on this architecture
                        return result, fmt.Errorf("threads value %d is out of range for uint32", v)
                }</span>
                <span class="cov0" title="0">result.Threads = common.SafeUint32(v)</span>
        }

        <span class="cov0" title="0">return result, nil</span>
}

func expandMemory(memory []interface{}) (kubevirtapiv1.Memory, error) <span class="cov0" title="0">{
        result := kubevirtapiv1.Memory{}

        if len(memory) == 0 || memory[0] == nil </span><span class="cov0" title="0">{
                return result, nil
        }</span>

        <span class="cov0" title="0">in := memory[0].(map[string]interface{})

        if v, ok := in["guest"].(string); ok </span><span class="cov0" title="0">{
                got, err := resource.ParseQuantity(v)
                if err != nil </span><span class="cov0" title="0">{
                        return result, err
                }</span>
                <span class="cov0" title="0">result.Guest = &amp;got</span>
        }

        <span class="cov0" title="0">if v, ok := in["hugepages"].(string); ok </span><span class="cov0" title="0">{
                if in["hugepages"].(string) != "" </span><span class="cov0" title="0">{
                        result.Hugepages = &amp;kubevirtapiv1.Hugepages{
                                PageSize: v,
                        }
                }</span>
        }

        <span class="cov0" title="0">return result, nil</span>
}

func expandFirmware(firmware []interface{}) (*kubevirtapiv1.Firmware, error) <span class="cov0" title="0">{
        if len(firmware) == 0 || firmware[0] == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">result := &amp;kubevirtapiv1.Firmware{}
        in := firmware[0].(map[string]interface{})

        if v, ok := in["uuid"].(string); ok &amp;&amp; v != "" </span><span class="cov0" title="0">{
                result.UUID = types.UID(v)
        }</span>

        <span class="cov0" title="0">if v, ok := in["serial"].(string); ok &amp;&amp; v != "" </span><span class="cov0" title="0">{
                result.Serial = v
        }</span>

        <span class="cov0" title="0">if v, ok := in["bootloader"].([]interface{}); ok &amp;&amp; len(v) &gt; 0 </span><span class="cov0" title="0">{
                bootloader, err := expandBootloader(v)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">result.Bootloader = bootloader</span>
        }

        <span class="cov0" title="0">return result, nil</span>
}

func expandBootloader(bootloader []interface{}) (*kubevirtapiv1.Bootloader, error) <span class="cov0" title="0">{
        if len(bootloader) == 0 || bootloader[0] == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">result := &amp;kubevirtapiv1.Bootloader{}
        in := bootloader[0].(map[string]interface{})

        if v, ok := in["bios"].([]interface{}); ok &amp;&amp; len(v) &gt; 0 </span><span class="cov0" title="0">{
                bios, err := expandBIOS(v)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">result.BIOS = bios</span>
        }

        <span class="cov0" title="0">if v, ok := in["efi"].([]interface{}); ok &amp;&amp; len(v) &gt; 0 </span><span class="cov0" title="0">{
                efi, err := expandEFI(v)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">result.EFI = efi</span>
        }

        <span class="cov0" title="0">return result, nil</span>
}

func expandBIOS(bios []interface{}) (*kubevirtapiv1.BIOS, error) <span class="cov0" title="0">{
        if len(bios) == 0 || bios[0] == nil </span><span class="cov0" title="0">{
                return &amp;kubevirtapiv1.BIOS{}, nil
        }</span>

        <span class="cov0" title="0">result := &amp;kubevirtapiv1.BIOS{}
        in := bios[0].(map[string]interface{})

        if v, ok := in["use_serial"].(bool); ok </span><span class="cov0" title="0">{
                result.UseSerial = &amp;v
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

func expandEFI(efi []interface{}) (*kubevirtapiv1.EFI, error) <span class="cov0" title="0">{
        if len(efi) == 0 || efi[0] == nil </span><span class="cov0" title="0">{
                return &amp;kubevirtapiv1.EFI{}, nil
        }</span>

        <span class="cov0" title="0">result := &amp;kubevirtapiv1.EFI{}
        in := efi[0].(map[string]interface{})

        if v, ok := in["secure_boot"]; ok </span><span class="cov0" title="0">{
                if secureBoot, ok := v.(bool); ok </span><span class="cov0" title="0">{
                        result.SecureBoot = &amp;secureBoot
                }</span>
        }

        <span class="cov0" title="0">if v, ok := in["persistent"]; ok </span><span class="cov0" title="0">{
                if persistent, ok := v.(bool); ok </span><span class="cov0" title="0">{
                        result.Persistent = &amp;persistent
                }</span>
        }

        <span class="cov0" title="0">return result, nil</span>
}

func expandFeatures(features []interface{}) (*kubevirtapiv1.Features, error) <span class="cov0" title="0">{
        if len(features) == 0 || features[0] == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">result := &amp;kubevirtapiv1.Features{}
        in := features[0].(map[string]interface{})

        if v, ok := in["acpi"].([]interface{}); ok &amp;&amp; len(v) &gt; 0 </span><span class="cov0" title="0">{
                acpi, err := expandFeatureState(v)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">result.ACPI = *acpi</span>
        }

        <span class="cov0" title="0">if v, ok := in["apic"].([]interface{}); ok &amp;&amp; len(v) &gt; 0 </span><span class="cov0" title="0">{
                apic, err := expandFeatureState(v)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">result.APIC = &amp;kubevirtapiv1.FeatureAPIC{
                        Enabled: apic.Enabled,
                }</span>
        }

        <span class="cov0" title="0">if v, ok := in["smm"].([]interface{}); ok &amp;&amp; len(v) &gt; 0 </span><span class="cov0" title="0">{
                smm, err := expandFeatureState(v)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">result.SMM = smm</span>
        }

        <span class="cov0" title="0">return result, nil</span>
}

func expandFeatureState(featureState []interface{}) (*kubevirtapiv1.FeatureState, error) <span class="cov0" title="0">{
        if len(featureState) == 0 || featureState[0] == nil </span><span class="cov0" title="0">{
                return &amp;kubevirtapiv1.FeatureState{}, nil
        }</span>

        <span class="cov0" title="0">result := &amp;kubevirtapiv1.FeatureState{}
        in := featureState[0].(map[string]interface{})

        if v, ok := in["enabled"].(bool); ok </span><span class="cov0" title="0">{
                result.Enabled = &amp;v
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

func ExpandDisks(disks []interface{}) []kubevirtapiv1.Disk <span class="cov0" title="0">{
        result := make([]kubevirtapiv1.Disk, len(disks))

        if len(disks) == 0 || disks[0] == nil </span><span class="cov0" title="0">{
                return result
        }</span>

        <span class="cov0" title="0">for i, condition := range disks </span><span class="cov0" title="0">{
                in := condition.(map[string]interface{})

                if v, ok := in["name"].(string); ok </span><span class="cov0" title="0">{
                        result[i].Name = v
                }</span>
                <span class="cov0" title="0">if v, ok := in["disk_device"].([]interface{}); ok </span><span class="cov0" title="0">{
                        result[i].DiskDevice = expandDiskDevice(v)
                }</span>
                <span class="cov0" title="0">if v, ok := in["serial"].(string); ok </span><span class="cov0" title="0">{
                        result[i].Serial = v
                }</span>
                <span class="cov0" title="0">if v, ok := in["boot_order"].(int); ok &amp;&amp; v &gt; 0 </span><span class="cov0" title="0">{
                        bootOrder := uint(v)
                        result[i].BootOrder = &amp;bootOrder
                }</span>
        }

        <span class="cov0" title="0">return result</span>
}

func expandDiskDevice(diskDevice []interface{}) kubevirtapiv1.DiskDevice <span class="cov0" title="0">{
        result := kubevirtapiv1.DiskDevice{}

        if len(diskDevice) == 0 || diskDevice[0] == nil </span><span class="cov0" title="0">{
                return result
        }</span>

        <span class="cov0" title="0">in := diskDevice[0].(map[string]interface{})

        if v, ok := in["disk"].([]interface{}); ok </span><span class="cov0" title="0">{
                result.Disk = expandDiskTarget(v)
        }</span>

        <span class="cov0" title="0">return result</span>
}

func expandDiskTarget(disk []interface{}) *kubevirtapiv1.DiskTarget <span class="cov0" title="0">{
        if len(disk) == 0 || disk[0] == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">result := &amp;kubevirtapiv1.DiskTarget{}

        in := disk[0].(map[string]interface{})

        if v, ok := in["bus"].(string); ok </span><span class="cov0" title="0">{
                result.Bus = kubevirtapiv1.DiskBus(v)
        }</span>
        <span class="cov0" title="0">if v, ok := in["read_only"].(bool); ok </span><span class="cov0" title="0">{
                result.ReadOnly = v
        }</span>
        <span class="cov0" title="0">if v, ok := in["pci_address"].(string); ok </span><span class="cov0" title="0">{
                result.PciAddress = v
        }</span>

        <span class="cov0" title="0">return result</span>
}

func ExpandInterfaces(interfaces []interface{}) []kubevirtapiv1.Interface <span class="cov0" title="0">{
        result := make([]kubevirtapiv1.Interface, len(interfaces))

        if len(interfaces) == 0 || interfaces[0] == nil </span><span class="cov0" title="0">{
                return result
        }</span>

        <span class="cov0" title="0">for i, condition := range interfaces </span><span class="cov0" title="0">{
                in := condition.(map[string]interface{})

                if v, ok := in["name"].(string); ok </span><span class="cov0" title="0">{
                        result[i].Name = v
                }</span>
                <span class="cov0" title="0">if v, ok := in["interface_binding_method"].(string); ok </span><span class="cov0" title="0">{
                        result[i].InterfaceBindingMethod = expandInterfaceBindingMethod(v)
                }</span>
                <span class="cov0" title="0">if v, ok := in["model"].(string); ok </span><span class="cov0" title="0">{
                        result[i].Model = v
                }</span>
        }

        <span class="cov0" title="0">return result</span>
}

func expandInterfaceBindingMethod(interfaceBindingMethod string) kubevirtapiv1.InterfaceBindingMethod <span class="cov0" title="0">{
        result := kubevirtapiv1.InterfaceBindingMethod{}

        switch interfaceBindingMethod </span>{
        case "InterfaceBridge":<span class="cov0" title="0">
                result.Bridge = &amp;kubevirtapiv1.InterfaceBridge{}</span>
        case "InterfaceSlirp":<span class="cov0" title="0">
                result.DeprecatedSlirp = &amp;kubevirtapiv1.DeprecatedInterfaceSlirp{}</span>
        case "InterfaceMasquerade":<span class="cov0" title="0">
                result.Masquerade = &amp;kubevirtapiv1.InterfaceMasquerade{}</span>
        case "InterfaceSRIOV":<span class="cov0" title="0">
                result.SRIOV = &amp;kubevirtapiv1.InterfaceSRIOV{}</span>
        }

        <span class="cov0" title="0">return result</span>
}

func FlattenDomainSpec(in kubevirtapiv1.DomainSpec) []interface{} <span class="cov0" title="0">{
        att := make(map[string]interface{})

        att["resources"] = flattenResources(in.Resources)
        if in.CPU != nil &amp;&amp; in.CPU.Cores != 0 </span><span class="cov0" title="0">{
                att["cpu"] = flattenCPU(in.CPU)
        }</span>
        <span class="cov0" title="0">if in.Memory != nil &amp;&amp; (in.Memory.Guest != nil || in.Memory.Hugepages != nil) </span><span class="cov0" title="0">{
                att["memory"] = flattenMemory(in.Memory)
        }</span>
        <span class="cov0" title="0">if in.Firmware != nil </span><span class="cov0" title="0">{
                att["firmware"] = flattenFirmware(in.Firmware)
        }</span>
        <span class="cov0" title="0">if in.Features != nil </span><span class="cov0" title="0">{
                features := flattenFeatures(in.Features)
                if len(features) &gt; 0 </span><span class="cov0" title="0">{
                        att["features"] = features
                }</span>
        }
        <span class="cov0" title="0">att["devices"] = flattenDevices(in.Devices)

        return []interface{}{att}</span>
}

func flattenCPU(in *kubevirtapiv1.CPU) []interface{} <span class="cov0" title="0">{
        att := make(map[string]interface{})

        if in.Cores != 0 </span><span class="cov0" title="0">{
                att["cores"] = in.Cores
        }</span>
        <span class="cov0" title="0">if in.Sockets != 0 </span><span class="cov0" title="0">{
                att["sockets"] = in.Sockets
        }</span>
        <span class="cov0" title="0">if in.Threads != 0 </span><span class="cov0" title="0">{
                att["threads"] = in.Threads
        }</span>
        <span class="cov0" title="0">return []interface{}{att}</span>
}

func flattenMemory(in *kubevirtapiv1.Memory) []interface{} <span class="cov0" title="0">{
        att := make(map[string]interface{})

        if in.Guest != nil </span><span class="cov0" title="0">{
                att["guest"] = in.Guest.String()
        }</span>

        <span class="cov0" title="0">if in.Hugepages != nil </span><span class="cov0" title="0">{
                att["hugepages"] = in.Hugepages.PageSize
        }</span>

        <span class="cov0" title="0">return []interface{}{att}</span>
}

func flattenFirmware(in *kubevirtapiv1.Firmware) []interface{} <span class="cov0" title="0">{
        att := make(map[string]interface{})

        if in.UUID != "" </span><span class="cov0" title="0">{
                att["uuid"] = string(in.UUID)
        }</span>

        <span class="cov0" title="0">if in.Serial != "" </span><span class="cov0" title="0">{
                att["serial"] = in.Serial
        }</span>

        <span class="cov0" title="0">if in.Bootloader != nil </span><span class="cov0" title="0">{
                bootloader := flattenBootloader(in.Bootloader)
                if len(bootloader) &gt; 0 </span><span class="cov0" title="0">{
                        att["bootloader"] = bootloader
                }</span>
        }

        <span class="cov0" title="0">return []interface{}{att}</span>
}

func flattenBootloader(in *kubevirtapiv1.Bootloader) []interface{} <span class="cov0" title="0">{
        att := make(map[string]interface{})

        if in.BIOS != nil </span><span class="cov0" title="0">{
                bios := flattenBIOS(in.BIOS)
                if len(bios) &gt; 0 </span><span class="cov0" title="0">{
                        att["bios"] = bios
                }</span>
        }

        <span class="cov0" title="0">if in.EFI != nil </span><span class="cov0" title="0">{
                efi := flattenEFI(in.EFI)
                if len(efi) &gt; 0 </span><span class="cov0" title="0">{
                        att["efi"] = efi
                }</span>
        }

        <span class="cov0" title="0">if len(att) == 0 </span><span class="cov0" title="0">{
                return []interface{}{}
        }</span>

        <span class="cov0" title="0">return []interface{}{att}</span>
}

func flattenBIOS(in *kubevirtapiv1.BIOS) []interface{} <span class="cov0" title="0">{
        att := make(map[string]interface{})

        if in.UseSerial != nil </span><span class="cov0" title="0">{
                att["use_serial"] = *in.UseSerial
        }</span>

        <span class="cov0" title="0">if len(att) == 0 </span><span class="cov0" title="0">{
                return []interface{}{}
        }</span>

        <span class="cov0" title="0">return []interface{}{att}</span>
}

func flattenEFI(in *kubevirtapiv1.EFI) []interface{} <span class="cov0" title="0">{
        att := make(map[string]interface{})

        // Always include secure_boot - use default true if nil
        if in.SecureBoot != nil </span><span class="cov0" title="0">{
                att["secure_boot"] = *in.SecureBoot
        }</span> else<span class="cov0" title="0"> {
                att["secure_boot"] = false
        }</span>

        // Always include persistent if it's non-nil (explicitly set by API)
        // If nil, set to false as default
        <span class="cov0" title="0">if in.Persistent != nil </span><span class="cov0" title="0">{
                att["persistent"] = *in.Persistent
        }</span> else<span class="cov0" title="0"> {
                // Set default to false when empty/nil
                att["persistent"] = false
        }</span>

        <span class="cov0" title="0">if len(att) == 0 </span><span class="cov0" title="0">{
                return []interface{}{}
        }</span>

        <span class="cov0" title="0">return []interface{}{att}</span>
}

func flattenFeatures(in *kubevirtapiv1.Features) []interface{} <span class="cov0" title="0">{
        att := make(map[string]interface{})

        if in.ACPI.Enabled != nil </span><span class="cov0" title="0">{
                acpi := flattenFeatureState(&amp;in.ACPI)
                if len(acpi) &gt; 0 </span><span class="cov0" title="0">{
                        att["acpi"] = acpi
                }</span>
        }

        <span class="cov0" title="0">if in.APIC != nil &amp;&amp; in.APIC.Enabled != nil </span><span class="cov0" title="0">{
                apic := flattenFeatureState(&amp;kubevirtapiv1.FeatureState{
                        Enabled: in.APIC.Enabled,
                })
                if len(apic) &gt; 0 </span><span class="cov0" title="0">{
                        att["apic"] = apic
                }</span>
        }

        <span class="cov0" title="0">if in.SMM != nil &amp;&amp; in.SMM.Enabled != nil </span><span class="cov0" title="0">{
                smm := flattenFeatureState(in.SMM)
                if len(smm) &gt; 0 </span><span class="cov0" title="0">{
                        att["smm"] = smm
                }</span>
        }

        <span class="cov0" title="0">if len(att) == 0 </span><span class="cov0" title="0">{
                return []interface{}{}
        }</span>

        <span class="cov0" title="0">return []interface{}{att}</span>
}

func flattenFeatureState(in *kubevirtapiv1.FeatureState) []interface{} <span class="cov0" title="0">{
        att := make(map[string]interface{})

        if in.Enabled != nil </span><span class="cov0" title="0">{
                att["enabled"] = *in.Enabled
        }</span>

        <span class="cov0" title="0">if len(att) == 0 </span><span class="cov0" title="0">{
                return []interface{}{}
        }</span>

        <span class="cov0" title="0">return []interface{}{att}</span>
}

func flattenResources(in kubevirtapiv1.ResourceRequirements) []interface{} <span class="cov0" title="0">{
        att := make(map[string]interface{})

        att["requests"] = utils.FlattenStringMap(utils.FlattenResourceList(in.Requests))
        att["limits"] = utils.FlattenStringMap(utils.FlattenResourceList(in.Limits))
        att["over_commit_guest_overhead"] = in.OvercommitGuestOverhead

        return []interface{}{att}
}</span>

func flattenDevices(in kubevirtapiv1.Devices) []interface{} <span class="cov0" title="0">{
        att := make(map[string]interface{})

        att["disk"] = flattenDisks(in.Disks)
        att["interface"] = flattenInterfaces(in.Interfaces)

        return []interface{}{att}
}</span>

func flattenDisks(in []kubevirtapiv1.Disk) []interface{} <span class="cov0" title="0">{
        att := make([]interface{}, len(in))

        for i, v := range in </span><span class="cov0" title="0">{
                c := make(map[string]interface{})

                c["name"] = v.Name
                c["disk_device"] = flattenDiskDevice(v.DiskDevice)
                c["serial"] = v.Serial
                if v.BootOrder != nil </span><span class="cov0" title="0">{
                        // Safe conversion from uint to int to avoid potential overflow
                        if *v.BootOrder &lt;= math.MaxInt32 </span><span class="cov0" title="0">{
                                c["boot_order"] = int(*v.BootOrder)
                        }</span>
                }

                <span class="cov0" title="0">att[i] = c</span>
        }

        <span class="cov0" title="0">return att</span>
}

func flattenDiskDevice(in kubevirtapiv1.DiskDevice) []interface{} <span class="cov0" title="0">{
        att := make(map[string]interface{})

        if in.Disk != nil </span><span class="cov0" title="0">{
                att["disk"] = flattenDiskTarget(*in.Disk)
        }</span>

        <span class="cov0" title="0">return []interface{}{att}</span>
}

func flattenDiskTarget(in kubevirtapiv1.DiskTarget) []interface{} <span class="cov0" title="0">{
        att := make(map[string]interface{})

        att["bus"] = in.Bus
        att["read_only"] = in.ReadOnly
        att["pci_address"] = in.PciAddress

        return []interface{}{att}
}</span>

func flattenInterfaces(in []kubevirtapiv1.Interface) []interface{} <span class="cov0" title="0">{
        att := make([]interface{}, len(in))

        for i, v := range in </span><span class="cov0" title="0">{
                c := make(map[string]interface{})

                c["name"] = v.Name
                c["interface_binding_method"] = flattenInterfaceBindingMethod(v.InterfaceBindingMethod)
                if v.Model != "" </span><span class="cov0" title="0">{
                        c["model"] = v.Model
                }</span>
                <span class="cov0" title="0">att[i] = c</span>
        }

        <span class="cov0" title="0">return att</span>
}

func flattenInterfaceBindingMethod(in kubevirtapiv1.InterfaceBindingMethod) string <span class="cov0" title="0">{
        if in.Bridge != nil </span><span class="cov0" title="0">{
                return "InterfaceBridge"
        }</span>
        <span class="cov0" title="0">if in.DeprecatedSlirp != nil </span><span class="cov0" title="0">{
                return "InterfaceSlirp"
        }</span>
        <span class="cov0" title="0">if in.Masquerade != nil </span><span class="cov0" title="0">{
                return "InterfaceMasquerade"
        }</span>
        <span class="cov0" title="0">if in.SRIOV != nil </span><span class="cov0" title="0">{
                return "InterfaceSRIOV"
        }</span>

        <span class="cov0" title="0">return ""</span>
}
</pre>
		
		<pre class="file" id="file92" style="display: none">package virtualmachineinstance

import (
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        kubevirtapiv1 "kubevirt.io/api/core/v1"
)

func networkFields() map[string]*schema.Schema <span class="cov8" title="1">{
        return map[string]*schema.Schema{
                "name": {
                        Type:        schema.TypeString,
                        Description: "Network name.",
                        Required:    true,
                },
                "network_source": {
                        Type:        schema.TypeList,
                        Description: "NetworkSource represents the network type and the source interface that should be connected to the virtual machine.",
                        MaxItems:    1,
                        Optional:    true,
                        Elem: &amp;schema.Resource{
                                Schema: map[string]*schema.Schema{
                                        "pod": {
                                                Type:        schema.TypeList,
                                                Description: "Pod network.",
                                                MaxItems:    1,
                                                Optional:    true,
                                                Elem: &amp;schema.Resource{
                                                        Schema: map[string]*schema.Schema{
                                                                "vm_network_cidr": {
                                                                        Type:        schema.TypeString,
                                                                        Description: "CIDR for vm network.",
                                                                        Optional:    true,
                                                                },
                                                        },
                                                },
                                        },
                                        "multus": {
                                                Type:        schema.TypeList,
                                                Description: "Multus network.",
                                                MaxItems:    1,
                                                Optional:    true,
                                                Elem: &amp;schema.Resource{
                                                        Schema: map[string]*schema.Schema{
                                                                "network_name": {
                                                                        Type:        schema.TypeString,
                                                                        Description: "References to a NetworkAttachmentDefinition CRD object. Format: &lt;networkName&gt;, &lt;namespace&gt;/&lt;networkName&gt;. If namespace is not specified, VMI namespace is assumed.",
                                                                        Required:    true,
                                                                },
                                                                "default": {
                                                                        Type:        schema.TypeBool,
                                                                        Description: "Select the default network and add it to the multus-cni.io/default-network annotation.",
                                                                        Optional:    true,
                                                                },
                                                        },
                                                },
                                        },
                                },
                        },
                },
        }
}</span>

func NetworksSchema() *schema.Schema <span class="cov8" title="1">{
        fields := networkFields()

        return &amp;schema.Schema{
                Type: schema.TypeList,

                Description: "List of networks that can be attached to a vm's virtual interface.",
                Optional:    true,
                Elem: &amp;schema.Resource{
                        Schema: fields,
                },
        }
}</span>

func expandNetworks(networks []interface{}) []kubevirtapiv1.Network <span class="cov0" title="0">{
        result := make([]kubevirtapiv1.Network, len(networks))

        if len(networks) == 0 || networks[0] == nil </span><span class="cov0" title="0">{
                return result
        }</span>

        <span class="cov0" title="0">for i, network := range networks </span><span class="cov0" title="0">{
                in := network.(map[string]interface{})

                if v, ok := in["name"].(string); ok </span><span class="cov0" title="0">{
                        result[i].Name = v
                }</span>
                <span class="cov0" title="0">if v, ok := in["network_source"].([]interface{}); ok </span><span class="cov0" title="0">{
                        result[i].NetworkSource = expandNetworkSource(v)
                }</span>
        }

        <span class="cov0" title="0">return result</span>
}

func expandNetworkSource(networkSource []interface{}) kubevirtapiv1.NetworkSource <span class="cov0" title="0">{
        result := kubevirtapiv1.NetworkSource{}

        if len(networkSource) == 0 || networkSource[0] == nil </span><span class="cov0" title="0">{
                return result
        }</span>

        <span class="cov0" title="0">in := networkSource[0].(map[string]interface{})

        if v, ok := in["pod"].([]interface{}); ok &amp;&amp; len(v) == 1 </span><span class="cov0" title="0">{
                result.Pod = expandPodNetwork(v)
        }</span>
        <span class="cov0" title="0">if v, ok := in["multus"].([]interface{}); ok &amp;&amp; len(v) == 1 </span><span class="cov0" title="0">{
                result.Multus = expandMultusNetwork(v)
        }</span>

        <span class="cov0" title="0">return result</span>
}

func expandPodNetwork(pod []interface{}) *kubevirtapiv1.PodNetwork <span class="cov0" title="0">{
        result := &amp;kubevirtapiv1.PodNetwork{}

        if len(pod) == 0 || pod[0] == nil </span><span class="cov0" title="0">{
                return result
        }</span>

        <span class="cov0" title="0">in := pod[0].(map[string]interface{})

        if v, ok := in["vm_network_cidr"].(string); ok </span><span class="cov0" title="0">{
                result.VMNetworkCIDR = v
        }</span>

        <span class="cov0" title="0">return result</span>
}

func expandMultusNetwork(multus []interface{}) *kubevirtapiv1.MultusNetwork <span class="cov0" title="0">{
        if len(multus) == 0 || multus[0] == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">result := &amp;kubevirtapiv1.MultusNetwork{}
        in := multus[0].(map[string]interface{})

        if v, ok := in["network_name"].(string); ok </span><span class="cov0" title="0">{
                result.NetworkName = v
        }</span>
        <span class="cov0" title="0">if v, ok := in["default"].(bool); ok </span><span class="cov0" title="0">{
                result.Default = v
        }</span>

        <span class="cov0" title="0">return result</span>
}

func flattenNetworks(in []kubevirtapiv1.Network) []interface{} <span class="cov0" title="0">{
        att := make([]interface{}, len(in))

        for i, v := range in </span><span class="cov0" title="0">{
                c := make(map[string]interface{})

                c["name"] = v.Name
                c["network_source"] = flattenNetworkSource(v.NetworkSource)

                att[i] = c
        }</span>

        <span class="cov0" title="0">return att</span>
}

func flattenNetworkSource(in kubevirtapiv1.NetworkSource) []interface{} <span class="cov0" title="0">{
        att := make(map[string]interface{})

        if in.Pod != nil </span><span class="cov0" title="0">{
                att["pod"] = flattenPodNetwork(*in.Pod)
        }</span>
        <span class="cov0" title="0">if in.Multus != nil </span><span class="cov0" title="0">{
                att["multus"] = flattenMultusNetwork(*in.Multus)
        }</span>

        <span class="cov0" title="0">return []interface{}{att}</span>
}

func flattenPodNetwork(in kubevirtapiv1.PodNetwork) []interface{} <span class="cov0" title="0">{
        att := make(map[string]interface{})

        att["vm_network_cidr"] = in.VMNetworkCIDR

        return []interface{}{att}
}</span>

func flattenMultusNetwork(in kubevirtapiv1.MultusNetwork) []interface{} <span class="cov0" title="0">{
        att := make(map[string]interface{})

        att["network_name"] = in.NetworkName
        att["default"] = in.Default

        return []interface{}{att}
}</span>
</pre>
		
		<pre class="file" id="file93" style="display: none">package virtualmachineinstance

import (
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        kubevirtapiv1 "kubevirt.io/api/core/v1"
)

func probeFields() map[string]*schema.Schema <span class="cov10" title="2">{
        return map[string]*schema.Schema{
                // TODO nargaman
        }
}</span>

func ProbeSchema() *schema.Schema <span class="cov10" title="2">{
        fields := probeFields()

        return &amp;schema.Schema{
                Type: schema.TypeList,

                Description: "Specification of the desired behavior of the VirtualMachineInstance on the host.",
                Optional:    true,
                MaxItems:    1,
                Elem: &amp;schema.Resource{
                        Schema: fields,
                },
        }
}</span>

func expandProbe(probe []interface{}) *kubevirtapiv1.Probe <span class="cov0" title="0">{
        if len(probe) == 0 || probe[0] == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">result := &amp;kubevirtapiv1.Probe{}

        _ = probe[0].(map[string]interface{})

        // TODO nargaman

        return result</span>
}

func flattenProbe(in kubevirtapiv1.Probe) []interface{} <span class="cov0" title="0">{
        att := make(map[string]interface{})

        // att["spec"] = flattenVirtualMachineInstanceSpecSpec(in.Spec)
        // att["status"] = flattenVirtualMachineInstanceSpecStatus(in.Status)
        // TODO nargaman

        return []interface{}{att}
}</span>
</pre>
		
		<pre class="file" id="file94" style="display: none">package virtualmachineinstance

import (
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        k8sv1 "k8s.io/api/core/v1"
        kubevirtapiv1 "kubevirt.io/api/core/v1"

        "github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/kubevirt/schema/k8s"

        "github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/kubevirt/utils"
)

func expandVirtualMachineInstanceSpec(d *schema.ResourceData) (kubevirtapiv1.VirtualMachineInstanceSpec, error) <span class="cov0" title="0">{
        result := kubevirtapiv1.VirtualMachineInstanceSpec{}

        if v, ok := d.GetOk("priority_class_name"); ok </span><span class="cov0" title="0">{
                result.PriorityClassName = v.(string)
        }</span>

        <span class="cov0" title="0">if domain, err := ExpandDomainSpec(d); err == nil </span><span class="cov0" title="0">{
                result.Domain = domain
        }</span> else<span class="cov0" title="0"> {
                return result, err
        }</span>
        <span class="cov0" title="0">if v, ok := d.GetOk("node_selector"); ok &amp;&amp; len(v.(map[string]interface{})) &gt; 0 </span><span class="cov0" title="0">{
                result.NodeSelector = utils.ExpandStringMap(v.(map[string]interface{}))
        }</span>
        <span class="cov0" title="0">if v, ok := d.GetOk("affinity"); ok </span><span class="cov0" title="0">{
                result.Affinity = k8s.ExpandAffinity(v.([]interface{}))
        }</span>
        <span class="cov0" title="0">if v, ok := d.GetOk("scheduler_name"); ok </span><span class="cov0" title="0">{
                result.SchedulerName = v.(string)
        }</span>
        <span class="cov0" title="0">if v, ok := d.GetOk("tolerations"); ok </span><span class="cov0" title="0">{
                tolerations, err := k8s.ExpandTolerations(v.([]interface{}))
                if err != nil </span><span class="cov0" title="0">{
                        return result, err
                }</span>
                <span class="cov0" title="0">result.Tolerations = tolerations</span>
        }
        <span class="cov0" title="0">if v, ok := d.GetOk("eviction_strategy"); ok </span><span class="cov0" title="0">{
                if v.(string) != "" </span><span class="cov0" title="0">{
                        evictionStrategy := kubevirtapiv1.EvictionStrategy(v.(string))
                        result.EvictionStrategy = &amp;evictionStrategy
                }</span>
        }
        <span class="cov0" title="0">if v, ok := d.GetOk("termination_grace_period_seconds"); ok </span><span class="cov0" title="0">{
                seconds := int64(v.(int))
                result.TerminationGracePeriodSeconds = &amp;seconds
        }</span>
        <span class="cov0" title="0">if v, ok := d.GetOk("volume"); ok </span><span class="cov0" title="0">{
                result.Volumes = expandVolumes(v.([]interface{}))
        }</span>
        <span class="cov0" title="0">if v, ok := d.GetOk("liveness_probe"); ok </span><span class="cov0" title="0">{
                result.LivenessProbe = expandProbe(v.([]interface{}))
        }</span>
        <span class="cov0" title="0">if v, ok := d.GetOk("readiness_probe"); ok </span><span class="cov0" title="0">{
                result.ReadinessProbe = expandProbe(v.([]interface{}))
        }</span>
        <span class="cov0" title="0">if v, ok := d.GetOk("hostname"); ok </span><span class="cov0" title="0">{
                result.Hostname = v.(string)
        }</span>
        <span class="cov0" title="0">if v, ok := d.GetOk("subdomain"); ok </span><span class="cov0" title="0">{
                result.Subdomain = v.(string)
        }</span>
        <span class="cov0" title="0">if v, ok := d.GetOk("network"); ok </span><span class="cov0" title="0">{
                result.Networks = expandNetworks(v.([]interface{}))
        }</span>
        <span class="cov0" title="0">if v, ok := d.GetOk("dns_policy"); ok </span><span class="cov0" title="0">{
                result.DNSPolicy = k8sv1.DNSPolicy(v.(string))
        }</span>
        <span class="cov0" title="0">if v, ok := d.GetOk("pod_dns_config"); ok </span><span class="cov0" title="0">{
                dnsConfig, err := k8s.ExpandPodDNSConfig(v.([]interface{}))
                if err != nil </span><span class="cov0" title="0">{
                        return result, err
                }</span>
                <span class="cov0" title="0">result.DNSConfig = dnsConfig</span>
        }

        <span class="cov0" title="0">return result, nil</span>
}

func flattenVirtualMachineInstanceSpec(in kubevirtapiv1.VirtualMachineInstanceSpec, resourceData *schema.ResourceData) []interface{} <span class="cov0" title="0">{
        att := make(map[string]interface{})

        att["priority_class_name"] = in.PriorityClassName
        att["domain"] = FlattenDomainSpec(in.Domain)

        att["node_selector"] = utils.FlattenStringMap(in.NodeSelector)
        att["affinity"] = k8s.FlattenAffinity(in.Affinity)
        att["scheduler_name"] = in.SchedulerName
        att["tolerations"] = k8s.FlattenTolerations(in.Tolerations)
        if in.EvictionStrategy != nil </span><span class="cov0" title="0">{
                att["eviction_strategy"] = string(*in.EvictionStrategy)
        }</span>
        <span class="cov0" title="0">if in.TerminationGracePeriodSeconds != nil </span><span class="cov0" title="0">{
                att["termination_grace_period_seconds"] = *in.TerminationGracePeriodSeconds
        }</span>
        <span class="cov0" title="0">att["volume"] = flattenVolumes(in.Volumes)
        if in.LivenessProbe != nil </span><span class="cov0" title="0">{
                att["liveness_probe"] = flattenProbe(*in.LivenessProbe)
        }</span>
        <span class="cov0" title="0">if in.ReadinessProbe != nil </span><span class="cov0" title="0">{
                att["readiness_probe"] = flattenProbe(*in.ReadinessProbe)
        }</span>
        <span class="cov0" title="0">att["hostname"] = in.Hostname
        att["subdomain"] = in.Subdomain
        att["network"] = flattenNetworks(in.Networks)
        att["dns_policy"] = string(in.DNSPolicy)
        if in.DNSConfig != nil </span><span class="cov0" title="0">{
                att["pod_dns_config"] = k8s.FlattenPodDNSConfig(in.DNSConfig)
        }</span>

        <span class="cov0" title="0">return []interface{}{att}</span>
}
</pre>
		
		<pre class="file" id="file95" style="display: none">package virtualmachineinstance

import (
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        kubevirtapiv1 "kubevirt.io/api/core/v1"
)

func ExpandVirtualMachineInstanceTemplateSpec(d *schema.ResourceData) (*kubevirtapiv1.VirtualMachineInstanceTemplateSpec, error) <span class="cov0" title="0">{
        result := &amp;kubevirtapiv1.VirtualMachineInstanceTemplateSpec{}

        // we have removed metadata for template hence set empty metadata object (TBD)***
        result.ObjectMeta = metav1.ObjectMeta{}

        if spec, err := expandVirtualMachineInstanceSpec(d); err == nil </span><span class="cov0" title="0">{
                result.Spec = spec
        }</span> else<span class="cov0" title="0"> {
                return result, err
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

func FlattenVirtualMachineInstanceTemplateSpec(in kubevirtapiv1.VirtualMachineInstanceTemplateSpec, resourceData *schema.ResourceData) []interface{} <span class="cov0" title="0">{
        att := make(map[string]interface{})

        // Since we removed metadata support in VM instance Spec metadata is not set.
        att["spec"] = flattenVirtualMachineInstanceSpec(in.Spec, resourceData)

        return []interface{}{att}
}</span>
</pre>
		
		<pre class="file" id="file96" style="display: none">package virtualmachineinstance

import (
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        v1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/api/resource"
        kubevirtapiv1 "kubevirt.io/api/core/v1"

        "github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/kubevirt/schema/k8s"
)

func volumesFields() map[string]*schema.Schema <span class="cov8" title="1">{
        return map[string]*schema.Schema{
                "name": {
                        Type:        schema.TypeString,
                        Description: "Volume's name.",
                        Required:    true,
                },
                "volume_source": {
                        Type:        schema.TypeList,
                        Description: "VolumeSource represents the location and type of the mounted volume. Defaults to Disk, if no type is specified.",
                        MaxItems:    1,
                        Required:    true,
                        Elem: &amp;schema.Resource{
                                Schema: map[string]*schema.Schema{
                                        "data_volume": {
                                                Type:        schema.TypeList,
                                                Description: "DataVolume represents the dynamic creation a PVC for this volume as well as the process of populating that PVC with a disk image.",
                                                MaxItems:    1,
                                                Optional:    true,
                                                Elem: &amp;schema.Resource{
                                                        Schema: map[string]*schema.Schema{
                                                                "name": {
                                                                        Type:        schema.TypeString,
                                                                        Description: "Name represents the name of the DataVolume in the same namespace.",
                                                                        Required:    true,
                                                                },
                                                        },
                                                },
                                        },
                                        "cloud_init_config_drive": {
                                                Type:        schema.TypeList,
                                                Description: "CloudInitConfigDrive represents a cloud-init Config Drive user-data source.",
                                                MaxItems:    1,
                                                Optional:    true,
                                                Elem: &amp;schema.Resource{
                                                        Schema: map[string]*schema.Schema{
                                                                "user_data_secret_ref": k8s.LocalObjectReferenceSchema("UserDataSecretRef references a k8s secret that contains config drive userdata."),
                                                                "user_data_base64": {
                                                                        Type:        schema.TypeString,
                                                                        Description: "UserDataBase64 contains config drive cloud-init userdata as a base64 encoded string.",
                                                                        Optional:    true,
                                                                },
                                                                "user_data": {
                                                                        Type:        schema.TypeString,
                                                                        Description: "UserData contains config drive inline cloud-init userdata.",
                                                                        Optional:    true,
                                                                },
                                                                "network_data_secret_ref": k8s.LocalObjectReferenceSchema("NetworkDataSecretRef references a k8s secret that contains config drive networkdata."),
                                                                "network_data_base64": {
                                                                        Type:        schema.TypeString,
                                                                        Description: "NetworkDataBase64 contains config drive cloud-init networkdata as a base64 encoded string.",
                                                                        Optional:    true,
                                                                },
                                                                "network_data": {
                                                                        Type:        schema.TypeString,
                                                                        Description: "NetworkData contains config drive inline cloud-init networkdata.",
                                                                        Optional:    true,
                                                                },
                                                        },
                                                },
                                        },
                                        "service_account": {
                                                Type:        schema.TypeList,
                                                Description: "ServiceAccountVolumeSource represents a reference to a service account.",
                                                MaxItems:    1,
                                                Optional:    true,
                                                Elem: &amp;schema.Resource{
                                                        Schema: map[string]*schema.Schema{
                                                                "service_account_name": {
                                                                        Type:        schema.TypeString,
                                                                        Description: "Name of the service account in the pod's namespace to use.",
                                                                        Required:    true,
                                                                },
                                                        },
                                                },
                                        },
                                        "container_disk": {
                                                Type:     schema.TypeSet,
                                                Optional: true,
                                                Elem: &amp;schema.Resource{
                                                        Schema: map[string]*schema.Schema{
                                                                "image_url": {
                                                                        Type:        schema.TypeString,
                                                                        Required:    true,
                                                                        Description: "The URL of the container image to use as the disk. This can be a local file path, a remote URL, or a registry URL.",
                                                                },
                                                        },
                                                },
                                                Description: "A container disk is a disk that is backed by a container image. The container image is expected to contain a disk image in a supported format. The disk image is extracted from the container image and used as the disk for the VM.",
                                        },
                                        "cloud_init_no_cloud": {
                                                Type:     schema.TypeSet,
                                                Optional: true,
                                                Elem: &amp;schema.Resource{
                                                        Schema: map[string]*schema.Schema{
                                                                "user_data_secret_ref": k8s.LocalObjectReferenceSchema("UserDataSecretRef references a k8s secret that contains cloud-init userdata."),
                                                                "user_data_base64": {
                                                                        Type:        schema.TypeString,
                                                                        Description: "UserDataBase64 contains cloud-init userdata as a base64 encoded string.",
                                                                        Optional:    true,
                                                                },
                                                                "user_data": {
                                                                        Type:        schema.TypeString,
                                                                        Description: "UserData contains cloud-init inline userdata.",
                                                                        Optional:    true,
                                                                },
                                                                "network_data_secret_ref": k8s.LocalObjectReferenceSchema("NetworkDataSecretRef references a k8s secret that contains cloud-init networkdata."),
                                                                "network_data_base64": {
                                                                        Type:        schema.TypeString,
                                                                        Description: "NetworkDataBase64 contains cloud-init networkdata as a base64 encoded string.",
                                                                        Optional:    true,
                                                                },
                                                                "network_data": {
                                                                        Type:        schema.TypeString,
                                                                        Optional:    true,
                                                                        Description: "NetworkData contains cloud-init inline network configuration data.",
                                                                },
                                                        },
                                                },
                                                Description: "Used to specify a cloud-init `noCloud` image. The image is expected to contain a disk image in a supported format. The disk image is extracted from the cloud-init `noCloud `image and used as the disk for the VM",
                                        },
                                        "ephemeral": {
                                                Type:        schema.TypeList,
                                                Description: "EphemeralVolumeSource represents a volume that is populated with the contents of a pod. Ephemeral volumes do not support ownership management or SELinux relabeling.",
                                                MaxItems:    1,
                                                Optional:    true,
                                                Elem: &amp;schema.Resource{
                                                        Schema: map[string]*schema.Schema{
                                                                "persistent_volume_claim": {
                                                                        Type:        schema.TypeList,
                                                                        Description: "PersistentVolumeClaimVolumeSource represents a reference to a PersistentVolumeClaim in the same namespace.",
                                                                        MaxItems:    1,
                                                                        Optional:    true,
                                                                        Elem: &amp;schema.Resource{
                                                                                Schema: map[string]*schema.Schema{
                                                                                        "claim_name": {
                                                                                                Type:        schema.TypeString,
                                                                                                Description: "ClaimName is the name of a PersistentVolumeClaim in the same namespace as the pod using this volume. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims",
                                                                                                Required:    true,
                                                                                        },
                                                                                        "read_only": {
                                                                                                Type:        schema.TypeBool,
                                                                                                Description: "Will force the ReadOnly setting in VolumeMounts. Default false.",
                                                                                                Optional:    true,
                                                                                        },
                                                                                },
                                                                        },
                                                                },
                                                        },
                                                },
                                        },
                                        "empty_disk": {
                                                Type:        schema.TypeList,
                                                Description: "EmptyDisk represents a temporary disk which shares the VM's lifecycle.",
                                                MaxItems:    1,
                                                Optional:    true,
                                                Elem: &amp;schema.Resource{
                                                        Schema: map[string]*schema.Schema{
                                                                "capacity": {
                                                                        Type:        schema.TypeString,
                                                                        Description: "Capacity of the sparse disk.",
                                                                        Required:    true,
                                                                },
                                                        },
                                                },
                                        },
                                        "persistent_volume_claim": {
                                                Type:        schema.TypeList,
                                                Description: "PersistentVolumeClaimVolumeSource represents a reference to a PersistentVolumeClaim in the same namespace.",
                                                MaxItems:    1,
                                                Optional:    true,
                                                Elem: &amp;schema.Resource{
                                                        Schema: map[string]*schema.Schema{
                                                                "claim_name": {
                                                                        Type:        schema.TypeString,
                                                                        Description: "ClaimName is the name of a PersistentVolumeClaim in the same namespace as the pod using this volume. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims",
                                                                        Required:    true,
                                                                },
                                                                "read_only": {
                                                                        Type:        schema.TypeBool,
                                                                        Description: "Will force the ReadOnly setting in VolumeMounts. Default false.",
                                                                        Optional:    true,
                                                                },
                                                        },
                                                },
                                        },
                                        "host_disk": {
                                                Type:        schema.TypeList,
                                                Description: "HostDisk represents a disk created on the host.",
                                                MaxItems:    1,
                                                Optional:    true,
                                                Elem: &amp;schema.Resource{
                                                        Schema: map[string]*schema.Schema{
                                                                "path": {
                                                                        Type:        schema.TypeString,
                                                                        Description: "Path of the disk.",
                                                                        Required:    true,
                                                                },
                                                                "type": {
                                                                        Type:        schema.TypeString,
                                                                        Description: "Type of the disk, supported values are disk, directory, socket, char, block.",
                                                                        Required:    true,
                                                                },
                                                        },
                                                },
                                        },
                                        "config_map": {
                                                Type:        schema.TypeList,
                                                Description: "ConfigMapVolumeSource adapts a ConfigMap into a volume.",
                                                MaxItems:    1,
                                                Optional:    true,
                                                Elem: &amp;schema.Resource{
                                                        Schema: map[string]*schema.Schema{
                                                                "default_mode": {
                                                                        Type:        schema.TypeInt,
                                                                        Description: "Optional: mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.",
                                                                        Optional:    true,
                                                                },
                                                                "items": {
                                                                        Type:        schema.TypeList,
                                                                        Description: "If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.",
                                                                        Optional:    true,
                                                                        Elem: &amp;schema.Resource{
                                                                                Schema: map[string]*schema.Schema{
                                                                                        "key": {
                                                                                                Type:     schema.TypeString,
                                                                                                Optional: true,
                                                                                        },
                                                                                },
                                                                        },
                                                                },
                                                        },
                                                },
                                        },
                                        // TODO nargaman - Add other data volume source types
                                },
                        },
                },
        }
}</span>

func VolumesSchema() *schema.Schema <span class="cov8" title="1">{
        fields := volumesFields()

        return &amp;schema.Schema{
                Type: schema.TypeList,

                Description: "Specification of the desired behavior of the VirtualMachineInstance on the host.",
                Optional:    true,
                Elem: &amp;schema.Resource{
                        Schema: fields,
                },
        }
}</span>

func expandVolumes(volumes []interface{}) []kubevirtapiv1.Volume <span class="cov0" title="0">{
        result := make([]kubevirtapiv1.Volume, len(volumes))

        if len(volumes) == 0 || volumes[0] == nil </span><span class="cov0" title="0">{
                return result
        }</span>

        <span class="cov0" title="0">for i, condition := range volumes </span><span class="cov0" title="0">{
                in := condition.(map[string]interface{})

                if v, ok := in["name"].(string); ok </span><span class="cov0" title="0">{
                        result[i].Name = v
                }</span>
                <span class="cov0" title="0">if v, ok := in["volume_source"].([]interface{}); ok </span><span class="cov0" title="0">{
                        result[i].VolumeSource = expandVolumeSource(v)
                }</span>
        }

        <span class="cov0" title="0">return result</span>
}

func expandVolumeSource(volumeSource []interface{}) kubevirtapiv1.VolumeSource <span class="cov0" title="0">{
        result := kubevirtapiv1.VolumeSource{}

        if len(volumeSource) == 0 || volumeSource[0] == nil </span><span class="cov0" title="0">{
                return result
        }</span>

        <span class="cov0" title="0">in := volumeSource[0].(map[string]interface{})

        if v, ok := in["data_volume"].([]interface{}); ok </span><span class="cov0" title="0">{
                result.DataVolume = expandDataVolume(v)
        }</span>
        <span class="cov0" title="0">if v, ok := in["cloud_init_config_drive"].([]interface{}); ok </span><span class="cov0" title="0">{
                result.CloudInitConfigDrive = expandCloudInitConfigDrive(v)
        }</span>
        <span class="cov0" title="0">if v, ok := in["service_account"].([]interface{}); ok </span><span class="cov0" title="0">{
                result.ServiceAccount = expandServiceAccount(v)
        }</span>
        <span class="cov0" title="0">if v, ok := in["container_disk"].(*schema.Set); ok </span><span class="cov0" title="0">{
                result.ContainerDisk = expandContainerDisk(v.List())
        }</span>
        <span class="cov0" title="0">if v, ok := in["cloud_init_no_cloud"].(*schema.Set); ok </span><span class="cov0" title="0">{
                result.CloudInitNoCloud = expandCloudInitNoCloud(v.List())
        }</span>
        <span class="cov0" title="0">if v, ok := in["ephemeral"].([]interface{}); ok </span><span class="cov0" title="0">{
                result.Ephemeral = expandEphemeral(v)
        }</span>
        <span class="cov0" title="0">if v, ok := in["empty_disk"].([]interface{}); ok </span><span class="cov0" title="0">{
                result.EmptyDisk = expandEmptyDisk(v)
        }</span>
        <span class="cov0" title="0">if v, ok := in["host_disk"].([]interface{}); ok </span><span class="cov0" title="0">{
                result.HostDisk = expandHostDisk(v)
        }</span>
        <span class="cov0" title="0">if v, ok := in["config_map"].([]interface{}); ok </span><span class="cov0" title="0">{
                result.ConfigMap = expandConfigMap(v)
        }</span>

        <span class="cov0" title="0">return result</span>
}

func expandDataVolume(dataVolumeSource []interface{}) *kubevirtapiv1.DataVolumeSource <span class="cov0" title="0">{
        if len(dataVolumeSource) == 0 || dataVolumeSource[0] == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">result := &amp;kubevirtapiv1.DataVolumeSource{}
        in := dataVolumeSource[0].(map[string]interface{})

        if v, ok := in["name"].(string); ok </span><span class="cov0" title="0">{
                result.Name = v
        }</span>

        <span class="cov0" title="0">return result</span>
}

func expandCloudInitConfigDrive(cloudInitConfigDriveSource []interface{}) *kubevirtapiv1.CloudInitConfigDriveSource <span class="cov0" title="0">{
        if len(cloudInitConfigDriveSource) == 0 || cloudInitConfigDriveSource[0] == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">result := &amp;kubevirtapiv1.CloudInitConfigDriveSource{}
        in := cloudInitConfigDriveSource[0].(map[string]interface{})

        if v, ok := in["user_data_secret_ref"].([]interface{}); ok </span><span class="cov0" title="0">{
                result.UserDataSecretRef = k8s.ExpandLocalObjectReferences(v)
        }</span>
        <span class="cov0" title="0">if v, ok := in["user_data_base64"].(string); ok </span><span class="cov0" title="0">{
                result.UserDataBase64 = v
        }</span>
        <span class="cov0" title="0">if v, ok := in["user_data"].(string); ok </span><span class="cov0" title="0">{
                result.UserData = v
        }</span>
        <span class="cov0" title="0">if v, ok := in["network_data_secret_ref"].([]interface{}); ok </span><span class="cov0" title="0">{
                result.NetworkDataSecretRef = k8s.ExpandLocalObjectReferences(v)
        }</span>
        <span class="cov0" title="0">if v, ok := in["network_data_base64"].(string); ok </span><span class="cov0" title="0">{
                result.NetworkDataBase64 = v
        }</span>
        <span class="cov0" title="0">if v, ok := in["network_data"].(string); ok </span><span class="cov0" title="0">{
                result.NetworkData = v
        }</span>

        <span class="cov0" title="0">return result</span>
}

func expandServiceAccount(serviceAccountSource []interface{}) *kubevirtapiv1.ServiceAccountVolumeSource <span class="cov0" title="0">{
        if len(serviceAccountSource) == 0 || serviceAccountSource[0] == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">result := &amp;kubevirtapiv1.ServiceAccountVolumeSource{}
        in := serviceAccountSource[0].(map[string]interface{})

        if v, ok := in["service_account_name"].(string); ok </span><span class="cov0" title="0">{
                result.ServiceAccountName = v
        }</span>

        <span class="cov0" title="0">return result</span>
}

func expandContainerDisk(containerDiskSource []interface{}) *kubevirtapiv1.ContainerDiskSource <span class="cov0" title="0">{
        if len(containerDiskSource) == 0 || containerDiskSource[0] == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">result := &amp;kubevirtapiv1.ContainerDiskSource{}
        in := containerDiskSource[0].(map[string]interface{})

        if v, ok := in["image_url"].(string); ok </span><span class="cov0" title="0">{
                result.Image = v
        }</span>

        <span class="cov0" title="0">return result</span>
}

func expandCloudInitNoCloud(cloudInitNoCloudSource []interface{}) *kubevirtapiv1.CloudInitNoCloudSource <span class="cov0" title="0">{
        if len(cloudInitNoCloudSource) == 0 || cloudInitNoCloudSource[0] == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">result := &amp;kubevirtapiv1.CloudInitNoCloudSource{}
        in := cloudInitNoCloudSource[0].(map[string]interface{})

        if v, ok := in["user_data_secret_ref"].([]interface{}); ok </span><span class="cov0" title="0">{
                result.UserDataSecretRef = k8s.ExpandLocalObjectReferences(v)
        }</span>
        <span class="cov0" title="0">if v, ok := in["user_data_base64"].(string); ok </span><span class="cov0" title="0">{
                result.UserDataBase64 = v
        }</span>
        <span class="cov0" title="0">if v, ok := in["user_data"].(string); ok </span><span class="cov0" title="0">{
                result.UserData = v
        }</span>
        <span class="cov0" title="0">if v, ok := in["network_data_secret_ref"].([]interface{}); ok </span><span class="cov0" title="0">{
                result.NetworkDataSecretRef = k8s.ExpandLocalObjectReferences(v)
        }</span>
        <span class="cov0" title="0">if v, ok := in["network_data_base64"].(string); ok </span><span class="cov0" title="0">{
                result.NetworkDataBase64 = v
        }</span>
        <span class="cov0" title="0">if v, ok := in["network_data"].(string); ok </span><span class="cov0" title="0">{
                result.NetworkData = v
        }</span>

        <span class="cov0" title="0">return result</span>
}

func expandEphemeral(ephemeralSource []interface{}) *kubevirtapiv1.EphemeralVolumeSource <span class="cov0" title="0">{
        if len(ephemeralSource) == 0 || ephemeralSource[0] == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">result := &amp;kubevirtapiv1.EphemeralVolumeSource{}
        in := ephemeralSource[0].(map[string]interface{})

        if v, ok := in["persistent_volume_claim"].([]interface{}); ok </span><span class="cov0" title="0">{
                result.PersistentVolumeClaim = expandPersistentVolumeClaim(v)
        }</span>

        <span class="cov0" title="0">return result</span>
}

func expandPersistentVolumeClaim(persistentVolumeClaimSource []interface{}) *v1.PersistentVolumeClaimVolumeSource <span class="cov0" title="0">{
        if len(persistentVolumeClaimSource) == 0 || persistentVolumeClaimSource[0] == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        /*
                type PersistentVolumeClaimVolumeSource struct {
                        v1.PersistentVolumeClaimVolumeSource `json:",inline"`
                        // Hotpluggable indicates whether the volume can be hotplugged and hotunplugged.
                        // +optional
                        Hotpluggable bool `json:"hotpluggable,omitempty"`
                }

                type PersistentVolumeClaimVolumeSource struct {
                        // claimName is the name of a PersistentVolumeClaim in the same namespace as the pod using this volume.
                        // More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
                        ClaimName string `json:"claimName" protobuf:"bytes,1,opt,name=claimName"`
                        // readOnly Will force the ReadOnly setting in VolumeMounts.
                        // Default false.
                        // +optional
                        ReadOnly bool `json:"readOnly,omitempty" protobuf:"varint,2,opt,name=readOnly"`
                }

        */

        <span class="cov0" title="0">result := &amp;v1.PersistentVolumeClaimVolumeSource{}
        in := persistentVolumeClaimSource[0].(map[string]interface{})

        if v, ok := in["claim_name"].(string); ok </span><span class="cov0" title="0">{
                result.ClaimName = v
        }</span>
        <span class="cov0" title="0">if v, ok := in["read_only"].(bool); ok </span><span class="cov0" title="0">{
                result.ReadOnly = v
        }</span>

        <span class="cov0" title="0">return result</span>
}

func expandEmptyDisk(emptyDiskSource []interface{}) *kubevirtapiv1.EmptyDiskSource <span class="cov0" title="0">{
        if len(emptyDiskSource) == 0 || emptyDiskSource[0] == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">result := &amp;kubevirtapiv1.EmptyDiskSource{}
        in := emptyDiskSource[0].(map[string]interface{})

        /* type EmptyDiskSource struct {
                // Capacity of the sparse disk.
                Capacity resource.Quantity `json:"capacity"`
        }
        type Quantity struct {
                // i is the quantity in int64 scaled form, if d.Dec == nil
                i int64Amount
                // d is the quantity in inf.Dec form if d.Dec != nil
                d infDecAmount
                // s is the generated value of this quantity to avoid recalculation
                s string

                // Change Format at will. See the comment for Canonicalize for
                // more details.
                Format
        }

        */
        if v, ok := in["capacity"].(string); ok </span><span class="cov0" title="0">{
                result.Capacity = resource.MustParse(v)
        }</span>

        <span class="cov0" title="0">return result</span>
}

func expandHostDisk(hostDiskSource []interface{}) *kubevirtapiv1.HostDisk <span class="cov0" title="0">{
        if len(hostDiskSource) == 0 || hostDiskSource[0] == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">result := &amp;kubevirtapiv1.HostDisk{}
        in := hostDiskSource[0].(map[string]interface{})

        if v, ok := in["path"].(string); ok </span><span class="cov0" title="0">{
                result.Path = v
        }</span>
        <span class="cov0" title="0">if v, ok := in["type"].(string); ok </span><span class="cov0" title="0">{
                result.Type = kubevirtapiv1.HostDiskType(v)
        }</span>

        <span class="cov0" title="0">return result</span>
}

func expandConfigMap(configMapSource []interface{}) *kubevirtapiv1.ConfigMapVolumeSource <span class="cov0" title="0">{
        if len(configMapSource) == 0 || configMapSource[0] == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">result := &amp;kubevirtapiv1.ConfigMapVolumeSource{}

        in := configMapSource[0].(map[string]interface{})
        if v, ok := in["name"].(string); ok </span><span class="cov0" title="0">{
                result.Name = v
        }</span>
        <span class="cov0" title="0">if v, ok := in["optional"].(bool); ok </span><span class="cov0" title="0">{
                result.Optional = &amp;v
        }</span>
        <span class="cov0" title="0">if v, ok := in["volume_label"].(string); ok </span><span class="cov0" title="0">{
                result.VolumeLabel = v
        }</span>

        <span class="cov0" title="0">return result</span>
}

func flattenVolumes(in []kubevirtapiv1.Volume) []interface{} <span class="cov0" title="0">{
        att := make([]interface{}, len(in))

        for i, v := range in </span><span class="cov0" title="0">{
                c := make(map[string]interface{})

                c["name"] = v.Name
                c["volume_source"] = flattenVolumeSource(v.VolumeSource)

                att[i] = c
        }</span>

        <span class="cov0" title="0">return att</span>
}

func flattenVolumeSource(in kubevirtapiv1.VolumeSource) []interface{} <span class="cov0" title="0">{
        att := make(map[string]interface{})

        if in.DataVolume != nil </span><span class="cov0" title="0">{
                att["data_volume"] = flattenDataVolume(*in.DataVolume)
        }</span>
        <span class="cov0" title="0">if in.CloudInitConfigDrive != nil </span><span class="cov0" title="0">{
                att["cloud_init_config_drive"] = flattenCloudInitConfigDrive(*in.CloudInitConfigDrive)
        }</span>
        <span class="cov0" title="0">if in.ServiceAccount != nil </span><span class="cov0" title="0">{
                att["service_account"] = flattenServiceAccount(*in.ServiceAccount)
        }</span>
        <span class="cov0" title="0">if in.ContainerDisk != nil </span><span class="cov0" title="0">{
                att["container_disk"] = flattenContainerDisk(*in.ContainerDisk)
        }</span>
        <span class="cov0" title="0">if in.CloudInitNoCloud != nil </span><span class="cov0" title="0">{
                att["cloud_init_no_cloud"] = flattenCloudInitNoCloud(*in.CloudInitNoCloud)
        }</span>
        <span class="cov0" title="0">if in.Ephemeral != nil </span><span class="cov0" title="0">{
                att["ephemeral"] = flattenEphemeral(*in.Ephemeral)
        }</span>
        <span class="cov0" title="0">if in.EmptyDisk != nil </span><span class="cov0" title="0">{
                att["empty_disk"] = flattenEmptyDisk(*in.EmptyDisk)
        }</span>
        <span class="cov0" title="0">if in.HostDisk != nil </span><span class="cov0" title="0">{
                att["host_disk"] = flattenHostDisk(*in.HostDisk)
        }</span>
        /*if in.PersistentVolumeClaim != nil {
                att["persistent_volume_claim"] = flattenPersistentVolumeClaim(in.PersistentVolumeClaim)
        }*/
        <span class="cov0" title="0">if in.ConfigMap != nil </span><span class="cov0" title="0">{
                att["config_map"] = flattenConfigMap(*in.ConfigMap)
        }</span>

        <span class="cov0" title="0">return []interface{}{att}</span>
}

func flattenDataVolume(in kubevirtapiv1.DataVolumeSource) []interface{} <span class="cov0" title="0">{
        att := make(map[string]interface{})

        att["name"] = in.Name

        return []interface{}{att}
}</span>

func flattenCloudInitConfigDrive(in kubevirtapiv1.CloudInitConfigDriveSource) []interface{} <span class="cov0" title="0">{
        att := make(map[string]interface{})

        if in.UserDataSecretRef != nil </span><span class="cov0" title="0">{
                att["user_data_secret_ref"] = k8s.FlattenLocalObjectReferences(*in.UserDataSecretRef)
        }</span>
        <span class="cov0" title="0">att["user_data_base64"] = in.UserDataBase64
        att["user_data"] = in.UserData
        if in.NetworkDataSecretRef != nil </span><span class="cov0" title="0">{
                att["network_data_secret_ref"] = k8s.FlattenLocalObjectReferences(*in.NetworkDataSecretRef)
        }</span>
        <span class="cov0" title="0">att["network_data_base64"] = in.NetworkDataBase64
        att["network_data"] = in.NetworkData

        return []interface{}{att}</span>
}

func flattenServiceAccount(in kubevirtapiv1.ServiceAccountVolumeSource) []interface{} <span class="cov0" title="0">{
        att := make(map[string]interface{})

        att["service_account_name"] = in.ServiceAccountName

        return []interface{}{att}
}</span>

func flattenContainerDisk(in kubevirtapiv1.ContainerDiskSource) []interface{} <span class="cov0" title="0">{
        att := make(map[string]interface{})

        att["image_url"] = in.Image

        return []interface{}{att}
}</span>

func flattenCloudInitNoCloud(in kubevirtapiv1.CloudInitNoCloudSource) []interface{} <span class="cov0" title="0">{
        att := make(map[string]interface{})

        if in.UserDataSecretRef != nil </span><span class="cov0" title="0">{
                att["user_data_secret_ref"] = k8s.FlattenLocalObjectReferences(*in.UserDataSecretRef)
        }</span>
        <span class="cov0" title="0">att["user_data_base64"] = in.UserDataBase64
        att["user_data"] = in.UserData
        if in.NetworkDataSecretRef != nil </span><span class="cov0" title="0">{
                att["network_data_secret_ref"] = k8s.FlattenLocalObjectReferences(*in.NetworkDataSecretRef)
        }</span>
        <span class="cov0" title="0">att["network_data_base64"] = in.NetworkDataBase64
        att["network_data"] = in.NetworkData

        return []interface{}{att}</span>
}

func flattenEphemeral(in kubevirtapiv1.EphemeralVolumeSource) []interface{} <span class="cov0" title="0">{
        att := make(map[string]interface{})

        if in.PersistentVolumeClaim != nil </span><span class="cov0" title="0">{
                att["persistent_volume_claim"] = flattenPersistentVolumeClaim(*in.PersistentVolumeClaim)
        }</span>

        <span class="cov0" title="0">return []interface{}{att}</span>
}

func flattenPersistentVolumeClaim(in v1.PersistentVolumeClaimVolumeSource) []interface{} <span class="cov0" title="0">{
        att := make(map[string]interface{})

        att["claim_name"] = in.ClaimName

        return []interface{}{att}
}</span>

func flattenEmptyDisk(in kubevirtapiv1.EmptyDiskSource) []interface{} <span class="cov0" title="0">{
        att := make(map[string]interface{})

        att["capacity"] = in.Capacity

        return []interface{}{att}
}</span>

func flattenHostDisk(in kubevirtapiv1.HostDisk) []interface{} <span class="cov0" title="0">{
        att := make(map[string]interface{})

        att["path"] = in.Path
        att["type"] = in.Type

        return []interface{}{att}
}</span>

func flattenConfigMap(in kubevirtapiv1.ConfigMapVolumeSource) []interface{} <span class="cov0" title="0">{
        att := make(map[string]interface{})

        att["name"] = in.Name

        return []interface{}{att}
}</span>
</pre>
		
		<pre class="file" id="file97" style="display: none">package expand_utils

import (
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        test_entities "github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/kubevirt/test_utils/entities"
        "github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/kubevirt/utils"
        k8sv1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/api/resource"
        v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        kubevirtapiv1 "kubevirt.io/api/core/v1"
        cdiv1 "kubevirt.io/containerized-data-importer-api/pkg/apis/core/v1beta1"
)

func getDataVolumeSpec() cdiv1.DataVolumeSpec <span class="cov0" title="0">{
        imgURL := "docker://gcr.io/spectro-images-public/daily/os/ubuntu-container-disk:22.04"
        limitStorage, _ := resource.ParseQuantity("20Gi")
        requestStorage, _ := resource.ParseQuantity("10Gi")
        storageClassName := "standard"
        volumeMode := "Block"
        return cdiv1.DataVolumeSpec{
                Source: &amp;cdiv1.DataVolumeSource{
                        HTTP: &amp;cdiv1.DataVolumeSourceHTTP{
                                URL:           "https://cloud.centos.org/centos/7/images/CentOS-7-x86_64-GenericCloud.qcow2",
                                SecretRef:     "secret_ref",
                                CertConfigMap: "cert_config_map",
                        },
                        Registry: &amp;cdiv1.DataVolumeSourceRegistry{
                                URL: &amp;imgURL,
                        },
                        PVC: &amp;cdiv1.DataVolumeSourcePVC{
                                Namespace: "namespace",
                                Name:      "name",
                        },
                        Blank: &amp;cdiv1.DataVolumeBlankImage{},
                },
                PVC: &amp;k8sv1.PersistentVolumeClaimSpec{
                        AccessModes: []k8sv1.PersistentVolumeAccessMode{"ReadWriteOnce"},
                        Resources: k8sv1.VolumeResourceRequirements{
                                Requests: k8sv1.ResourceList{
                                        "storage": requestStorage,
                                },
                                Limits: k8sv1.ResourceList{
                                        "storage": limitStorage,
                                },
                        },
                        Selector: &amp;v1.LabelSelector{
                                MatchLabels: map[string]string{
                                        "anti-affinity-key": "anti-affinity-val",
                                },
                        },
                        VolumeName:       "volume_name",
                        StorageClassName: &amp;storageClassName,
                        VolumeMode:       (*k8sv1.PersistentVolumeMode)(&amp;volumeMode),
                },
                ContentType: "content_type",
        }
}</span>

func getBaseOutputForDataVolumeTemplateSpec() kubevirtapiv1.DataVolumeTemplateSpec <span class="cov0" title="0">{
        return kubevirtapiv1.DataVolumeTemplateSpec{
                ObjectMeta: v1.ObjectMeta{
                        Name: "test-vm-bootvolume",
                },
                Spec: getDataVolumeSpec(),
        }
}</span>

func GetBaseInputForDataVolume() interface{} <span class="cov0" title="0">{
        return []interface{}{map[string]interface{}{
                "metadata": []interface{}{
                        map[string]interface{}{
                                "name": "test-vm-bootvolume",
                        },
                },
                "spec": []interface{}{
                        map[string]interface{}{
                                "source": []interface{}{
                                        map[string]interface{}{
                                                "blank": []interface{}{
                                                        map[string]interface{}{},
                                                },
                                                "http": []interface{}{
                                                        map[string]interface{}{
                                                                "url":             "https://cloud.centos.org/centos/7/images/CentOS-7-x86_64-GenericCloud.qcow2",
                                                                "secret_ref":      "secret_ref",
                                                                "cert_config_map": "cert_config_map",
                                                        },
                                                },
                                                "pvc": []interface{}{
                                                        map[string]interface{}{
                                                                "namespace": "namespace",
                                                                "name":      "name",
                                                        },
                                                },
                                                "registry": []interface{}{
                                                        map[string]interface{}{
                                                                "image_url": "docker://gcr.io/spectro-images-public/daily/os/ubuntu-container-disk:22.04",
                                                        },
                                                },
                                        },
                                },
                                "pvc": []interface{}{
                                        map[string]interface{}{
                                                "access_modes": utils.NewStringSet(schema.HashString, []string{"ReadWriteOnce"}),
                                                "resources": []interface{}{
                                                        map[string]interface{}{
                                                                "requests": map[string]interface{}{
                                                                        "storage": "10Gi",
                                                                },
                                                                "limits": map[string]interface{}{
                                                                        "storage": "20Gi",
                                                                },
                                                        },
                                                },
                                                "selector":           test_entities.LabelSelectorTerraform,
                                                "volume_name":        "volume_name",
                                                "storage_class_name": "standard",
                                                "volume_mode":        "Block",
                                        },
                                },
                                "content_type": "content_type",
                        },
                },
        }}
}</span>

func GetBaseInputForVirtualMachine() interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "data_volume_templates": GetBaseInputForDataVolume(),
                "run_strategy":          "Always",
                "annotations": map[string]interface{}{
                        "annotation_key": "annotation_value",
                },
                "labels": map[string]interface{}{
                        "kubevirt.io/vm": "test-vm",
                },
                "generate_name":       "generate_name",
                "name":                "name",
                "namespace":           "namespace",
                "priority_class_name": "priority_class_name",
                "resources": []interface{}{
                        map[string]interface{}{
                                "requests": map[string]interface{}{
                                        "cpu":    "4",
                                        "memory": "10G",
                                },
                                "limits": map[string]interface{}{
                                        "cpu":    "8",
                                        "memory": "20G",
                                },
                                "over_commit_guest_overhead": false,
                        },
                },
                "disk": []interface{}{
                        map[string]interface{}{
                                "disk_device": []interface{}{
                                        map[string]interface{}{
                                                "disk": []interface{}{
                                                        map[string]interface{}{
                                                                "bus":         "virtio",
                                                                "read_only":   true,
                                                                "pci_address": "pci_address",
                                                        },
                                                },
                                        },
                                },
                                "name":       "test-vm-datavolumedisk1",
                                "serial":     "serial",
                                "boot_order": 1,
                        },
                },
                "interface": []interface{}{
                        map[string]interface{}{
                                "interface_binding_method": "InterfaceBridge",
                                "name":                     "main",
                        },
                },
                "node_selector": map[string]interface{}{
                        "node_selector_key": "node_selector_value",
                },
                "affinity": []interface{}{
                        map[string]interface{}{
                                "node_affinity": []interface{}{
                                        map[string]interface{}{
                                                "required_during_scheduling_ignored_during_execution":  test_entities.NodeRequiredDuringSchedulingIgnoredDuringExecution,
                                                "preferred_during_scheduling_ignored_during_execution": test_entities.NodePreferredDuringSchedulingIgnoredDuringExecution,
                                        },
                                },
                                "pod_affinity": []interface{}{
                                        map[string]interface{}{
                                                "preferred_during_scheduling_ignored_during_execution": test_entities.PodPreferredDuringSchedulingIgnoredDuringExecutionTerraform,
                                                "required_during_scheduling_ignored_during_execution":  test_entities.PodRequiredDuringSchedulingIgnoredDuringExecutionTerraform,
                                        },
                                },
                                "pod_anti_affinity": []interface{}{
                                        map[string]interface{}{
                                                "preferred_during_scheduling_ignored_during_execution": test_entities.PodPreferredDuringSchedulingIgnoredDuringExecutionTerraform,
                                                "required_during_scheduling_ignored_during_execution":  test_entities.PodRequiredDuringSchedulingIgnoredDuringExecutionTerraform,
                                        },
                                },
                        },
                },
                "scheduler_name": "scheduler_name",
                "tolerations": []interface{}{
                        map[string]interface{}{
                                "effect":             "effect",
                                "key":                "key",
                                "operator":           "operator",
                                "toleration_seconds": "60",
                                "value":              "value",
                        },
                },
                "eviction_strategy":                "eviction_strategy",
                "termination_grace_period_seconds": 120,
                "volume": []interface{}{
                        map[string]interface{}{
                                "name": "test-vm-datavolumedisk1",
                                "volume_source": []interface{}{
                                        map[string]interface{}{
                                                "data_volume": []interface{}{
                                                        map[string]interface{}{
                                                                "name": "test-vm-bootvolume",
                                                        },
                                                },
                                                "cloud_init_config_drive": []interface{}{
                                                        map[string]interface{}{
                                                                "user_data_secret_ref": []interface{}{
                                                                        map[string]interface{}{
                                                                                "name": "name",
                                                                        },
                                                                },
                                                                "user_data_base64": "user_data_base64",
                                                                "user_data":        "user_data",
                                                                "network_data_secret_ref": []interface{}{
                                                                        map[string]interface{}{
                                                                                "name": "name",
                                                                        },
                                                                },
                                                                "network_data_base64": "network_data_base64",
                                                                "network_data":        "network_data",
                                                        },
                                                },
                                                "service_account": []interface{}{
                                                        map[string]interface{}{
                                                                "service_account_name": "service_account_name",
                                                        },
                                                },
                                        },
                                },
                        },
                },
                "hostname":  "hostname",
                "subdomain": "subdomain",
                "network": []interface{}{
                        map[string]interface{}{
                                "name": "main",
                                "network_source": []interface{}{
                                        map[string]interface{}{
                                                "pod": []interface{}{
                                                        map[string]interface{}{
                                                                "vm_network_cidr": "vm_network_cidr",
                                                        },
                                                },
                                                "multus": []interface{}{
                                                        map[string]interface{}{
                                                                "network_name": "tenantcluster",
                                                        },
                                                },
                                        },
                                },
                        },
                },
                "dns_policy": "dns_policy",
        }
}</span>

func GetBaseOutputForVirtualMachine() kubevirtapiv1.VirtualMachineSpec <span class="cov0" title="0">{
        return kubevirtapiv1.VirtualMachineSpec{
                RunStrategy: (func() *kubevirtapiv1.VirtualMachineRunStrategy </span><span class="cov0" title="0">{
                        strategy := kubevirtapiv1.VirtualMachineRunStrategy("Always")
                        return &amp;strategy
                }</span>)(),
                DataVolumeTemplates: []kubevirtapiv1.DataVolumeTemplateSpec{
                        getBaseOutputForDataVolumeTemplateSpec(),
                },
                Template: &amp;kubevirtapiv1.VirtualMachineInstanceTemplateSpec{
                        ObjectMeta: v1.ObjectMeta{},
                        Spec: kubevirtapiv1.VirtualMachineInstanceSpec{
                                PriorityClassName: "priority_class_name",
                                Domain: kubevirtapiv1.DomainSpec{
                                        Resources: kubevirtapiv1.ResourceRequirements{
                                                Requests: k8sv1.ResourceList{
                                                        "memory": (func() resource.Quantity <span class="cov0" title="0">{ res, _ := resource.ParseQuantity("10G"); return res }</span>)(),
                                                        "cpu":    *resource.NewQuantity(int64(4), resource.DecimalExponent),
                                                },
                                                Limits: k8sv1.ResourceList{
                                                        "memory": (func() resource.Quantity <span class="cov0" title="0">{ res, _ := resource.ParseQuantity("20G"); return res }</span>)(),
                                                        "cpu":    *resource.NewQuantity(int64(8), resource.DecimalExponent),
                                                },
                                                OvercommitGuestOverhead: false,
                                        },
                                        Devices: kubevirtapiv1.Devices{
                                                Disks: []kubevirtapiv1.Disk{
                                                        {
                                                                Name:      "test-vm-datavolumedisk1",
                                                                Serial:    "serial",
                                                                BootOrder: func() *uint <span class="cov0" title="0">{ bo := uint(1); return &amp;bo }</span>(),
                                                                DiskDevice: kubevirtapiv1.DiskDevice{
                                                                        Disk: &amp;kubevirtapiv1.DiskTarget{
                                                                                Bus:        "virtio",
                                                                                ReadOnly:   true,
                                                                                PciAddress: "pci_address",
                                                                        },
                                                                },
                                                        },
                                                },
                                                Interfaces: []kubevirtapiv1.Interface{
                                                        {
                                                                Name: "main",
                                                                InterfaceBindingMethod: kubevirtapiv1.InterfaceBindingMethod{
                                                                        Bridge: &amp;kubevirtapiv1.InterfaceBridge{},
                                                                },
                                                        },
                                                },
                                        },
                                },
                                NodeSelector: map[string]string{
                                        "node_selector_key": "node_selector_value",
                                },
                                Affinity:      nil,
                                SchedulerName: "scheduler_name",
                                Tolerations: []k8sv1.Toleration{
                                        {
                                                Effect:            k8sv1.TaintEffect("effect"),
                                                Key:               "key",
                                                Operator:          k8sv1.TolerationOperator("operator"),
                                                TolerationSeconds: utils.PtrToInt64(int64(60)),
                                                Value:             "value",
                                        },
                                },
                                EvictionStrategy: (func() *kubevirtapiv1.EvictionStrategy <span class="cov0" title="0">{
                                        retval := kubevirtapiv1.EvictionStrategy("eviction_strategy")
                                        return &amp;retval
                                }</span>)(),
                                TerminationGracePeriodSeconds: utils.PtrToInt64(int64(120)),
                                Volumes: []kubevirtapiv1.Volume{
                                        {
                                                Name: "test-vm-datavolumedisk1",
                                                VolumeSource: kubevirtapiv1.VolumeSource{
                                                        DataVolume: &amp;kubevirtapiv1.DataVolumeSource{
                                                                Name: "test-vm-bootvolume",
                                                        },
                                                        CloudInitConfigDrive: &amp;kubevirtapiv1.CloudInitConfigDriveSource{
                                                                UserDataSecretRef: &amp;k8sv1.LocalObjectReference{
                                                                        Name: "name",
                                                                },
                                                                UserDataBase64: "user_data_base64",
                                                                UserData:       "user_data",
                                                                NetworkDataSecretRef: &amp;k8sv1.LocalObjectReference{
                                                                        Name: "name",
                                                                },
                                                                NetworkDataBase64: "network_data_base64",
                                                                NetworkData:       "network_data",
                                                        },
                                                        ServiceAccount: &amp;kubevirtapiv1.ServiceAccountVolumeSource{
                                                                ServiceAccountName: "service_account_name",
                                                        },
                                                },
                                        },
                                },
                                Hostname:  "hostname",
                                Subdomain: "subdomain",
                                Networks: []kubevirtapiv1.Network{
                                        {
                                                Name: "main",
                                                NetworkSource: kubevirtapiv1.NetworkSource{
                                                        Pod: &amp;kubevirtapiv1.PodNetwork{
                                                                VMNetworkCIDR: "vm_network_cidr",
                                                        },
                                                        Multus: &amp;kubevirtapiv1.MultusNetwork{
                                                                NetworkName: "tenantcluster",
                                                        },
                                                },
                                        },
                                },
                                DNSPolicy: k8sv1.DNSPolicy("dns_policy"),
                                DNSConfig: nil,
                        },
                },
        }
}
</pre>
		
		<pre class="file" id="file98" style="display: none">package flatten_utils

import (
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

        test_entities "github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/kubevirt/test_utils/entities"
        "github.com/spectrocloud/terraform-provider-spectrocloud/types"

        "github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/kubevirt/utils"

        k8sv1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/api/resource"
        v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        cdiv1 "kubevirt.io/containerized-data-importer-api/pkg/apis/core/v1beta1"

        kubevirtapiv1 "kubevirt.io/api/core/v1"
)

func getDataVolumeSpec() cdiv1.DataVolumeSpec <span class="cov0" title="0">{
        return cdiv1.DataVolumeSpec{
                Source: &amp;cdiv1.DataVolumeSource{
                        Blank: &amp;cdiv1.DataVolumeBlankImage{},
                        HTTP: &amp;cdiv1.DataVolumeSourceHTTP{
                                URL:           "https://cloud.centos.org/centos/7/images/CentOS-7-x86_64-GenericCloud.qcow2",
                                SecretRef:     "secret_ref",
                                CertConfigMap: "cert_config_map",
                        },
                        PVC: &amp;cdiv1.DataVolumeSourcePVC{
                                Namespace: "namespace",
                                Name:      "name",
                        },
                        Registry: &amp;cdiv1.DataVolumeSourceRegistry{
                                URL: types.Ptr("docker://gcr.io/spectro-images-public/daily/os/ubuntu-container-disk:22.04"),
                        },
                },
                PVC: &amp;k8sv1.PersistentVolumeClaimSpec{
                        AccessModes: []k8sv1.PersistentVolumeAccessMode{
                                "ReadWriteOnce",
                        },
                        Resources: k8sv1.VolumeResourceRequirements{
                                Requests: k8sv1.ResourceList{
                                        "storage": (func() resource.Quantity </span><span class="cov0" title="0">{ res, _ := resource.ParseQuantity("10Gi"); return res }</span>)(),
                                },
                                Limits: k8sv1.ResourceList{
                                        "storage": (func() resource.Quantity <span class="cov0" title="0">{ res, _ := resource.ParseQuantity("20Gi"); return res }</span>)(),
                                },
                        },
                        Selector:         test_entities.LabelSelectorAPI,
                        VolumeName:       "volume_name",
                        StorageClassName: (func() *string <span class="cov0" title="0">{ str := "standard"; return &amp;str }</span>)(),
                },
                ContentType: cdiv1.DataVolumeContentType("content_type"),
        }
}

func GetBaseInputForDataVolume() cdiv1.DataVolume <span class="cov0" title="0">{
        return cdiv1.DataVolume{
                ObjectMeta: v1.ObjectMeta{
                        GenerateName: "generate_name",
                        Name:         "test-vm-bootvolume",
                        Namespace:    "tenantcluster",
                },
                Spec: getDataVolumeSpec(),
        }
}</span>

func GetBaseInputForDataVolumeTemplateSpec() kubevirtapiv1.DataVolumeTemplateSpec <span class="cov0" title="0">{
        return kubevirtapiv1.DataVolumeTemplateSpec{
                ObjectMeta: v1.ObjectMeta{},
                Spec:       getDataVolumeSpec(),
        }
}</span>

func GetBaseOutputForDataVolume() interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "metadata": []interface{}{
                        map[string]interface{}{
                                "annotations":      interface{}(map[string]interface{}(nil)),
                                "labels":           interface{}(map[string]interface{}(nil)),
                                "name":             "test-vm-bootvolume",
                                "resource_version": interface{}(""),
                                "self_link":        interface{}(""),
                                "uid":              interface{}(""),
                                "generation":       interface{}(int64(0)),
                                "namespace":        "tenantcluster",
                                "generate_name":    "generate_name",
                        },
                },
                "spec": []interface{}{
                        map[string]interface{}{
                                "pvc": []interface{}{
                                        map[string]interface{}{
                                                "access_modes": (func() *schema.Set </span><span class="cov0" title="0">{
                                                        out := []interface{}{
                                                                "ReadWriteOnce",
                                                        }
                                                        return schema.NewSet(schema.HashString, out)
                                                }</span>)(),
                                                "resources": []interface{}{
                                                        map[string]interface{}{
                                                                "requests": map[string]interface{}{
                                                                        "storage": "10Gi",
                                                                },
                                                                "limits": map[string]interface{}{
                                                                        "storage": "20Gi",
                                                                },
                                                        },
                                                },
                                                "selector":           test_entities.LabelSelectorTerraform,
                                                "volume_name":        "volume_name",
                                                "storage_class_name": "standard",
                                        },
                                },
                                "source": []interface{}{
                                        map[string]interface{}{
                                                "blank": []interface{}{
                                                        map[string]interface{}{},
                                                },
                                                "http": []interface{}{
                                                        map[string]interface{}{
                                                                "url":             "https://cloud.centos.org/centos/7/images/CentOS-7-x86_64-GenericCloud.qcow2",
                                                                "secret_ref":      "secret_ref",
                                                                "cert_config_map": "cert_config_map",
                                                        },
                                                },
                                                "pvc": []interface{}{
                                                        map[string]interface{}{
                                                                "namespace": "namespace",
                                                                "name":      "name",
                                                        },
                                                },
                                                "registry": []interface{}{
                                                        map[string]interface{}{
                                                                "image_url": types.Ptr("docker://gcr.io/spectro-images-public/daily/os/ubuntu-container-disk:22.04"),
                                                        },
                                                },
                                        },
                                },
                                "content_type": "content_type",
                        },
                },
                "status": []interface{}{
                        map[string]interface{}{
                                "phase":    "",
                                "progress": "",
                        },
                },
        }
}

func GetBaseInputForVirtualMachine() kubevirtapiv1.VirtualMachineSpec <span class="cov0" title="0">{
        return kubevirtapiv1.VirtualMachineSpec{
                RunStrategy: (func() *kubevirtapiv1.VirtualMachineRunStrategy </span><span class="cov0" title="0">{
                        strategy := kubevirtapiv1.VirtualMachineRunStrategy("Always")
                        return &amp;strategy
                }</span>)(),
                DataVolumeTemplates: []kubevirtapiv1.DataVolumeTemplateSpec{
                        GetBaseInputForDataVolumeTemplateSpec(),
                },
                Template: &amp;kubevirtapiv1.VirtualMachineInstanceTemplateSpec{
                        ObjectMeta: v1.ObjectMeta{},
                        Spec: kubevirtapiv1.VirtualMachineInstanceSpec{
                                PriorityClassName: "priority_class_name",
                                Volumes: []kubevirtapiv1.Volume{
                                        {
                                                Name: "test-vm-datavolumedisk1",
                                                VolumeSource: kubevirtapiv1.VolumeSource{
                                                        DataVolume: &amp;kubevirtapiv1.DataVolumeSource{
                                                                Name: "test-vm-bootvolume",
                                                        },
                                                        CloudInitConfigDrive: &amp;kubevirtapiv1.CloudInitConfigDriveSource{
                                                                UserDataSecretRef: &amp;k8sv1.LocalObjectReference{
                                                                        Name: "name",
                                                                },
                                                                UserDataBase64: "user_data_base64",
                                                                UserData:       "user_data",
                                                                NetworkDataSecretRef: &amp;k8sv1.LocalObjectReference{
                                                                        Name: "name",
                                                                },
                                                                NetworkDataBase64: "network_data_base64",
                                                                NetworkData:       "network_data",
                                                        },
                                                        ServiceAccount: &amp;kubevirtapiv1.ServiceAccountVolumeSource{
                                                                ServiceAccountName: "service_account_name",
                                                        },
                                                },
                                        },
                                },
                                Domain: kubevirtapiv1.DomainSpec{
                                        Resources: kubevirtapiv1.ResourceRequirements{
                                                Requests: k8sv1.ResourceList{
                                                        "memory": (func() resource.Quantity <span class="cov0" title="0">{ res, _ := resource.ParseQuantity("10G"); return res }</span>)(),
                                                        "cpu":    *resource.NewQuantity(int64(4), resource.DecimalExponent),
                                                },
                                                Limits: k8sv1.ResourceList{
                                                        "memory": (func() resource.Quantity <span class="cov0" title="0">{ res, _ := resource.ParseQuantity("20G"); return res }</span>)(),
                                                        "cpu":    *resource.NewQuantity(int64(8), resource.DecimalExponent),
                                                },
                                                OvercommitGuestOverhead: true,
                                        },
                                        Devices: kubevirtapiv1.Devices{
                                                Disks: []kubevirtapiv1.Disk{
                                                        {
                                                                Name:      "test-vm-datavolumedisk1",
                                                                Serial:    "serial",
                                                                BootOrder: func() *uint <span class="cov0" title="0">{ bo := uint(1); return &amp;bo }</span>(),
                                                                DiskDevice: kubevirtapiv1.DiskDevice{
                                                                        Disk: &amp;kubevirtapiv1.DiskTarget{
                                                                                Bus:        "virtio",
                                                                                ReadOnly:   true,
                                                                                PciAddress: "pci_address",
                                                                        },
                                                                },
                                                        },
                                                },
                                                Interfaces: []kubevirtapiv1.Interface{
                                                        {
                                                                Name: "main",
                                                                InterfaceBindingMethod: kubevirtapiv1.InterfaceBindingMethod{
                                                                        Bridge: &amp;kubevirtapiv1.InterfaceBridge{},
                                                                },
                                                        },
                                                },
                                        },
                                },
                                NodeSelector: map[string]string{
                                        "node_selector_key": "node_selector_value",
                                },
                                Hostname:      "hostname",
                                Subdomain:     "subdomain",
                                SchedulerName: "scheduler_name",
                                Tolerations: []k8sv1.Toleration{
                                        {
                                                Effect:            k8sv1.TaintEffect("effect"),
                                                Key:               "key",
                                                Operator:          k8sv1.TolerationOperator("operator"),
                                                TolerationSeconds: utils.PtrToInt64(int64(60)),
                                                Value:             "value",
                                        },
                                },
                                EvictionStrategy: (func() *kubevirtapiv1.EvictionStrategy <span class="cov0" title="0">{
                                        retval := kubevirtapiv1.EvictionStrategy("eviction_strategy")
                                        return &amp;retval
                                }</span>)(),
                                TerminationGracePeriodSeconds: utils.PtrToInt64(int64(120)),
                                Networks: []kubevirtapiv1.Network{
                                        {
                                                Name: "main",
                                                NetworkSource: kubevirtapiv1.NetworkSource{
                                                        Pod: &amp;kubevirtapiv1.PodNetwork{
                                                                VMNetworkCIDR: "vm_network_cidr",
                                                        },
                                                        Multus: &amp;kubevirtapiv1.MultusNetwork{
                                                                NetworkName: "tenantcluster",
                                                        },
                                                },
                                        },
                                },
                                DNSPolicy: k8sv1.DNSPolicy("dns_policy"),
                                DNSConfig: &amp;k8sv1.PodDNSConfig{
                                        Options: []k8sv1.PodDNSConfigOption{
                                                {
                                                        Name:  "name",
                                                        Value: (func() *string <span class="cov0" title="0">{ retval := "value"; return &amp;retval }</span>)(),
                                                },
                                        },
                                },
                                Affinity: &amp;k8sv1.Affinity{
                                        NodeAffinity: &amp;k8sv1.NodeAffinity{
                                                RequiredDuringSchedulingIgnoredDuringExecution: &amp;k8sv1.NodeSelector{
                                                        NodeSelectorTerms: test_entities.NodeSelectorTermAPI,
                                                },
                                                PreferredDuringSchedulingIgnoredDuringExecution: []k8sv1.PreferredSchedulingTerm{
                                                        {
                                                                Weight: int32(10),
                                                                Preference: k8sv1.NodeSelectorTerm{
                                                                        MatchExpressions: test_entities.MatchExpressionAPI,
                                                                        MatchFields:      test_entities.MatchFieldsAPI,
                                                                },
                                                        },
                                                },
                                        },
                                        PodAffinity: &amp;k8sv1.PodAffinity{
                                                PreferredDuringSchedulingIgnoredDuringExecution: test_entities.PodPreferredDuringSchedulingIgnoredDuringExecutionAPI,
                                                RequiredDuringSchedulingIgnoredDuringExecution:  test_entities.PodRequiredDuringSchedulingIgnoredDuringExecutionAPI,
                                        },
                                        PodAntiAffinity: &amp;k8sv1.PodAntiAffinity{
                                                PreferredDuringSchedulingIgnoredDuringExecution: test_entities.PodPreferredDuringSchedulingIgnoredDuringExecutionAPI,
                                                RequiredDuringSchedulingIgnoredDuringExecution:  test_entities.PodRequiredDuringSchedulingIgnoredDuringExecutionAPI,
                                        },
                                },
                        },
                },
        }
}

func GetBaseOutputForVirtualMachine() interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "data_volume_templates": []interface{}{
                        map[string]interface{}{
                                "metadata": []any{
                                        map[string]any{
                                                "annotations":      map[string]any(nil),
                                                "generation":       int64(0),
                                                "labels":           map[string]any(nil),
                                                "name":             string(""),
                                                "resource_version": string(""),
                                                "uid":              string(""),
                                        },
                                },
                                "spec": []interface{}{
                                        map[string]interface{}{
                                                "pvc": []interface{}{
                                                        map[string]interface{}{
                                                                "access_modes": (func() *schema.Set </span><span class="cov0" title="0">{
                                                                        out := []interface{}{
                                                                                "ReadWriteOnce",
                                                                        }
                                                                        return schema.NewSet(schema.HashString, out)
                                                                }</span>)(),
                                                                "resources": []interface{}{
                                                                        map[string]interface{}{
                                                                                "requests": map[string]interface{}{
                                                                                        "storage": "10Gi",
                                                                                },
                                                                                "limits": map[string]interface{}{
                                                                                        "storage": "20Gi",
                                                                                },
                                                                        },
                                                                },
                                                                "selector":           test_entities.LabelSelectorTerraform,
                                                                "volume_name":        "volume_name",
                                                                "storage_class_name": "standard",
                                                        },
                                                },
                                                "source": []interface{}{
                                                        map[string]interface{}{
                                                                "blank": []interface{}{
                                                                        map[string]interface{}{},
                                                                },
                                                                "http": []interface{}{
                                                                        map[string]interface{}{
                                                                                "url":             "https://cloud.centos.org/centos/7/images/CentOS-7-x86_64-GenericCloud.qcow2",
                                                                                "secret_ref":      "secret_ref",
                                                                                "cert_config_map": "cert_config_map",
                                                                        },
                                                                },
                                                                "pvc": []interface{}{
                                                                        map[string]interface{}{
                                                                                "namespace": "namespace",
                                                                                "name":      "name",
                                                                        },
                                                                },
                                                                "registry": []interface{}{
                                                                        map[string]interface{}{
                                                                                "image_url": types.Ptr("docker://gcr.io/spectro-images-public/daily/os/ubuntu-container-disk:22.04"),
                                                                        },
                                                                },
                                                        },
                                                },
                                                "content_type": "content_type",
                                        },
                                },
                        },
                },
                "run_strategy": "Always",
                "template": []interface{}{
                        map[string]interface{}{
                                "spec": []interface{}{
                                        map[string]interface{}{
                                                "node_selector": map[string]interface{}{
                                                        "node_selector_key": "node_selector_value",
                                                },
                                                "scheduler_name": "scheduler_name",
                                                "tolerations": []interface{}{
                                                        map[string]interface{}{
                                                                "effect":             "effect",
                                                                "key":                "key",
                                                                "operator":           "operator",
                                                                "toleration_seconds": "60",
                                                                "value":              "value",
                                                        },
                                                },
                                                "dns_policy":          "dns_policy",
                                                "priority_class_name": "priority_class_name",
                                                "hostname":            "hostname",
                                                "subdomain":           "subdomain",
                                                "pod_dns_config": []interface{}{
                                                        map[string]interface{}{
                                                                "option": []interface{}{
                                                                        map[string]interface{}{
                                                                                "name":  "name",
                                                                                "value": "value",
                                                                        },
                                                                },
                                                        },
                                                },
                                                "affinity": []interface{}{
                                                        map[string]interface{}{
                                                                "node_affinity": []interface{}{
                                                                        map[string]interface{}{
                                                                                "required_during_scheduling_ignored_during_execution":  test_entities.NodeRequiredDuringSchedulingIgnoredDuringExecution,
                                                                                "preferred_during_scheduling_ignored_during_execution": test_entities.NodePreferredDuringSchedulingIgnoredDuringExecution,
                                                                        },
                                                                },
                                                                "pod_affinity": []interface{}{
                                                                        map[string]interface{}{
                                                                                "preferred_during_scheduling_ignored_during_execution": test_entities.PodPreferredDuringSchedulingIgnoredDuringExecutionTerraform,
                                                                                "required_during_scheduling_ignored_during_execution":  test_entities.PodRequiredDuringSchedulingIgnoredDuringExecutionTerraform,
                                                                        },
                                                                },
                                                                "pod_anti_affinity": []interface{}{
                                                                        map[string]interface{}{
                                                                                "preferred_during_scheduling_ignored_during_execution": test_entities.PodPreferredDuringSchedulingIgnoredDuringExecutionTerraform,
                                                                                "required_during_scheduling_ignored_during_execution":  test_entities.PodRequiredDuringSchedulingIgnoredDuringExecutionTerraform,
                                                                        },
                                                                },
                                                        },
                                                },
                                                "domain": []interface{}{
                                                        map[string]interface{}{
                                                                "devices": []interface{}{
                                                                        map[string]interface{}{
                                                                                "disk": []interface{}{
                                                                                        map[string]interface{}{
                                                                                                "disk_device": []interface{}{
                                                                                                        map[string]interface{}{
                                                                                                                "disk": []interface{}{
                                                                                                                        map[string]interface{}{
                                                                                                                                "bus":         kubevirtapiv1.DiskBus("virtio"),
                                                                                                                                "read_only":   true,
                                                                                                                                "pci_address": "pci_address",
                                                                                                                        },
                                                                                                                },
                                                                                                        },
                                                                                                },
                                                                                                "name":       "test-vm-datavolumedisk1",
                                                                                                "serial":     "serial",
                                                                                                "boot_order": 1,
                                                                                        },
                                                                                },
                                                                                "interface": []interface{}{
                                                                                        map[string]interface{}{
                                                                                                "interface_binding_method": "InterfaceBridge",
                                                                                                "name":                     "main",
                                                                                        },
                                                                                },
                                                                        },
                                                                },
                                                                "resources": []interface{}{
                                                                        map[string]interface{}{
                                                                                "requests": map[string]interface{}{
                                                                                        "cpu":    "4",
                                                                                        "memory": "10G",
                                                                                },
                                                                                "limits": map[string]interface{}{
                                                                                        "cpu":    "8",
                                                                                        "memory": "20G",
                                                                                },
                                                                                "over_commit_guest_overhead": true,
                                                                        },
                                                                },
                                                        },
                                                },
                                                "eviction_strategy":                "eviction_strategy",
                                                "termination_grace_period_seconds": int64(120),
                                                "volume": []interface{}{
                                                        map[string]interface{}{
                                                                "name": "test-vm-datavolumedisk1",
                                                                "volume_source": []interface{}{
                                                                        map[string]interface{}{
                                                                                "data_volume": []interface{}{
                                                                                        map[string]interface{}{
                                                                                                "name": "test-vm-bootvolume",
                                                                                        },
                                                                                },
                                                                                "cloud_init_config_drive": []interface{}{
                                                                                        map[string]interface{}{
                                                                                                "user_data_secret_ref": []interface{}{
                                                                                                        map[string]interface{}{
                                                                                                                "name": "name",
                                                                                                        },
                                                                                                },
                                                                                                "user_data_base64": "user_data_base64",
                                                                                                "user_data":        "user_data",
                                                                                                "network_data_secret_ref": []interface{}{
                                                                                                        map[string]interface{}{
                                                                                                                "name": "name",
                                                                                                        },
                                                                                                },
                                                                                                "network_data_base64": "network_data_base64",
                                                                                                "network_data":        "network_data",
                                                                                        },
                                                                                },
                                                                                "service_account": []interface{}{
                                                                                        map[string]interface{}{
                                                                                                "service_account_name": "service_account_name",
                                                                                        },
                                                                                },
                                                                        },
                                                                },
                                                        },
                                                },
                                                "network": []interface{}{
                                                        map[string]interface{}{
                                                                "name": "main",
                                                                "network_source": []interface{}{
                                                                        map[string]interface{}{
                                                                                "pod": []interface{}{
                                                                                        map[string]interface{}{
                                                                                                "vm_network_cidr": "vm_network_cidr",
                                                                                        },
                                                                                },
                                                                                "multus": []interface{}{
                                                                                        map[string]interface{}{
                                                                                                "network_name": "tenantcluster",
                                                                                                "default":      false,
                                                                                        },
                                                                                },
                                                                        },
                                                                },
                                                        },
                                                },
                                        },
                                },
                        },
                },
        }
}
</pre>
		
		<pre class="file" id="file99" style="display: none">package test_utils

import "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

func NullifySchemaSetFunction(ss *schema.Set) <span class="cov0" title="0">{
        ss.F = nil
}</span>

func GetPVCRequirements(dataVolume interface{}) interface{} <span class="cov0" title="0">{
        return dataVolume.(map[string]interface{})["spec"].([]interface{})[0].(map[string]interface{})["pvc"].([]interface{})[0].(map[string]interface{})["resources"].([]interface{})[0]
}</span>
</pre>
		
		<pre class="file" id="file100" style="display: none">package patch

import (
        "encoding/json"
        "reflect"
        "sort"
        "strings"
)

func DiffStringMap(pathPrefix string, oldV, newV map[string]interface{}) PatchOperations <span class="cov0" title="0">{
        ops := make([]PatchOperation, 0)

        pathPrefix = strings.TrimRight(pathPrefix, "/")

        // If old value was empty, just create the object
        if len(oldV) == 0 </span><span class="cov0" title="0">{
                ops = append(ops, &amp;AddOperation{
                        Path:  pathPrefix,
                        Value: newV,
                })
                return ops
        }</span>

        // This is suboptimal for adding whole new map from scratch
        // or deleting the whole map, but it's actually intention.
        // There may be some other map items managed outside of TF
        // and we don't want to touch these.

        <span class="cov0" title="0">for k := range oldV </span><span class="cov0" title="0">{
                if _, ok := newV[k]; ok </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">ops = append(ops, &amp;RemoveOperation{
                        Path: pathPrefix + "/" + escapeJsonPointer(k),
                })</span>
        }

        <span class="cov0" title="0">for k, v := range newV </span><span class="cov0" title="0">{
                newValue := v.(string)

                if oldValue, ok := oldV[k].(string); ok </span><span class="cov0" title="0">{
                        if oldValue == newValue </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">ops = append(ops, &amp;ReplaceOperation{
                                Path:  pathPrefix + "/" + escapeJsonPointer(k),
                                Value: newValue,
                        })
                        continue</span>
                }

                <span class="cov0" title="0">ops = append(ops, &amp;AddOperation{
                        Path:  pathPrefix + "/" + escapeJsonPointer(k),
                        Value: newValue,
                })</span>
        }

        <span class="cov0" title="0">return ops</span>
}

// escapeJsonPointer escapes string per RFC 6901
// so it can be used as path in JSON patch operations
func escapeJsonPointer(path string) string <span class="cov0" title="0">{
        path = strings.Replace(path, "~", "~0", -1)
        path = strings.Replace(path, "/", "~1", -1)
        return path
}</span>

type PatchOperations []PatchOperation

func (po PatchOperations) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        var v []PatchOperation = po
        return json.Marshal(v)
}</span>

func (po PatchOperations) Equal(ops []PatchOperation) bool <span class="cov0" title="0">{
        var v []PatchOperation = po

        sort.Slice(v, sortByPathAsc(v))
        sort.Slice(ops, sortByPathAsc(ops))

        return reflect.DeepEqual(v, ops)
}</span>

func sortByPathAsc(ops []PatchOperation) func(i, j int) bool <span class="cov0" title="0">{
        return func(i, j int) bool </span><span class="cov0" title="0">{
                return ops[i].GetPath() &lt; ops[j].GetPath()
        }</span>
}

type PatchOperation interface {
        MarshalJSON() ([]byte, error)
        GetPath() string
}

type ReplaceOperation struct {
        Path  string      `json:"path"`
        Value interface{} `json:"value"`
        Op    string      `json:"op"`
}

func (o *ReplaceOperation) GetPath() string <span class="cov0" title="0">{
        return o.Path
}</span>

func (o *ReplaceOperation) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        o.Op = "replace"
        return json.Marshal(*o)
}</span>

func (o *ReplaceOperation) String() string <span class="cov0" title="0">{
        b, _ := o.MarshalJSON()
        return string(b)
}</span>

type AddOperation struct {
        Path  string      `json:"path"`
        Value interface{} `json:"value"`
        Op    string      `json:"op"`
}

func (o *AddOperation) GetPath() string <span class="cov0" title="0">{
        return o.Path
}</span>

func (o *AddOperation) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        o.Op = "add"
        return json.Marshal(*o)
}</span>

func (o *AddOperation) String() string <span class="cov0" title="0">{
        b, _ := o.MarshalJSON()
        return string(b)
}</span>

type RemoveOperation struct {
        Path string `json:"path"`
        Op   string `json:"op"`
}

func (o *RemoveOperation) GetPath() string <span class="cov0" title="0">{
        return o.Path
}</span>

func (o *RemoveOperation) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        o.Op = "remove"
        return json.Marshal(*o)
}</span>

func (o *RemoveOperation) String() string <span class="cov0" title="0">{
        b, _ := o.MarshalJSON()
        return string(b)
}</span>
</pre>
		
		<pre class="file" id="file101" style="display: none">package utils

import (
        "encoding/base64"
        "fmt"
        "strings"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/spectrocloud/palette-sdk-go/api/models"
        api "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/api/resource"
)

func IdParts(id string) (string, string, string, string, error) <span class="cov0" title="0">{
        parts := strings.Split(id, "/")
        if len(parts) != 4 </span><span class="cov0" title="0">{
                err := fmt.Errorf("unexpected ID format (%q), expected %q", id, "namespace/name")
                return "", "", "", "", err
        }</span>

        <span class="cov0" title="0">return parts[0], parts[1], parts[2], parts[3], nil</span>
}

func IdPartsDV(id string) (string, string, string, string, string, error) <span class="cov0" title="0">{
        parts := strings.Split(id, "/")
        if len(parts) != 5 </span><span class="cov0" title="0">{
                err := fmt.Errorf("unexpected ID format (%q), expected %q", id, "namespace/name")
                return "", "", "", "", "", err
        }</span>

        <span class="cov0" title="0">return parts[0], parts[1], parts[2], parts[3], parts[4], nil</span>
}

func BuildId(clusterScope, clusterUid string, meta *models.V1VMObjectMeta) string <span class="cov0" title="0">{
        return clusterScope + "/" + clusterUid + "/" + meta.Namespace + "/" + meta.Name
}</span>

func BuildIdDV(clusterScope, clusterUid, vm_namespace, vm_name string, meta *models.V1VMObjectMeta) string <span class="cov0" title="0">{
        return clusterScope + "/" + clusterUid + "/" + vm_namespace + "/" + vm_name + "/" + meta.Name
}</span>

func FlattenStringMap(m map[string]string) map[string]interface{} <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">result := make(map[string]interface{})
        for k, v := range m </span><span class="cov0" title="0">{
                result[k] = v
        }</span>
        <span class="cov0" title="0">return result</span>
}

func ExpandStringMap(m map[string]interface{}) map[string]string <span class="cov0" title="0">{
        result := make(map[string]string)
        for k, v := range m </span><span class="cov0" title="0">{
                result[k] = v.(string)
        }</span>
        <span class="cov0" title="0">return result</span>
}

func ExpandBase64MapToByteMap(m map[string]interface{}) map[string][]byte <span class="cov0" title="0">{
        result := make(map[string][]byte)
        for k, v := range m </span><span class="cov0" title="0">{
                b, err := base64.StdEncoding.DecodeString(v.(string))
                if err == nil </span><span class="cov0" title="0">{
                        result[k] = b
                }</span>
        }
        <span class="cov0" title="0">return result</span>
}

func ExpandStringMapToByteMap(m map[string]interface{}) map[string][]byte <span class="cov0" title="0">{
        result := make(map[string][]byte)
        for k, v := range m </span><span class="cov0" title="0">{
                result[k] = []byte(v.(string))
        }</span>
        <span class="cov0" title="0">return result</span>
}

func ExpandStringSlice(s []interface{}) []string <span class="cov0" title="0">{
        result := make([]string, len(s))
        for k, v := range s </span><span class="cov0" title="0">{
                // Handle the Terraform parser bug which turns empty strings in lists to nil.
                if v == nil </span><span class="cov0" title="0">{
                        result[k] = ""
                }</span> else<span class="cov0" title="0"> {
                        result[k] = v.(string)
                }</span>
        }
        <span class="cov0" title="0">return result</span>
}

func FlattenByteMapToBase64Map(m map[string][]byte) map[string]string <span class="cov0" title="0">{
        result := make(map[string]string)
        for k, v := range m </span><span class="cov0" title="0">{
                result[k] = base64.StdEncoding.EncodeToString([]byte(v))
        }</span>
        <span class="cov0" title="0">return result</span>
}

func FlattenByteMapToStringMap(m map[string][]byte) map[string]string <span class="cov0" title="0">{
        result := make(map[string]string)
        for k, v := range m </span><span class="cov0" title="0">{
                result[k] = string(v)
        }</span>
        <span class="cov0" title="0">return result</span>
}

func PtrToString(s string) *string <span class="cov0" title="0">{
        return &amp;s
}</span>

func PtrToBool(b bool) *bool <span class="cov0" title="0">{
        return &amp;b
}</span>

func PtrToInt32(i int32) *int32 <span class="cov0" title="0">{
        return &amp;i
}</span>

func PtrToInt64(i int64) *int64 <span class="cov0" title="0">{
        return &amp;i
}</span>

func SliceOfString(slice []interface{}) []string <span class="cov0" title="0">{
        result := make([]string, len(slice))
        for i, s := range slice </span><span class="cov0" title="0">{
                result[i] = s.(string)
        }</span>
        <span class="cov0" title="0">return result</span>
}

func Base64EncodeStringMap(m map[string]interface{}) map[string]interface{} <span class="cov0" title="0">{
        result := make(map[string]interface{})
        for k, v := range m </span><span class="cov0" title="0">{
                value := v.(string)
                result[k] = base64.StdEncoding.EncodeToString([]byte(value))
        }</span>
        <span class="cov0" title="0">return result</span>
}

func NewStringSet(f schema.SchemaSetFunc, in []string) *schema.Set <span class="cov7" title="4">{
        var out = make([]interface{}, len(in))
        for i, v := range in </span><span class="cov10" title="6">{
                out[i] = v
        }</span>
        <span class="cov7" title="4">return schema.NewSet(f, out)</span>
}

func NewInt64Set(f schema.SchemaSetFunc, in []int64) *schema.Set <span class="cov0" title="0">{
        var out = make([]interface{}, len(in))
        for i, v := range in </span><span class="cov0" title="0">{
                out[i] = int(v)
        }</span>
        <span class="cov0" title="0">return schema.NewSet(f, out)</span>
}

func SchemaSetToStringArray(set *schema.Set) []string <span class="cov0" title="0">{
        array := make([]string, 0, set.Len())
        for _, elem := range set.List() </span><span class="cov0" title="0">{
                e := elem.(string)
                array = append(array, e)
        }</span>
        <span class="cov0" title="0">return array</span>
}

func SchemaSetToInt64Array(set *schema.Set) []int64 <span class="cov0" title="0">{
        array := make([]int64, 0, set.Len())
        for _, elem := range set.List() </span><span class="cov0" title="0">{
                e := elem.(int)
                array = append(array, int64(e))
        }</span>
        <span class="cov0" title="0">return array</span>
}

func ExpandMapToResourceList(m map[string]interface{}) (*api.ResourceList, error) <span class="cov0" title="0">{
        out := make(api.ResourceList)
        for stringKey, origValue := range m </span><span class="cov0" title="0">{
                key := api.ResourceName(stringKey)
                var value resource.Quantity

                if v, ok := origValue.(int); ok </span><span class="cov0" title="0">{
                        q := resource.NewQuantity(int64(v), resource.DecimalExponent)
                        value = *q
                }</span> else<span class="cov0" title="0"> if v, ok := origValue.(string); ok </span><span class="cov0" title="0">{
                        var err error
                        value, err = resource.ParseQuantity(v)
                        if err != nil </span><span class="cov0" title="0">{
                                return &amp;out, err
                        }</span>
                } else<span class="cov0" title="0"> {
                        return &amp;out, fmt.Errorf("unexpected value type: %#v", origValue)
                }</span>

                <span class="cov0" title="0">out[key] = value</span>
        }
        <span class="cov0" title="0">return &amp;out, nil</span>
}

func FlattenResourceList(l api.ResourceList) map[string]string <span class="cov0" title="0">{
        m := make(map[string]string)
        for k, v := range l </span><span class="cov0" title="0">{
                m[string(k)] = v.String()
        }</span>
        <span class="cov0" title="0">return m</span>
}
</pre>
		
		<pre class="file" id="file102" style="display: none">package utils

import (
        "fmt"
        "strconv"
        "strings"

        "github.com/hashicorp/go-cty/cty"
        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        apiValidation "k8s.io/apimachinery/pkg/api/validation"
        utilValidation "k8s.io/apimachinery/pkg/util/validation"
)

func ValidateAnnotations(value interface{}, key string) (ws []string, es []error) <span class="cov0" title="0">{
        m := value.(map[string]interface{})
        for k := range m </span><span class="cov0" title="0">{
                errors := utilValidation.IsQualifiedName(strings.ToLower(k))
                if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                        for _, e := range errors </span><span class="cov0" title="0">{
                                es = append(es, fmt.Errorf("%s (%q) %s", key, k, e))
                        }</span>
                }
        }
        <span class="cov0" title="0">return</span>
}

func ValidateName(value interface{}, key string) (ws []string, es []error) <span class="cov0" title="0">{
        v := value.(string)
        errors := apiValidation.NameIsDNSSubdomain(v, false)
        if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                for _, err := range errors </span><span class="cov0" title="0">{
                        es = append(es, fmt.Errorf("%s %s", key, err))
                }</span>
        }
        <span class="cov0" title="0">return</span>
}

func ValidateGenerateName(value interface{}, key string) (ws []string, es []error) <span class="cov0" title="0">{
        v := value.(string)

        errors := apiValidation.NameIsDNSLabel(v, true)
        if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                for _, err := range errors </span><span class="cov0" title="0">{
                        es = append(es, fmt.Errorf("%s %s", key, err))
                }</span>
        }
        <span class="cov0" title="0">return</span>
}

func ValidateLabels(value interface{}, key string) (ws []string, es []error) <span class="cov0" title="0">{
        m := value.(map[string]interface{})
        for k, v := range m </span><span class="cov0" title="0">{
                for _, msg := range utilValidation.IsQualifiedName(k) </span><span class="cov0" title="0">{
                        es = append(es, fmt.Errorf("%s (%q) %s", key, k, msg))
                }</span>
                <span class="cov0" title="0">val, isString := v.(string)
                if !isString </span><span class="cov0" title="0">{
                        es = append(es, fmt.Errorf("%s.%s (%#v): Expected value to be string", key, k, v))
                        return
                }</span>
                <span class="cov0" title="0">for _, msg := range utilValidation.IsValidLabelValue(val) </span><span class="cov0" title="0">{
                        es = append(es, fmt.Errorf("%s (%q) %s", key, val, msg))
                }</span>
        }
        <span class="cov0" title="0">return</span>
}

// validateTypeStringNullableInt provides custom error messaging for TypeString ints
// Some arguments require an int value or unspecified, empty field.
func ValidateTypeStringNullableInt(v interface{}, k string) (ws []string, es []error) <span class="cov0" title="0">{
        value, ok := v.(string)
        if !ok </span><span class="cov0" title="0">{
                es = append(es, fmt.Errorf("expected type of %s to be string", k))
                return
        }</span>

        <span class="cov0" title="0">if value == "" </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">if _, err := strconv.ParseInt(value, 10, 64); err != nil </span><span class="cov0" title="0">{
                es = append(es, fmt.Errorf("%s: cannot parse '%s' as int: %s", k, value, err))
        }</span>

        <span class="cov0" title="0">return</span>
}

func StringIsIntInRange(min int, max int) schema.SchemaValidateDiagFunc <span class="cov8" title="1">{
        return func(i interface{}, p cty.Path) diag.Diagnostics </span><span class="cov0" title="0">{
                var diags diag.Diagnostics

                stringVal, ok := i.(string)
                if !ok </span><span class="cov0" title="0">{
                        diags = append(diags, diag.Diagnostic{
                                Severity: diag.Error,
                                Summary:  fmt.Sprintf("Expected type of %s to be string", p),
                        })
                        return diags
                }</span>

                <span class="cov0" title="0">intVal, err := strconv.Atoi(stringVal)
                if err != nil </span><span class="cov0" title="0">{
                        diags = append(diags, diag.Diagnostic{
                                Severity: diag.Error,
                                Summary:  fmt.Sprintf("Expected %s to be string representation of integer", p),
                        })
                        return diags
                }</span>

                <span class="cov0" title="0">if intVal &lt; min || intVal &gt; max </span><span class="cov0" title="0">{
                        diags = append(diags, diag.Diagnostic{
                                Severity: diag.Error,
                                Summary:  fmt.Sprintf("Expected %s to be between %d and %d inclusive", p, min, max),
                        })
                        return diags
                }</span>

                <span class="cov0" title="0">return diags</span>
        }
}
</pre>
		
		<pre class="file" id="file103" style="display: none">package spectrocloud

import (
        "context"
        "crypto/tls"
        "net/http"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"

        "github.com/spectrocloud/palette-sdk-go/client"
)

// make a constant string describing which project will be specified.
const (
        PROJECT_NAME_NUANCE = "If  the `project` context is specified, the project name will sourced from the provider configuration parameter " +
                "[`project_name`](https://registry.terraform.io/providers/spectrocloud/spectrocloud/latest/docs#schema)."
)

var ProviderInitProjectUid = ""

func New(_ string) func() *schema.Provider <span class="cov8" title="1">{
        return func() *schema.Provider </span><span class="cov8" title="1">{
                p := &amp;schema.Provider{
                        Schema: map[string]*schema.Schema{
                                "host": {
                                        Type:        schema.TypeString,
                                        Optional:    true,
                                        Description: "The Spectro Cloud API host url. Can also be set with the `SPECTROCLOUD_HOST` environment variable. Defaults to https://api.spectrocloud.com",
                                        DefaultFunc: schema.EnvDefaultFunc("SPECTROCLOUD_HOST", "api.spectrocloud.com"),
                                },
                                "api_key": {
                                        Type:        schema.TypeString,
                                        Optional:    true,
                                        Sensitive:   true,
                                        Description: "The Spectro Cloud API key. Can also be set with the `SPECTROCLOUD_APIKEY` environment variable.",
                                        DefaultFunc: schema.EnvDefaultFunc("SPECTROCLOUD_APIKEY", nil),
                                },
                                "trace": {
                                        Type:        schema.TypeBool,
                                        Optional:    true,
                                        Description: "Enable HTTP request tracing. Can also be set with the `SPECTROCLOUD_TRACE` environment variable. To enable Terraform debug logging, set `TF_LOG=DEBUG`. Visit the Terraform documentation to learn more about Terraform [debugging](https://developer.hashicorp.com/terraform/plugin/log/managing).",
                                        DefaultFunc: schema.EnvDefaultFunc("SPECTROCLOUD_TRACE", nil),
                                },
                                "retry_attempts": {
                                        Type:        schema.TypeInt,
                                        Optional:    true,
                                        Description: "Number of retry attempts. Can also be set with the `SPECTROCLOUD_RETRY_ATTEMPTS` environment variable. Defaults to 10.",
                                        DefaultFunc: schema.EnvDefaultFunc("SPECTROCLOUD_RETRY_ATTEMPTS", 10),
                                },
                                "project_name": {
                                        Type:     schema.TypeString,
                                        Optional: true,
                                        Default:  "Default",
                                        // cannot be empty
                                        ValidateFunc: validation.StringIsNotEmpty,
                                        Description:  "The Palette project the provider will target. If no value is provided, the `Default` Palette project is used. The default value is `Default`.",
                                },
                                "ignore_insecure_tls_error": {
                                        Type:        schema.TypeBool,
                                        Optional:    true,
                                        Description: "Ignore insecure TLS errors for Spectro Cloud API endpoints.  WARNING: Setting this to true disables SSL certificate verification and makes connections vulnerable to man-in-the-middle attacks. Only use this in development/testing environments or when connecting to self-signed certificates in trusted networks. Defaults to false.",
                                },
                        },
                        ResourcesMap: map[string]*schema.Resource{
                                "spectrocloud_team": resourceTeam(),

                                "spectrocloud_project": resourceProject(),

                                "spectrocloud_macros": resourceMacros(),

                                "spectrocloud_filter": resourceFilter(),

                                "spectrocloud_cluster_config_template": resourceClusterConfigTemplate(),
                                "spectrocloud_cluster_config_policy":   resourceClusterConfigPolicy(),

                                "spectrocloud_application_profile":    resourceApplicationProfile(),
                                "spectrocloud_cluster_profile":        resourceClusterProfile(),
                                "spectrocloud_cluster_profile_import": resourceClusterProfileImportFeature(),

                                "spectrocloud_cloudaccount_custom":  resourceCloudAccountCustom(),
                                "spectrocloud_cluster_custom_cloud": resourceClusterCustomCloud(),

                                "spectrocloud_cloudaccount_aws": resourceCloudAccountAws(),
                                "spectrocloud_cluster_aws":      resourceClusterAws(),

                                "spectrocloud_cloudaccount_maas": resourceCloudAccountMaas(),
                                "spectrocloud_cluster_maas":      resourceClusterMaas(),

                                "spectrocloud_cluster_eks": resourceClusterEks(),

                                "spectrocloud_cloudaccount_azure": resourceCloudAccountAzure(),
                                "spectrocloud_cluster_azure":      resourceClusterAzure(),

                                "spectrocloud_cluster_aks": resourceClusterAks(),

                                "spectrocloud_cluster_brownfield": resourceClusterBrownfield(),

                                "spectrocloud_cloudaccount_gcp": resourceCloudAccountGcp(),

                                "spectrocloud_cluster_gcp": resourceClusterGcp(),
                                "spectrocloud_cluster_gke": resourceClusterGke(),

                                "spectrocloud_cloudaccount_openstack": resourceCloudAccountOpenstack(),
                                "spectrocloud_cluster_openstack":      resourceClusterOpenStack(),

                                "spectrocloud_cloudaccount_apache_cloudstack": resourceCloudAccountApacheCloudStack(),
                                "spectrocloud_cluster_apache_cloudstack":      resourceClusterApacheCloudStack(),

                                "spectrocloud_cloudaccount_vsphere": resourceCloudAccountVsphere(),
                                "spectrocloud_cluster_vsphere":      resourceClusterVsphere(),

                                "spectrocloud_cluster_edge_native": resourceClusterEdgeNative(),

                                "spectrocloud_cluster_edge_vsphere": resourceClusterEdgeVsphere(),

                                "spectrocloud_virtual_cluster": resourceClusterVirtual(),

                                "spectrocloud_cluster_group": resourceClusterGroup(),

                                "spectrocloud_addon_deployment": resourceAddonDeployment(),

                                "spectrocloud_virtual_machine": resourceKubevirtVirtualMachine(),

                                "spectrocloud_datavolume": resourceKubevirtDataVolume(),

                                "spectrocloud_application": resourceApplication(),

                                "spectrocloud_privatecloudgateway_ippool": resourcePrivateCloudGatewayIpPool(),

                                "spectrocloud_privatecloudgateway_dns_map": resourcePrivateCloudGatewayDNSMap(),

                                "spectrocloud_backup_storage_location": resourceBackupStorageLocation(),

                                "spectrocloud_registry_oci":  resourceRegistryOciEcr(),
                                "spectrocloud_registry_helm": resourceRegistryHelm(),

                                "spectrocloud_appliance": resourceAppliance(),

                                "spectrocloud_workspace":          resourceWorkspace(),
                                "spectrocloud_alert":              resourceAlert(),
                                "spectrocloud_ssh_key":            resourceSSHKey(),
                                "spectrocloud_user":               resourceUser(),
                                "spectrocloud_role":               resourceRole(),
                                "spectrocloud_password_policy":    resourcePasswordPolicy(),
                                "spectrocloud_resource_limit":     resourceResourceLimit(),
                                "spectrocloud_developer_setting":  resourceDeveloperSetting(),
                                "spectrocloud_platform_setting":   resourcePlatformSetting(),
                                "spectrocloud_registration_token": resourceRegistrationToken(),
                                "spectrocloud_sso":                resourceSSO(),
                        },
                        DataSourcesMap: map[string]*schema.Resource{
                                "spectrocloud_permission": dataSourcePermission(),

                                "spectrocloud_team": dataSourceTeam(),

                                "spectrocloud_user":    dataSourceUser(),
                                "spectrocloud_project": dataSourceProject(),

                                "spectrocloud_filter": dataSourceFilter(),

                                "spectrocloud_cluster_config_template": dataSourceClusterConfigTemplate(),
                                "spectrocloud_cluster_config_policy":   dataSourceClusterConfigPolicy(),

                                "spectrocloud_role": dataSourceRole(),

                                "spectrocloud_pack":        dataSourcePack(),
                                "spectrocloud_pack_simple": dataSourcePackSimple(),

                                "spectrocloud_cluster_profile": dataSourceClusterProfile(),

                                "spectrocloud_cloudaccount_aws": dataSourceCloudAccountAws(),

                                "spectrocloud_cloudaccount_azure":             dataSourceCloudAccountAzure(),
                                "spectrocloud_cloudaccount_gcp":               dataSourceCloudAccountGcp(),
                                "spectrocloud_cloudaccount_vsphere":           dataSourceCloudAccountVsphere(),
                                "spectrocloud_cloudaccount_openstack":         dataSourceCloudAccountOpenStack(),
                                "spectrocloud_cloudaccount_apache_cloudstack": dataSourceCloudAccountApacheCloudStack(),
                                "spectrocloud_cloudaccount_maas":              dataSourceCloudAccountMaas(),
                                "spectrocloud_cloudaccount_custom":            dataSourceCloudAccountCustom(),

                                "spectrocloud_backup_storage_location": dataSourceBackupStorageLocation(),

                                "spectrocloud_registry_pack": dataSourceRegistryPack(),
                                "spectrocloud_registry_helm": dataSourceRegistryHelm(),
                                "spectrocloud_registry_oci":  dataSourceRegistryOci(),
                                "spectrocloud_registry":      dataSourceRegistry(), // registry datasource for all types.

                                "spectrocloud_appliance":                   dataSourceAppliance(),
                                "spectrocloud_appliances":                  dataSourceAppliances(),
                                "spectrocloud_cluster":                     dataSourceCluster(),
                                "spectrocloud_cluster_group":               dataSourceClusterGroup(),
                                "spectrocloud_application_profile":         dataSourceApplicationProfile(),
                                "spectrocloud_workspace":                   dataSourceWorkspace(),
                                "spectrocloud_private_cloud_gateway":       dataSourcePCG(),
                                "spectrocloud_ippool":                      dataSourcePrivateCloudGatewayIpPool(),
                                "spectrocloud_privatecloudgateway_dns_map": dataSourcePrivateCloudGatewayDNSMap(),
                                "spectrocloud_ssh_key":                     dataSourceSSHKey(),
                                "spectrocloud_registration_token":          dataSourceRegistrationToken(),
                                "spectrocloud_macros":                      dataSourceMacros(),
                        },
                        ConfigureContextFunc: providerConfigure,
                }

                return p
        }</span>
}

func providerConfigure(ctx context.Context, d *schema.ResourceData) (interface{}, diag.Diagnostics) <span class="cov0" title="0">{
        var diags diag.Diagnostics

        host := d.Get("host").(string)
        projectName := d.Get("project_name").(string)

        insecure := d.Get("ignore_insecure_tls_error").(bool)

        if insecure </span><span class="cov0" title="0">{
                // #nosec G402
                http.DefaultTransport.(*http.Transport).TLSClientConfig = &amp;tls.Config{InsecureSkipVerify: true}
        }</span>

        <span class="cov0" title="0">apiKey := ""
        if d.Get("api_key") != nil </span><span class="cov0" title="0">{
                apiKey = d.Get("api_key").(string)
        }</span>
        <span class="cov0" title="0">if apiKey == "" </span><span class="cov0" title="0">{
                diags = append(diags, diag.Diagnostic{
                        Severity: diag.Error,
                        Summary:  "Unable to create Spectro Cloud client",
                        Detail:   "Unable to authenticate user for authenticated Spectro Cloud client",
                })
                return nil, diags
        }</span>

        <span class="cov0" title="0">retryAttempts := 10
        if d.Get("retry_attempts") != nil </span><span class="cov0" title="0">{
                retryAttempts = d.Get("retry_attempts").(int)
        }</span>

        <span class="cov0" title="0">transportDebug := false
        if d.Get("trace") != nil </span><span class="cov0" title="0">{
                transportDebug = d.Get("trace").(bool)
        }</span>

        <span class="cov0" title="0">c := client.New(
                client.WithPaletteURI(host),
                client.WithAPIKey(apiKey),
                client.WithInsecureSkipVerify(insecure),
                client.WithRetries(retryAttempts),
        )
        if transportDebug </span><span class="cov0" title="0">{
                client.WithTransportDebug()(c)
        }</span>

        <span class="cov0" title="0">uid, err := c.GetProjectUID(projectName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">if uid != "" </span><span class="cov0" title="0">{
                ProviderInitProjectUid = uid
                client.WithScopeProject(uid)(c)
        }</span>

        <span class="cov0" title="0">return c, diags</span>
}
</pre>
		
		<pre class="file" id="file104" style="display: none">package spectrocloud

import (
        "context"
        "fmt"
        "log"
        "net/mail"
        "strings"
        "time"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
        "github.com/spectrocloud/palette-sdk-go/api/models"
)

// validateEmail validates email addresses using net/mail standard library
func validateEmail(v interface{}, k string) (warnings []string, errors []error) <span class="cov0" title="0">{
        email := v.(string)
        _, err := mail.ParseAddress(email)
        if err != nil </span><span class="cov0" title="0">{
                errors = append(errors, fmt.Errorf("%q is not a valid email address: %v", k, err))
        }</span>
        <span class="cov0" title="0">return warnings, errors</span>
}

func resourceAlert() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                CreateContext: resourceAlertCreate,
                ReadContext:   resourceAlertRead,
                UpdateContext: resourceAlertUpdate,
                DeleteContext: resourceAlertDelete,
                Importer: &amp;schema.ResourceImporter{
                        StateContext: resourceAlertImport,
                },

                Timeouts: &amp;schema.ResourceTimeout{
                        Create: schema.DefaultTimeout(10 * time.Minute),
                        Update: schema.DefaultTimeout(10 * time.Minute),
                        Delete: schema.DefaultTimeout(10 * time.Minute),
                },
                SchemaVersion: 2,
                Schema: map[string]*schema.Schema{
                        "project": {
                                Type:        schema.TypeString,
                                Required:    true,
                                ForceNew:    true,
                                Description: "The project to which the alert belongs to.",
                        },
                        "is_active": {
                                Type:        schema.TypeBool,
                                Required:    true,
                                Description: "Indicates whether the alert is active. Set to `true` to activate the alert, or `false` to deactivate it.",
                        },
                        "component": {
                                Type:         schema.TypeString,
                                Required:     true,
                                ValidateFunc: validation.StringInSlice([]string{"ClusterHealth"}, false),
                                Description:  "The component of the system that the alert is associated with. Currently, `ClusterHealth` is the only supported value.",
                        },
                        "type": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "",
                                ValidateFunc: validation.StringInSlice([]string{"", "email", "http"}, false),
                                Description:  "The type of alert mechanism to use. Can be `email` for email alerts, `http` for HTTP webhooks, or empty string to auto-detect based on provided configuration.",
                        },
                        "alert_all_users": {
                                Type:        schema.TypeBool,
                                Optional:    true,
                                Default:     false,
                                Description: "If set to `true`, the alert will be sent to all users. If `false`, it will target specific users or identifiers.",
                        },
                        "created_by": {
                                Type:        schema.TypeString,
                                Optional:    true,
                                Description: "The user who created the alert.",
                        },
                        // Status is defined here just for schema, we are not using this status. it implemented for internal logic
                        "status": {
                                Type:        schema.TypeList,
                                Optional:    true,
                                Description: "A status block representing the internal status of the alert. This is primarily for internal use and not utilized directly.",
                                Elem: &amp;schema.Resource{
                                        Schema: map[string]*schema.Schema{
                                                "is_succeeded": {
                                                        Type:     schema.TypeBool,
                                                        Optional: true,
                                                },
                                                "message": {
                                                        Type:     schema.TypeString,
                                                        Optional: true,
                                                },
                                                "time": {
                                                        Type:     schema.TypeString,
                                                        Optional: true,
                                                },
                                        },
                                },
                        },
                        "identifiers": {
                                Type:        schema.TypeSet,
                                Optional:    true,
                                Description: "A set of unique identifiers to which the alert will be sent. This is used to target specific users or groups.",
                                Set:         schema.HashString,
                                Elem: &amp;schema.Schema{
                                        Type:         schema.TypeString,
                                        ValidateFunc: validateEmail,
                                },
                        },
                        "http": {
                                Type:        schema.TypeList,
                                Optional:    true,
                                Description: "The configuration block for HTTP-based alerts. This is used when the `type` is set to `http`.",
                                Elem: &amp;schema.Resource{
                                        Schema: map[string]*schema.Schema{
                                                "method": {
                                                        Type:         schema.TypeString,
                                                        Required:     true,
                                                        Description:  "The HTTP method to use for the alert. Supported values are `POST`, `GET`, and `PUT`.",
                                                        ValidateFunc: validation.StringInSlice([]string{"POST", "GET", "PUT"}, false),
                                                },
                                                "url": {
                                                        Type:        schema.TypeString,
                                                        Required:    true,
                                                        Description: "The target URL to send the HTTP request to when the alert is triggered.",
                                                },
                                                "body": {
                                                        Type:        schema.TypeString,
                                                        Required:    true,
                                                        Description: "The payload to include in the HTTP request body when the alert is triggered.",
                                                },
                                                "headers": {
                                                        Type:        schema.TypeMap,
                                                        Optional:    true,
                                                        Description: "Optional HTTP headers to include in the request. Each header should be specified as a key-value pair.",
                                                        Elem: &amp;schema.Schema{
                                                                Type: schema.TypeString,
                                                        },
                                                },
                                        },
                                },
                        },
                },
        }
}</span>

func resourceAlertCreate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        c := getV1ClientWithResourceContext(m, "")
        component := d.Get("component").(string)
        var err error
        projectUid := ""

        projectUid, err = getProjectID(d, m)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">projectName := d.Get("project").(string)
        if projectName == "" </span><span class="cov0" title="0">{
                return diag.Errorf("project name is required")
        }</span>

        <span class="cov0" title="0">var diags diag.Diagnostics

        // Convert schema to channels (handles both single and combined alerts)
        newChannels := toAlertChannels(d)

        if len(newChannels) == 0 </span><span class="cov0" title="0">{
                return diag.Errorf("at least one of 'identifiers', 'alert_all_users', or 'http' block must be specified")
        }</span>

        // Create alert entity with all new channels
        <span class="cov0" title="0">alertEntity := &amp;models.V1AlertEntity{
                Channels: newChannels,
        }

        err = c.UpdateProjectAlerts(alertEntity, projectUid, component)
        if err != nil </span><span class="cov0" title="0">{
                // Handle first-time setup for ClusterHealth
                if strings.Contains(err.Error(), "Project 'ClusterHealth' alerts are not found") </span><span class="cov0" title="0">{
                        err = c.UpdateProjectAlerts(alertEntity, projectUid, component)
                        if err != nil </span><span class="cov0" title="0">{
                                return diag.FromErr(err)
                        }</span>
                } else<span class="cov0" title="0"> {
                        return diag.FromErr(err)
                }</span>
        }

        // Generate unique ID based on project and component (singleton resource)
        <span class="cov0" title="0">alertID := fmt.Sprintf("%s:%s", projectUid, component)
        d.SetId(alertID)
        return diags</span>
}
func resourceAlertUpdate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        c := getV1ClientWithResourceContext(m, "")
        var err error
        var diags diag.Diagnostics

        projectName := d.Get("project").(string)
        if projectName == "" </span><span class="cov0" title="0">{
                return diag.Errorf("project name is required")
        }</span>
        <span class="cov0" title="0">projectUid, err := getProjectID(d, m)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">component := d.Get("component").(string)

        // Convert schema to channels (handles both single and combined alerts)
        newChannels := toAlertChannels(d)

        if len(newChannels) == 0 </span><span class="cov0" title="0">{
                return diag.Errorf("at least one of 'identifiers', 'alert_all_users', or 'http' block must be specified")
        }</span>

        // Update alert entity with all new channels
        <span class="cov0" title="0">alertEntity := &amp;models.V1AlertEntity{
                Channels: newChannels,
        }

        err = c.UpdateProjectAlerts(alertEntity, projectUid, component)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">return diags</span>
}

// toAlertChannels converts the Terraform schema data to API channel models
// Returns multiple channels when both email and http are configured
func toAlertChannels(d *schema.ResourceData) []*models.V1Channel <span class="cov0" title="0">{
        var channels []*models.V1Channel
        alertType := d.Get("type").(string)
        isActive := d.Get("is_active").(bool)
        createdBy := d.Get("created_by").(string)
        alertAllUsers := d.Get("alert_all_users").(bool)

        _, hasIdentifiers := d.GetOk("identifiers")
        _, hasHttp := d.GetOk("http")

        // Determine effective types based on configuration
        createEmail := false
        createHttp := false

        switch alertType </span>{
        case "email":<span class="cov0" title="0">
                createEmail = true</span>
        case "http":<span class="cov0" title="0">
                createHttp = true</span>
        case "":<span class="cov0" title="0">
                // Auto-detect based on what's configured
                createEmail = hasIdentifiers || alertAllUsers
                createHttp = hasHttp</span>
        }

        // Create email channel if needed
        <span class="cov0" title="0">if createEmail </span><span class="cov0" title="0">{
                emailChannel := &amp;models.V1Channel{
                        IsActive:      isActive,
                        Type:          "email",
                        CreatedBy:     createdBy,
                        AlertAllUsers: alertAllUsers,
                }
                if hasIdentifiers </span><span class="cov0" title="0">{
                        emailIDs := make([]string, 0)
                        for _, email := range d.Get("identifiers").(*schema.Set).List() </span><span class="cov0" title="0">{
                                emailIDs = append(emailIDs, email.(string))
                        }</span>
                        <span class="cov0" title="0">emailChannel.Identifiers = emailIDs</span>
                }
                <span class="cov0" title="0">channels = append(channels, emailChannel)</span>
        }

        // Create http channels if needed
        <span class="cov0" title="0">if createHttp </span><span class="cov0" title="0">{
                httpList := d.Get("http").([]interface{})
                for _, httpItem := range httpList </span><span class="cov0" title="0">{
                        httpConfig := httpItem.(map[string]interface{})
                        headersMap := make(map[string]string)
                        if httpConfig["headers"] != nil </span><span class="cov0" title="0">{
                                for key, element := range httpConfig["headers"].(map[string]interface{}) </span><span class="cov0" title="0">{
                                        headersMap[key] = element.(string)
                                }</span>
                        }
                        <span class="cov0" title="0">httpChannel := &amp;models.V1Channel{
                                IsActive:  isActive,
                                Type:      "http",
                                CreatedBy: createdBy,
                                HTTP: &amp;models.V1ChannelHTTP{
                                        Body:    httpConfig["body"].(string),
                                        Method:  httpConfig["method"].(string),
                                        URL:     httpConfig["url"].(string),
                                        Headers: headersMap,
                                },
                        }
                        channels = append(channels, httpChannel)</span>
                }
        }

        <span class="cov0" title="0">return channels</span>
}

// toAlert is kept for backward compatibility - returns single channel
func toAlert(d *schema.ResourceData) *models.V1Channel <span class="cov0" title="0">{
        channels := toAlertChannels(d)
        if len(channels) &gt; 0 </span><span class="cov0" title="0">{
                return channels[0]
        }</span>
        <span class="cov0" title="0">return &amp;models.V1Channel{
                IsActive: d.Get("is_active").(bool),
                Type:     d.Get("type").(string),
        }</span>
}

func resourceAlertDelete(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        c := getV1ClientWithResourceContext(m, "")
        var diags diag.Diagnostics

        projectUid, err := getProjectID(d, m)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">component := d.Get("component").(string)

        // Delete all channels by setting empty channels (singleton resource)
        alertEntity := &amp;models.V1AlertEntity{
                Channels: []*models.V1Channel{},
        }

        err = c.UpdateProjectAlerts(alertEntity, projectUid, component)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">return diags</span>
}

func resourceAlertRead(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        c := getV1ClientWithResourceContext(m, "")
        var diags diag.Diagnostics

        projectName := d.Get("project").(string)
        if projectName == "" </span><span class="cov0" title="0">{
                log.Printf("[WARN] Project name is empty during refresh. State preserved.")
                return diags
        }</span>

        <span class="cov0" title="0">projectUid, err := getProjectID(d, m)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[WARN] Error getting project ID during refresh: %v. State preserved.", err)
                return diags
        }</span>
        <span class="cov0" title="0">if projectUid == "" </span><span class="cov0" title="0">{
                log.Printf("[WARN] Project UID is empty during refresh. State preserved.")
                return diags
        }</span>

        <span class="cov0" title="0">component := d.Get("component").(string)
        alertId := d.Id()

        log.Printf("[DEBUG] Reading alert: projectUid=%s, component=%s, alertId=%s", projectUid, component, alertId)

        projectSpec, err := c.GetProject(projectUid)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[WARN] Error getting project during refresh: %v. State preserved.", err)
                return diags
        }</span>

        // Find the alert entity for this component
        <span class="cov0" title="0">var channels []*models.V1Channel
        for _, alert := range projectSpec.Spec.Alerts </span><span class="cov0" title="0">{
                if alert != nil &amp;&amp; alert.Component == component &amp;&amp; len(alert.Channels) &gt; 0 </span><span class="cov0" title="0">{
                        channels = alert.Channels
                        break</span>
                }
        }

        <span class="cov0" title="0">if len(channels) == 0 </span><span class="cov0" title="0">{
                log.Printf("[DEBUG] No alerts found for component %s, clearing from state", component)
                d.SetId("")
                return diags
        }</span>

        <span class="cov0" title="0">log.Printf("[DEBUG] Found %d channels for component %s", len(channels), component)

        // Find email and http channels
        var emailChannel *models.V1Channel
        var httpChannel *models.V1Channel

        for _, channel := range channels </span><span class="cov0" title="0">{
                switch channel.Type </span>{
                case "email":<span class="cov0" title="0">
                        emailChannel = channel</span>
                case "http":<span class="cov0" title="0">
                        httpChannel = channel</span>
                }
        }

        // Determine the effective type based on what's configured
        <span class="cov0" title="0">var effectiveType string
        var isActive bool

        if emailChannel != nil &amp;&amp; httpChannel != nil </span><span class="cov0" title="0">{
                effectiveType = ""
                isActive = emailChannel.IsActive || httpChannel.IsActive
        }</span> else<span class="cov0" title="0"> if emailChannel != nil </span><span class="cov0" title="0">{
                effectiveType = "email"
                isActive = emailChannel.IsActive
        }</span> else<span class="cov0" title="0"> if httpChannel != nil </span><span class="cov0" title="0">{
                effectiveType = "http"
                isActive = httpChannel.IsActive
        }</span> else<span class="cov0" title="0"> {
                log.Printf("[DEBUG] No valid channels found, clearing from state")
                d.SetId("")
                return diags
        }</span>

        // Set project and component
        <span class="cov0" title="0">if err := d.Set("project", projectName); err != nil </span><span class="cov0" title="0">{
                log.Printf("[WARN] Error setting project: %v", err)
        }</span>
        <span class="cov0" title="0">if err := d.Set("component", component); err != nil </span><span class="cov0" title="0">{
                log.Printf("[WARN] Error setting component: %v", err)
        }</span>

        // Set common fields
        <span class="cov0" title="0">if err := d.Set("is_active", isActive); err != nil </span><span class="cov0" title="0">{
                log.Printf("[WARN] Error setting is_active: %v", err)
        }</span>
        <span class="cov0" title="0">if err := d.Set("type", effectiveType); err != nil </span><span class="cov0" title="0">{
                log.Printf("[WARN] Error setting type: %v", err)
        }</span>

        // Set email-related fields
        <span class="cov0" title="0">if emailChannel != nil </span><span class="cov0" title="0">{
                if err := d.Set("alert_all_users", emailChannel.AlertAllUsers); err != nil </span><span class="cov0" title="0">{
                        log.Printf("[WARN] Error setting alert_all_users: %v", err)
                }</span>
                <span class="cov0" title="0">if err := d.Set("identifiers", emailChannel.Identifiers); err != nil </span><span class="cov0" title="0">{
                        log.Printf("[WARN] Error setting identifiers: %v", err)
                }</span>
        } else<span class="cov0" title="0"> {
                if err := d.Set("alert_all_users", false); err != nil </span><span class="cov0" title="0">{
                        log.Printf("[WARN] Error setting alert_all_users: %v", err)
                }</span>
                <span class="cov0" title="0">if err := d.Set("identifiers", []string{}); err != nil </span><span class="cov0" title="0">{
                        log.Printf("[WARN] Error setting identifiers: %v", err)
                }</span>
        }

        // Set http-related fields
        <span class="cov0" title="0">if httpChannel != nil &amp;&amp; httpChannel.HTTP != nil </span><span class="cov0" title="0">{
                headersMap := make(map[string]interface{})
                if httpChannel.HTTP.Headers != nil </span><span class="cov0" title="0">{
                        for k, v := range httpChannel.HTTP.Headers </span><span class="cov0" title="0">{
                                headersMap[k] = v
                        }</span>
                }
                <span class="cov0" title="0">httpConfig := []map[string]interface{}{
                        {
                                "method":  httpChannel.HTTP.Method,
                                "url":     httpChannel.HTTP.URL,
                                "body":    httpChannel.HTTP.Body,
                                "headers": headersMap,
                        },
                }
                if err := d.Set("http", httpConfig); err != nil </span><span class="cov0" title="0">{
                        log.Printf("[WARN] Error setting http: %v", err)
                }</span>
        } else<span class="cov0" title="0"> {
                if err := d.Set("http", []interface{}{}); err != nil </span><span class="cov0" title="0">{
                        log.Printf("[WARN] Error clearing http: %v", err)
                }</span>
        }

        <span class="cov0" title="0">log.Printf("[DEBUG] Alert read complete, preserving resource ID: %s", d.Id())
        return diags</span>
}

func getProjectID(d *schema.ResourceData, m interface{}) (string, error) <span class="cov0" title="0">{
        projectUid := ""
        var err error
        c := getV1ClientWithResourceContext(m, "")
        if v, ok := d.GetOk("project"); ok &amp;&amp; v.(string) != "" </span><span class="cov0" title="0">{
                projectUid, err = c.GetProjectUID(v.(string))
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
        }
        <span class="cov0" title="0">return projectUid, nil</span>
}
</pre>
		
		<pre class="file" id="file105" style="display: none">package spectrocloud

import (
        "context"
        "fmt"
        "strings"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
)

func resourceAlertImport(ctx context.Context, d *schema.ResourceData, m interface{}) ([]*schema.ResourceData, error) <span class="cov0" title="0">{
        // Expected ID format: projectUID:component OR projectName:component
        idParts := strings.Split(d.Id(), ":")

        if len(idParts) != 2 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid import ID format. Expected: 'projectUID:component' or 'projectName:component', got: %s", d.Id())
        }</span>

        <span class="cov0" title="0">projectIdentifier := idParts[0]
        component := idParts[1]

        // Validate component
        if component != "ClusterHealth" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid component: %s. Only 'ClusterHealth' is supported", component)
        }</span>

        <span class="cov0" title="0">c := getV1ClientWithResourceContext(m, "")

        // Try to get project by UID first, then by name
        var projectName string
        var projectUID string

        // Check if projectIdentifier is a UID or name by trying to get the project
        pjt, err := c.GetProject(projectIdentifier)
        if err != nil </span><span class="cov0" title="0">{
                // If failed, try to get project UID from name
                projectUID, err = c.GetProjectUID(projectIdentifier)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("could not find project with identifier '%s': %v", projectIdentifier, err)
                }</span>
                // Get project details using the UID
                <span class="cov0" title="0">pjt, err = c.GetProject(projectUID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("could not get project details for UID '%s': %v", projectUID, err)
                }</span>
                <span class="cov0" title="0">projectName = pjt.Metadata.Name</span>
        } else<span class="cov0" title="0"> {
                projectName = pjt.Metadata.Name
                projectUID = pjt.Metadata.UID
        }</span>

        // Set the project and component in state
        <span class="cov0" title="0">if err := d.Set("project", projectName); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error setting project: %v", err)
        }</span>
        <span class="cov0" title="0">if err := d.Set("component", component); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error setting component: %v", err)
        }</span>

        // Set the canonical ID format
        <span class="cov0" title="0">d.SetId(fmt.Sprintf("%s:%s", projectUID, component))

        // Read all alert data to populate the state
        diags := resourceAlertRead(ctx, d, m)
        if diags.HasError() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("could not read alert for import: %v", diags)
        }</span>

        <span class="cov0" title="0">return []*schema.ResourceData{d}, nil</span>
}
</pre>
		
		<pre class="file" id="file106" style="display: none">package spectrocloud

import (
        "context"
        "errors"
        "fmt"
        "log"
        "time"

        "github.com/go-openapi/strfmt"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
        "github.com/spectrocloud/palette-sdk-go/api/apiutil/transport"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/spectrocloud/palette-sdk-go/api/models"
        "github.com/spectrocloud/palette-sdk-go/client"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
)

func resourceAppliance() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                CreateContext: resourceApplianceCreate,
                ReadContext:   resourceApplianceRead,
                UpdateContext: resourceApplianceUpdate,
                DeleteContext: resourceApplianceDelete,
                Importer: &amp;schema.ResourceImporter{
                        StateContext: resourceApplianceImport,
                },

                Timeouts: &amp;schema.ResourceTimeout{
                        Create: schema.DefaultTimeout(20 * time.Minute),
                        Update: schema.DefaultTimeout(10 * time.Minute),
                        Delete: schema.DefaultTimeout(10 * time.Minute),
                },

                Description: "A resource for creating and managing appliances for Edge Native cluster provisioning.",

                SchemaVersion: 2,
                Schema: map[string]*schema.Schema{
                        "uid": {
                                Type:        schema.TypeString,
                                Required:    true,
                                ForceNew:    true,
                                Description: "The unique identifier (UID) for the appliance.",
                        },
                        "tags": {
                                Type:        schema.TypeMap,
                                Optional:    true,
                                Description: "A set of key-value pairs that can be used to organize and categorize the appliance.",
                                Elem: &amp;schema.Schema{
                                        Type: schema.TypeString,
                                },
                        },
                        "pairing_key": {
                                Type:        schema.TypeString,
                                Optional:    true,
                                Description: "The pairing key used for appliance pairing.",
                        },
                        "remote_shell": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "disabled",
                                ValidateFunc: validation.StringInSlice([]string{"enabled", "disabled"}, false),
                                Description:  "Activate remote shell access to troubleshoot edge hosts by initiating an SSH connection from Palette using the configured username and password credentials. https://docs.spectrocloud.com/clusters/edge/cluster-management/remote-shell/",
                        },
                        "temporary_shell_credentials": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "disabled",
                                ValidateFunc: validation.StringInSlice([]string{"enabled", "disabled"}, false),
                                Description:  "Enable the creation of a temporary user on the edge host with sudo privileges for SSH access from Palette. These credentials will be embedded in the SSH connection string for auto login, and the temporary user is deleted upon deactivation.",
                        },
                        "wait": {
                                Type:        schema.TypeBool,
                                Optional:    true,
                                ForceNew:    true,
                                Description: "If set to `true`, the resource creation will wait for the appliance provisioning process to complete before returning. Defaults to `false`.",
                        },
                },
                CustomizeDiff: func(ctx context.Context, d *schema.ResourceDiff, meta interface{}) error </span><span class="cov0" title="0">{
                        remoteShell := d.Get("remote_shell").(string)
                        temporaryCreds := d.Get("temporary_shell_credentials").(string)

                        if temporaryCreds == "enabled" &amp;&amp; remoteShell == "disabled" </span><span class="cov0" title="0">{
                                return fmt.Errorf("temporary_shell_credentials can only be set to 'enabled' when remote_shell is also enabled")
                        }</span>

                        <span class="cov0" title="0">return nil</span>
                },
        }
}

/*
{"metadata":{"name":"test_id","uid":"test_id","tags":{"name":"test_tag"}}}
*/
var resourceApplianceCreatePendingStates = []string{
        "unpaired_", "ready_",
}

func resourceApplianceCreate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        c := getV1ClientWithResourceContext(m, "")
        var diags diag.Diagnostics

        appliance := toApplianceEntity(d)
        uid, err := c.CreateAppliance(appliance)

        if err != nil </span><span class="cov0" title="0">{
                var e *transport.TransportError
                if errors.As(err, &amp;e) &amp;&amp; e.Payload.Code == "AlreadyRegisteredEdgeHostDevice" </span><span class="cov0" title="0">{
                        uid = d.Get("uid").(string)
                        d.SetId(uid)
                }</span> else<span class="cov0" title="0"> {
                        return diag.FromErr(err)
                }</span>
        }

        <span class="cov0" title="0">d.SetId(uid)

        // Wait, catching any errors
        if d.Get("wait") != nil &amp;&amp; d.Get("wait").(bool) </span><span class="cov0" title="0">{
                stateConf := &amp;retry.StateChangeConf{
                        Pending:    resourceApplianceCreatePendingStates,
                        Target:     []string{"ready_healthy"},
                        Refresh:    resourceApplianceStateRefreshFunc(c, d.Id()),
                        Timeout:    d.Timeout(schema.TimeoutCreate) - 1*time.Minute,
                        MinTimeout: 10 * time.Second,
                        Delay:      30 * time.Second,
                }

                _, err = stateConf.WaitForStateContext(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
        }
        <span class="cov0" title="0">diags = commonApplianceUpdate(ctx, d, c)

        return diags</span>
}

func resourceApplianceStateRefreshFunc(c *client.V1Client, id string) retry.StateRefreshFunc <span class="cov0" title="0">{
        return func() (interface{}, string, error) </span><span class="cov0" title="0">{
                appliance, err := c.GetAppliance(id)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, "", err
                }</span> else<span class="cov0" title="0"> if appliance == nil </span><span class="cov0" title="0">{
                        return nil, "Deleted", nil
                }</span>

                <span class="cov0" title="0">state := appliance.Status.State + "_" + appliance.Status.Health.State
                log.Printf("Appliance state (%s): %s", id, state)

                return appliance, state, nil</span>
        }
}

func resourceApplianceRead(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        c := getV1ClientWithResourceContext(m, "")
        var diags diag.Diagnostics
        if id, okId := d.GetOk("uid"); okId </span><span class="cov0" title="0">{
                appliance, err := c.GetAppliance(id.(string))
                if err != nil </span><span class="cov0" title="0">{
                        return handleReadError(d, err, diags)
                }</span> else<span class="cov0" title="0"> if appliance == nil </span><span class="cov0" title="0">{
                        d.SetId("")
                        return diags
                }</span>
                <span class="cov0" title="0">d.SetId(appliance.Metadata.UID)
                if appliance.Spec.TunnelConfig != nil </span><span class="cov0" title="0">{
                        err = d.Set("remote_shell", appliance.Spec.TunnelConfig.RemoteSSH)
                        if err != nil </span><span class="cov0" title="0">{
                                return diag.FromErr(err)
                        }</span>
                        <span class="cov0" title="0">err = d.Set("temporary_shell_credentials", appliance.Spec.TunnelConfig.RemoteSSHTempUser)
                        if err != nil </span><span class="cov0" title="0">{
                                return diag.FromErr(err)
                        }</span>
                }

                /*err = d.Set("name", appliance.Metadata.Name)
                if err != nil {
                        return diag.FromErr(err)
                }*/
        }
        <span class="cov0" title="0">return diags</span>
}

func commonApplianceUpdate(ctx context.Context, d *schema.ResourceData, c *client.V1Client) diag.Diagnostics <span class="cov0" title="0">{
        var diags diag.Diagnostics

        if d.HasChange("tags") </span><span class="cov0" title="0">{
                applianceMeta := toApplianceMeta(d)
                err := c.UpdateApplianceMeta(d.Id(), applianceMeta)
                if err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
        }

        <span class="cov0" title="0">if d.HasChange("remote_shell") || d.HasChange("temporary_shell_credentials") </span><span class="cov0" title="0">{
                err := c.UpdateEdgeHostTunnelConfig(d.Id(), d.Get("remote_shell").(string), d.Get("temporary_shell_credentials").(string))
                if err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
        }

        <span class="cov0" title="0">return diags</span>
}

func resourceApplianceUpdate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        c := getV1ClientWithResourceContext(m, "")
        var diags diag.Diagnostics
        commonApplianceUpdate(ctx, d, c)
        return diags
}</span>

func resourceApplianceDelete(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        c := getV1ClientWithResourceContext(m, "")
        var diags diag.Diagnostics
        err := c.DeleteAppliance(d.Id())
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">return diags</span>
}

func toApplianceEntity(d *schema.ResourceData) *models.V1EdgeHostDeviceEntity <span class="cov0" title="0">{
        id := d.Get("uid").(string)
        tags := map[string]string{}
        if d.Get("tags") != nil </span><span class="cov0" title="0">{
                tags = expandStringMap(d.Get("tags").(map[string]interface{}))
        }</span>

        <span class="cov0" title="0">metadata := &amp;models.V1ObjectTagsEntity{
                UID:    id,
                Name:   id,
                Labels: tags,
        }

        key := ""
        if d.Get("pairing_key") != nil </span><span class="cov0" title="0">{
                key = d.Get("pairing_key").(string)
        }</span>
        <span class="cov0" title="0">return &amp;models.V1EdgeHostDeviceEntity{
                Metadata: metadata,
                Spec: &amp;models.V1EdgeHostDeviceSpecEntity{
                        HostPairingKey: strfmt.Password(key),
                },
        }</span>
}

func toApplianceMeta(d *schema.ResourceData) *models.V1EdgeHostDeviceMetaUpdateEntity <span class="cov0" title="0">{
        if d.Get("tags") != nil </span><span class="cov0" title="0">{
                return &amp;models.V1EdgeHostDeviceMetaUpdateEntity{
                        Metadata: &amp;models.V1ObjectTagsEntity{
                                Labels: expandStringMap(d.Get("tags").(map[string]interface{})),
                                Name:   d.Id(),
                                UID:    d.Id(),
                        },
                }
        }</span>
        <span class="cov0" title="0">return &amp;models.V1EdgeHostDeviceMetaUpdateEntity{}</span>
}

func toAppliance(d *schema.ResourceData) *models.V1EdgeHostDevice <span class="cov0" title="0">{
        if d.Get("tags") != nil </span><span class="cov0" title="0">{
                tags := d.Get("tags").(map[string]interface{})

                appliance := setFields(d, tags)

                return &amp;appliance
        }</span>

        <span class="cov0" title="0">return &amp;models.V1EdgeHostDevice{}</span>
}

func setFields(d *schema.ResourceData, tags map[string]interface{}) models.V1EdgeHostDevice <span class="cov0" title="0">{
        appliance := models.V1EdgeHostDevice{}
        appliance.Metadata = &amp;models.V1ObjectMeta{}
        appliance.Metadata.UID = d.Id()
        if tags["name"] != nil </span><span class="cov0" title="0">{
                appliance.Metadata.Name = tags["name"].(string)
        }</span>
        <span class="cov0" title="0">appliance.Metadata.Labels = expandStringMap(tags)
        return appliance</span>
}
</pre>
		
		<pre class="file" id="file107" style="display: none">package spectrocloud

import (
        "context"
        "fmt"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/spectrocloud/palette-sdk-go/client"
)

func resourceApplianceImport(ctx context.Context, d *schema.ResourceData, m interface{}) ([]*schema.ResourceData, error) <span class="cov0" title="0">{
        _, err := GetCommonAppliance(d, m)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Read all appliance data to populate the state
        <span class="cov0" title="0">diags := resourceApplianceRead(ctx, d, m)
        if diags.HasError() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("could not read appliance for import: %v", diags)
        }</span>

        <span class="cov0" title="0">return []*schema.ResourceData{d}, nil</span>
}

func GetCommonAppliance(d *schema.ResourceData, m interface{}) (*client.V1Client, error) <span class="cov0" title="0">{
        // Appliances are project-level resources
        c := getV1ClientWithResourceContext(m, "project")

        // The import ID should be the appliance UID
        applianceUID := d.Id()
        if applianceUID == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("appliance import ID is required")
        }</span>

        // Validate that the appliance exists and we can access it
        <span class="cov0" title="0">appliance, err := c.GetAppliance(applianceUID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unable to retrieve appliance: %s", err)
        }</span>
        <span class="cov0" title="0">if appliance == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("appliance with ID %s not found", applianceUID)
        }</span>

        // Set the required uid field (this is what the resource uses internally)
        <span class="cov0" title="0">if err := d.Set("uid", appliance.Metadata.UID); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Set optional fields if they exist
        <span class="cov0" title="0">if len(appliance.Metadata.Labels) &gt; 0 </span><span class="cov0" title="0">{
                if err := d.Set("tags", appliance.Metadata.Labels); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        // Set other optional fields with default values to prevent validation errors
        <span class="cov0" title="0">if appliance.Spec != nil </span><span class="cov0" title="0">{
                // Set wait to false as default (this is likely what users expect for import)
                if err := d.Set("wait", false); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                // Set remote shell access if configured
                <span class="cov0" title="0">if appliance.Spec.TunnelConfig != nil </span><span class="cov0" title="0">{
                        if err := d.Set("remote_shell", appliance.Spec.TunnelConfig.RemoteSSH); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">if err := d.Set("temporary_shell_credentials", appliance.Spec.TunnelConfig.RemoteSSHTempUser); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                }
        }

        // Set the ID to the appliance UID
        <span class="cov0" title="0">d.SetId(applianceUID)

        return c, nil</span>
}
</pre>
		
		<pre class="file" id="file108" style="display: none">package spectrocloud

import (
        "context"
        "errors"
        "fmt"
        "time"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
)

func resourceApplication() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                CreateContext: resourceApplicationCreate,
                ReadContext:   resourceApplicationRead,
                UpdateContext: resourceApplicationUpdate,
                DeleteContext: resourceApplicationDelete,
                Importer: &amp;schema.ResourceImporter{
                        StateContext: resourceApplicationImport,
                },

                Timeouts: &amp;schema.ResourceTimeout{
                        Create: schema.DefaultTimeout(60 * time.Minute),
                        Update: schema.DefaultTimeout(60 * time.Minute),
                        Delete: schema.DefaultTimeout(60 * time.Minute),
                },

                SchemaVersion: 2,
                Schema: map[string]*schema.Schema{
                        "name": {
                                Type:        schema.TypeString,
                                Required:    true,
                                Description: "The name of the application being created.",
                        },
                        "tags": {
                                Type:        schema.TypeSet,
                                Optional:    true,
                                Set:         schema.HashString,
                                Description: "A set of tags to associate with the application for easier identification and categorization.",
                                Elem: &amp;schema.Schema{
                                        Type: schema.TypeString,
                                },
                        },
                        "application_profile_uid": {
                                Type:        schema.TypeString,
                                Required:    true,
                                Description: "The unique identifier (UID) of the application profile to use for this application.",
                        },
                        "config": {
                                Type:        schema.TypeList,
                                Optional:    true,
                                MaxItems:    1,
                                Description: "The configuration block for specifying cluster and resource limits for the application.",
                                Elem: &amp;schema.Resource{
                                        Schema: map[string]*schema.Schema{
                                                "cluster_uid": {
                                                        Type:        schema.TypeString,
                                                        Optional:    true,
                                                        Description: "The unique identifier (UID) of the target cluster. Either `cluster_uid` or `cluster_group_uid` can be provided.",
                                                },
                                                "cluster_group_uid": {
                                                        Type:        schema.TypeString,
                                                        Optional:    true,
                                                        Description: "The unique identifier (UID) of the cluster group. Either `cluster_uid` or `cluster_group_uid` can be provided.",
                                                },
                                                "cluster_context": {
                                                        Type:        schema.TypeString,
                                                        Required:    true,
                                                        Description: "The context for the cluster,  Either `tenant` or `project` can be provided.",
                                                },
                                                "cluster_name": {
                                                        Type:        schema.TypeString,
                                                        Optional:    true,
                                                        Description: "An optional name for the target cluster.",
                                                },
                                                "limits": {
                                                        Type:        schema.TypeList,
                                                        Optional:    true,
                                                        Description: "Optional resource limits for the application, including CPU, memory, and storage constraints.",
                                                        Elem: &amp;schema.Resource{
                                                                Schema: map[string]*schema.Schema{
                                                                        "cpu": {
                                                                                Type:        schema.TypeInt,
                                                                                Optional:    true,
                                                                                Description: "The CPU allocation for the application, specified in integer values.",
                                                                        },
                                                                        "memory": {
                                                                                Type:        schema.TypeInt,
                                                                                Optional:    true,
                                                                                Description: "The memory allocation for the application, specified in megabytes.",
                                                                        },
                                                                        "storage": {
                                                                                Type:        schema.TypeInt,
                                                                                Optional:    true,
                                                                                Description: "The storage allocation for the application, specified in gigabytes.",
                                                                        },
                                                                },
                                                        },
                                                },
                                        },
                                },
                        },
                },
        }
}</span>

func resourceApplicationCreate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        resourceContext := ""
        // Warning or errors can be collected in a slice type
        var diags diag.Diagnostics

        /*clusterUid := d.Get("cluster_group_uid").(string)

        cluster, err := c.GetCluster(clusterUid)
        if err != nil &amp;&amp; cluster == nil {
                return diag.FromErr(errors.New(fmt.Sprintf("Cluster not found: %s", clusterUid)))
        }*/
        val_error := errors.New("config block should have either 'cluster_uid' or 'cluster_group_uid' attributes specified")

        var uid string
        var err error
        var config map[string]interface{}
        var cluster_uid interface{}
        configList := d.Get("config")
        if configList.([]interface{})[0] != nil </span><span class="cov0" title="0">{
                config = configList.([]interface{})[0].(map[string]interface{})
                cluster_uid = config["cluster_uid"]
                resourceContext = config["cluster_context"].(string)
        }</span> else<span class="cov0" title="0"> {
                return diag.FromErr(val_error)
        }</span>
        <span class="cov0" title="0">c := getV1ClientWithResourceContext(m, resourceContext)
        if cluster_uid == "" </span><span class="cov0" title="0">{
                if config["cluster_group_uid"] == "" </span><span class="cov0" title="0">{
                        return diag.FromErr(val_error)
                }</span>
                <span class="cov0" title="0">application := toAppDeploymentClusterGroupEntity(d)

                /*diagnostics, isError := waitForClusterCreation(ctx, d, clusterUid, diags, c)
                if isError {
                        return diagnostics
                }*/

                uid, err = c.CreateApplicationWithNewSandboxCluster(application)
                if err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
        } else<span class="cov0" title="0"> {
                application := toAppDeploymentVirtualClusterEntity(d)

                /*diagnostics, isError := waitForClusterCreation(ctx, d, clusterUid, diags, c)
                if isError {
                        return diagnostics
                }*/

                uid, err = c.CreateApplicationWithExistingSandboxCluster(application)
                if err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
        }

        <span class="cov0" title="0">d.SetId(uid)

        diagnostics, isError := waitForApplicationCreation(ctx, d, diags, c)
        if isError </span><span class="cov0" title="0">{
                return diagnostics
        }</span>

        <span class="cov0" title="0">resourceApplicationRead(ctx, d, m)

        return diags</span>
}

//goland:noinspection GoUnhandledErrorResult
func resourceApplicationRead(_ context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        // Get the resource context from existing configuration, default to project
        resourceContext := "project"
        configList := d.Get("config")
        if configList != nil &amp;&amp; len(configList.([]interface{})) &gt; 0 &amp;&amp; configList.([]interface{})[0] != nil </span><span class="cov0" title="0">{
                config := configList.([]interface{})[0].(map[string]interface{})
                if clusterContext, ok := config["cluster_context"].(string); ok &amp;&amp; clusterContext != "" </span><span class="cov0" title="0">{
                        resourceContext = clusterContext
                }</span>
        }

        <span class="cov0" title="0">c := getV1ClientWithResourceContext(m, resourceContext)
        var diags diag.Diagnostics

        // Get the application deployment by ID
        appDeployment, err := c.GetApplication(d.Id())
        if err != nil </span><span class="cov0" title="0">{
                // If not found in current context, try the other context
                if resourceContext == "project" </span><span class="cov0" title="0">{
                        c = getV1ClientWithResourceContext(m, "tenant")
                        appDeployment, err = c.GetApplication(d.Id())
                        if err == nil &amp;&amp; appDeployment != nil </span><span class="cov0" title="0">{
                                resourceContext = "tenant"
                        }</span>
                } else<span class="cov0" title="0"> {
                        c = getV1ClientWithResourceContext(m, "project")
                        appDeployment, err = c.GetApplication(d.Id())
                        if err == nil &amp;&amp; appDeployment != nil </span><span class="cov0" title="0">{
                                resourceContext = "project"
                        }</span>
                }

                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return handleReadError(d, err, diags)
                }</span>
        }

        <span class="cov0" title="0">if appDeployment == nil </span><span class="cov0" title="0">{
                // Deleted - Terraform will recreate it
                d.SetId("")
                return diags
        }</span>

        // Set basic fields
        <span class="cov0" title="0">if err := d.Set("name", appDeployment.Metadata.Name); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">if err := d.Set("tags", flattenTags(appDeployment.Metadata.Labels)); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        // Set application profile UID
        <span class="cov0" title="0">if appDeployment.Spec != nil &amp;&amp; appDeployment.Spec.Profile != nil &amp;&amp; appDeployment.Spec.Profile.Metadata != nil </span><span class="cov0" title="0">{
                if err := d.Set("application_profile_uid", appDeployment.Spec.Profile.Metadata.UID); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
        }

        // Set config based on deployment type
        <span class="cov0" title="0">if appDeployment.Spec != nil &amp;&amp; appDeployment.Spec.Config != nil &amp;&amp; appDeployment.Spec.Config.Target != nil </span><span class="cov0" title="0">{
                config := make(map[string]interface{})
                config["cluster_context"] = resourceContext

                // Check cluster reference
                if clusterRef := appDeployment.Spec.Config.Target.ClusterRef; clusterRef != nil </span><span class="cov0" title="0">{
                        // Set cluster UID and name based on the available information
                        if clusterRef.UID != "" </span><span class="cov0" title="0">{
                                config["cluster_uid"] = clusterRef.UID
                        }</span>
                        <span class="cov0" title="0">if clusterRef.Name != "" </span><span class="cov0" title="0">{
                                config["cluster_name"] = clusterRef.Name
                        }</span>
                }

                // Check environment reference for cluster group information
                // if envRef := appDeployment.Spec.Config.Target.EnvRef; envRef != nil {
                //         // Environment references might contain cluster group information
                //         // This would need to be mapped based on the actual API response structure
                // }

                <span class="cov0" title="0">if err := d.Set("config", []interface{}{config}); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
        }

        <span class="cov0" title="0">return diags</span>
}

func resourceApplicationUpdate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        // Warning or errors can be collected in a slice type
        var diags diag.Diagnostics

        if d.HasChanges("config.0.cluster_uid", "config.0.cluster_profile") </span><span class="cov0" title="0">{
                configList := d.Get("config")
                c := getV1ClientWithResourceContext(m, "")
                if configList.([]interface{})[0] != nil </span><span class="cov0" title="0">{
                        config := configList.([]interface{})[0].(map[string]interface{})
                        resourceContext := config["cluster_context"].(string)
                        c = getV1ClientWithResourceContext(m, resourceContext)
                }</span>

                <span class="cov0" title="0">clusterUid := d.Get("cluster_uid").(string)
                cluster, err := c.GetCluster(clusterUid)
                if err != nil &amp;&amp; cluster == nil </span><span class="cov0" title="0">{
                        return diag.FromErr(fmt.Errorf("cluster not found: %s", clusterUid))
                }</span>

                <span class="cov0" title="0">addonDeployment, err := toAddonDeployment(c, d)
                if err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>

                <span class="cov0" title="0">newProfile, err := c.GetClusterProfile(addonDeployment.Profiles[0].UID)
                if err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
                <span class="cov0" title="0">err = c.UpdateAddonDeployment(cluster, addonDeployment, newProfile)
                if err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>

                <span class="cov0" title="0">clusterProfile, err := c.GetClusterProfile(addonDeployment.Profiles[0].UID)
                if err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
                <span class="cov0" title="0">d.SetId(getAddonDeploymentId(clusterUid, clusterProfile))
                diagnostics, isError := waitForApplicationUpdate(ctx, d, diags, c)
                if isError </span><span class="cov0" title="0">{
                        return diagnostics
                }</span>

                <span class="cov0" title="0">resourceApplicationRead(ctx, d, m)

                return diags</span>
        }

        <span class="cov0" title="0">return diags</span>
}
</pre>
		
		<pre class="file" id="file109" style="display: none">package spectrocloud

import (
        "context"
        "fmt"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/spectrocloud/palette-sdk-go/client"
)

func resourceApplicationImport(ctx context.Context, d *schema.ResourceData, m interface{}) ([]*schema.ResourceData, error) <span class="cov0" title="0">{
        _, err := GetCommonApplication(d, m)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Read all application data to populate the state
        <span class="cov0" title="0">diags := resourceApplicationRead(ctx, d, m)
        if diags.HasError() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("could not read application for import: %v", diags)
        }</span>

        <span class="cov0" title="0">return []*schema.ResourceData{d}, nil</span>
}

func GetCommonApplication(d *schema.ResourceData, m interface{}) (*client.V1Client, error) <span class="cov0" title="0">{
        // Applications can work in both tenant and project context, so we'll try project first
        applicationID := d.Id()
        if applicationID == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("application ID is required for import")
        }</span>

        // Try project context first
        <span class="cov0" title="0">c := getV1ClientWithResourceContext(m, "project")

        // Use the ID to retrieve the application data from the API
        appDeployment, err := c.GetApplication(applicationID)
        if err != nil </span><span class="cov0" title="0">{
                // If not found in project context, try tenant context
                c = getV1ClientWithResourceContext(m, "tenant")
                appDeployment, err = c.GetApplication(applicationID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unable to retrieve application data in either project or tenant context: %s", err)
                }</span>
        }

        <span class="cov0" title="0">if appDeployment == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("application with ID %s not found", applicationID)
        }</span>

        // Set the application name from the retrieved application
        <span class="cov0" title="0">if err := d.Set("name", appDeployment.Metadata.Name); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Set placeholder values for required fields to prevent validation errors during import
        // These will be properly populated by the read function
        <span class="cov0" title="0">if appDeployment.Spec != nil &amp;&amp; appDeployment.Spec.Profile != nil &amp;&amp; appDeployment.Spec.Profile.Metadata != nil </span><span class="cov0" title="0">{
                if err := d.Set("application_profile_uid", appDeployment.Spec.Profile.Metadata.UID); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        // Set placeholder config with required cluster_context
        // The resource context will be determined and set properly in the read function
        <span class="cov0" title="0">if appDeployment.Spec != nil &amp;&amp; appDeployment.Spec.Config != nil &amp;&amp; appDeployment.Spec.Config.Target != nil </span><span class="cov0" title="0">{
                config := make(map[string]interface{})
                // Default to project context, will be adjusted in read function if needed
                config["cluster_context"] = "project"

                if err := d.Set("config", []interface{}{config}); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        // Set the ID of the resource in the state. This ID is used to track the
        // resource and must be set in the state during the import.
        <span class="cov0" title="0">d.SetId(appDeployment.Metadata.UID)

        return c, nil</span>
}
</pre>
		
		<pre class="file" id="file110" style="display: none">package spectrocloud

import (
        "context"
        "fmt"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"

        "github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/schemas"
        "github.com/spectrocloud/terraform-provider-spectrocloud/types"

        "log"
        "strings"
        "time"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/spectrocloud/palette-sdk-go/api/models"
        "github.com/spectrocloud/palette-sdk-go/client"
)

func resourceApplicationProfile() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                CreateContext: resourceApplicationProfileCreate,
                ReadContext:   resourceApplicationProfileRead,
                UpdateContext: resourceApplicationProfileUpdate,
                DeleteContext: resourceApplicationProfileDelete,
                Importer: &amp;schema.ResourceImporter{
                        StateContext: resourceApplicationProfileImport,
                },

                Timeouts: &amp;schema.ResourceTimeout{
                        Create: schema.DefaultTimeout(20 * time.Second),
                        Update: schema.DefaultTimeout(20 * time.Second),
                        Delete: schema.DefaultTimeout(20 * time.Second),
                },

                Description: "Provisions an Application Profile. App Profiles are templates created with preconfigured services. You can create as many profiles as required, with multiple tiers serving different functionalities per use case.",

                Schema: map[string]*schema.Schema{
                        "name": {
                                Type:        schema.TypeString,
                                Description: "Name of the application profile",
                                Required:    true,
                        },
                        "version": {
                                Type:        schema.TypeString,
                                Optional:    true,
                                Default:     "1.0.0", // default as in UI
                                Description: "Version of the profile. Default value is 1.0.0.",
                        },
                        "context": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "project",
                                ValidateFunc: validation.StringInSlice([]string{"", "project", "tenant", "system"}, false),
                                Description: "Context of the profile. Allowed values are `project`, `cluster`, or `namespace`. " +
                                        "Default value is `project`." + PROJECT_NAME_NUANCE,
                        },
                        "tags": {
                                Type:        schema.TypeSet,
                                Optional:    true,
                                Set:         schema.HashString,
                                Description: "A list of tags to be applied to the application profile. Tags must be in the form of `key:value`.",
                                Elem: &amp;schema.Schema{
                                        Type: schema.TypeString,
                                },
                        },
                        "description": {
                                Type:        schema.TypeString,
                                Description: "Description of the profile.",
                                Optional:    true,
                        },
                        "cloud": {
                                Type:        schema.TypeString,
                                Default:     "all",
                                Description: "The cloud provider the profile is eligible for. Default value is `all`.",
                                Optional:    true,
                        },
                        "pack": schemas.AppPackSchema(),
                },
        }
}</span>

func resourceApplicationProfileCreate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        ProfileContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, ProfileContext)

        // Warning or errors can be collected in a slice type
        var diags diag.Diagnostics

        applicationProfile, err := toApplicationProfileCreate(d)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        // Create

        <span class="cov0" title="0">uid, err := c.CreateApplicationProfile(applicationProfile)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">d.SetId(uid)
        resourceApplicationProfileRead(ctx, d, m)
        return diags</span>
}

func resourceApplicationProfileRead(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        ProfileContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, ProfileContext)

        var diags diag.Diagnostics

        cp, err := c.GetApplicationProfile(d.Id())
        if err != nil </span><span class="cov0" title="0">{
                return handleReadError(d, err, diags)
        }</span> else<span class="cov0" title="0"> if cp == nil </span><span class="cov0" title="0">{
                // Deleted - Terraform will recreate it
                d.SetId("")
                return diags
        }</span>

        <span class="cov0" title="0">tags := flattenTags(cp.Metadata.Labels)
        if tags != nil </span><span class="cov0" title="0">{
                if err := d.Set("tags", tags); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
        }

        <span class="cov0" title="0">tierDetails, d2, done2 := getAppTiersContent(c, d)
        if done2 </span><span class="cov0" title="0">{
                return d2
        }</span>

        <span class="cov0" title="0">err = d.Set("name", cp.Metadata.Name)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">diagPacks, diagnostics, done := GetDiagPacks(d, err)
        if done </span><span class="cov0" title="0">{
                return diagnostics
        }</span>
        <span class="cov0" title="0">packs, err := flattenAppPacks(c, diagPacks, cp.Spec.Template.AppTiers, tierDetails, d, ctx)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">if err := d.Set("pack", packs); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">return diags</span>
}

func getAppTiersContent(c *client.V1Client, d *schema.ResourceData) ([]*models.V1AppTier, diag.Diagnostics, bool) <span class="cov0" title="0">{
        tiersDetails, err := c.GetApplicationProfileTiers(d.Id())
        if err != nil </span><span class="cov0" title="0">{
                return nil, diag.FromErr(err), true
        }</span>
        <span class="cov0" title="0">return tiersDetails, nil, false</span>
}

func getValueInProperties(prop map[string]interface{}, key string) string <span class="cov0" title="0">{
        for k, v := range prop </span><span class="cov0" title="0">{
                if k == key </span><span class="cov0" title="0">{
                        return v.(string)
                }</span>
        }
        <span class="cov0" title="0">return ""</span>
}

func flattenAppPacks(c *client.V1Client, diagPacks []*models.V1PackManifestEntity, tiers []*models.V1AppTierRef, tierDet []*models.V1AppTier, d *schema.ResourceData, ctx context.Context) ([]interface{}, error) <span class="cov0" title="0">{
        if tiers == nil </span><span class="cov0" title="0">{
                return make([]interface{}, 0), nil
        }</span>

        // Build registry maps to track which packs use registry_name or registry_uid
        <span class="cov0" title="0">registryNameMap := buildPackRegistryNameMap(d)
        registryUIDMap := buildPackRegistryUIDMap(d)

        ps := make([]interface{}, len(tiers))
        for i, tier := range tierDet </span><span class="cov0" title="0">{
                p := make(map[string]interface{})
                p["uid"] = tier.Metadata.UID

                // Get the registry UID from the API response
                registryUID := tier.Spec.RegistryUID
                if registryUID == "" </span><span class="cov0" title="0">{
                        registryUID = c.GetPackRegistry(tier.Metadata.UID, string(*tier.Spec.Type))
                }</span>

                // Determine what the user originally provided in their config
                <span class="cov0" title="0">usesRegistryName := registryNameMap != nil &amp;&amp; registryNameMap[tier.Metadata.Name]
                usesRegistryUID := registryUIDMap != nil &amp;&amp; registryUIDMap[tier.Metadata.Name]

                if usesRegistryName </span><span class="cov0" title="0">{
                        // User originally specified registry_name, resolve UID back to name
                        if registryUID != "" </span><span class="cov0" title="0">{
                                registryName, err := resolveRegistryUIDToName(c, registryUID)
                                if err == nil &amp;&amp; registryName != "" </span><span class="cov0" title="0">{
                                        p["registry_name"] = registryName
                                        // Do NOT set registry_uid - user didn't provide it
                                }</span> else<span class="cov0" title="0"> {
                                        // Fallback to UID if name resolution fails
                                        p["registry_uid"] = registryUID
                                }</span>
                        }
                } else<span class="cov0" title="0"> if usesRegistryUID </span><span class="cov0" title="0">{
                        // User originally specified registry_uid, set registry_uid
                        if registryUID != "" </span><span class="cov0" title="0">{
                                p["registry_uid"] = registryUID
                        }</span>
                        // Do NOT set registry_name - user didn't provide it
                }
                // else: User didn't specify either registry_uid or registry_name
                // (they probably used uid directly), so don't set either in state

                <span class="cov0" title="0">p["name"] = tier.Metadata.Name
                //p["tag"] = tier.Tag
                p["type"] = tier.Spec.Type
                p["source_app_tier"] = tier.Spec.SourceAppTierUID
                prop := make(map[string]string)
                if len(tier.Spec.Properties) &gt; 0 </span><span class="cov0" title="0">{
                        for _, pt := range tier.Spec.Properties </span><span class="cov0" title="0">{
                                if pt.Value != "********" </span><span class="cov0" title="0">{
                                        prop[pt.Name] = pt.Value
                                }</span> else<span class="cov0" title="0"> {
                                        if _, ok := d.GetOk("pack"); ok </span><span class="cov0" title="0">{
                                                ogProp := d.Get("pack").([]interface{})[i].(map[string]interface{})["properties"]
                                                prop[pt.Name] = getValueInProperties(ogProp.(map[string]interface{}), pt.Name)
                                        }</span>
                                }
                        }
                }
                <span class="cov0" title="0">p["properties"] = prop
                if tier.Spec.Type != nil &amp;&amp; string(*tier.Spec.Type) == "container" </span><span class="cov0" title="0">{
                        p["values"] = tier.Spec.Values
                }</span>
                <span class="cov0" title="0">if tier.Spec.Type != nil &amp;&amp; (*tier.Spec.Type == "helm" || *tier.Spec.Type == "manifest") </span><span class="cov0" title="0">{
                        if len(tier.Spec.Manifests) &gt; 0 </span><span class="cov0" title="0">{
                                ma := make([]interface{}, len(tier.Spec.Manifests))
                                for j, m := range tier.Spec.Manifests </span><span class="cov0" title="0">{
                                        mj := make(map[string]interface{})
                                        mj["name"] = m.Name
                                        mj["uid"] = m.UID
                                        cnt, err := c.GetApplicationProfileTierManifestContent(d.Id(), tier.Metadata.UID, m.UID)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return nil, err
                                        }</span>
                                        <span class="cov0" title="0">if cnt != "" </span><span class="cov0" title="0">{
                                                mj["content"] = cnt
                                        }</span> else<span class="cov0" title="0"> {
                                                mj["content"] = ""
                                        }</span>
                                        <span class="cov0" title="0">ma[j] = mj</span>
                                }
                                <span class="cov0" title="0">p["manifest"] = ma</span>
                        }
                }
                <span class="cov0" title="0">ps[i] = p</span>
        }

        <span class="cov0" title="0">return ps, nil</span>
}

func resourceApplicationProfileUpdate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        ProfileContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, ProfileContext)

        // Warning or errors can be collected in a slice type
        var diags diag.Diagnostics

        if d.HasChanges("name") || d.HasChanges("tags") || d.HasChanges("pack") </span><span class="cov0" title="0">{
                log.Printf("Updating packs")
                tiersCreate, tiersUpdateMap, tiersDeleteIds, err := toApplicationTiersUpdate(d, c)
                if err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
                <span class="cov0" title="0">metadata, err := toApplicationProfilePatch(d)
                if err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>

                //ProfileContext := d.Get("context").(string)
                <span class="cov0" title="0">if err := c.CreateApplicationProfileTiers(d.Id(), tiersCreate); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
                <span class="cov0" title="0">for i, tier := range tiersUpdateMap </span><span class="cov0" title="0">{
                        if err := c.UpdateApplicationProfileTiers(d.Id(), i, tier); err != nil </span><span class="cov0" title="0">{
                                return diag.FromErr(err)
                        }</span>
                }
                <span class="cov0" title="0">if err := c.DeleteApplicationProfileTiers(d.Id(), tiersDeleteIds); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
                <span class="cov0" title="0">if err := c.PatchApplicationProfile(d.Id(), metadata); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
        }

        <span class="cov0" title="0">resourceApplicationProfileRead(ctx, d, m)

        return diags</span>
}

func resourceApplicationProfileDelete(_ context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        ProfileContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, ProfileContext)

        var diags diag.Diagnostics

        err := c.DeleteApplicationProfile(d.Id())
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">return diags</span>
}

func toApplicationProfileCreate(d *schema.ResourceData) (*models.V1AppProfileEntity, error) <span class="cov0" title="0">{
        cp := toApplicationProfileBasic(d)

        tiers := make([]*models.V1AppTierEntity, 0)
        for _, tier := range d.Get("pack").([]interface{}) </span><span class="cov0" title="0">{
                if t, e := toApplicationProfilePackCreate(tier); e != nil </span><span class="cov0" title="0">{
                        return nil, e
                }</span> else<span class="cov0" title="0"> {
                        tiers = append(tiers, t)
                }</span>
        }
        <span class="cov0" title="0">cp.Spec.Template.AppTiers = tiers
        return cp, nil</span>
}

func toApplicationProfileBasic(d *schema.ResourceData) *models.V1AppProfileEntity <span class="cov0" title="0">{
        description := ""
        if d.Get("description") != nil </span><span class="cov0" title="0">{
                description = d.Get("description").(string)
        }</span>
        <span class="cov0" title="0">cp := &amp;models.V1AppProfileEntity{
                Metadata: &amp;models.V1ObjectMetaInputEntity{
                        Name: d.Get("name").(string),
                        Annotations: map[string]string{
                                "description": description,
                        },
                        Labels: toTags(d),
                },
                Spec: &amp;models.V1AppProfileEntitySpec{
                        Template: &amp;models.V1AppProfileTemplateEntity{
                                AppTiers: toAppTiers(),
                        },
                        Version: d.Get("version").(string),
                },
        }
        return cp</span>
}

func toAppTiers() []*models.V1AppTierEntity <span class="cov0" title="0">{
        ret := make([]*models.V1AppTierEntity, 0)
        return ret
}</span>

func toApplicationProfilePackCreate(pSrc interface{}) (*models.V1AppTierEntity, error) <span class="cov0" title="0">{
        return toApplicationProfilePackCreateWithClient(pSrc, nil)
}</span>

func toApplicationProfilePackCreateWithClient(pSrc interface{}, c *client.V1Client) (*models.V1AppTierEntity, error) <span class="cov0" title="0">{
        p := pSrc.(map[string]interface{})

        pName := p["name"].(string)
        pVersion := ""
        if p["tag"] != nil </span><span class="cov0" title="0">{
                pVersion = p["tag"].(string)
        }</span>
        <span class="cov0" title="0">source_app_tier := p["source_app_tier"].(string)
        //pTag := p["tag"].(string)
        //pUID := p["uid"].(string)
        pRegistryUID := ""
        if p["registry_uid"] != nil </span><span class="cov0" title="0">{
                pRegistryUID = p["registry_uid"].(string)
        }</span>
        <span class="cov0" title="0">pRegistryName := ""
        if p["registry_name"] != nil </span><span class="cov0" title="0">{
                pRegistryName = p["registry_name"].(string)
        }</span>
        <span class="cov0" title="0">pType := models.V1AppTierType(p["type"].(string))

        // Validate that both registry_uid and registry_name are not provided together
        if pRegistryUID != "" &amp;&amp; pRegistryName != "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("pack %s: only one of 'registry_uid' or 'registry_name' can be specified, not both", pName)
        }</span>

        // If registry_name is provided and client is available, resolve it to registry_uid
        <span class="cov0" title="0">if pRegistryName != "" &amp;&amp; pRegistryUID == "" &amp;&amp; c != nil </span><span class="cov0" title="0">{
                resolvedUID, err := resolveRegistryNameToUID(c, pRegistryName, p["type"].(string))
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("pack %s: %w", pName, err)
                }</span>
                <span class="cov0" title="0">pRegistryUID = resolvedUID</span>
        }

        <span class="cov0" title="0">tier := &amp;models.V1AppTierEntity{
                Name:             types.Ptr(pName),
                Version:          pVersion,
                SourceAppTierUID: source_app_tier,
                RegistryUID:      pRegistryUID,
                //UID:         pUID,
                Type: &amp;pType,
                // UI strips a single newline, so we should do the same
                Values:     strings.TrimSpace(p["values"].(string)),
                Properties: toPropertiesTier(p),
        }

        manifests := make([]*models.V1ManifestInputEntity, 0)
        if len(p["manifest"].([]interface{})) &gt; 0 </span><span class="cov0" title="0">{
                for _, manifest := range p["manifest"].([]interface{}) </span><span class="cov0" title="0">{
                        m := manifest.(map[string]interface{})
                        manifests = append(manifests, &amp;models.V1ManifestInputEntity{
                                Content: strings.TrimSpace(m["content"].(string)),
                                Name:    m["name"].(string),
                        })
                }</span>
        }
        <span class="cov0" title="0">tier.Manifests = manifests

        return tier, nil</span>
}

// get update create delete separately based on previous version.
func toApplicationTiersUpdate(d *schema.ResourceData, c *client.V1Client) ([]*models.V1AppTierEntity, map[string]*models.V1AppTierUpdateEntity, []string, error) <span class="cov0" title="0">{
        previousTiers, err := c.GetApplicationProfileTiers(d.Id())
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, nil, err
        }</span>

        <span class="cov0" title="0">previousTiersMap := map[string]*models.V1AppTier{}
        for _, tier := range previousTiers </span><span class="cov0" title="0">{
                previousTiersMap[tier.Metadata.Name] = tier
        }</span>

        <span class="cov0" title="0">var createTiers []*models.V1AppTierEntity
        updateTiersMap := map[string]*models.V1AppTierUpdateEntity{}
        updateTiersMapId := map[string]*models.V1AppTierUpdateEntity{}
        var deleteTiers []string

        createTiersMap := map[string]*models.V1AppTierEntity{}
        for _, tier := range d.Get("pack").([]interface{}) </span><span class="cov0" title="0">{
                if _, found := previousTiersMap[tier.(map[string]interface{})["name"].(string)]; found </span><span class="cov0" title="0">{
                        t := toApplicationProfilePackUpdate(tier)
                        updateTiersMap[t.Name] = t
                }</span> else<span class="cov0" title="0"> {
                        if t, e := toApplicationProfilePackCreate(tier); e != nil </span><span class="cov0" title="0">{
                                return nil, nil, nil, e
                        }</span> else<span class="cov0" title="0"> {
                                createTiers = append(createTiers, t)
                                createTiersMap[*t.Name] = t
                        }</span>
                }
        }

        <span class="cov0" title="0">for _, tier := range previousTiers </span><span class="cov0" title="0">{
                _, create := createTiersMap[tier.Metadata.Name]
                _, update := updateTiersMap[tier.Metadata.Name]
                if !create &amp;&amp; !update </span><span class="cov0" title="0">{
                        deleteTiers = append(deleteTiers, tier.Metadata.UID)
                }</span>
                <span class="cov0" title="0">if update </span><span class="cov0" title="0">{
                        updateTiersMapId[tier.Metadata.UID] = updateTiersMap[tier.Metadata.Name]
                }</span>
        }

        <span class="cov0" title="0">return createTiers, updateTiersMapId, deleteTiers, nil</span>
}

func toApplicationProfilePatch(d *schema.ResourceData) (*models.V1AppProfileMetaEntity, error) <span class="cov0" title="0">{
        description := ""
        if d.Get("description") != nil </span><span class="cov0" title="0">{
                description = d.Get("description").(string)
        }</span>

        <span class="cov0" title="0">metadata := &amp;models.V1AppProfileMetaEntity{
                Metadata: &amp;models.V1AppProfileMetaUpdateEntity{
                        //TODO name change?: Name: d.Get("name").(string),
                        Annotations: map[string]string{
                                "description": description,
                        },
                        Labels: toTags(d),
                },
                /*TODO: check profile version: Spec: &amp;models.V1ClusterProfileSpecEntity{
                        Version: d.Get("version").(string),
                },*/
        }

        return metadata, nil</span>
}

func toPropertiesTier(prop map[string]interface{}) []*models.V1AppTierPropertyEntity <span class="cov0" title="0">{
        pProperties := make([]*models.V1AppTierPropertyEntity, 0)
        if prop["properties"] != nil </span><span class="cov0" title="0">{
                for k, val := range prop["properties"].(map[string]interface{}) </span><span class="cov0" title="0">{
                        prop := &amp;models.V1AppTierPropertyEntity{
                                Name:  k,
                                Value: val.(string),
                        }
                        pProperties = append(pProperties, prop)
                }</span>
        }
        <span class="cov0" title="0">return pProperties</span>
}

func toApplicationProfilePackUpdate(pSrc interface{}) *models.V1AppTierUpdateEntity <span class="cov0" title="0">{
        p := pSrc.(map[string]interface{})

        pName := p["name"].(string)
        pTag := p["tag"].(string)
        //pUID := p["uid"].(string)

        manifests := make([]*models.V1ManifestRefUpdateEntity, 0)
        for _, manifest := range p["manifest"].([]interface{}) </span><span class="cov0" title="0">{
                m := manifest.(map[string]interface{})
                manifests = append(manifests, &amp;models.V1ManifestRefUpdateEntity{
                        Content: strings.TrimSpace(m["content"].(string)),
                        Name:    types.Ptr(m["name"].(string)),
                        //UID:     getManifestUID(m["name"].(string), packs),
                })
        }</span>

        <span class="cov0" title="0">pack := &amp;models.V1AppTierUpdateEntity{

                Name:      pName,
                Version:   pTag,
                Manifests: manifests,
                //RegistryUID: pRegistryUID,
                // UI strips a single newline, so we should do the same
                Values:     strings.TrimSpace(p["values"].(string)),
                Properties: toPropertiesTier(p),
        }

        return pack</span>
}
</pre>
		
		<pre class="file" id="file111" style="display: none">package spectrocloud

import (
        "context"
        "fmt"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
)

func resourceApplicationProfileImport(ctx context.Context, d *schema.ResourceData, m interface{}) ([]*schema.ResourceData, error) <span class="cov0" title="0">{
        // Application profiles have a context, default to "project"
        c := getV1ClientWithResourceContext(m, "project")

        // The import ID should be the application profile UID
        profileUID := d.Id()

        // Validate that the application profile exists and we can access it
        appProfile, err := c.GetApplicationProfile(profileUID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("could not retrieve application profile for import: %s", err)
        }</span>
        <span class="cov0" title="0">if appProfile == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("application profile with ID %s not found", profileUID)
        }</span>

        // Set the application profile name from the retrieved profile
        <span class="cov0" title="0">if err := d.Set("name", appProfile.Metadata.Name); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        // Set the application profile version from the retrieved profile
        <span class="cov0" title="0">if err := d.Set("version", appProfile.Spec.Version); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        // Set the cloud to all as default for import
        <span class="cov0" title="0">if err := d.Set("cloud", "all"); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        // Set the context to project as default for import
        <span class="cov0" title="0">if err := d.Set("context", "project"); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Read all application profile data to populate the state
        <span class="cov0" title="0">diags := resourceApplicationProfileRead(ctx, d, m)
        if diags.HasError() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("could not read application profile for import: %v", diags)
        }</span>

        <span class="cov0" title="0">return []*schema.ResourceData{d}, nil</span>
}
</pre>
		
		<pre class="file" id="file112" style="display: none">package spectrocloud

import (
        "context"
        "time"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
)

const (
        StorageProviderAWS   = "aws"
        StorageProviderMinio = "minio"
        StorageProviderGCP   = "gcp"
        StorageProviderAzure = "azure"
)

func resourceBackupStorageLocation() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                CreateContext: resourceBackupStorageLocationCreate,
                ReadContext:   resourceBackupStorageLocationRead,
                UpdateContext: resourceBackupStorageLocationUpdate,
                DeleteContext: resourceBackupStorageLocationDelete,
                Importer: &amp;schema.ResourceImporter{
                        StateContext: resourceBackupStorageLocationImport,
                },

                Timeouts: &amp;schema.ResourceTimeout{
                        Create: schema.DefaultTimeout(10 * time.Minute),
                        Update: schema.DefaultTimeout(10 * time.Minute),
                        Delete: schema.DefaultTimeout(10 * time.Minute),
                },

                SchemaVersion: 2,
                Schema: map[string]*schema.Schema{
                        "name": {
                                Type:        schema.TypeString,
                                Required:    true,
                                Description: "The name of the backup storage location. This is a unique identifier for the backup location.",
                        },
                        "storage_provider": {
                                Type:     schema.TypeString,
                                Optional: true,
                                ForceNew: true,
                                Default:  StorageProviderAWS,
                                ValidateFunc: validation.StringInSlice([]string{
                                        StorageProviderAWS,
                                        StorageProviderMinio,
                                        StorageProviderGCP,
                                        StorageProviderAzure,
                                }, false),
                                Description: "The storage location provider for backup storage. Allowed values are `aws` or `minio` or `gcp` or `azure`. " +
                                        "Default value is `aws`.",
                        },
                        "context": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "project",
                                ValidateFunc: validation.StringInSlice([]string{"project", "tenant"}, false),
                                Description: "The context of the backup storage location. Allowed values are `project` or `tenant`. " +
                                        "Default value is `project`. " + PROJECT_NAME_NUANCE,
                        },
                        "is_default": {
                                Type:        schema.TypeBool,
                                Optional:    true,
                                Default:     false,
                                Description: "Specifies if this backup storage location should be used as the default location for storing backups.",
                        },
                        "region": {
                                Type:        schema.TypeString,
                                Optional:    true,
                                Description: "The region where the backup storage is located, typically corresponding to the region of the cloud provider. This is relevant for S3 or S3-compatible(minio) storage services.",
                        },
                        "bucket_name": {
                                Type:        schema.TypeString,
                                Optional:    true,
                                Description: "The name of the storage bucket where backups are stored. This is relevant for S3 or S3-compatible(minio) or gcp storage services.",
                        },
                        "ca_cert": {
                                Type:        schema.TypeString,
                                Optional:    true,
                                Description: "An optional CA certificate used for SSL connections to ensure secure communication with the storage provider. This is relevant for S3 or S3-compatible(minio) storage services.",
                        },
                        "s3": {
                                Type:        schema.TypeList,
                                Optional:    true,
                                MaxItems:    1,
                                Description: "S3-specific settings for configuring the backup storage location.",
                                Elem: &amp;schema.Resource{
                                        Schema: map[string]*schema.Schema{
                                                "s3_url": {
                                                        Type:        schema.TypeString,
                                                        Optional:    true,
                                                        Description: "The S3 URL endpoint.",
                                                },
                                                "s3_force_path_style": {
                                                        Type:        schema.TypeBool,
                                                        Optional:    true,
                                                        Description: "A boolean flag indicating whether to enforce the path-style URL for accessing S3.",
                                                },
                                                "credential_type": {
                                                        Type:         schema.TypeString,
                                                        Required:     true,
                                                        ValidateFunc: validation.StringInSlice([]string{"secret", "sts"}, false),
                                                        Description:  "The type of credentials used to access the S3 storage. Supported values are 'secret' for static credentials and 'sts' for temporary, token-based credentials.",
                                                },
                                                "access_key": {
                                                        Type:        schema.TypeString,
                                                        Optional:    true,
                                                        Description: "The access key for S3 authentication, required if 'credential_type' is set to 'secret'.",
                                                },
                                                "secret_key": {
                                                        Type:        schema.TypeString,
                                                        Optional:    true,
                                                        Sensitive:   true,
                                                        Description: "The secret key for S3 authentication, required if 'credential_type' is set to 'secret'.",
                                                },
                                                "arn": {
                                                        Type:        schema.TypeString,
                                                        Optional:    true,
                                                        Description: "The Amazon Resource Name (ARN) of the IAM role to assume for accessing S3 when using 'sts' credentials.",
                                                },
                                                "external_id": {
                                                        Type:        schema.TypeString,
                                                        Optional:    true,
                                                        Description: "An external ID used for cross-account access to the S3 storage when using 'sts' credentials.",
                                                },
                                        },
                                },
                        },
                        "gcp_storage_config": {
                                Type:        schema.TypeList,
                                Optional:    true,
                                MaxItems:    1,
                                Description: "GCP storage settings for configuring the backup storage location.",
                                Elem: &amp;schema.Resource{
                                        Schema: map[string]*schema.Schema{
                                                "project_id": {
                                                        Type:        schema.TypeString,
                                                        Required:    true,
                                                        Description: "The GCP project ID.",
                                                },
                                                "gcp_json_credentials": {
                                                        Type:        schema.TypeString,
                                                        Required:    true,
                                                        Sensitive:   true,
                                                        Description: "The GCP credentials in JSON format. These credentials are required to authenticate and manage.",
                                                },
                                        },
                                },
                        },
                        "azure_storage_config": {
                                Type:        schema.TypeList,
                                Optional:    true,
                                MaxItems:    1,
                                Description: "Azure storage settings for configuring the backup storage location.",
                                Elem: &amp;schema.Resource{
                                        Schema: map[string]*schema.Schema{
                                                "container_name": {
                                                        Type:        schema.TypeString,
                                                        Required:    true,
                                                        Description: "The container name.",
                                                },
                                                "storage_name": {
                                                        Type:        schema.TypeString,
                                                        Required:    true,
                                                        Description: "The storage name.",
                                                },
                                                "stock_keeping_unit": {
                                                        Type:        schema.TypeString,
                                                        Required:    true,
                                                        Description: "The stop-keeping unit. eg: `Standard_LRS`",
                                                },
                                                "resource_group": {
                                                        Type:        schema.TypeString,
                                                        Required:    true,
                                                        Description: "The resource group name.",
                                                },
                                                "azure_tenant_id": {
                                                        Type:        schema.TypeString,
                                                        Required:    true,
                                                        Description: "Unique tenant Id from Azure console.",
                                                },
                                                "azure_client_id": {
                                                        Type:        schema.TypeString,
                                                        Required:    true,
                                                        Description: "Unique client Id from Azure console.",
                                                },
                                                "subscription_id": {
                                                        Type:        schema.TypeString,
                                                        Required:    true,
                                                        Description: "Unique subscription Id from Azure console.",
                                                },
                                                "azure_client_secret": {
                                                        Type:        schema.TypeString,
                                                        Required:    true,
                                                        Sensitive:   true,
                                                        Description: "Azure secret for authentication.",
                                                },
                                        },
                                },
                        },
                },
                CustomizeDiff: schemaValidationForLocationProvider,
        }
}</span>

func resourceBackupStorageLocationCreate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        assetContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, assetContext)
        storageProvider := d.Get("storage_provider").(string)

        switch storageProvider </span>{
        case StorageProviderAWS:<span class="cov0" title="0">
                return S3BackupStorageLocationCreate(d, c)</span>
        case StorageProviderMinio:<span class="cov0" title="0">
                return MinioBackupStorageLocationCreate(d, c)</span>
        case StorageProviderGCP:<span class="cov0" title="0">
                return GcpBackupStorageLocationCreate(d, c)</span>
        case StorageProviderAzure:<span class="cov0" title="0">
                return AzureBackupStorageLocationCreate(d, c)</span>
        default:<span class="cov0" title="0">
                return S3BackupStorageLocationCreate(d, c)</span>
        }
}

func resourceBackupStorageLocationRead(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        assetContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, assetContext)
        storageProvider := d.Get("storage_provider").(string)

        switch storageProvider </span>{
        case StorageProviderAWS:<span class="cov0" title="0">
                return S3BackupStorageLocationRead(d, c)</span>
        case StorageProviderMinio:<span class="cov0" title="0">
                return MinioBackupStorageLocationRead(d, c)</span>
        case StorageProviderGCP:<span class="cov0" title="0">
                return GcpBackupStorageLocationRead(d, c)</span>
        case StorageProviderAzure:<span class="cov0" title="0">
                return AzureBackupStorageLocationRead(d, c)</span>
        default:<span class="cov0" title="0">
                return S3BackupStorageLocationRead(d, c)</span>
        }
}

func resourceBackupStorageLocationUpdate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        assetContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, assetContext)

        storageProvider := d.Get("storage_provider").(string)

        switch storageProvider </span>{
        case StorageProviderAWS:<span class="cov0" title="0">
                return S3BackupStorageLocationUpdate(d, c)</span>
        case StorageProviderMinio:<span class="cov0" title="0">
                return MinioBackupStorageLocationUpdate(d, c)</span>
        case StorageProviderGCP:<span class="cov0" title="0">
                return GcpBackupStorageLocationUpdate(d, c)</span>
        case StorageProviderAzure:<span class="cov0" title="0">
                return AzureBackupStorageLocationUpdate(d, c)</span>
        default:<span class="cov0" title="0">
                return S3BackupStorageLocationUpdate(d, c)</span>
        }
}

func resourceBackupStorageLocationDelete(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        assetContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, assetContext)
        var diags diag.Diagnostics
        err := c.DeleteS3BackupStorageLocation(d.Id())
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">return diags</span>
}
</pre>
		
		<pre class="file" id="file113" style="display: none">package spectrocloud

import (
        "context"
        "fmt"
        "strings"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/spectrocloud/palette-sdk-go/client"
)

func resourceBackupStorageLocationImport(ctx context.Context, d *schema.ResourceData, m interface{}) ([]*schema.ResourceData, error) <span class="cov0" title="0">{
        _, err := GetCommonBackupStorageLocation(d, m)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Read all backup storage location data to populate the state
        <span class="cov0" title="0">diags := resourceBackupStorageLocationRead(ctx, d, m)
        if diags.HasError() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("could not read backup storage location for import: %v", diags)
        }</span>

        <span class="cov0" title="0">return []*schema.ResourceData{d}, nil</span>
}

func GetCommonBackupStorageLocation(d *schema.ResourceData, m interface{}) (*client.V1Client, error) <span class="cov0" title="0">{
        // Parse the import ID which can be either:
        // 1. Simple format: bsl_id (defaults to project context)
        // 2. Context format: context:bsl_id (explicit context)
        importID := d.Id()
        if importID == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("backup storage location import ID is required")
        }</span>

        <span class="cov0" title="0">var context string
        var bslID string

        // Check if the import ID contains context specification
        parts := strings.Split(importID, ":")
        if len(parts) == 2 </span><span class="cov0" title="0">{
                // Format: context:bsl_id
                bslID = parts[0]
                context = parts[1]

                // Validate context
                if context != "project" &amp;&amp; context != "tenant" </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid context '%s'. Expected 'project' or 'tenant'", context)
                }</span>
        } else<span class="cov0" title="0"> if len(parts) == 1 </span><span class="cov0" title="0">{
                // Format: bsl_id (default to project context)
                context = "project"
                bslID = parts[0]
        }</span> else<span class="cov0" title="0"> {
                return nil, fmt.Errorf("invalid import ID format. Expected 'bsl_id' or 'context:bsl_id', got: %s", importID)
        }</span>

        // Try the specified context first
        <span class="cov0" title="0">c := getV1ClientWithResourceContext(m, context)
        bsl, err := c.GetBackupStorageLocation(bslID)

        if err != nil || bsl == nil </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unable to retrieve backup storage location in either project or tenant context: %s", err)
                }</span>
                <span class="cov0" title="0">if bsl == nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("backup storage location with ID %s not found", bslID)
                }</span>
        }

        // Set the required fields for the resource
        <span class="cov0" title="0">if err := d.Set("name", bsl.Metadata.Name); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := d.Set("context", context); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Set the storage provider by mapping from API type to Terraform constants
        <span class="cov0" title="0">storageProvider := mapAPITypeToTerraformProvider(string(*bsl.Spec.Storage))
        if err := d.Set("storage_provider", storageProvider); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Set the ID to the backup storage location ID
        <span class="cov0" title="0">d.SetId(bslID)

        return c, nil</span>
}

// mapAPITypeToTerraformProvider maps API storage type values to Terraform provider constants
func mapAPITypeToTerraformProvider(apiType string) string <span class="cov0" title="0">{
        switch apiType </span>{
        case "s3":<span class="cov0" title="0">
                return "aws"</span> // API uses "s3" but Terraform uses "aws"
        case "gcp":<span class="cov0" title="0">
                return "gcp"</span> // Same in both
        case "minio":<span class="cov0" title="0">
                return "minio"</span> // Same in both
        case "azure":<span class="cov0" title="0">
                return "azure"</span> // Same in both
        default:<span class="cov0" title="0">
                // Default to aws if unknown type
                return "aws"</span>
        }
}
</pre>
		
		<pre class="file" id="file114" style="display: none">package spectrocloud

import (
        "context"
        "fmt"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
        "github.com/spectrocloud/palette-sdk-go/api/models"
        "github.com/spectrocloud/palette-sdk-go/client"
        "github.com/spectrocloud/terraform-provider-spectrocloud/types"
)

func resourceCloudAccountApacheCloudStack() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                CreateContext: resourceCloudAccountApacheCloudStackCreate,
                ReadContext:   resourceCloudAccountApacheCloudStackRead,
                UpdateContext: resourceCloudAccountApacheCloudStackUpdate,
                DeleteContext: resourceCloudAccountApacheCloudStackDelete,
                Importer: &amp;schema.ResourceImporter{
                        StateContext: resourceAccountApacheCloudStackImport,
                },
                Schema: map[string]*schema.Schema{
                        "name": {
                                Type:        schema.TypeString,
                                Required:    true,
                                Description: "Name of the Apache CloudStack cloud account.",
                        },
                        "context": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "project",
                                ValidateFunc: validation.StringInSlice([]string{"", "project", "tenant"}, false),
                                Description: "The context of the Apache CloudStack configuration. " +
                                        "Allowed values are `project` or `tenant`. Default value is `project`. " + PROJECT_NAME_NUANCE,
                        },
                        "private_cloud_gateway_id": {
                                Type:        schema.TypeString,
                                Required:    true,
                                Description: "ID of the private cloud gateway that is used to connect to the Apache CloudStack cloud.",
                        },
                        "api_url": {
                                Type:        schema.TypeString,
                                Required:    true,
                                Description: "The API URL of the Apache CloudStack management server. For example: https://cloudstack.example.com:8080/client/api",
                        },
                        "api_key": {
                                Type:        schema.TypeString,
                                Required:    true,
                                Sensitive:   true,
                                Description: "The API key for Apache CloudStack authentication.",
                        },
                        "secret_key": {
                                Type:        schema.TypeString,
                                Required:    true,
                                Sensitive:   true,
                                Description: "The secret key for Apache CloudStack authentication.",
                        },
                        "domain": {
                                Type:        schema.TypeString,
                                Optional:    true,
                                Default:     "",
                                Description: "The domain for the Apache CloudStack account. Optional, for multi-domain CloudStack environments. Default is empty (ROOT domain).",
                        },
                        "insecure": {
                                Type:        schema.TypeBool,
                                Optional:    true,
                                Default:     false,
                                Description: "Skip SSL certificate verification. Default is `false`. Note: Apache CloudStack must have valid SSL certificates from a trusted CA if this is false.",
                        },
                },
        }
}</span>

func resourceCloudAccountApacheCloudStackCreate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        resourceContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, resourceContext)

        var diags diag.Diagnostics

        account := toApacheCloudStackAccount(d, c)
        uid, err := c.CreateCloudAccountCloudStack(account)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">d.SetId(uid)

        resourceCloudAccountApacheCloudStackRead(ctx, d, m)

        return diags</span>
}

func resourceCloudAccountApacheCloudStackRead(_ context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        resourceContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, resourceContext)

        var diags diag.Diagnostics

        uid := d.Id()
        account, err := c.GetCloudAccountCloudStack(uid)
        if err != nil </span><span class="cov0" title="0">{
                return handleReadError(d, err, diags)
        }</span> else<span class="cov0" title="0"> if account == nil </span><span class="cov0" title="0">{
                d.SetId("")
                return diags
        }</span>

        <span class="cov0" title="0">if err := d.Set("name", account.Metadata.Name); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">if err := d.Set("private_cloud_gateway_id", account.Metadata.Annotations[OverlordUID]); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">if account.Spec != nil </span><span class="cov0" title="0">{
                if account.Spec.APIURL != nil </span><span class="cov0" title="0">{
                        if err := d.Set("api_url", *account.Spec.APIURL); err != nil </span><span class="cov0" title="0">{
                                return diag.FromErr(err)
                        }</span>
                }
                <span class="cov0" title="0">if err := d.Set("domain", account.Spec.Domain); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
                <span class="cov0" title="0">if err := d.Set("insecure", account.Spec.Insecure); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
        }

        <span class="cov0" title="0">return diags</span>
}

func resourceCloudAccountApacheCloudStackUpdate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        resourceContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, resourceContext)

        var diags diag.Diagnostics

        account := toApacheCloudStackAccount(d, c)

        err := c.UpdateCloudAccountCloudStack(account)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">resourceCloudAccountApacheCloudStackRead(ctx, d, m)

        return diags</span>
}

func resourceCloudAccountApacheCloudStackDelete(_ context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        resourceContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, resourceContext)

        var diags diag.Diagnostics

        cloudAccountID := d.Id()
        err := c.DeleteCloudAccountCloudStack(cloudAccountID)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">return diags</span>
}

func toApacheCloudStackAccount(d *schema.ResourceData, c *client.V1Client) *models.V1CloudStackAccount <span class="cov0" title="0">{
        account := &amp;models.V1CloudStackAccount{
                Metadata: &amp;models.V1ObjectMeta{
                        Name:        d.Get("name").(string),
                        Annotations: map[string]string{OverlordUID: d.Get("private_cloud_gateway_id").(string)},
                        UID:         d.Id(),
                },
                Spec: &amp;models.V1CloudStackCloudAccount{
                        APIURL:    types.Ptr(d.Get("api_url").(string)),
                        APIKey:    types.Ptr(d.Get("api_key").(string)),
                        SecretKey: types.Ptr(d.Get("secret_key").(string)),
                        Domain:    d.Get("domain").(string),
                        Insecure:  d.Get("insecure").(bool),
                },
        }
        // for system pcg, set overlordType to "system" in annotation only for apache cloudstack account
        pcgID := d.Get("private_cloud_gateway_id").(string)
        pcg, _ := c.GetPCGByID(pcgID)
        if pcg.Metadata.Name == "System Private Gateway" </span><span class="cov0" title="0">{
                account.Metadata.Annotations["overlordType"] = "system"
        }</span>

        <span class="cov0" title="0">return account</span>
}

func resourceAccountApacheCloudStackImport(ctx context.Context, d *schema.ResourceData, m interface{}) ([]*schema.ResourceData, error) <span class="cov0" title="0">{
        resourceContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, resourceContext)

        err := GetCommonAccount(d, c)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">diags := resourceCloudAccountApacheCloudStackRead(ctx, d, m)
        if diags.HasError() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("could not read account for import: %v", diags)
        }</span>

        <span class="cov0" title="0">return []*schema.ResourceData{d}, nil</span>
}
</pre>
		
		<pre class="file" id="file115" style="display: none">package spectrocloud

import (
        "context"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"

        "github.com/spectrocloud/palette-sdk-go/api/models"
        "github.com/spectrocloud/terraform-provider-spectrocloud/types"
)

func resourceCloudAccountAws() *schema.Resource <span class="cov10" title="5">{
        return &amp;schema.Resource{
                CreateContext: resourceCloudAccountAwsCreate,
                ReadContext:   resourceCloudAccountAwsRead,
                UpdateContext: resourceCloudAccountAwsUpdate,
                DeleteContext: resourceCloudAccountAwsDelete,
                Importer: &amp;schema.ResourceImporter{
                        StateContext: resourceAccountAwsImport,
                },
                Schema: map[string]*schema.Schema{
                        "name": {
                                Type:     schema.TypeString,
                                Required: true,
                        },
                        "context": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "project",
                                ValidateFunc: validation.StringInSlice([]string{"", "project", "tenant"}, false),
                                Description: "The context of the AWS configuration. Allowed values are `project` or `tenant`. " +
                                        "Default value is `project`. " + PROJECT_NAME_NUANCE,
                        },
                        "private_cloud_gateway_id": {
                                Type:        schema.TypeString,
                                Optional:    true,
                                Description: "ID of the private cloud gateway. This is the ID of the private cloud gateway that is used to connect to the private cluster endpoint.",
                        },
                        "aws_access_key": {
                                Type:        schema.TypeString,
                                Optional:    true,
                                Description: "The AWS access key used to authenticate. **Deprecated:** Use `aws_secured_access_key` instead for enhanced security. **Note:** This field is mutually exclusive with `aws_secured_access_key`.",
                        },
                        "aws_secured_access_key": {
                                Type:        schema.TypeString,
                                Optional:    true,
                                Sensitive:   true,
                                Description: "The AWS access key used to authenticate. This is a secure alternative to `aws_access_key` with sensitive attribute enabled. **Note:** This field is mutually exclusive with `aws_access_key`.",
                        },
                        "aws_secret_key": {
                                Type:        schema.TypeString,
                                Optional:    true,
                                Sensitive:   true,
                                Description: "The AWS secret key used in conjunction with the access key for authentication.",
                        },
                        "type": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                ValidateFunc: validation.StringInSlice([]string{"secret", "sts", "pod-identity"}, false),
                                Default:      "secret",
                                Description:  "The type of AWS credentials to use. Can be `secret`, `sts`, or `pod-identity`. ",
                        },
                        "arn": {
                                Type:        schema.TypeString,
                                Optional:    true,
                                Description: "The Amazon Resource Name (ARN) associated with the AWS resource. This is used for identifying resources in AWS. Used for STS credential type.",
                        },
                        "external_id": {
                                Type:        schema.TypeString,
                                Optional:    true,
                                Sensitive:   true,
                                Description: "An optional external ID that can be used for cross-account access in AWS. Used for STS credential type.",
                        },
                        "role_arn": {
                                Type:        schema.TypeString,
                                Optional:    true,
                                Description: "The IAM Role ARN for AWS EKS Pod Identity authentication. Required when type is `pod-identity`.",
                        },
                        "permission_boundary_arn": {
                                Type:        schema.TypeString,
                                Optional:    true,
                                Description: "Optional Permission Boundary ARN to limit the maximum permissions for roles created by Hubble. Used with `pod-identity` credential type.",
                        },
                        "partition": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "aws",
                                ValidateFunc: validation.StringInSlice([]string{"aws", "aws-us-gov"}, false),
                                Description: `The AWS partition in which the cloud account is located. 
Can be 'aws' for standard AWS regions or 'aws-us-gov' for AWS GovCloud (US) regions.
Default is 'aws'.`,
                        },
                        "policy_arns": {
                                Type:        schema.TypeSet,
                                Optional:    true,
                                Elem:        &amp;schema.Schema{Type: schema.TypeString},
                                Description: "A set of ARNs for the IAM policies that should be associated with the cloud account.",
                        },
                },
        }
}</span>

func resourceCloudAccountAwsCreate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        resourceContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, resourceContext)

        // Warning or errors can be collected in a slice type
        var diags diag.Diagnostics

        account, err := toAwsAccount(d)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">uid, err := c.CreateCloudAccountAws(account)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">d.SetId(uid)

        resourceCloudAccountAwsRead(ctx, d, m)

        return diags</span>
}

func resourceCloudAccountAwsRead(_ context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        resourceContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, resourceContext)

        var diags diag.Diagnostics

        uid := d.Id()
        account, err := c.GetCloudAccountAws(uid)
        if err != nil </span><span class="cov0" title="0">{
                return handleReadError(d, err, diags)
        }</span> else<span class="cov0" title="0"> if account == nil </span><span class="cov0" title="0">{
                // Deleted - Terraform will recreate it
                d.SetId("")
                return diags
        }</span>

        <span class="cov0" title="0">diagnostics, done := flattenCloudAccountAws(d, account)
        if done </span><span class="cov0" title="0">{
                return diagnostics
        }</span>

        <span class="cov0" title="0">return diags</span>
}

func resourceCloudAccountAwsUpdate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        resourceContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, resourceContext)

        // Warning or errors can be collected in a slice type
        var diags diag.Diagnostics

        account, err := toAwsAccount(d)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">err = c.UpdateCloudAccountAws(account)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">resourceCloudAccountAwsRead(ctx, d, m)

        return diags</span>
}

func resourceCloudAccountAwsDelete(_ context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        resourceContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, resourceContext)

        var diags diag.Diagnostics

        cloudAccountID := d.Id()

        err := c.DeleteCloudAccountAws(cloudAccountID)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        // d.SetId("") is automatically called assuming delete returns no errors

        <span class="cov0" title="0">return diags</span>
}

func toAwsAccount(d *schema.ResourceData) (*models.V1AwsAccount, error) <span class="cov8" title="4">{
        // Validate that only one access key field is set
        securedAccessKey := d.Get("aws_secured_access_key").(string)
        legacyAccessKey := d.Get("aws_access_key").(string)

        // if securedAccessKey != "" &amp;&amp; legacyAccessKey != "" {
        //         return nil, fmt.Errorf("conflicting configuration arguments: only one of 'aws_access_key' or 'aws_secured_access_key' can be set")
        // }

        // Determine which access key field to use (prefer secured, fallback to legacy)
        accessKey := securedAccessKey
        if accessKey == "" </span><span class="cov7" title="3">{
                accessKey = legacyAccessKey
        }</span>

        <span class="cov8" title="4">account := &amp;models.V1AwsAccount{
                Metadata: &amp;models.V1ObjectMeta{
                        Name: d.Get("name").(string),
                        UID:  d.Id(),
                },
                Spec: &amp;models.V1AwsCloudAccount{
                        AccessKey: accessKey,
                        SecretKey: d.Get("aws_secret_key").(string),
                },
        }
        if d.Get("context") != nil </span><span class="cov8" title="4">{
                ctxAnnotation := map[string]string{
                        "scope":     d.Get("context").(string),
                        OverlordUID: d.Get("private_cloud_gateway_id").(string),
                }
                account.Metadata.Annotations = ctxAnnotation
        }</span>
        <span class="cov8" title="4">if len(d.Get("type").(string)) == 0 || d.Get("type").(string) == "secret" </span><span class="cov4" title="2">{
                account.Spec.CredentialType = models.V1AwsCloudAccountCredentialTypeSecret.Pointer()
                account.Spec.AccessKey = accessKey
                account.Spec.SecretKey = d.Get("aws_secret_key").(string)
        }</span> else<span class="cov4" title="2"> if d.Get("type").(string) == "sts" </span><span class="cov1" title="1">{
                account.Spec.CredentialType = models.V1AwsCloudAccountCredentialTypeSts.Pointer()
                account.Spec.Sts = &amp;models.V1AwsStsCredentials{
                        Arn:        d.Get("arn").(string),
                        ExternalID: d.Get("external_id").(string),
                }
        }</span> else<span class="cov1" title="1"> if d.Get("type").(string) == "pod-identity" </span><span class="cov1" title="1">{
                account.Spec.CredentialType = models.V1AwsCloudAccountCredentialTypePodDashIdentity.Pointer()
                account.Spec.PodIdentity = &amp;models.V1AwsPodIdentityCredentials{
                        RoleArn:               d.Get("role_arn").(string),
                        PermissionBoundaryArn: d.Get("permission_boundary_arn").(string),
                }
        }</span>

        // add partition to account
        <span class="cov8" title="4">if d.Get("partition") != nil </span><span class="cov8" title="4">{
                account.Spec.Partition = types.Ptr(d.Get("partition").(string))
        }</span>

        // add policy arns to account
        <span class="cov8" title="4">if d.Get("policy_arns") != nil &amp;&amp; len(d.Get("policy_arns").(*schema.Set).List()) &gt; 0 </span><span class="cov0" title="0">{
                policyArns := d.Get("policy_arns").(*schema.Set).List()
                policies := make([]string, 0)
                for _, v := range policyArns </span><span class="cov0" title="0">{
                        policies = append(policies, v.(string))
                }</span>
                <span class="cov0" title="0">account.Spec.PolicyARNs = policies</span>
        }

        <span class="cov8" title="4">return account, nil</span>
}

func flattenCloudAccountAws(d *schema.ResourceData, account *models.V1AwsAccount) (diag.Diagnostics, bool) <span class="cov0" title="0">{
        if err := d.Set("name", account.Metadata.Name); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err), true
        }</span>
        <span class="cov0" title="0">if err := d.Set("context", account.Metadata.Annotations["scope"]); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err), true
        }</span>
        <span class="cov0" title="0">if err := d.Set("private_cloud_gateway_id", account.Metadata.Annotations[OverlordUID]); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err), true
        }</span>
        <span class="cov0" title="0">if err := d.Set("type", account.Spec.CredentialType); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err), true
        }</span>
        <span class="cov0" title="0">switch *account.Spec.CredentialType </span>{
        case models.V1AwsCloudAccountCredentialTypeSecret:<span class="cov0" title="0">
                // Set the access key to the appropriate field based on which one is currently in use
                // Prefer aws_secured_access_key if it was set, otherwise use aws_access_key for backward compatibility
                if d.Get("aws_secured_access_key").(string) != "" </span><span class="cov0" title="0">{
                        if err := d.Set("aws_secured_access_key", account.Spec.AccessKey); err != nil </span><span class="cov0" title="0">{
                                return diag.FromErr(err), true
                        }</span>
                        // Clear the conflicting field to avoid conflicts
                        <span class="cov0" title="0">if err := d.Set("aws_access_key", ""); err != nil </span><span class="cov0" title="0">{
                                return diag.FromErr(err), true
                        }</span>
                } else<span class="cov0" title="0"> {
                        if err := d.Set("aws_access_key", account.Spec.AccessKey); err != nil </span><span class="cov0" title="0">{
                                return diag.FromErr(err), true
                        }</span>
                        // Clear the conflicting field to avoid conflicts
                        <span class="cov0" title="0">if err := d.Set("aws_secured_access_key", ""); err != nil </span><span class="cov0" title="0">{
                                return diag.FromErr(err), true
                        }</span>
                }
        case models.V1AwsCloudAccountCredentialTypeSts:<span class="cov0" title="0">
                if err := d.Set("arn", account.Spec.Sts.Arn); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err), true
                }</span>
        case models.V1AwsCloudAccountCredentialTypePodDashIdentity:<span class="cov0" title="0">
                if err := d.Set("role_arn", account.Spec.PodIdentity.RoleArn); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err), true
                }</span>
                <span class="cov0" title="0">if err := d.Set("permission_boundary_arn", account.Spec.PodIdentity.PermissionBoundaryArn); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err), true
                }</span>
        }
        <span class="cov0" title="0">if account.Spec.Partition != nil </span><span class="cov0" title="0">{
                if err := d.Set("partition", account.Spec.Partition); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err), true
                }</span>
        }
        <span class="cov0" title="0">if account.Spec.PolicyARNs != nil </span><span class="cov0" title="0">{
                if err := d.Set("policy_arns", account.Spec.PolicyARNs); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err), true
                }</span>
        }

        <span class="cov0" title="0">return nil, false</span>
}
</pre>
		
		<pre class="file" id="file116" style="display: none">package spectrocloud

import (
        "context"
        "fmt"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
)

func resourceAccountAwsImport(ctx context.Context, d *schema.ResourceData, m interface{}) ([]*schema.ResourceData, error) <span class="cov0" title="0">{
        resourceContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, resourceContext)

        err := GetCommonAccount(d, c)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">diags := resourceCloudAccountAwsRead(ctx, d, m)
        if diags.HasError() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("could not read cluster for import: %v", diags)
        }</span>

        // Return the resource data. In most cases, this method is only used to
        // import one resource at a time, so you should return the resource data
        // in a slice with a single element.
        <span class="cov0" title="0">return []*schema.ResourceData{d}, nil</span>
}
</pre>
		
		<pre class="file" id="file117" style="display: none">package spectrocloud

import (
        "context"
        "fmt"

        "github.com/go-openapi/strfmt"
        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
        "github.com/spectrocloud/palette-sdk-go/api/models"
        "github.com/spectrocloud/terraform-provider-spectrocloud/types"
)

func resourceCloudAccountAzure() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                CreateContext: resourceCloudAccountAzureCreate,
                ReadContext:   resourceCloudAccountAzureRead,
                UpdateContext: resourceCloudAccountAzureUpdate,
                DeleteContext: resourceCloudAccountAzureDelete,
                Importer: &amp;schema.ResourceImporter{
                        StateContext: resourceAccountAzureImport,
                },
                Schema: map[string]*schema.Schema{
                        "name": {
                                Type:        schema.TypeString,
                                Required:    true,
                                Description: "The name of the Azure cloud account.",
                        },
                        "context": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "project",
                                ValidateFunc: validation.StringInSlice([]string{"", "project", "tenant"}, false),
                                Description: "The context of the Azure configuration. " +
                                        "Defaults to `project`. " + PROJECT_NAME_NUANCE,
                        },
                        "private_cloud_gateway_id": {
                                Type:        schema.TypeString,
                                Optional:    true,
                                Description: "ID of the private cloud gateway. This is the ID of the private cloud gateway that is used to connect to the private cluster endpoint.",
                        },
                        "azure_tenant_id": {
                                Type:        schema.TypeString,
                                Required:    true,
                                Description: "Unique tenant Id from Azure console.",
                        },
                        "azure_client_id": {
                                Type:        schema.TypeString,
                                Required:    true,
                                Description: "Unique client Id from Azure console.",
                        },
                        "azure_client_secret": {
                                Type:        schema.TypeString,
                                Required:    true,
                                Sensitive:   true,
                                Description: "Azure secret for authentication.",
                        },
                        "tenant_name": {
                                Type:        schema.TypeString,
                                Optional:    true,
                                Description: "The name of the tenant. This is the name of the tenant that is used to connect to the Azure cloud.",
                        },
                        "disable_properties_request": {
                                Type:        schema.TypeBool,
                                Optional:    true,
                                Default:     false,
                                Description: "Disable properties request. This is a boolean value that indicates whether to disable properties request or not. If not specified, the default value is `false`.",
                        },
                        "cloud": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "AzurePublicCloud",
                                ValidateFunc: validation.StringInSlice([]string{"AzurePublicCloud", "AzureUSGovernmentCloud", "AzureUSSecretCloud"}, false),
                                Description: `The Azure partition in which the cloud account is located. 
Can be 'AzurePublicCloud' for standard Azure regions or 'AzureUSGovernmentCloud' for Azure GovCloud (US) regions or 'AzureUSSecretCloud' for Azure Secret Cloud regions.
Default is 'AzurePublicCloud'.`,
                        },
                        "tls_cert": {
                                Type:        schema.TypeString,
                                Optional:    true,
                                Description: "TLS certificate for authentication. This field is only allowed when cloud is set to 'AzureUSSecretCloud'.",
                        },
                },
        }
}</span>

func resourceCloudAccountAzureCreate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        resourceContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, resourceContext)

        // Warning or errors can be collected in a slice type
        var diags diag.Diagnostics

        // Validate tls_cert is only used with AzureUSSecretCloud
        if err := validateTlsCertConfiguration(d); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">account := toAzureAccount(d)

        uid, err := c.CreateCloudAccountAzure(account)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">d.SetId(uid)

        resourceCloudAccountAzureRead(ctx, d, m)

        return diags</span>
}

func resourceCloudAccountAzureRead(_ context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        resourceContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, resourceContext)

        var diags diag.Diagnostics

        uid := d.Id()

        account, err := c.GetCloudAccountAzure(uid)
        if err != nil </span><span class="cov0" title="0">{
                return handleReadError(d, err, diags)
        }</span> else<span class="cov0" title="0"> if account == nil </span><span class="cov0" title="0">{
                // Deleted - Terraform will recreate it
                d.SetId("")
                return diags
        }</span>

        <span class="cov0" title="0">diagnostics, done := flattenCloudAccountAzure(d, account)
        if done </span><span class="cov0" title="0">{
                return diagnostics
        }</span>

        <span class="cov0" title="0">return diags</span>
}

func flattenCloudAccountAzure(d *schema.ResourceData, account *models.V1AzureAccount) (diag.Diagnostics, bool) <span class="cov0" title="0">{
        if err := d.Set("name", account.Metadata.Name); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err), true
        }</span>
        <span class="cov0" title="0">if err := d.Set("context", account.Metadata.Annotations["scope"]); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err), true
        }</span>
        <span class="cov0" title="0">if err := d.Set("private_cloud_gateway_id", account.Metadata.Annotations[OverlordUID]); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err), true
        }</span>
        <span class="cov0" title="0">if err := d.Set("azure_tenant_id", *account.Spec.TenantID); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err), true
        }</span>
        <span class="cov0" title="0">if err := d.Set("azure_client_id", *account.Spec.ClientID); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err), true
        }</span>
        <span class="cov0" title="0">if err := d.Set("tenant_name", account.Spec.TenantName); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err), true
        }</span>
        <span class="cov0" title="0">if err := d.Set("disable_properties_request", account.Spec.Settings.DisablePropertiesRequest); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err), true
        }</span>
        <span class="cov0" title="0">if account.Spec.AzureEnvironment != nil </span><span class="cov0" title="0">{
                if err := d.Set("cloud", account.Spec.AzureEnvironment); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err), true
                }</span>
        }
        <span class="cov0" title="0">if account.Spec.TLS != nil &amp;&amp; account.Spec.TLS.Cert != "" </span><span class="cov0" title="0">{
                if err := d.Set("tls_cert", account.Spec.TLS.Cert); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err), true
                }</span>
        }
        <span class="cov0" title="0">return nil, false</span>
}

func resourceCloudAccountAzureUpdate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        resourceContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, resourceContext)

        // Warning or errors can be collected in a slice type
        var diags diag.Diagnostics

        // Validate tls_cert is only used with AzureUSSecretCloud
        if err := validateTlsCertConfiguration(d); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">account := toAzureAccount(d)

        err := c.UpdateCloudAccountAzure(account)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">resourceCloudAccountAzureRead(ctx, d, m)

        return diags</span>
}

func resourceCloudAccountAzureDelete(_ context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        resourceContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, resourceContext)

        var diags diag.Diagnostics

        cloudAccountID := d.Id()
        //AccountContext := d.Get("context").(string)
        err := c.DeleteCloudAccountAzure(cloudAccountID)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        // d.SetId("") is automatically called assuming delete returns no errors

        <span class="cov0" title="0">return diags</span>
}

func toAzureAccount(d *schema.ResourceData) *models.V1AzureAccount <span class="cov0" title="0">{
        clientSecret := strfmt.Password(d.Get("azure_client_secret").(string)).String()
        account := &amp;models.V1AzureAccount{
                Metadata: &amp;models.V1ObjectMeta{
                        Name: d.Get("name").(string),
                        Annotations: map[string]string{
                                "scope":     d.Get("context").(string),
                                OverlordUID: d.Get("private_cloud_gateway_id").(string),
                        },
                        UID: d.Id(),
                },
                Spec: &amp;models.V1AzureCloudAccount{
                        ClientID:     types.Ptr(d.Get("azure_client_id").(string)),
                        ClientSecret: &amp;clientSecret,
                        TenantID:     types.Ptr(d.Get("azure_tenant_id").(string)),
                        TenantName:   d.Get("tenant_name").(string),
                        Settings: &amp;models.V1CloudAccountSettings{
                                DisablePropertiesRequest: d.Get("disable_properties_request").(bool),
                        },
                },
        }

        // add partition to account
        if d.Get("cloud") != nil </span><span class="cov0" title="0">{
                account.Spec.AzureEnvironment = types.Ptr(d.Get("cloud").(string))
        }</span>

        // add TLS configuration if tls_cert is provided
        <span class="cov0" title="0">if tlsCert, ok := d.GetOk("tls_cert"); ok &amp;&amp; tlsCert.(string) != "" </span><span class="cov0" title="0">{
                account.Spec.TLS = &amp;models.V1AzureSecretTLSConfig{
                        Cert: tlsCert.(string),
                }
        }</span>

        <span class="cov0" title="0">return account</span>
}

func validateTlsCertConfiguration(d *schema.ResourceData) error <span class="cov0" title="0">{
        cloud := d.Get("cloud").(string)
        tlsCert := d.Get("tls_cert").(string)

        // If tls_cert is provided but cloud is not AzureUSSecretCloud, return an error
        if tlsCert != "" &amp;&amp; cloud != "AzureUSSecretCloud" </span><span class="cov0" title="0">{
                return fmt.Errorf("tls_cert can only be set when cloud is 'AzureUSSecretCloud', but cloud is set to '%s'", cloud)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func resourceAccountAzureImport(ctx context.Context, d *schema.ResourceData, m interface{}) ([]*schema.ResourceData, error) <span class="cov0" title="0">{
        resourceContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, resourceContext)

        err := GetCommonAccount(d, c)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">diags := resourceCloudAccountAzureRead(ctx, d, m)
        if diags.HasError() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("could not read cluster for import: %v", diags)
        }</span>

        // Return the resource data. In most cases, this method is only used to
        // import one resource at a time, so you should return the resource data
        // in a slice with a single element.
        <span class="cov0" title="0">return []*schema.ResourceData{d}, nil</span>
}
</pre>
		
		<pre class="file" id="file118" style="display: none">package spectrocloud

import (
        "context"
        "fmt"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
        "github.com/spectrocloud/palette-sdk-go/api/models"
)

func resourceCloudAccountCustom() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                CreateContext: resourceCloudAccountCustomCreate,
                ReadContext:   resourceCloudAccountCustomRead,
                UpdateContext: resourceCloudAccountCustomUpdate,
                DeleteContext: resourceCloudAccountCustomDelete,
                Importer: &amp;schema.ResourceImporter{
                        StateContext: resourceAccountCustomImport,
                },
                Schema: map[string]*schema.Schema{
                        "name": {
                                Type:        schema.TypeString,
                                Required:    true,
                                Description: "The name of the cloud account.",
                        },
                        "cloud": {
                                Type:        schema.TypeString,
                                ForceNew:    true,
                                Required:    true,
                                Description: "The cloud provider name.",
                        },
                        "context": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "project",
                                ForceNew:     true,
                                ValidateFunc: validation.StringInSlice([]string{"", "project", "tenant"}, false),
                                Description: "The context of the custom cloud configuration. Allowed values are `project` or `tenant`. " +
                                        "Default value is `project`. " + PROJECT_NAME_NUANCE,
                        },
                        "private_cloud_gateway_id": {
                                Type:        schema.TypeString,
                                Required:    true,
                                ForceNew:    true,
                                Description: "ID of the private cloud gateway, which serves as the connection point to establish connectivity with the cloud infrastructure.",
                        },
                        "credentials": {
                                Type:        schema.TypeMap,
                                Optional:    true,
                                Sensitive:   true,
                                Description: "The credentials required for accessing the cloud.",
                                Elem: &amp;schema.Schema{
                                        Type: schema.TypeString,
                                },
                        },
                },
        }
}</span>

func resourceCloudAccountCustomCreate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        resourceContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, resourceContext)
        var diags diag.Diagnostics

        //accountContext := d.Get("context").(string)
        cloudType := d.Get("cloud").(string)

        // For custom cloud we need to validate cloud type id isCustom for all actions.
        err := c.ValidateCustomCloudType(d.Get("cloud").(string))
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">account, err := toCloudAccountCustom(d)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">uid, err := c.CreateAccountCustomCloud(account, cloudType)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">d.SetId(uid)
        resourceCloudAccountCustomRead(ctx, d, m)

        return diags</span>
}

func resourceCloudAccountCustomRead(_ context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        resourceContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, resourceContext)

        var diags diag.Diagnostics
        cloudType := d.Get("cloud").(string)

        account, err := c.GetCustomCloudAccount(d.Id(), cloudType)
        if err != nil </span><span class="cov0" title="0">{
                return handleReadError(d, err, diags)
        }</span> else<span class="cov0" title="0"> if account == nil </span><span class="cov0" title="0">{
                // Deleted - Terraform will recreate it
                d.SetId("")
                return diags
        }</span>
        <span class="cov0" title="0">diagnostics, done := flattenCloudAccountCustom(d, account)
        if done </span><span class="cov0" title="0">{
                return diagnostics
        }</span>

        <span class="cov0" title="0">return diags</span>
}

func resourceCloudAccountCustomUpdate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        resourceContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, resourceContext)

        // Warning or errors can be collected in a slice type
        var diags diag.Diagnostics
        cloudType := d.Get("cloud").(string)
        account, err := toCloudAccountCustom(d)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">err = c.UpdateAccountCustomCloud(d.Id(), account, cloudType)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">resourceCloudAccountCustomRead(ctx, d, m)

        return diags</span>
}

func resourceCloudAccountCustomDelete(_ context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        resourceContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, resourceContext)

        var diags diag.Diagnostics
        customAccountID := d.Id()
        cloudType := d.Get("cloud").(string)
        err := c.DeleteCloudAccountCustomCloud(customAccountID, cloudType)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">return diags</span>
}

func toCloudAccountCustom(d *schema.ResourceData) (*models.V1CustomAccountEntity, error) <span class="cov0" title="0">{
        var overlayID string
        credentials := make(map[string]string)
        overlayID = d.Get("private_cloud_gateway_id").(string)

        // Validate that credentials are provided for create/update operations
        credInterface, ok := d.GetOk("credentials")
        if !ok || credInterface == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("credentials are required for custom cloud account operations")
        }</span>

        <span class="cov0" title="0">credMap, ok := credInterface.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("credentials must be a map of string values")
        }</span>

        <span class="cov0" title="0">if len(credMap) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("credentials cannot be empty - at least one credential key-value pair is required")
        }</span>

        <span class="cov0" title="0">for k, v := range credMap </span><span class="cov0" title="0">{
                if vStr, ok := v.(string); ok </span><span class="cov0" title="0">{
                        credentials[k] = vStr
                }</span> else<span class="cov0" title="0"> {
                        return nil, fmt.Errorf("credential value for key '%s' must be a string", k)
                }</span>
        }

        <span class="cov0" title="0">account := &amp;models.V1CustomAccountEntity{
                Metadata: &amp;models.V1ObjectMetaInputEntity{
                        Annotations: map[string]string{
                                OverlordUID: overlayID,
                        },
                        Name: d.Get("name").(string),
                },
                Spec: &amp;models.V1CustomCloudAccount{
                        Credentials: credentials,
                },
        }
        return account, nil</span>
}

func flattenCloudAccountCustom(d *schema.ResourceData, account *models.V1CustomAccount) (diag.Diagnostics, bool) <span class="cov0" title="0">{
        if err := d.Set("name", account.Metadata.Name); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err), true
        }</span>
        <span class="cov0" title="0">if err := d.Set("context", account.Metadata.Annotations["scope"]); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err), true
        }</span>
        <span class="cov0" title="0">if err := d.Set("private_cloud_gateway_id", account.Metadata.Annotations[OverlordUID]); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err), true
        }</span>
        <span class="cov0" title="0">if err := d.Set("cloud", account.Kind); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err), true
        }</span>

        <span class="cov0" title="0">return nil, false</span>
}

func resourceAccountCustomImport(ctx context.Context, d *schema.ResourceData, m interface{}) ([]*schema.ResourceData, error) <span class="cov0" title="0">{
        cloudAccountID, scope, customCloudName, err := ParseResourceCustomCloudImportID(d)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">d.SetId(cloudAccountID + ":" + scope)
        _ = d.Set("context", scope)
        _ = d.Set("cloud", customCloudName)
        c := getV1ClientWithResourceContext(m, scope)

        err = GetCommonAccount(d, c)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">diags := resourceCloudAccountCustomRead(ctx, d, m)
        if diags.HasError() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("could not read cluster for import: %v", diags)
        }</span>

        <span class="cov0" title="0">return []*schema.ResourceData{d}, nil</span>
}
</pre>
		
		<pre class="file" id="file119" style="display: none">package spectrocloud

import (
        "context"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
        "github.com/spectrocloud/palette-sdk-go/api/models"
)

func resourceCloudAccountGcp() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                CreateContext: resourceCloudAccountGcpCreate,
                ReadContext:   resourceCloudAccountGcpRead,
                UpdateContext: resourceCloudAccountGcpUpdate,
                DeleteContext: resourceCloudAccountGcpDelete,
                Importer: &amp;schema.ResourceImporter{
                        StateContext: resourceAccountGcpImport,
                },
                Schema: map[string]*schema.Schema{
                        "name": {
                                Type:        schema.TypeString,
                                Required:    true,
                                Description: "The name of the GCP account.",
                        },
                        "context": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "project",
                                ValidateFunc: validation.StringInSlice([]string{"", "project", "tenant"}, false),
                                Description: "The context of the GCP configuration. " +
                                        "Allowed values are `project` or `tenant`. Default value is `project`. " + PROJECT_NAME_NUANCE,
                        },
                        "gcp_json_credentials": {
                                Type:        schema.TypeString,
                                Required:    true,
                                Sensitive:   true,
                                Description: "The GCP credentials in JSON format. These credentials are required to authenticate and manage.",
                        },
                },
        }
}</span>

func resourceCloudAccountGcpCreate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        resourceContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, resourceContext)

        // Warning or errors can be collected in a slice type
        var diags diag.Diagnostics

        account := toGcpAccount(d)
        uid, err := c.CreateCloudAccountGcp(account)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">d.SetId(uid)

        resourceCloudAccountGcpRead(ctx, d, m)

        return diags</span>
}

func resourceCloudAccountGcpRead(_ context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        resourceContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, resourceContext)

        var diags diag.Diagnostics

        uid := d.Id()
        account, err := c.GetCloudAccountGcp(uid)
        if err != nil </span><span class="cov0" title="0">{
                return handleReadError(d, err, diags)
        }</span> else<span class="cov0" title="0"> if account == nil </span><span class="cov0" title="0">{
                // Deleted - Terraform will recreate it
                d.SetId("")
                return diags
        }</span>

        <span class="cov0" title="0">if err := d.Set("name", account.Metadata.Name); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">if err := d.Set("context", account.Metadata.Annotations["scope"]); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">return diags</span>
}

func resourceCloudAccountGcpUpdate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        resourceContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, resourceContext)

        // Warning or errors can be collected in a slice type
        var diags diag.Diagnostics

        account := toGcpAccount(d)

        err := c.UpdateCloudAccountGcp(account)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">resourceCloudAccountGcpRead(ctx, d, m)

        return diags</span>
}

func resourceCloudAccountGcpDelete(_ context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        resourceContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, resourceContext)

        var diags diag.Diagnostics

        cloudAccountID := d.Id()
        //AccountContext := d.Get("context").(string)
        err := c.DeleteCloudAccountGcp(cloudAccountID)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">return diags</span>
}

func toGcpAccount(d *schema.ResourceData) *models.V1GcpAccountEntity <span class="cov0" title="0">{
        account := &amp;models.V1GcpAccountEntity{
                Metadata: &amp;models.V1ObjectMeta{
                        Name: d.Get("name").(string),
                        UID:  d.Id(),
                },
                Spec: &amp;models.V1GcpAccountEntitySpec{
                        JSONCredentials: d.Get("gcp_json_credentials").(string),
                },
        }
        return account
}</span>
</pre>
		
		<pre class="file" id="file120" style="display: none">package spectrocloud

import (
        "context"
        "fmt"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/spectrocloud/palette-sdk-go/client"
)

func resourceAccountGcpImport(ctx context.Context, d *schema.ResourceData, m interface{}) ([]*schema.ResourceData, error) <span class="cov0" title="0">{
        resourceContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, resourceContext)

        err := GetCommonAccount(d, c)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">diags := resourceCloudAccountGcpRead(ctx, d, m)
        if diags.HasError() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("could not read cluster for import: %v", diags)
        }</span>

        // Return the resource data. In most cases, this method is only used to
        // import one resource at a time, so you should return the resource data
        // in a slice with a single element.
        <span class="cov0" title="0">return []*schema.ResourceData{d}, nil</span>
}

func GetCommonAccount(d *schema.ResourceData, c *client.V1Client) error <span class="cov0" title="0">{
        // parse resource ID and scope
        scope, accountID, err := ParseResourceID(d)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Use the IDs to retrieve the cluster data from the API
        <span class="cov0" title="0">cluster, err := c.GetCloudAccount(accountID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unable to retrieve cluster data: %s", err)
        }</span>

        <span class="cov0" title="0">err = d.Set("name", cluster.Metadata.Name)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if cluster.Metadata.Annotations != nil </span><span class="cov0" title="0">{
                if scope != cluster.Metadata.Annotations["scope"] </span><span class="cov0" title="0">{
                        return fmt.Errorf("CloudAccount scope mismatch: %s != %s", scope, cluster.Metadata.Annotations["scope"])
                }</span>
                <span class="cov0" title="0">err = d.Set("context", cluster.Metadata.Annotations["scope"])
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        // Set the ID of the resource in the state. This ID is used to track the
        // resource and must be set in the state during the import.
        <span class="cov0" title="0">d.SetId(accountID)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file121" style="display: none">package spectrocloud

import (
        "context"
        "fmt"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
        "github.com/spectrocloud/palette-sdk-go/api/models"
)

func resourceCloudAccountMaas() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                CreateContext: resourceCloudAccountMaasCreate,
                ReadContext:   resourceCloudAccountMaasRead,
                UpdateContext: resourceCloudAccountMaasUpdate,
                DeleteContext: resourceCloudAccountMaasDelete,
                Importer: &amp;schema.ResourceImporter{
                        StateContext: resourceAccountMaasImport,
                },
                Schema: map[string]*schema.Schema{
                        "name": {
                                Type:        schema.TypeString,
                                Required:    true,
                                Description: "Name of the MAAS cloud account.",
                        },
                        "context": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "project",
                                ValidateFunc: validation.StringInSlice([]string{"", "project", "tenant"}, false),
                                Description: "The context of the MAAS configuration. " +
                                        "Allowed values are `project` or `tenant`. Default value is `project`. " + PROJECT_NAME_NUANCE,
                        },
                        "private_cloud_gateway_id": {
                                Type:        schema.TypeString,
                                Required:    true,
                                Description: "ID of the private cloud gateway that is used to connect to the MAAS cloud.",
                        },
                        "maas_api_endpoint": {
                                Type:        schema.TypeString,
                                Required:    true,
                                Description: "Endpoint of the MAAS API that is used to connect to the MAAS cloud. I.e. http://maas:5240/MAAS",
                        },
                        "maas_api_key": {
                                Type:        schema.TypeString,
                                Required:    true,
                                Sensitive:   true,
                                Description: "API key that is used to connect to the MAAS cloud.",
                        },
                },
        }
}</span>

func resourceCloudAccountMaasCreate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        resourceContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, resourceContext)

        // Warning or errors can be collected in a slice type
        var diags diag.Diagnostics

        account := toMaasAccount(d)
        uid, err := c.CreateCloudAccountMaas(account)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">d.SetId(uid)

        resourceCloudAccountMaasRead(ctx, d, m)

        return diags</span>
}

func resourceCloudAccountMaasRead(_ context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        resourceContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, resourceContext)

        var diags diag.Diagnostics

        uid := d.Id()
        account, err := c.GetCloudAccountMaas(uid)
        if err != nil </span><span class="cov0" title="0">{
                return handleReadError(d, err, diags)
        }</span> else<span class="cov0" title="0"> if account == nil </span><span class="cov0" title="0">{
                // Deleted - Terraform will recreate it
                d.SetId("")
                return diags
        }</span>

        <span class="cov0" title="0">if err := d.Set("name", account.Metadata.Name); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">if err := d.Set("private_cloud_gateway_id", account.Metadata.Annotations[OverlordUID]); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">return diags</span>
}

func resourceCloudAccountMaasUpdate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        resourceContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, resourceContext)

        // Warning or errors can be collected in a slice type
        var diags diag.Diagnostics

        account := toMaasAccount(d)
        err := c.UpdateCloudAccountMaas(account)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">resourceCloudAccountMaasRead(ctx, d, m)

        return diags</span>
}

func resourceCloudAccountMaasDelete(_ context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        resourceContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, resourceContext)

        var diags diag.Diagnostics

        cloudAccountID := d.Id()
        err := c.DeleteCloudAccountMaas(cloudAccountID)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        // d.SetId("") is automatically called assuming delete returns no errors

        <span class="cov0" title="0">return diags</span>
}

func toMaasAccount(d *schema.ResourceData) *models.V1MaasAccount <span class="cov0" title="0">{
        EndpointVal := d.Get("maas_api_endpoint").(string)
        KeyVal := d.Get("maas_api_key").(string)
        account := &amp;models.V1MaasAccount{
                Metadata: &amp;models.V1ObjectMeta{
                        Name:        d.Get("name").(string),
                        Annotations: map[string]string{OverlordUID: d.Get("private_cloud_gateway_id").(string)},
                        UID:         d.Id(),
                },
                Spec: &amp;models.V1MaasCloudAccount{
                        APIEndpoint: &amp;EndpointVal,
                        APIKey:      &amp;KeyVal,
                },
        }

        return account
}</span>

func resourceAccountMaasImport(ctx context.Context, d *schema.ResourceData, m interface{}) ([]*schema.ResourceData, error) <span class="cov0" title="0">{
        resourceContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, resourceContext)

        err := GetCommonAccount(d, c)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">diags := resourceCloudAccountMaasRead(ctx, d, m)
        if diags.HasError() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("could not read cluster for import: %v", diags)
        }</span>

        // Return the resource data. In most cases, this method is only used to
        // import one resource at a time, so you should return the resource data
        // in a slice with a single element.
        <span class="cov0" title="0">return []*schema.ResourceData{d}, nil</span>
}
</pre>
		
		<pre class="file" id="file122" style="display: none">package spectrocloud

import (
        "context"
        "fmt"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
        "github.com/spectrocloud/palette-sdk-go/api/models"
        "github.com/spectrocloud/terraform-provider-spectrocloud/types"
)

func resourceCloudAccountOpenstack() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                CreateContext: resourceCloudAccountOpenStackCreate,
                ReadContext:   resourceCloudAccountOpenStackRead,
                UpdateContext: resourceCloudAccountOpenStackUpdate,
                DeleteContext: resourceCloudAccountOpenStackDelete,
                Importer: &amp;schema.ResourceImporter{
                        StateContext: resourceAccountOpenstackImport,
                },
                Schema: map[string]*schema.Schema{
                        "name": {
                                Type:        schema.TypeString,
                                Required:    true,
                                Description: "Name of the OpenStack cloud account.",
                        },
                        "context": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "project",
                                ValidateFunc: validation.StringInSlice([]string{"", "project", "tenant"}, false),
                                Description: "The context of the OpenStack configuration. " +
                                        "Allowed values are `project` or `tenant`. Default value is `project`. " + PROJECT_NAME_NUANCE,
                        },
                        "private_cloud_gateway_id": {
                                Type:        schema.TypeString,
                                Required:    true,
                                Description: "ID of the private cloud gateway that is used to connect to the OpenStack cloud.",
                        },
                        "openstack_username": {
                                Type:        schema.TypeString,
                                Required:    true,
                                Description: "The username of the OpenStack cloud that is used to connect to the OpenStack cloud.",
                        },
                        "openstack_password": {
                                Type:        schema.TypeString,
                                Required:    true,
                                Sensitive:   true,
                                Description: "The password of the OpenStack cloud that is used to connect to the OpenStack cloud.",
                        },
                        "identity_endpoint": {
                                Type:        schema.TypeString,
                                Required:    true,
                                Description: "The identity endpoint of the OpenStack cloud that is used to connect to the OpenStack cloud.",
                        },
                        "openstack_allow_insecure": {
                                Type:        schema.TypeBool,
                                Optional:    true,
                                Default:     false,
                                Description: "Whether to allow insecure connections to the OpenStack cloud. Default is `false`.",
                        },
                        "ca_certificate": {
                                Type:        schema.TypeString,
                                Optional:    true,
                                Description: "The CA certificate of the OpenStack cloud that is used to connect to the OpenStack cloud.",
                        },
                        "parent_region": {
                                Type:        schema.TypeString,
                                Required:    true,
                                Description: "The parent region of the OpenStack cloud that is used to connect to the OpenStack cloud.",
                        },
                        "default_domain": {
                                Type:        schema.TypeString,
                                Required:    true,
                                Description: "The default domain of the OpenStack cloud that is used to connect to the OpenStack cloud.",
                        },
                        "default_project": {
                                Type:        schema.TypeString,
                                Required:    true,
                                Description: "The default project of the OpenStack cloud that is used to connect to the OpenStack cloud.",
                        },
                },
        }
}</span>

func resourceCloudAccountOpenStackCreate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        resourceContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, resourceContext)

        // Warning or errors can be collected in a slice type
        var diags diag.Diagnostics

        account := toOpenStackAccount(d)
        uid, err := c.CreateCloudAccountOpenStack(account)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">d.SetId(uid)

        resourceCloudAccountOpenStackRead(ctx, d, m)

        return diags</span>
}

func resourceCloudAccountOpenStackRead(_ context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        resourceContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, resourceContext)

        var diags diag.Diagnostics

        uid := d.Id()
        account, err := c.GetCloudAccountOpenStack(uid)
        if err != nil </span><span class="cov0" title="0">{
                return handleReadError(d, err, diags)
        }</span> else<span class="cov0" title="0"> if account == nil </span><span class="cov0" title="0">{
                d.SetId("")
                return diags
        }</span>

        <span class="cov0" title="0">if err := d.Set("name", account.Metadata.Name); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">if err := d.Set("private_cloud_gateway_id", account.Metadata.Annotations[OverlordUID]); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">if err := d.Set("identity_endpoint", *account.Spec.IdentityEndpoint); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">if err := d.Set("openstack_username", *account.Spec.Username); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">if err := d.Set("openstack_allow_insecure", account.Spec.Insecure); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">if err := d.Set("ca_certificate", account.Spec.CaCert); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">if err := d.Set("parent_region", account.Spec.ParentRegion); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">if err := d.Set("default_domain", account.Spec.DefaultDomain); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">if err := d.Set("default_project", account.Spec.DefaultProject); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">return diags</span>
}

func resourceCloudAccountOpenStackUpdate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        resourceContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, resourceContext)

        // Warning or errors can be collected in a slice type
        var diags diag.Diagnostics

        account := toOpenStackAccount(d)

        err := c.UpdateCloudAccountOpenStack(account)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">resourceCloudAccountOpenStackRead(ctx, d, m)

        return diags</span>
}

func resourceCloudAccountOpenStackDelete(_ context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        resourceContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, resourceContext)

        var diags diag.Diagnostics

        cloudAccountID := d.Id()
        err := c.DeleteCloudAccountOpenStack(cloudAccountID)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">return diags</span>
}

func toOpenStackAccount(d *schema.ResourceData) *models.V1OpenStackAccount <span class="cov0" title="0">{
        account := &amp;models.V1OpenStackAccount{
                Metadata: &amp;models.V1ObjectMeta{
                        Name:        d.Get("name").(string),
                        Annotations: map[string]string{OverlordUID: d.Get("private_cloud_gateway_id").(string)},
                        UID:         d.Id(),
                },

                Spec: &amp;models.V1OpenStackCloudAccount{
                        CaCert:           d.Get("ca_certificate").(string),
                        DefaultDomain:    d.Get("default_domain").(string),
                        DefaultProject:   d.Get("default_project").(string),
                        IdentityEndpoint: types.Ptr(d.Get("identity_endpoint").(string)),
                        Insecure:         d.Get("openstack_allow_insecure").(bool),
                        ParentRegion:     d.Get("parent_region").(string),
                        Password:         types.Ptr(d.Get("openstack_password").(string)),
                        Username:         types.Ptr(d.Get("openstack_username").(string)),
                },
        }

        return account
}</span>

func resourceAccountOpenstackImport(ctx context.Context, d *schema.ResourceData, m interface{}) ([]*schema.ResourceData, error) <span class="cov0" title="0">{
        resourceContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, resourceContext)

        err := GetCommonAccount(d, c)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">diags := resourceCloudAccountOpenStackRead(ctx, d, m)
        if diags.HasError() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("could not read cluster for import: %v", diags)
        }</span>

        // Return the resource data. In most cases, this method is only used to
        // import one resource at a time, so you should return the resource data
        // in a slice with a single element.
        <span class="cov0" title="0">return []*schema.ResourceData{d}, nil</span>
}
</pre>
		
		<pre class="file" id="file123" style="display: none">package spectrocloud

import (
        "context"
        "fmt"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
        "github.com/spectrocloud/palette-sdk-go/api/models"
        "github.com/spectrocloud/terraform-provider-spectrocloud/types"
)

const OverlordUID = "overlordUid"

func resourceCloudAccountVsphere() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                CreateContext: resourceCloudAccountVsphereCreate,
                ReadContext:   resourceCloudAccountVsphereRead,
                UpdateContext: resourceCloudAccountVsphereUpdate,
                DeleteContext: resourceCloudAccountVsphereDelete,
                Importer: &amp;schema.ResourceImporter{
                        StateContext: resourceAccountVsphereImport,
                },
                Description: "A resource to manage a vSphere cloud account in Palette.",
                Schema: map[string]*schema.Schema{
                        "name": {
                                Type:        schema.TypeString,
                                Required:    true,
                                Description: "Name of the cloud account. This name is used to identify the cloud account in the Spectro Cloud UI.",
                        },
                        "context": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "project",
                                ValidateFunc: validation.StringInSlice([]string{"", "project", "tenant"}, false),
                                Description: "Context of the cloud account. Allowed values are `project` or `tenant`. " +
                                        "Default value is `project`. " + PROJECT_NAME_NUANCE,
                        },
                        "private_cloud_gateway_id": {
                                Type:        schema.TypeString,
                                Required:    true,
                                Description: "ID of the private cloud gateway. This is the ID of the private cloud gateway that is used to connect to the vSphere cloud.",
                        },
                        "vsphere_vcenter": {
                                Type:        schema.TypeString,
                                Required:    true,
                                Description: "vCenter server address. This is the address of the vCenter server that is used to connect to the vSphere cloud.",
                        },
                        "vsphere_username": {
                                Type:        schema.TypeString,
                                Required:    true,
                                Description: "Username of the vSphere cloud. This is the username of the vSphere cloud that is used to connect to the vSphere cloud.",
                        },
                        "vsphere_password": {
                                Type:        schema.TypeString,
                                Required:    true,
                                Sensitive:   true,
                                Description: "Password of the vSphere cloud. This is the password of the vSphere cloud that is used to connect to the vSphere cloud.",
                        },
                        "vsphere_ignore_insecure_error": {
                                Type:        schema.TypeBool,
                                Optional:    true,
                                Description: "Ignore insecure error. This is a boolean value that indicates whether to ignore the insecure error or not. If not specified, the default value is false.",
                        },
                },
        }
}</span>

func resourceCloudAccountVsphereCreate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        resourceContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, resourceContext)

        // Warning or errors can be collected in a slice type
        var diags diag.Diagnostics

        account := toVsphereAccount(d)

        uid, err := c.CreateCloudAccountVsphere(account)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">d.SetId(uid)

        resourceCloudAccountVsphereRead(ctx, d, m)

        return diags</span>
}

func resourceCloudAccountVsphereRead(_ context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        resourceContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, resourceContext)

        var diags diag.Diagnostics

        uid := d.Id()
        account, err := c.GetCloudAccountVsphere(uid)
        if err != nil </span><span class="cov0" title="0">{
                return handleReadError(d, err, diags)
        }</span> else<span class="cov0" title="0"> if account == nil </span><span class="cov0" title="0">{
                // Deleted - Terraform will recreate it
                d.SetId("")
                return diags
        }</span>

        <span class="cov0" title="0">diagnostics, done := flattenVsphereCloudAccount(d, account)
        if done </span><span class="cov0" title="0">{
                return diagnostics
        }</span>

        <span class="cov0" title="0">return diags</span>
}

func flattenVsphereCloudAccount(d *schema.ResourceData, account *models.V1VsphereAccount) (diag.Diagnostics, bool) <span class="cov0" title="0">{
        if err := d.Set("name", account.Metadata.Name); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err), true
        }</span>
        <span class="cov0" title="0">if err := d.Set("context", account.Metadata.Annotations["scope"]); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err), true
        }</span>
        <span class="cov0" title="0">if err := d.Set("private_cloud_gateway_id", account.Metadata.Annotations[OverlordUID]); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err), true
        }</span>
        <span class="cov0" title="0">if err := d.Set("vsphere_vcenter", *account.Spec.VcenterServer); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err), true
        }</span>
        <span class="cov0" title="0">if err := d.Set("vsphere_username", *account.Spec.Username); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err), true
        }</span>
        <span class="cov0" title="0">if err := d.Set("vsphere_ignore_insecure_error", account.Spec.Insecure); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err), true
        }</span>
        <span class="cov0" title="0">return nil, false</span>
}

func resourceCloudAccountVsphereUpdate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        resourceContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, resourceContext)

        // Warning or errors can be collected in a slice type
        var diags diag.Diagnostics

        account := toVsphereAccount(d)

        err := c.UpdateCloudAccountVsphere(account)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">resourceCloudAccountVsphereRead(ctx, d, m)

        return diags</span>
}

func resourceCloudAccountVsphereDelete(_ context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        resourceContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, resourceContext)

        var diags diag.Diagnostics

        cloudAccountID := d.Id()
        err := c.DeleteCloudAccountVsphere(cloudAccountID)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">return diags</span>
}

func toVsphereAccount(d *schema.ResourceData) *models.V1VsphereAccount <span class="cov0" title="0">{
        account := &amp;models.V1VsphereAccount{
                Metadata: &amp;models.V1ObjectMeta{
                        Name: d.Get("name").(string),
                        Annotations: map[string]string{
                                "scope":     d.Get("context").(string),
                                OverlordUID: d.Get("private_cloud_gateway_id").(string),
                        },
                        UID: d.Id(),
                },
                Spec: &amp;models.V1VsphereCloudAccount{
                        VcenterServer: types.Ptr(d.Get("vsphere_vcenter").(string)),
                        Username:      types.Ptr(d.Get("vsphere_username").(string)),
                        Password:      types.Ptr(d.Get("vsphere_password").(string)),
                        Insecure:      d.Get("vsphere_ignore_insecure_error").(bool),
                },
        }
        return account
}</span>

func resourceAccountVsphereImport(ctx context.Context, d *schema.ResourceData, m interface{}) ([]*schema.ResourceData, error) <span class="cov0" title="0">{
        resourceContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, resourceContext)

        err := GetCommonAccount(d, c)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">diags := resourceCloudAccountVsphereRead(ctx, d, m)
        if diags.HasError() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("could not read cluster for import: %v", diags)
        }</span>

        // Return the resource data. In most cases, this method is only used to
        // import one resource at a time, so you should return the resource data
        // in a slice with a single element.
        <span class="cov0" title="0">return []*schema.ResourceData{d}, nil</span>
}
</pre>
		
		<pre class="file" id="file124" style="display: none">package spectrocloud

import (
        "context"
        "log"
        "time"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"

        "github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/schemas"
        "github.com/spectrocloud/terraform-provider-spectrocloud/types"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/spectrocloud/palette-sdk-go/api/models"
        "github.com/spectrocloud/palette-sdk-go/client"
)

func resourceClusterAks() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                CreateContext: resourceClusterAksCreate,
                ReadContext:   resourceClusterAksRead,
                UpdateContext: resourceClusterAksUpdate,
                DeleteContext: resourceClusterDelete,
                Importer: &amp;schema.ResourceImporter{
                        StateContext: resourceClusterAksImport,
                },
                Description: "Resource for managing AKS clusters in Spectro Cloud through Palette.",

                Timeouts: &amp;schema.ResourceTimeout{
                        Create: schema.DefaultTimeout(60 * time.Minute),
                        Update: schema.DefaultTimeout(60 * time.Minute),
                        Delete: schema.DefaultTimeout(60 * time.Minute),
                },

                SchemaVersion: 3,
                StateUpgraders: []schema.StateUpgrader{
                        {
                                Type:    resourceClusterAksResourceV2().CoreConfigSchema().ImpliedType(),
                                Upgrade: resourceClusterAksStateUpgradeV2,
                                Version: 2,
                        },
                },
                Schema: map[string]*schema.Schema{
                        "name": {
                                Type:        schema.TypeString,
                                Required:    true,
                                ForceNew:    true,
                                Description: "",
                        },
                        "context": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "project",
                                ValidateFunc: validation.StringInSlice([]string{"", "project", "tenant"}, false),
                                Description: "The context of the AKS cluster. Allowed values are `project` or `tenant`. " +
                                        "Default is `project`. " + PROJECT_NAME_NUANCE,
                        },
                        "tags": {
                                Type:     schema.TypeSet,
                                Optional: true,
                                Set:      schema.HashString,
                                Elem: &amp;schema.Schema{
                                        Type: schema.TypeString,
                                },
                                Description: "A list of tags to be applied to the cluster. Tags must be in the form of `key:value`.",
                        },
                        "description": {
                                Type:        schema.TypeString,
                                Optional:    true,
                                Default:     "",
                                Description: "The description of the cluster. Default value is empty string.",
                        },
                        "cluster_meta_attribute": {
                                Type:        schema.TypeString,
                                Optional:    true,
                                Description: "`cluster_meta_attribute` can be used to set additional cluster metadata information, eg `{'nic_name': 'test', 'env': 'stage'}`",
                        },
                        "cluster_profile":  schemas.ClusterProfileSchema(),
                        "cluster_template": schemas.ClusterTemplateSchema(),
                        "apply_setting": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "DownloadAndInstall",
                                ValidateFunc: validation.StringInSlice([]string{"DownloadAndInstall", "DownloadAndInstallLater"}, false),
                                Description: "The setting to apply the cluster profile. `DownloadAndInstall` will download and install packs in one action. " +
                                        "`DownloadAndInstallLater` will only download artifact and postpone install for later. " +
                                        "Default value is `DownloadAndInstall`.",
                        },
                        "cloud_account_id": {
                                Type:     schema.TypeString,
                                Required: true,
                                ForceNew: true,
                        },
                        "cloud_config_id": {
                                Type:        schema.TypeString,
                                Computed:    true,
                                Description: "ID of the cloud config used for the cluster. This cloud config must be of type `azure`.",
                                Deprecated:  "This field is deprecated and will be removed in the future. Use `cloud_config` instead.",
                        },
                        "review_repave_state": {
                                Type:         schema.TypeString,
                                Default:      "",
                                Optional:     true,
                                ValidateFunc: validateReviewRepaveValue,
                                Description:  "To authorize the cluster repave, set the value to `Approved` for approval and `\"\"` to decline. Default value is `\"\"`.",
                        },
                        "pause_agent_upgrades": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "unlock",
                                ValidateFunc: validation.StringInSlice([]string{"lock", "unlock"}, false),
                                Description:  "The pause agent upgrades setting allows to control the automatic upgrade of the Palette component and agent for an individual cluster. The default value is `unlock`, meaning upgrades occur automatically. Setting it to `lock` pauses automatic agent upgrades for the cluster.",
                        },
                        "os_patch_on_boot": {
                                Type:        schema.TypeBool,
                                Optional:    true,
                                Default:     false,
                                Description: "Whether to apply OS patch on boot. Default is `false`.",
                        },
                        "os_patch_schedule": {
                                Type:             schema.TypeString,
                                Optional:         true,
                                ValidateDiagFunc: validateOsPatchSchedule,
                                Description:      "The cron schedule for OS patching. This must be in the form of cron syntax. Ex: `0 0 * * *`.",
                        },
                        "os_patch_after": {
                                Type:             schema.TypeString,
                                Optional:         true,
                                ValidateDiagFunc: validateOsPatchOnDemandAfter,
                                Description:      "The date and time after which to patch the cluster. Prefix the time value with the respective RFC. Ex: `RFC3339: 2006-01-02T15:04:05Z07:00`",
                        },
                        "cluster_timezone": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "",
                                ValidateFunc: validateTimezone,
                                Description:  "Defines the time zone used by this cluster to interpret scheduled operations. Maintenance tasks like upgrades will follow this time zone to ensure they run at the appropriate local time for the cluster. Must be in IANA timezone format (e.g., 'America/New_York', 'Asia/Kolkata', 'Europe/London').",
                        },
                        "kubeconfig": {
                                Type:        schema.TypeString,
                                Computed:    true,
                                Description: "Kubeconfig for the cluster. This can be used to connect to the cluster using `kubectl`.",
                        },
                        "admin_kube_config": {
                                Type:        schema.TypeString,
                                Computed:    true,
                                Description: "Admin Kube-config for the cluster. This can be used to connect to the cluster using `kubectl`, With admin privilege.",
                        },
                        "cloud_config": {
                                Type:     schema.TypeList,
                                ForceNew: true,
                                Required: true,
                                MaxItems: 1,
                                Elem: &amp;schema.Resource{
                                        Schema: map[string]*schema.Schema{
                                                "subscription_id": {
                                                        Type:     schema.TypeString,
                                                        Required: true,
                                                        ForceNew: true,
                                                },
                                                "resource_group": {
                                                        Type:     schema.TypeString,
                                                        Required: true,
                                                        ForceNew: true,
                                                },
                                                "region": {
                                                        Type:     schema.TypeString,
                                                        Required: true,
                                                        ForceNew: true,
                                                },
                                                "ssh_key": {
                                                        Type:        schema.TypeString,
                                                        Required:    true,
                                                        ForceNew:    true,
                                                        Description: "Public SSH key to be used for the cluster nodes.",
                                                },
                                                "private_cluster": {
                                                        Type:        schema.TypeBool,
                                                        Optional:    true,
                                                        Default:     false,
                                                        ForceNew:    true,
                                                        Description: "Whether to create a private cluster(API endpoint). Default is `false`.",
                                                },

                                                // fields for static placement are having flat structure as backend currently doesn't support multiple subnets.
                                                "vnet_name": {
                                                        Type:     schema.TypeString,
                                                        Optional: true,
                                                        ForceNew: true,
                                                },

                                                "vnet_resource_group": {
                                                        Type:     schema.TypeString,
                                                        Optional: true,
                                                        ForceNew: true,
                                                },

                                                "vnet_cidr_block": {
                                                        Type:     schema.TypeString,
                                                        Optional: true,
                                                        ForceNew: true,
                                                },

                                                "worker_subnet_name": {
                                                        Type:     schema.TypeString,
                                                        Optional: true,
                                                        ForceNew: true,
                                                },
                                                "worker_cidr": {
                                                        Type:     schema.TypeString,
                                                        Optional: true,
                                                        ForceNew: true,
                                                },
                                                "worker_subnet_security_group_name": {
                                                        Type:     schema.TypeString,
                                                        Optional: true,
                                                        ForceNew: true,
                                                },
                                                "control_plane_subnet_name": {
                                                        Type:     schema.TypeString,
                                                        Optional: true,
                                                        ForceNew: true,
                                                },
                                                "control_plane_cidr": {
                                                        Type:     schema.TypeString,
                                                        Optional: true,
                                                        ForceNew: true,
                                                },
                                                "control_plane_subnet_security_group_name": {
                                                        Type:     schema.TypeString,
                                                        Optional: true,
                                                        ForceNew: true,
                                                },
                                        },
                                },
                        },
                        "machine_pool": {
                                Type:     schema.TypeSet,
                                Required: true,
                                Set:      resourceMachinePoolAksHash,
                                Elem: &amp;schema.Resource{
                                        Schema: map[string]*schema.Schema{
                                                "name": {
                                                        Type:     schema.TypeString,
                                                        Required: true,
                                                        //ForceNew: true,
                                                },
                                                "additional_labels": {
                                                        Type:     schema.TypeMap,
                                                        Optional: true,
                                                        Elem: &amp;schema.Schema{
                                                                Type: schema.TypeString,
                                                        },
                                                        Description: "Additional labels to be applied to the machine pool. Labels must be in the form of `key:value`.",
                                                },
                                                "additional_annotations": {
                                                        Type:     schema.TypeMap,
                                                        Optional: true,
                                                        Elem: &amp;schema.Schema{
                                                                Type: schema.TypeString,
                                                        },
                                                        Description: "Additional annotations to be applied to the machine pool. Annotations must be in the form of `key:value`.",
                                                },
                                                "node":   schemas.NodeSchema(),
                                                "taints": schemas.ClusterTaintsSchema(),
                                                "count": {
                                                        Type:        schema.TypeInt,
                                                        Required:    true,
                                                        Description: "Number of nodes in the machine pool.",
                                                },
                                                "update_strategy": {
                                                        Type:         schema.TypeString,
                                                        Optional:     true,
                                                        Default:      "RollingUpdateScaleOut",
                                                        Description:  "Update strategy for the machine pool. Valid values are `RollingUpdateScaleOut`, `RollingUpdateScaleIn` and `OverrideScaling`. If `OverrideScaling` is used, `override_scaling` must be specified with both `max_surge` and `max_unavailable`.",
                                                        ValidateFunc: validation.StringInSlice([]string{"RollingUpdateScaleOut", "RollingUpdateScaleIn", "OverrideScaling"}, false),
                                                },
                                                "override_scaling": schemas.OverrideScalingSchema(),
                                                "override_kubeadm_configuration": {
                                                        Type:        schema.TypeString,
                                                        Optional:    true,
                                                        Description: "YAML config for kubeletExtraArgs, preKubeadmCommands, postKubeadmCommands. Overrides pack-level settings. Worker pools only.",
                                                },
                                                "instance_type": {
                                                        Type:     schema.TypeString,
                                                        Required: true,
                                                },
                                                "min": {
                                                        Type:        schema.TypeInt,
                                                        Optional:    true,
                                                        Description: "Minimum number of nodes in the machine pool. This is used for autoscaling the machine pool.",
                                                },
                                                "max": {
                                                        Type:        schema.TypeInt,
                                                        Optional:    true,
                                                        Description: "Maximum number of nodes in the machine pool. This is used for autoscaling the machine pool.",
                                                },
                                                "disk_size_gb": {
                                                        Type:     schema.TypeInt,
                                                        Required: true,
                                                },
                                                "is_system_node_pool": {
                                                        Type:     schema.TypeBool,
                                                        Required: true,
                                                },
                                                "storage_account_type": {
                                                        Type:     schema.TypeString,
                                                        Required: true,
                                                        //ExactlyOneOf: []string{"Standard_LRS", "Standard_GRS", "Standard_RAGRS", "Standard_ZRS", "Premium_LRS", "Premium_ZRS", "Standard_GZRS", "Standard_RAGZRS"},
                                                },
                                        },
                                },
                        },
                        "backup_policy":        schemas.BackupPolicySchema(),
                        "scan_policy":          schemas.ScanPolicySchema(),
                        "cluster_rbac_binding": schemas.ClusterRbacBindingSchema(),
                        "namespaces":           schemas.ClusterNamespacesSchema(),
                        "host_config":          schemas.ClusterHostConfigSchema(),
                        "location_config":      schemas.ClusterLocationSchemaComputed(),
                        "skip_completion": {
                                Type:        schema.TypeBool,
                                Optional:    true,
                                Default:     false,
                                Description: "If `true`, the cluster will be created asynchronously. Default value is `false`.",
                        },
                        "force_delete": {
                                Type:        schema.TypeBool,
                                Optional:    true,
                                Default:     false,
                                Description: "If set to `true`, the cluster will be force deleted and user has to manually clean up the provisioned cloud resources.",
                        },
                        "force_delete_delay": {
                                Type:             schema.TypeInt,
                                Optional:         true,
                                Default:          20,
                                Description:      "Delay duration in minutes to before invoking cluster force delete. Default and minimum is 20.",
                                ValidateDiagFunc: validation.ToDiagFunc(validation.IntAtLeast(20)),
                        },
                },
        }
}</span>

func resourceClusterAksCreate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        resourceContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, resourceContext)

        // Warning or errors can be collected in a slice type
        var diags diag.Diagnostics

        // Validate override_Scaling configuration
        if err := validateOverrideScaling(d, "machine_pool"); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">cluster, err := toAksCluster(c, d)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">uid, err := c.CreateClusterAks(cluster)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">diagnostics, isError := waitForClusterCreation(ctx, d, uid, diags, c, true)
        if len(diagnostics) &gt; 0 </span><span class="cov0" title="0">{
                diags = append(diags, diagnostics...)
        }</span>
        <span class="cov0" title="0">if isError </span><span class="cov0" title="0">{
                return diagnostics
        }</span>

        <span class="cov0" title="0">resourceClusterAksRead(ctx, d, m)

        return diags</span>
}

//goland:noinspection GoUnhandledErrorResult
func resourceClusterAksRead(_ context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        resourceContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, resourceContext)

        var diags diag.Diagnostics

        cluster, err := resourceClusterRead(d, c, diags)
        if err != nil </span><span class="cov0" title="0">{
                return handleReadError(d, err, diags)
        }</span> else<span class="cov0" title="0"> if cluster == nil </span><span class="cov0" title="0">{
                // Deleted - Terraform will recreate it
                d.SetId("")
                return diags
        }</span>

        // verify cluster type
        <span class="cov0" title="0">err = ValidateCloudType("spectrocloud_cluster_aks", cluster)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">configUID := cluster.Spec.CloudConfigRef.UID
        if err := d.Set("cloud_config_id", configUID); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">if err := ReadCommonAttributes(d); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        //ClusterContext := d.Get("context").(string)
        <span class="cov0" title="0">if config, err := c.GetCloudConfigAks(configUID); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span> else<span class="cov0" title="0"> {
                if err := d.Set("cloud_account_id", config.Spec.CloudAccountRef.UID); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
                <span class="cov0" title="0">if err := d.Set("cloud_config", flattenClusterConfigsAks(config)); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
                <span class="cov0" title="0">mp := flattenMachinePoolConfigsAks(config.Spec.MachinePoolConfig)
                mp, err := flattenNodeMaintenanceStatus(c, d, c.GetNodeStatusMapAks, mp, configUID)
                if err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
                <span class="cov0" title="0">if err := d.Set("machine_pool", mp); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
        }

        <span class="cov0" title="0">diagnostics, done := readCommonFields(c, d, cluster)
        if done </span><span class="cov0" title="0">{
                return diagnostics
        }</span>

        // Flatten cluster_template variables using variables API
        <span class="cov0" title="0">if err := flattenClusterTemplateVariables(c, d, d.Id()); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">generalWarningForRepave(&amp;diags)
        return diags</span>
}

func ReadCommonAttributes(d *schema.ResourceData) error <span class="cov0" title="0">{
        ForceDelete := d.Get("force_delete").(bool)
        if err := d.Set("force_delete", ForceDelete); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">ForceDeleteDelay := d.Get("force_delete_delay").(int)
        if ForceDeleteDelay == 0 </span><span class="cov0" title="0">{
                ForceDeleteDelay = 20 // set default value
        }</span>
        <span class="cov0" title="0">if err := d.Set("force_delete_delay", ForceDeleteDelay); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">OsPatchOnBoot := d.Get("os_patch_on_boot").(bool)
        if err := d.Set("os_patch_on_boot", OsPatchOnBoot); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">SkipCompletion := d.Get("skip_completion").(bool)
        if err := d.Set("skip_completion", SkipCompletion); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">ApplySetting := d.Get("apply_setting").(string)
        if ApplySetting == "" </span><span class="cov0" title="0">{
                ApplySetting = "DownloadAndInstall" // set default value
        }</span>
        <span class="cov0" title="0">if err := d.Set("apply_setting", ApplySetting); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func flattenClusterConfigsAks(config *models.V1AzureCloudConfig) []interface{} <span class="cov0" title="0">{
        if config == nil || config.Spec == nil || config.Spec.ClusterConfig == nil </span><span class="cov0" title="0">{
                return make([]interface{}, 0)
        }</span>

        <span class="cov0" title="0">m := make(map[string]interface{})

        if config.Spec.ClusterConfig.SubscriptionID != nil </span><span class="cov0" title="0">{
                m["subscription_id"] = config.Spec.ClusterConfig.SubscriptionID
        }</span>
        <span class="cov0" title="0">if config.Spec.ClusterConfig.ResourceGroup != "" </span><span class="cov0" title="0">{
                m["resource_group"] = config.Spec.ClusterConfig.ResourceGroup
        }</span>
        <span class="cov0" title="0">if config.Spec.ClusterConfig.Location != nil </span><span class="cov0" title="0">{
                m["region"] = *config.Spec.ClusterConfig.Location
        }</span>
        <span class="cov0" title="0">if config.Spec.ClusterConfig.SSHKey != nil </span><span class="cov0" title="0">{
                m["ssh_key"] = *config.Spec.ClusterConfig.SSHKey
        }</span>
        <span class="cov0" title="0">m["private_cluster"] = config.Spec.ClusterConfig.APIServerAccessProfile.EnablePrivateCluster
        if config.Spec.ClusterConfig.VnetName != "" </span><span class="cov0" title="0">{
                m["vnet_name"] = config.Spec.ClusterConfig.VnetName
        }</span>
        <span class="cov0" title="0">if config.Spec.ClusterConfig.VnetResourceGroup != "" </span><span class="cov0" title="0">{
                m["vnet_resource_group"] = config.Spec.ClusterConfig.VnetResourceGroup
        }</span>
        <span class="cov0" title="0">if config.Spec.ClusterConfig.VnetCidrBlock != "" </span><span class="cov0" title="0">{
                m["vnet_cidr_block"] = config.Spec.ClusterConfig.VnetCidrBlock
        }</span>
        <span class="cov0" title="0">if config.Spec.ClusterConfig.WorkerSubnet != nil </span><span class="cov0" title="0">{
                m["worker_subnet_name"] = config.Spec.ClusterConfig.WorkerSubnet.Name
                m["worker_cidr"] = config.Spec.ClusterConfig.WorkerSubnet.CidrBlock
                if config.Spec.ClusterConfig.WorkerSubnet.SecurityGroupName != "" </span><span class="cov0" title="0">{
                        m["worker_subnet_security_group_name"] = config.Spec.ClusterConfig.WorkerSubnet.SecurityGroupName
                }</span>
        }
        <span class="cov0" title="0">if config.Spec.ClusterConfig.ControlPlaneSubnet != nil </span><span class="cov0" title="0">{
                m["control_plane_subnet_name"] = config.Spec.ClusterConfig.ControlPlaneSubnet.Name
                m["control_plane_cidr"] = config.Spec.ClusterConfig.ControlPlaneSubnet.CidrBlock
                if config.Spec.ClusterConfig.ControlPlaneSubnet.SecurityGroupName != "" </span><span class="cov0" title="0">{
                        m["control_plane_subnet_security_group_name"] = config.Spec.ClusterConfig.ControlPlaneSubnet.SecurityGroupName
                }</span>
        }

        <span class="cov0" title="0">return []interface{}{m}</span>
}

func flattenMachinePoolConfigsAks(machinePools []*models.V1AzureMachinePoolConfig) []interface{} <span class="cov0" title="0">{
        if machinePools == nil </span><span class="cov0" title="0">{
                return make([]interface{}, 0)
        }</span>

        <span class="cov0" title="0">ois := make([]interface{}, 0)
        for _, machinePool := range machinePools </span><span class="cov0" title="0">{
                oi := make(map[string]interface{})

                FlattenAdditionalLabelsAnnotationsAndTaints(machinePool.AdditionalLabels, machinePool.AdditionalAnnotations, machinePool.Taints, oi)

                if machinePool.IsControlPlane != nil &amp;&amp; *machinePool.IsControlPlane </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">oi["name"] = machinePool.Name
                oi["count"] = int(machinePool.Size)
                oi["min"] = int(machinePool.MinSize)
                oi["max"] = int(machinePool.MaxSize)
                if machinePool.UpdateStrategy != nil </span><span class="cov0" title="0">{
                        oi["update_strategy"] = machinePool.UpdateStrategy.Type
                        // Flatten override_Scaling if using OverrideScaling strategy
                        flattenOverrideScaling(machinePool.UpdateStrategy, oi)
                }</span>

                // Flatten override_kubeadm_configuration (worker pools only)
                <span class="cov0" title="0">if machinePool.OverrideKubeadmConfiguration != "" </span><span class="cov0" title="0">{
                        oi["override_kubeadm_configuration"] = machinePool.OverrideKubeadmConfiguration
                }</span>

                <span class="cov0" title="0">oi["instance_type"] = machinePool.InstanceType
                oi["disk_size_gb"] = int(machinePool.OsDisk.DiskSizeGB)
                oi["is_system_node_pool"] = machinePool.IsSystemNodePool
                oi["storage_account_type"] = machinePool.OsDisk.ManagedDisk.StorageAccountType
                oi["min"] = int(machinePool.MinSize)
                oi["max"] = int(machinePool.MaxSize)
                ois = append(ois, oi)</span>
        }
        <span class="cov0" title="0">return ois</span>
}

func resourceClusterAksUpdate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        resourceContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, resourceContext)

        // Warning or errors can be collected in a slice type
        var diags diag.Diagnostics

        err := validateSystemRepaveApproval(d, c)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">cloudConfigId := d.Get("cloud_config_id").(string)
        CloudConfig, err := c.GetCloudConfigAks(cloudConfigId)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">if d.HasChange("machine_pool") </span><span class="cov0" title="0">{
                // Validate override_Scaling configuration
                if err := validateOverrideScaling(d, "machine_pool"); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>

                <span class="cov0" title="0">log.Printf("[DEBUG] === MACHINE POOL CHANGE DETECTED ===")
                oraw, nraw := d.GetChange("machine_pool")
                if oraw == nil </span><span class="cov0" title="0">{
                        oraw = new(schema.Set)
                }</span>
                <span class="cov0" title="0">if nraw == nil </span><span class="cov0" title="0">{
                        nraw = new(schema.Set)
                }</span>

                <span class="cov0" title="0">os := oraw.(*schema.Set)
                ns := nraw.(*schema.Set)

                log.Printf("[DEBUG] Old machine pools count: %d, New machine pools count: %d", os.Len(), ns.Len())

                // Create maps by machine pool name for proper comparison
                osMap := make(map[string]interface{})
                for _, mp := range os.List() </span><span class="cov0" title="0">{
                        machinePoolResource := mp.(map[string]interface{})
                        name := machinePoolResource["name"].(string)
                        if name != "" </span><span class="cov0" title="0">{
                                osMap[name] = machinePoolResource
                        }</span>
                }

                <span class="cov0" title="0">nsMap := make(map[string]interface{})
                for _, mp := range ns.List() </span><span class="cov0" title="0">{
                        machinePoolResource := mp.(map[string]interface{})
                        name := machinePoolResource["name"].(string)
                        if name != "" </span><span class="cov0" title="0">{
                                nsMap[name] = machinePoolResource

                                // Check if this is a new, updated, or unchanged machine pool
                                if oldMachinePool, exists := osMap[name]; !exists </span><span class="cov0" title="0">{
                                        // NEW machine pool - CREATE
                                        log.Printf("[DEBUG] Creating new machine pool %s", name)
                                        machinePool := toMachinePoolAks(machinePoolResource)
                                        if err := c.CreateMachinePoolAks(cloudConfigId, machinePool); err != nil </span><span class="cov0" title="0">{
                                                return diag.FromErr(err)
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        // EXISTING machine pool - check if hash changed
                                        oldHash := resourceMachinePoolAksHash(oldMachinePool)
                                        newHash := resourceMachinePoolAksHash(machinePoolResource)

                                        if oldHash != newHash </span><span class="cov0" title="0">{
                                                // MODIFIED machine pool - UPDATE
                                                log.Printf("[DEBUG] Updating machine pool %s (hash changed: %d -&gt; %d)", name, oldHash, newHash)
                                                machinePool := toMachinePoolAks(machinePoolResource)
                                                if err := c.UpdateMachinePoolAks(cloudConfigId, machinePool); err != nil </span><span class="cov0" title="0">{
                                                        return diag.FromErr(err)
                                                }</span>
                                                // Node Maintenance Actions
                                                <span class="cov0" title="0">err = resourceNodeAction(c, ctx, machinePoolResource, c.GetNodeMaintenanceStatusAks, CloudConfig.Kind, cloudConfigId, name)
                                                if err != nil </span><span class="cov0" title="0">{
                                                        return diag.FromErr(err)
                                                }</span>
                                        } else<span class="cov0" title="0"> {
                                                // UNCHANGED machine pool - no action needed
                                                log.Printf("[DEBUG] Machine pool %s unchanged (hash: %d)", name, oldHash)
                                        }</span>
                                }

                                // Mark as processed
                                <span class="cov0" title="0">delete(osMap, name)</span>
                        } else<span class="cov0" title="0"> {
                                log.Printf("[DEBUG] WARNING: Machine pool has empty name!")
                        }</span>
                }

                // REMOVED machine pools - DELETE
                <span class="cov0" title="0">for name := range osMap </span><span class="cov0" title="0">{
                        log.Printf("[DEBUG] Deleting removed machine pool %s", name)
                        if err := c.DeleteMachinePoolAks(cloudConfigId, name); err != nil </span><span class="cov0" title="0">{
                                return diag.FromErr(err)
                        }</span>
                }
        }

        <span class="cov0" title="0">diagnostics, done := updateCommonFields(d, c)
        if done </span><span class="cov0" title="0">{
                return diagnostics
        }</span>

        <span class="cov0" title="0">resourceClusterAksRead(ctx, d, m)

        return diags</span>
}

func toAksCluster(c *client.V1Client, d *schema.ResourceData) (*models.V1SpectroAzureClusterEntity, error) <span class="cov0" title="0">{
        config := d.Get("cloud_config").([]interface{})
        cloudConfig := config[0]
        cloudConfigMap := cloudConfig.(map[string]interface{})

        // static placement support
        var vnetname string
        if cloudConfigMap["vnet_name"] != nil </span><span class="cov0" title="0">{
                vnetname = cloudConfigMap["vnet_name"].(string)
        }</span>

        <span class="cov0" title="0">var vnetResourceGroup string
        if cloudConfigMap["vnet_resource_group"] != nil </span><span class="cov0" title="0">{
                vnetResourceGroup = cloudConfigMap["vnet_resource_group"].(string)
        }</span>

        <span class="cov0" title="0">var vnetcidr string
        if cloudConfigMap["vnet_cidr_block"] != nil </span><span class="cov0" title="0">{
                vnetcidr = cloudConfigMap["vnet_cidr_block"].(string)
        }</span>

        <span class="cov0" title="0">var workerSubnet *models.V1Subnet
        if cloudConfigMap["worker_subnet_name"] != nil &amp;&amp; cloudConfigMap["worker_cidr"] != nil </span><span class="cov0" title="0">{
                workerSubnet = &amp;models.V1Subnet{
                        Name:              cloudConfigMap["worker_subnet_name"].(string),
                        CidrBlock:         cloudConfigMap["worker_cidr"].(string),
                        SecurityGroupName: cloudConfigMap["worker_subnet_security_group_name"].(string),
                }
        }</span>

        <span class="cov0" title="0">var controlPlaneSubnet *models.V1Subnet
        if cloudConfigMap["control_plane_subnet_name"] != "" &amp;&amp; cloudConfigMap["control_plane_cidr"] != "" </span><span class="cov0" title="0">{
                controlPlaneSubnet = &amp;models.V1Subnet{
                        Name:              cloudConfigMap["control_plane_subnet_name"].(string),
                        CidrBlock:         cloudConfigMap["control_plane_cidr"].(string),
                        SecurityGroupName: cloudConfigMap["control_plane_subnet_security_group_name"].(string),
                }
        }</span>

        <span class="cov0" title="0">clusterContext := d.Get("context").(string)
        profiles, err := toProfiles(c, d, clusterContext)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">cluster := &amp;models.V1SpectroAzureClusterEntity{
                Metadata: getClusterMetadata(d),
                Spec: &amp;models.V1SpectroAzureClusterEntitySpec{
                        CloudAccountUID: types.Ptr(d.Get("cloud_account_id").(string)),
                        Profiles:        profiles,
                        ClusterTemplate: toClusterTemplateReference(d),
                        Policies:        toPolicies(d),
                        CloudConfig: &amp;models.V1AzureClusterConfig{
                                Location:      types.Ptr(cloudConfigMap["region"].(string)),
                                ResourceGroup: cloudConfigMap["resource_group"].(string),
                                SSHKey:        types.Ptr(cloudConfigMap["ssh_key"].(string)),
                                APIServerAccessProfile: &amp;models.V1APIServerAccessProfile{
                                        EnablePrivateCluster: cloudConfigMap["private_cluster"].(bool),
                                },
                                SubscriptionID:     types.Ptr(cloudConfigMap["subscription_id"].(string)),
                                VnetName:           vnetname,
                                VnetResourceGroup:  vnetResourceGroup,
                                VnetCidrBlock:      vnetcidr,
                                ControlPlaneSubnet: controlPlaneSubnet,
                                WorkerSubnet:       workerSubnet,
                        },
                },
        }

        machinePoolConfigs := make([]*models.V1AzureMachinePoolConfigEntity, 0)
        for _, machinePool := range d.Get("machine_pool").(*schema.Set).List() </span><span class="cov0" title="0">{
                mp := toMachinePoolAks(machinePool)
                machinePoolConfigs = append(machinePoolConfigs, mp)
        }</span>
        <span class="cov0" title="0">cluster.Spec.Machinepoolconfig = machinePoolConfigs
        cluster.Spec.ClusterConfig = toClusterConfig(d)

        return cluster, nil</span>
}

func toMachinePoolAks(machinePool interface{}) *models.V1AzureMachinePoolConfigEntity <span class="cov0" title="0">{
        m := machinePool.(map[string]interface{})

        labels := make([]string, 0)
        controlPlane, _ := m["control_plane"].(bool)
        if controlPlane </span><span class="cov0" title="0">{
                labels = append(labels, "control-plane")
        }</span> else<span class="cov0" title="0"> {
                labels = append(labels, "worker")
        }</span>

        <span class="cov0" title="0">min := SafeInt32(m["count"].(int))
        max := SafeInt32(m["count"].(int))

        if m["min"] != nil </span><span class="cov0" title="0">{
                min = SafeInt32(m["min"].(int))
        }</span>

        <span class="cov0" title="0">if m["max"] != nil </span><span class="cov0" title="0">{
                max = SafeInt32(m["max"].(int))
        }</span>

        <span class="cov0" title="0">mp := &amp;models.V1AzureMachinePoolConfigEntity{
                CloudConfig: &amp;models.V1AzureMachinePoolCloudConfigEntity{
                        InstanceType: m["instance_type"].(string),
                        OsDisk: &amp;models.V1AzureOSDisk{
                                DiskSizeGB: SafeInt32(m["disk_size_gb"].(int)),
                                ManagedDisk: &amp;models.V1ManagedDisk{
                                        StorageAccountType: m["storage_account_type"].(string),
                                },
                                OsType: models.NewV1OsType(""), // TODO: PA1-SIVA fix a right type
                        },
                        IsSystemNodePool: m["is_system_node_pool"].(bool),
                },
                ManagedPoolConfig: &amp;models.V1AzureManagedMachinePoolConfig{
                        IsSystemNodePool: m["is_system_node_pool"].(bool),
                },
                PoolConfig: &amp;models.V1MachinePoolConfigEntity{
                        AdditionalLabels:      toAdditionalNodePoolLabels(m),
                        AdditionalAnnotations: toAdditionalNodePoolAnnotations(m),
                        Taints:                toClusterTaints(m),
                        IsControlPlane:        controlPlane,
                        Labels:                labels,
                        Name:                  types.Ptr(m["name"].(string)),
                        Size:                  types.Ptr(SafeInt32(m["count"].(int))),
                        UpdateStrategy:        toUpdateStrategy(m),
                        MinSize:               min,
                        MaxSize:               max,
                },
        }

        // Handle override_kubeadm_configuration (worker pools only)
        if !controlPlane </span><span class="cov0" title="0">{
                if overrideKubeadm, ok := m["override_kubeadm_configuration"].(string); ok &amp;&amp; overrideKubeadm != "" </span><span class="cov0" title="0">{
                        mp.PoolConfig.OverrideKubeadmConfiguration = overrideKubeadm
                }</span>
        }

        <span class="cov0" title="0">return mp</span>
}

func resourceClusterAksStateUpgradeV2(ctx context.Context, rawState map[string]interface{}, meta interface{}) (map[string]interface{}, error) <span class="cov0" title="0">{
        log.Printf("[DEBUG] Upgrading cluster AKS state from version 2 to 3")

        // Convert machine_pool from TypeList to TypeSet
        // Note: We keep the data as a list in rawState and let Terraform's schema processing
        // convert it to TypeSet during normal resource loading. This avoids JSON serialization
        // issues with schema.Set objects that contain hash functions.
        if machinePoolRaw, exists := rawState["machine_pool"]; exists </span><span class="cov0" title="0">{
                if machinePoolList, ok := machinePoolRaw.([]interface{}); ok </span><span class="cov0" title="0">{
                        log.Printf("[DEBUG] Keeping machine_pool as list during state upgrade with %d items", len(machinePoolList))

                        // Keep the machine pool data as-is (as a list)
                        // Terraform will convert it to TypeSet when loading the resource using the schema
                        rawState["machine_pool"] = machinePoolList

                        log.Printf("[DEBUG] Successfully prepared machine_pool for TypeSet conversion")
                }</span> else<span class="cov0" title="0"> {
                        log.Printf("[DEBUG] machine_pool is not a list, skipping conversion")
                }</span>
        } else<span class="cov0" title="0"> {
                log.Printf("[DEBUG] No machine_pool found in state, skipping conversion")
        }</span>

        <span class="cov0" title="0">return rawState, nil</span>
}
</pre>
		
		<pre class="file" id="file125" style="display: none">package spectrocloud

import (
        "context"
        "fmt"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
)

func resourceClusterAksImport(ctx context.Context, d *schema.ResourceData, m interface{}) ([]*schema.ResourceData, error) <span class="cov0" title="0">{
        // m is the client, which can be used to make API requests to the infrastructure
        c, err := GetCommonCluster(d, m)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">diags := resourceClusterAksRead(ctx, d, m)
        if diags.HasError() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("could not read cluster for import: %v", diags)
        }</span>

        // cluster profile and common default cluster attribute is get set here
        <span class="cov0" title="0">err = flattenCommonAttributeForClusterImport(c, d)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Return the resource data. In most cases, this method is only used to
        // import one resource at a time, so you should return the resource data
        // in a slice with a single element.
        <span class="cov0" title="0">return []*schema.ResourceData{d}, nil</span>
}
</pre>
		
		<pre class="file" id="file126" style="display: none">package spectrocloud

import (
        "context"
        "fmt"
        "log"
        "math"
        "sort"
        "strings"
        "time"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
        "github.com/spectrocloud/palette-sdk-go/api/models"
        "github.com/spectrocloud/palette-sdk-go/client"
        "github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/schemas"
        "github.com/spectrocloud/terraform-provider-spectrocloud/types"
)

// safeInt32Conversion safely converts int to int32 with overflow protection
// Returns the converted value and true if conversion is safe, or defaultVal and false if overflow would occur
func safeInt32Conversion(value int, defaultVal int32) int32 <span class="cov0" title="0">{
        if value &lt; math.MinInt32 || value &gt; math.MaxInt32 </span><span class="cov0" title="0">{
                return defaultVal
        }</span>
        <span class="cov0" title="0">return int32(value)</span>
}

func resourceClusterApacheCloudStack() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                CreateContext: resourceClusterApacheCloudStackCreate,
                ReadContext:   resourceClusterApacheCloudStackRead,
                UpdateContext: resourceClusterApacheCloudStackUpdate,
                DeleteContext: resourceClusterDelete,
                Importer: &amp;schema.ResourceImporter{
                        StateContext: resourceClusterApacheCloudStackImport,
                },
                Description: "Resource for managing Apache CloudStack clusters in Spectro Cloud through Palette.",

                Timeouts: &amp;schema.ResourceTimeout{
                        Create: schema.DefaultTimeout(60 * time.Minute),
                        Update: schema.DefaultTimeout(60 * time.Minute),
                        Delete: schema.DefaultTimeout(60 * time.Minute),
                },

                SchemaVersion: 2,
                Schema: map[string]*schema.Schema{
                        "name": {
                                Type:        schema.TypeString,
                                Required:    true,
                                ForceNew:    true,
                                Description: "The name of the cluster.",
                        },
                        "context": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "project",
                                ValidateFunc: validation.StringInSlice([]string{"", "project", "tenant"}, false),
                                Description: "The context of the CloudStack configuration. Allowed values are `project` or `tenant`. " +
                                        "Default is `project`. " + PROJECT_NAME_NUANCE,
                        },
                        "tags": {
                                Type:     schema.TypeSet,
                                Optional: true,
                                Set:      schema.HashString,
                                Elem: &amp;schema.Schema{
                                        Type: schema.TypeString,
                                },
                                Description: "A list of tags to be applied to the cluster. Tags must be in the form of `key:value`.",
                        },
                        "description": {
                                Type:        schema.TypeString,
                                Optional:    true,
                                Default:     "",
                                Description: "The description of the cluster. Default value is empty string.",
                        },
                        "cluster_meta_attribute": {
                                Type:        schema.TypeString,
                                Optional:    true,
                                Description: "`cluster_meta_attribute` can be used to set additional cluster metadata information, eg `{'nic_name': 'test', 'env': 'stage'}`",
                        },
                        "cluster_profile":  schemas.ClusterProfileSchema(),
                        "cluster_template": schemas.ClusterTemplateSchema(),
                        "apply_setting": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "DownloadAndInstall",
                                ValidateFunc: validation.StringInSlice([]string{"DownloadAndInstall", "DownloadAndInstallLater"}, false),
                                Description: "The setting to apply the cluster profile. `DownloadAndInstall` will download and install packs in one action. " +
                                        "`DownloadAndInstallLater` will only download artifact and postpone install for later. " +
                                        "Default value is `DownloadAndInstall`.",
                        },
                        "cloud_account_id": {
                                Type:        schema.TypeString,
                                Required:    true,
                                ForceNew:    true,
                                Description: "ID of the CloudStack cloud account used for the cluster. This cloud account must be of type `cloudstack`.",
                        },
                        "cloud_config_id": {
                                Type:        schema.TypeString,
                                Computed:    true,
                                Description: "ID of the cloud config used for the cluster. This cloud config must be of type `cloudstack`.",
                                Deprecated:  "This field is deprecated and will be removed in the future. Use `cloud_config` instead.",
                        },
                        "review_repave_state": {
                                Type:         schema.TypeString,
                                Default:      "",
                                Optional:     true,
                                ValidateFunc: validateReviewRepaveValue,
                                Description:  "To authorize the cluster repave, set the value to `Approved` for approval and `\"\"` to decline. Default value is `\"\"`.",
                        },
                        "pause_agent_upgrades": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "unlock",
                                ValidateFunc: validation.StringInSlice([]string{"lock", "unlock"}, false),
                                Description:  "The pause agent upgrades setting allows to control the automatic upgrade of the Palette component and agent for an individual cluster. The default value is `unlock`, meaning upgrades occur automatically. Setting it to `lock` pauses automatic agent upgrades for the cluster.",
                        },
                        "os_patch_on_boot": {
                                Type:        schema.TypeBool,
                                Optional:    true,
                                Default:     false,
                                Description: "Whether to apply OS patch on boot. Default is `false`.",
                        },
                        "os_patch_schedule": {
                                Type:             schema.TypeString,
                                Optional:         true,
                                ValidateDiagFunc: validateOsPatchSchedule,
                                Description:      "Cron schedule for OS patching. This must be in the form of `0 0 * * *`.",
                        },
                        "os_patch_after": {
                                Type:             schema.TypeString,
                                Optional:         true,
                                ValidateDiagFunc: validateOsPatchOnDemandAfter,
                                Description:      "The date and time after which to patch the cluster. Prefix the time value with the respective RFC. Ex: `RFC3339: 2006-01-02T15:04:05Z07:00`",
                        },
                        "cluster_timezone": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "",
                                ValidateFunc: validateTimezone,
                                Description:  "Defines the time zone used by this cluster to interpret scheduled operations. Maintenance tasks like upgrades will follow this time zone to ensure they run at the appropriate local time for the cluster. Must be in IANA timezone format (e.g., 'America/New_York', 'Asia/Kolkata', 'Europe/London').",
                        },
                        "update_worker_pools_in_parallel": {
                                Type:        schema.TypeBool,
                                Optional:    true,
                                Default:     false,
                                Description: "Controls whether worker pool updates occur in parallel or sequentially. When set to `true`, all worker pools are updated simultaneously. When `false` (default), worker pools are updated one at a time, reducing cluster disruption but taking longer to complete updates.",
                        },
                        "kubeconfig": {
                                Type:        schema.TypeString,
                                Computed:    true,
                                Description: "Kubeconfig for the cluster. This can be used to connect to the cluster using `kubectl`.",
                        },
                        "admin_kube_config": {
                                Type:        schema.TypeString,
                                Computed:    true,
                                Description: "Admin Kube-config for the cluster. This can be used to connect to the cluster using `kubectl`, With admin privilege.",
                        },
                        "cloud_config": {
                                Type:     schema.TypeList,
                                Required: true,
                                MaxItems: 1,
                                Elem: &amp;schema.Resource{
                                        Schema: map[string]*schema.Schema{
                                                "project": {
                                                        Type:        schema.TypeList,
                                                        Optional:    true,
                                                        MaxItems:    1,
                                                        Description: "CloudStack project configuration (optional). If not specified, the cluster will be created in the domain's default project.",
                                                        Elem: &amp;schema.Resource{
                                                                Schema: map[string]*schema.Schema{
                                                                        "id": {
                                                                                Type:        schema.TypeString,
                                                                                Optional:    true,
                                                                                Description: "CloudStack project ID.",
                                                                        },
                                                                        "name": {
                                                                                Type:        schema.TypeString,
                                                                                Optional:    true,
                                                                                Description: "CloudStack project name.",
                                                                        },
                                                                },
                                                        },
                                                },
                                                "ssh_key_name": {
                                                        Type:        schema.TypeString,
                                                        Optional:    true,
                                                        Description: "SSH key name for accessing cluster nodes.",
                                                },
                                                "control_plane_endpoint": {
                                                        Type:        schema.TypeString,
                                                        Optional:    true,
                                                        Description: "Endpoint IP to be used for the API server. Should only be set for static CloudStack networks.",
                                                },
                                                "sync_with_cks": {
                                                        Type:        schema.TypeBool,
                                                        Optional:    true,
                                                        Default:     false,
                                                        Description: "Determines if an external managed CKS (CloudStack Kubernetes Service) cluster should be created. Default is `false`.",
                                                },
                                                "zone": {
                                                        Type:     schema.TypeList,
                                                        Required: true,
                                                        MinItems: 1,
                                                        Elem: &amp;schema.Resource{
                                                                Schema: map[string]*schema.Schema{
                                                                        "id": {
                                                                                Type:        schema.TypeString,
                                                                                Optional:    true,
                                                                                Description: "CloudStack zone ID. Either `id` or `name` can be used to identify the zone. If both are specified, `id` takes precedence.",
                                                                        },
                                                                        "name": {
                                                                                Type:        schema.TypeString,
                                                                                Required:    true,
                                                                                Description: "CloudStack zone name where the cluster will be deployed.",
                                                                        },
                                                                        "network": {
                                                                                Type:     schema.TypeList,
                                                                                Optional: true,
                                                                                MaxItems: 1,
                                                                                Elem: &amp;schema.Resource{
                                                                                        Schema: map[string]*schema.Schema{
                                                                                                "id": {
                                                                                                        Type:        schema.TypeString,
                                                                                                        Optional:    true,
                                                                                                        Description: "Network ID in CloudStack. Either `id` or `name` can be used to identify the network. If both are specified, `id` takes precedence.",
                                                                                                },
                                                                                                "name": {
                                                                                                        Type:        schema.TypeString,
                                                                                                        Required:    true,
                                                                                                        Description: "Network name in this zone.",
                                                                                                },
                                                                                                "type": {
                                                                                                        Type:        schema.TypeString,
                                                                                                        Optional:    true,
                                                                                                        Description: "Network type: Isolated, Shared, etc.",
                                                                                                },
                                                                                                "gateway": {
                                                                                                        Type:        schema.TypeString,
                                                                                                        Optional:    true,
                                                                                                        Description: "Gateway IP address for the network.",
                                                                                                },
                                                                                                "netmask": {
                                                                                                        Type:        schema.TypeString,
                                                                                                        Optional:    true,
                                                                                                        Description: "Network mask for the network.",
                                                                                                },
                                                                                                "offering": {
                                                                                                        Type:        schema.TypeString,
                                                                                                        Optional:    true,
                                                                                                        Description: "Network offering name to use when creating the network. Optional for advanced network configurations.",
                                                                                                },
                                                                                                "routing_mode": {
                                                                                                        Type:        schema.TypeString,
                                                                                                        Optional:    true,
                                                                                                        Description: "Routing mode for the network (e.g., Static, Dynamic). Optional, defaults to CloudStack's default routing mode.",
                                                                                                },
                                                                                                "vpc": {
                                                                                                        Type:     schema.TypeList,
                                                                                                        Optional: true,
                                                                                                        MaxItems: 1,
                                                                                                        Elem: &amp;schema.Resource{
                                                                                                                Schema: map[string]*schema.Schema{
                                                                                                                        "id": {
                                                                                                                                Type:        schema.TypeString,
                                                                                                                                Optional:    true,
                                                                                                                                Description: "VPC ID. Either `id` or `name` can be used to identify the VPC. If both are specified, `id` takes precedence.",
                                                                                                                        },
                                                                                                                        "name": {
                                                                                                                                Type:        schema.TypeString,
                                                                                                                                Required:    true,
                                                                                                                                Description: "VPC name.",
                                                                                                                        },
                                                                                                                        "cidr": {
                                                                                                                                Type:        schema.TypeString,
                                                                                                                                Optional:    true,
                                                                                                                                Description: "CIDR block for the VPC (e.g., 10.0.0.0/16).",
                                                                                                                        },
                                                                                                                        "offering": {
                                                                                                                                Type:        schema.TypeString,
                                                                                                                                Optional:    true,
                                                                                                                                Description: "VPC offering name.",
                                                                                                                        },
                                                                                                                },
                                                                                                        },
                                                                                                        Description: "VPC configuration for VPC-based network deployments. Optional, only needed when deploying in a VPC.",
                                                                                                },
                                                                                        },
                                                                                },
                                                                                Description: "Network configuration for this zone.",
                                                                        },
                                                                },
                                                        },
                                                        Description: "List of CloudStack zones for multi-AZ deployments. If only one zone is specified, it will be treated as single-zone deployment.",
                                                },
                                        },
                                },
                                Description: "CloudStack cluster configuration.",
                        },
                        "machine_pool": {
                                Type:     schema.TypeSet,
                                Required: true,
                                Set:      resourceMachinePoolApacheCloudStackHash,
                                Elem: &amp;schema.Resource{
                                        Schema: map[string]*schema.Schema{
                                                "additional_labels": {
                                                        Type:     schema.TypeMap,
                                                        Optional: true,
                                                        Elem: &amp;schema.Schema{
                                                                Type: schema.TypeString,
                                                        },
                                                        Description: "Additional labels to be applied to the machine pool. Labels must be in the form of `key:value`.",
                                                },
                                                "additional_annotations": {
                                                        Type:     schema.TypeMap,
                                                        Optional: true,
                                                        Elem: &amp;schema.Schema{
                                                                Type: schema.TypeString,
                                                        },
                                                        Description: "Additional annotation to be applied to the machine pool. annotation must be in the form of `key:value`.",
                                                },
                                                "node":   schemas.NodeSchema(),
                                                "taints": schemas.ClusterTaintsSchema(),
                                                "control_plane": {
                                                        Type:        schema.TypeBool,
                                                        Optional:    true,
                                                        Default:     false,
                                                        Description: "Whether this machine pool is a control plane. Defaults to `false`.",
                                                },
                                                "control_plane_as_worker": {
                                                        Type:        schema.TypeBool,
                                                        Optional:    true,
                                                        Default:     false,
                                                        Description: "Whether this machine pool is a control plane and a worker. Defaults to `false`.",
                                                },
                                                "name": {
                                                        Type:        schema.TypeString,
                                                        Required:    true,
                                                        Description: "Name of the machine pool.",
                                                },
                                                "count": {
                                                        Type:        schema.TypeInt,
                                                        Required:    true,
                                                        Description: "Number of nodes in the machine pool.",
                                                },
                                                "node_repave_interval": {
                                                        Type:        schema.TypeInt,
                                                        Optional:    true,
                                                        Default:     0,
                                                        Description: "Minimum number of seconds node should be Ready, before the next node is selected for repave. Default value is `0`, Applicable only for worker pools.",
                                                },
                                                "update_strategy": {
                                                        Type:         schema.TypeString,
                                                        Optional:     true,
                                                        Default:      "RollingUpdateScaleOut",
                                                        Description:  "Update strategy for the machine pool. Valid values are `RollingUpdateScaleOut`, `RollingUpdateScaleIn` and `OverrideScaling`. If `OverrideScaling` is used, `override_scaling` must be specified with both `max_surge` and `max_unavailable`.",
                                                        ValidateFunc: validation.StringInSlice([]string{"RollingUpdateScaleOut", "RollingUpdateScaleIn", "OverrideScaling"}, false),
                                                },
                                                "override_scaling": schemas.OverrideScalingSchema(),
                                                "override_kubeadm_configuration": {
                                                        Type:        schema.TypeString,
                                                        Optional:    true,
                                                        Description: "YAML config for kubeletExtraArgs, preKubeadmCommands, postKubeadmCommands. Overrides pack-level settings. Worker pools only.",
                                                },
                                                "min": {
                                                        Type:        schema.TypeInt,
                                                        Optional:    true,
                                                        Description: "Minimum number of nodes in the machine pool. This is used for autoscaling.",
                                                },
                                                "max": {
                                                        Type:        schema.TypeInt,
                                                        Optional:    true,
                                                        Description: "Maximum number of nodes in the machine pool. This is used for autoscaling.",
                                                },
                                                "offering": {
                                                        Type:        schema.TypeString,
                                                        Required:    true,
                                                        Description: "Apache CloudStack compute offering (instance type/size) name.",
                                                },
                                                "instance_config": {
                                                        Type:        schema.TypeList,
                                                        Computed:    true,
                                                        Description: "Instance configuration details returned by the CloudStack API. This is a computed field based on the selected offering.",
                                                        Elem: &amp;schema.Resource{
                                                                Schema: map[string]*schema.Schema{
                                                                        "disk_gib": {
                                                                                Type:        schema.TypeInt,
                                                                                Computed:    true,
                                                                                Description: "Root disk size in GiB.",
                                                                        },
                                                                        "memory_mib": {
                                                                                Type:        schema.TypeInt,
                                                                                Computed:    true,
                                                                                Description: "Memory size in MiB.",
                                                                        },
                                                                        "num_cpus": {
                                                                                Type:        schema.TypeInt,
                                                                                Computed:    true,
                                                                                Description: "Number of CPUs for the instance.",
                                                                        },
                                                                        "cpu_set": {
                                                                                Type:        schema.TypeInt,
                                                                                Computed:    true,
                                                                                Description: "CPU set for the instance.",
                                                                        },
                                                                        "name": {
                                                                                Type:        schema.TypeString,
                                                                                Computed:    true,
                                                                                Description: "Name for the instance configuration.",
                                                                        },
                                                                        "category": {
                                                                                Type:        schema.TypeString,
                                                                                Computed:    true,
                                                                                Description: "Category for the instance configuration.",
                                                                        },
                                                                },
                                                        },
                                                },
                                                "template": {
                                                        Type:        schema.TypeList,
                                                        Optional:    true,
                                                        MaxItems:    1,
                                                        Description: "Apache CloudStack template override for this machine pool. If not specified, inherits cluster default.",
                                                        Elem: &amp;schema.Resource{
                                                                Schema: map[string]*schema.Schema{
                                                                        "id": {
                                                                                Type:        schema.TypeString,
                                                                                Optional:    true,
                                                                                Description: "Template ID. Either ID or name must be provided.",
                                                                        },
                                                                        "name": {
                                                                                Type:        schema.TypeString,
                                                                                Optional:    true,
                                                                                Description: "Template name. Either ID or name must be provided.",
                                                                        },
                                                                },
                                                        },
                                                },
                                                "network": {
                                                        Type:     schema.TypeList,
                                                        Optional: true,
                                                        Elem: &amp;schema.Resource{
                                                                Schema: map[string]*schema.Schema{
                                                                        "network_name": {
                                                                                Type:        schema.TypeString,
                                                                                Required:    true,
                                                                                Description: "Network name to attach to the machine pool.",
                                                                        },
                                                                        "ip_address": {
                                                                                Type:        schema.TypeString,
                                                                                Optional:    true,
                                                                                Deprecated:  "This field is no longer supported by the CloudStack API and will be ignored.",
                                                                                Description: "Static IP address to assign. **DEPRECATED**: This field is no longer supported by CloudStack and will be ignored.",
                                                                        },
                                                                },
                                                        },
                                                        Description: "Network configuration for the machine pool instances.",
                                                },
                                        },
                                },
                                Description: "Machine pool configuration for the cluster.",
                        },
                        "backup_policy":        schemas.BackupPolicySchema(),
                        "scan_policy":          schemas.ScanPolicySchema(),
                        "cluster_rbac_binding": schemas.ClusterRbacBindingSchema(),
                        "namespaces":           schemas.ClusterNamespacesSchema(),
                        "host_config":          schemas.ClusterHostConfigSchema(),
                        "location_config":      schemas.ClusterLocationSchemaComputed(),
                        "skip_completion": {
                                Type:        schema.TypeBool,
                                Optional:    true,
                                Default:     false,
                                Description: "If `true`, the cluster will be created asynchronously. Default value is `false`.",
                        },
                        "force_delete": {
                                Type:        schema.TypeBool,
                                Optional:    true,
                                Default:     false,
                                Description: "If set to `true`, the cluster will be force deleted and user has to manually clean up the provisioned cloud resources.",
                        },
                        "force_delete_delay": {
                                Type:             schema.TypeInt,
                                Optional:         true,
                                Default:          20,
                                Description:      "Delay duration in minutes to before invoking cluster force delete. Default and minimum is 20.",
                                ValidateDiagFunc: validation.ToDiagFunc(validation.IntAtLeast(20)),
                        },
                },
        }
}</span>

func resourceClusterApacheCloudStackCreate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        c := getV1ClientWithResourceContext(m, "")
        var diags diag.Diagnostics

        // Validate override_Scaling configuration
        if err := validateOverrideScaling(d, "machine_pool"); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">cluster, err := toCloudStackCluster(c, d)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">ClusterContext := d.Get("context").(string)
        if ClusterContext == "" </span><span class="cov0" title="0">{
                ClusterContext = "project"
        }</span>
        <span class="cov0" title="0">c = getV1ClientWithResourceContext(m, ClusterContext)
        uid, err := c.CreateClusterCloudStack(cluster)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">diags, done := waitForClusterCreation(ctx, d, uid, diags, c, false)
        if done </span><span class="cov0" title="0">{
                return diags
        }</span>

        <span class="cov0" title="0">resourceClusterApacheCloudStackRead(ctx, d, m)

        return diags</span>
}

func resourceClusterApacheCloudStackRead(_ context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        resourceContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, resourceContext)
        var diags diag.Diagnostics

        cluster, err := c.GetCluster(d.Id())
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span> else<span class="cov0" title="0"> if cluster == nil </span><span class="cov0" title="0">{
                // Deleted - Terraform will recreate it
                d.SetId("")
                return diags
        }</span>

        // Verify cluster type
        <span class="cov0" title="0">err = ValidateCloudType("spectrocloud_cluster_apache_cloudstack", cluster)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">diagnostics, done := readCommonFields(c, d, cluster)
        if done </span><span class="cov0" title="0">{
                return diagnostics
        }</span>

        // Flatten cluster_template variables using variables API
        <span class="cov0" title="0">if err := flattenClusterTemplateVariables(c, d, d.Id()); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">return flattenCloudConfigApacheCloudStack(cluster.Spec.CloudConfigRef.UID, d, c)</span>
}

func resourceClusterApacheCloudStackUpdate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        var diags diag.Diagnostics

        cloudConfigId := d.Get("cloud_config_id").(string)
        ClusterContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, ClusterContext)

        if err := validateSystemRepaveApproval(d, c); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">if d.HasChange("machine_pool") </span><span class="cov0" title="0">{
                // Validate override_Scaling configuration
                if err := validateOverrideScaling(d, "machine_pool"); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>

                <span class="cov0" title="0">if err := updateMachinePoolCloudStack(ctx, c, d, cloudConfigId); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
        }

        // Check common updates
        <span class="cov0" title="0">diagnostics, done := updateCommonFields(d, c)
        if done </span><span class="cov0" title="0">{
                return diagnostics
        }</span>

        <span class="cov0" title="0">resourceClusterApacheCloudStackRead(ctx, d, m)

        return diags</span>
}

func toCloudStackCluster(c *client.V1Client, d *schema.ResourceData) (*models.V1SpectroCloudStackClusterEntity, error) <span class="cov0" title="0">{
        cloudConfig := toCloudStackCloudConfig(d)

        clusterContext := d.Get("context").(string)
        profiles, err := toProfiles(c, d, clusterContext)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Convert metadata to input entity type
        <span class="cov0" title="0">metadata := getClusterMetadata(d)
        cluster := &amp;models.V1SpectroCloudStackClusterEntity{
                Metadata: &amp;models.V1ObjectMetaInputEntity{
                        Name:        metadata.Name,
                        Labels:      metadata.Labels,
                        Annotations: metadata.Annotations,
                },
                Spec: &amp;models.V1SpectroCloudStackClusterEntitySpec{
                        CloudAccountUID: types.Ptr(d.Get("cloud_account_id").(string)),
                        Profiles:        profiles,
                        Policies:        toPolicies(d),
                        CloudConfig:     cloudConfig,
                },
        }

        machinePoolConfigs := make([]*models.V1CloudStackMachinePoolConfigEntity, 0)
        for _, machinePool := range d.Get("machine_pool").(*schema.Set).List() </span><span class="cov0" title="0">{
                mp, err := toMachinePoolCloudStack(machinePool)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">machinePoolConfigs = append(machinePoolConfigs, mp)</span>
        }
        <span class="cov0" title="0">cluster.Spec.Machinepoolconfig = machinePoolConfigs
        cluster.Spec.ClusterConfig = toClusterConfig(d)

        return cluster, nil</span>
}

func toCloudStackCloudConfig(d *schema.ResourceData) *models.V1CloudStackClusterConfig <span class="cov0" title="0">{
        cloudConfig := d.Get("cloud_config").([]interface{})[0].(map[string]interface{})

        config := &amp;models.V1CloudStackClusterConfig{
                SSHKeyName:           cloudConfig["ssh_key_name"].(string),
                ControlPlaneEndpoint: cloudConfig["control_plane_endpoint"].(string),
                SyncWithCKS:          cloudConfig["sync_with_cks"].(bool),
        }

        // Process project if specified
        if projects, ok := cloudConfig["project"].([]interface{}); ok &amp;&amp; len(projects) &gt; 0 </span><span class="cov0" title="0">{
                project := projects[0].(map[string]interface{})
                config.Project = &amp;models.V1CloudStackResource{
                        ID:   project["id"].(string),
                        Name: project["name"].(string),
                }
        }</span>

        // Process zones
        <span class="cov0" title="0">if zones, ok := cloudConfig["zone"].([]interface{}); ok &amp;&amp; len(zones) &gt; 0 </span><span class="cov0" title="0">{
                config.Zones = make([]*models.V1CloudStackZoneSpec, 0, len(zones))
                for _, z := range zones </span><span class="cov0" title="0">{
                        zone := z.(map[string]interface{})
                        zoneSpec := &amp;models.V1CloudStackZoneSpec{
                                ID:   zone["id"].(string),
                                Name: zone["name"].(string),
                        }

                        // Process network configuration for the zone
                        if networks, ok := zone["network"].([]interface{}); ok &amp;&amp; len(networks) &gt; 0 </span><span class="cov0" title="0">{
                                network := networks[0].(map[string]interface{})
                                zoneSpec.Network = &amp;models.V1CloudStackNetworkSpec{
                                        ID:          network["id"].(string),
                                        Name:        network["name"].(string),
                                        Type:        network["type"].(string),
                                        Gateway:     network["gateway"].(string),
                                        Netmask:     network["netmask"].(string),
                                        Offering:    network["offering"].(string),
                                        RoutingMode: network["routing_mode"].(string),
                                }

                                // Process VPC configuration if present
                                if vpcs, ok := network["vpc"].([]interface{}); ok &amp;&amp; len(vpcs) &gt; 0 </span><span class="cov0" title="0">{
                                        vpc := vpcs[0].(map[string]interface{})
                                        zoneSpec.Network.Vpc = &amp;models.V1CloudStackVPCSpec{
                                                ID:       vpc["id"].(string),
                                                Name:     vpc["name"].(string),
                                                Cidr:     vpc["cidr"].(string),
                                                Offering: vpc["offering"].(string),
                                        }
                                }</span>
                        }

                        <span class="cov0" title="0">config.Zones = append(config.Zones, zoneSpec)</span>
                }
        }

        <span class="cov0" title="0">return config</span>
}

func toMachinePoolCloudStack(machinePool interface{}) (*models.V1CloudStackMachinePoolConfigEntity, error) <span class="cov0" title="0">{
        mp := machinePool.(map[string]interface{})

        labels := make([]string, 0)
        controlPlane := mp["control_plane"].(bool)
        controlPlaneAsWorker := mp["control_plane_as_worker"].(bool)
        if controlPlane </span><span class="cov0" title="0">{
                labels = append(labels, "control-plane")
        }</span>

        <span class="cov0" title="0">cloudConfig := &amp;models.V1CloudStackMachinePoolCloudConfigEntity{
                Offering: &amp;models.V1CloudStackResource{
                        Name: mp["offering"].(string),
                },
        }

        // Note: instance_config is computed (returned by API based on offering) - not sent in requests

        // Process template (RE-ADDED in new SDK)
        if templates, ok := mp["template"].([]interface{}); ok &amp;&amp; len(templates) &gt; 0 </span><span class="cov0" title="0">{
                tmpl := templates[0].(map[string]interface{})
                cloudConfig.Template = &amp;models.V1CloudStackResource{}
                if id, ok := tmpl["id"].(string); ok &amp;&amp; id != "" </span><span class="cov0" title="0">{
                        cloudConfig.Template.ID = id
                }</span>
                <span class="cov0" title="0">if name, ok := tmpl["name"].(string); ok &amp;&amp; name != "" </span><span class="cov0" title="0">{
                        cloudConfig.Template.Name = name
                }</span>
        }

        // NOTE: RootDiskSizeGB, DiskOffering, AffinityGroupIds, and Details have been REMOVED from the new SDK model

        // Process networks
        <span class="cov0" title="0">if networks, ok := mp["network"].([]interface{}); ok &amp;&amp; len(networks) &gt; 0 </span><span class="cov0" title="0">{
                cloudConfig.Networks = make([]*models.V1CloudStackNetworkConfig, 0, len(networks))
                for _, n := range networks </span><span class="cov0" title="0">{
                        network := n.(map[string]interface{})
                        netConfig := &amp;models.V1CloudStackNetworkConfig{
                                Name: network["network_name"].(string),
                                // Note: IP address assignment moved to different level in new SDK
                        }
                        cloudConfig.Networks = append(cloudConfig.Networks, netConfig)
                }</span>
        }

        <span class="cov0" title="0">poolConfig := &amp;models.V1MachinePoolConfigEntity{
                AdditionalLabels:        toAdditionalNodePoolLabels(mp),
                AdditionalAnnotations:   toAdditionalNodePoolAnnotations(mp),
                Taints:                  toClusterTaints(mp),
                IsControlPlane:          controlPlane,
                Labels:                  labels,
                Name:                    types.Ptr(mp["name"].(string)),
                Size:                    types.Ptr(safeInt32Conversion(mp["count"].(int), 1)),
                UpdateStrategy:          toUpdateStrategy(mp),
                UseControlPlaneAsWorker: controlPlaneAsWorker,
        }

        // Handle override_kubeadm_configuration (worker pools only)
        if !controlPlane </span><span class="cov0" title="0">{
                if overrideKubeadm, ok := mp["override_kubeadm_configuration"].(string); ok &amp;&amp; overrideKubeadm != "" </span><span class="cov0" title="0">{
                        poolConfig.OverrideKubeadmConfiguration = overrideKubeadm
                }</span>
        }

        // Safe conversion for min size
        <span class="cov0" title="0">if mp["min"] != nil </span><span class="cov0" title="0">{
                minSize := mp["min"].(int)
                if minSize &gt; 0 </span><span class="cov0" title="0">{
                        poolConfig.MinSize = safeInt32Conversion(minSize, 0)
                }</span>
        }

        // Safe conversion for max size
        <span class="cov0" title="0">if mp["max"] != nil </span><span class="cov0" title="0">{
                maxSize := mp["max"].(int)
                if maxSize &gt; 0 </span><span class="cov0" title="0">{
                        poolConfig.MaxSize = safeInt32Conversion(maxSize, 0)
                }</span>
        }

        // Handle node_repave_interval
        <span class="cov0" title="0">if !controlPlane </span><span class="cov0" title="0">{
                nodeRepaveInterval := 0
                if mp["node_repave_interval"] != nil </span><span class="cov0" title="0">{
                        nodeRepaveInterval = mp["node_repave_interval"].(int)
                }</span>
                <span class="cov0" title="0">poolConfig.NodeRepaveInterval = SafeInt32(nodeRepaveInterval)</span>
        } else<span class="cov0" title="0"> {
                err := ValidationNodeRepaveIntervalForControlPlane(mp["node_repave_interval"].(int))
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">mpEntity := &amp;models.V1CloudStackMachinePoolConfigEntity{
                CloudConfig: cloudConfig,
                PoolConfig:  poolConfig,
        }

        return mpEntity, nil</span>
}

func resourceMachinePoolApacheCloudStackHash(v interface{}) int <span class="cov0" title="0">{
        m := v.(map[string]interface{})
        buf := CommonHash(m)

        if _, ok := m["additional_annotations"]; ok </span><span class="cov0" title="0">{
                buf.WriteString(HashStringMap(m["additional_annotations"]))
        }</span>

        // Add CloudStack-specific fields
        <span class="cov0" title="0">if val, ok := m["offering"]; ok </span><span class="cov0" title="0">{
                fmt.Fprintf(buf, "%s-", val.(string))
        }</span>

        // Hash override_kubeadm_configuration
        <span class="cov0" title="0">if val, ok := m["override_kubeadm_configuration"].(string); ok &amp;&amp; val != "" </span><span class="cov0" title="0">{
                fmt.Fprintf(buf, "%s-", val)
        }</span>

        // Hash override_scaling
        <span class="cov0" title="0">if overrideScaling, ok := m["override_scaling"].([]interface{}); ok &amp;&amp; len(overrideScaling) &gt; 0 </span><span class="cov0" title="0">{
                scalingConfig := overrideScaling[0].(map[string]interface{})
                if maxSurge, ok := scalingConfig["max_surge"].(string); ok &amp;&amp; maxSurge != "" </span><span class="cov0" title="0">{
                        fmt.Fprintf(buf, "max_surge:%s-", maxSurge)
                }</span>
                <span class="cov0" title="0">if maxUnavailable, ok := scalingConfig["max_unavailable"].(string); ok &amp;&amp; maxUnavailable != "" </span><span class="cov0" title="0">{
                        fmt.Fprintf(buf, "max_unavailable:%s-", maxUnavailable)
                }</span>
        }

        // Note: instance_config is computed and excluded from hash to prevent false change detection

        // Hash template
        <span class="cov0" title="0">if templateList, ok := m["template"].([]interface{}); ok &amp;&amp; len(templateList) &gt; 0 </span><span class="cov0" title="0">{
                tmpl := templateList[0].(map[string]interface{})
                if val, ok := tmpl["id"]; ok </span><span class="cov0" title="0">{
                        fmt.Fprintf(buf, "%s-", val.(string))
                }</span>
                <span class="cov0" title="0">if val, ok := tmpl["name"]; ok </span><span class="cov0" title="0">{
                        fmt.Fprintf(buf, "%s-", val.(string))
                }</span>
        }

        // Hash networks
        <span class="cov0" title="0">if networksList, ok := m["network"].([]interface{}); ok &amp;&amp; len(networksList) &gt; 0 </span><span class="cov0" title="0">{
                var networkNames []string
                for _, n := range networksList </span><span class="cov0" title="0">{
                        network := n.(map[string]interface{})
                        if val, ok := network["network_name"]; ok </span><span class="cov0" title="0">{
                                networkNames = append(networkNames, val.(string))
                        }</span>
                }
                <span class="cov0" title="0">sort.Strings(networkNames)
                buf.WriteString(strings.Join(networkNames, "-"))</span>
        }

        <span class="cov0" title="0">return int(hash(buf.String()))</span>
}

func updateMachinePoolCloudStack(ctx context.Context, c *client.V1Client, d *schema.ResourceData, cloudConfigId string) error <span class="cov0" title="0">{
        log.Printf("[DEBUG] === MACHINE POOL CHANGE DETECTED ===")

        old, new := d.GetChange("machine_pool")
        oldMachinePools := old.(*schema.Set)
        newMachinePools := new.(*schema.Set)

        log.Printf("[DEBUG] Old machine pools count: %d, New machine pools count: %d", oldMachinePools.Len(), newMachinePools.Len())

        // Create maps by machine pool name for proper comparison
        osMap := make(map[string]interface{})
        for _, mp := range oldMachinePools.List() </span><span class="cov0" title="0">{
                machinePoolResource := mp.(map[string]interface{})
                name := machinePoolResource["name"].(string)
                if name != "" </span><span class="cov0" title="0">{
                        osMap[name] = machinePoolResource
                }</span>
        }

        <span class="cov0" title="0">nsMap := make(map[string]interface{})
        for _, mp := range newMachinePools.List() </span><span class="cov0" title="0">{
                machinePoolResource := mp.(map[string]interface{})
                name := machinePoolResource["name"].(string)
                if name != "" </span><span class="cov0" title="0">{
                        nsMap[name] = machinePoolResource

                        // Check if this is a new, updated, or unchanged machine pool
                        if oldMachinePool, exists := osMap[name]; !exists </span><span class="cov0" title="0">{
                                // NEW machine pool - CREATE
                                log.Printf("[DEBUG] Creating new machine pool %s", name)
                                machinePool, err := toMachinePoolCloudStack(machinePoolResource)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov0" title="0">if err := c.CreateMachinePoolCloudStack(cloudConfigId, machinePool); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        } else<span class="cov0" title="0"> {
                                // EXISTING machine pool - check if hash changed
                                oldHash := resourceMachinePoolApacheCloudStackHash(oldMachinePool)
                                newHash := resourceMachinePoolApacheCloudStackHash(machinePoolResource)

                                if oldHash != newHash </span><span class="cov0" title="0">{
                                        // MODIFIED machine pool - UPDATE
                                        log.Printf("[DEBUG] Updating machine pool %s (hash changed: %d -&gt; %d)", name, oldHash, newHash)
                                        machinePool, err := toMachinePoolCloudStack(machinePoolResource)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return err
                                        }</span>
                                        <span class="cov0" title="0">if err := c.UpdateMachinePoolCloudStack(cloudConfigId, machinePool); err != nil </span><span class="cov0" title="0">{
                                                return err
                                        }</span>
                                        // Note: Node maintenance actions are not supported for CloudStack clusters
                                } else<span class="cov0" title="0"> {
                                        // UNCHANGED machine pool - no action needed
                                        log.Printf("[DEBUG] Machine pool %s unchanged (hash: %d)", name, oldHash)
                                }</span>
                        }

                        // Mark as processed
                        <span class="cov0" title="0">delete(osMap, name)</span>
                } else<span class="cov0" title="0"> {
                        log.Printf("[DEBUG] WARNING: Machine pool has empty name!")
                }</span>
        }

        // REMOVED machine pools - DELETE
        <span class="cov0" title="0">for name := range osMap </span><span class="cov0" title="0">{
                log.Printf("[DEBUG] Deleting removed machine pool %s", name)
                if err := c.DeleteMachinePoolCloudStack(cloudConfigId, name); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func resourceClusterApacheCloudStackImport(ctx context.Context, d *schema.ResourceData, m interface{}) ([]*schema.ResourceData, error) <span class="cov0" title="0">{
        c, err := GetCommonCluster(d, m)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">diags := resourceClusterApacheCloudStackRead(ctx, d, m)
        if diags.HasError() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("could not read cluster for import: %v", diags)
        }</span>

        // cluster profile and common default cluster attribute is get set here
        <span class="cov0" title="0">err = flattenCommonAttributeForClusterImport(c, d)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return []*schema.ResourceData{d}, nil</span>
}

func flattenCloudConfigApacheCloudStack(configUID string, d *schema.ResourceData, c *client.V1Client) diag.Diagnostics <span class="cov0" title="0">{
        var diags diag.Diagnostics
        if err := d.Set("cloud_config_id", configUID); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">if err := ReadCommonAttributes(d); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">config, err := c.GetCloudConfigCloudStack(configUID)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">if config.Spec != nil &amp;&amp; config.Spec.CloudAccountRef != nil </span><span class="cov0" title="0">{
                if err := d.Set("cloud_account_id", config.Spec.CloudAccountRef.UID); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
        }

        <span class="cov0" title="0">if err := d.Set("cloud_config", flattenClusterConfigsApacheCloudStack(config)); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">mp := flattenMachinePoolConfigsApacheCloudStack(config.Spec.MachinePoolConfig)
        mp, err = flattenNodeMaintenanceStatus(c, d, c.GetNodeStatusMapCloudStack, mp, configUID)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">if err := d.Set("machine_pool", mp); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">generalWarningForRepave(&amp;diags)
        return diags</span>
}

func flattenClusterConfigsApacheCloudStack(config *models.V1CloudStackCloudConfig) []interface{} <span class="cov0" title="0">{
        if config == nil || config.Spec == nil || config.Spec.ClusterConfig == nil </span><span class="cov0" title="0">{
                return make([]interface{}, 0)
        }</span>

        <span class="cov0" title="0">clusterConfig := config.Spec.ClusterConfig
        m := make(map[string]interface{})

        // Flatten project (V1CloudStackResource)
        if clusterConfig.Project != nil </span><span class="cov0" title="0">{
                projectMap := make(map[string]interface{})
                if clusterConfig.Project.ID != "" </span><span class="cov0" title="0">{
                        projectMap["id"] = clusterConfig.Project.ID
                }</span>
                <span class="cov0" title="0">if clusterConfig.Project.Name != "" </span><span class="cov0" title="0">{
                        projectMap["name"] = clusterConfig.Project.Name
                }</span>
                <span class="cov0" title="0">m["project"] = []interface{}{projectMap}</span>
        }
        <span class="cov0" title="0">if clusterConfig.SSHKeyName != "" </span><span class="cov0" title="0">{
                m["ssh_key_name"] = clusterConfig.SSHKeyName
        }</span>
        <span class="cov0" title="0">if clusterConfig.ControlPlaneEndpoint != "" </span><span class="cov0" title="0">{
                m["control_plane_endpoint"] = clusterConfig.ControlPlaneEndpoint
        }</span>
        <span class="cov0" title="0">m["sync_with_cks"] = clusterConfig.SyncWithCKS

        // Flatten zones
        if len(clusterConfig.Zones) &gt; 0 </span><span class="cov0" title="0">{
                zones := make([]interface{}, 0, len(clusterConfig.Zones))
                for _, zone := range clusterConfig.Zones </span><span class="cov0" title="0">{
                        zoneMap := make(map[string]interface{})
                        if zone.ID != "" </span><span class="cov0" title="0">{
                                zoneMap["id"] = zone.ID
                        }</span>
                        <span class="cov0" title="0">if zone.Name != "" </span><span class="cov0" title="0">{
                                zoneMap["name"] = zone.Name
                        }</span>

                        // Flatten network
                        <span class="cov0" title="0">if zone.Network != nil </span><span class="cov0" title="0">{
                                network := make(map[string]interface{})
                                if zone.Network.ID != "" </span><span class="cov0" title="0">{
                                        network["id"] = zone.Network.ID
                                }</span>
                                <span class="cov0" title="0">if zone.Network.Name != "" </span><span class="cov0" title="0">{
                                        network["name"] = zone.Network.Name
                                }</span>
                                <span class="cov0" title="0">if zone.Network.Type != "" </span><span class="cov0" title="0">{
                                        network["type"] = zone.Network.Type
                                }</span>
                                <span class="cov0" title="0">if zone.Network.Gateway != "" </span><span class="cov0" title="0">{
                                        network["gateway"] = zone.Network.Gateway
                                }</span>
                                <span class="cov0" title="0">if zone.Network.Netmask != "" </span><span class="cov0" title="0">{
                                        network["netmask"] = zone.Network.Netmask
                                }</span>
                                <span class="cov0" title="0">if zone.Network.Offering != "" </span><span class="cov0" title="0">{
                                        network["offering"] = zone.Network.Offering
                                }</span>
                                <span class="cov0" title="0">if zone.Network.RoutingMode != "" </span><span class="cov0" title="0">{
                                        network["routing_mode"] = zone.Network.RoutingMode
                                }</span>

                                // Flatten VPC
                                <span class="cov0" title="0">if zone.Network.Vpc != nil </span><span class="cov0" title="0">{
                                        vpc := make(map[string]interface{})
                                        if zone.Network.Vpc.ID != "" </span><span class="cov0" title="0">{
                                                vpc["id"] = zone.Network.Vpc.ID
                                        }</span>
                                        <span class="cov0" title="0">if zone.Network.Vpc.Name != "" </span><span class="cov0" title="0">{
                                                vpc["name"] = zone.Network.Vpc.Name
                                        }</span>
                                        <span class="cov0" title="0">if zone.Network.Vpc.Cidr != "" </span><span class="cov0" title="0">{
                                                vpc["cidr"] = zone.Network.Vpc.Cidr
                                        }</span>
                                        <span class="cov0" title="0">if zone.Network.Vpc.Offering != "" </span><span class="cov0" title="0">{
                                                vpc["offering"] = zone.Network.Vpc.Offering
                                        }</span>
                                        <span class="cov0" title="0">network["vpc"] = []interface{}{vpc}</span>
                                }

                                <span class="cov0" title="0">zoneMap["network"] = []interface{}{network}</span>
                        }

                        <span class="cov0" title="0">zones = append(zones, zoneMap)</span>
                }
                <span class="cov0" title="0">m["zone"] = zones</span>
        }

        <span class="cov0" title="0">return []interface{}{m}</span>
}

func flattenMachinePoolConfigsApacheCloudStack(machinePools []*models.V1CloudStackMachinePoolConfig) []interface{} <span class="cov0" title="0">{
        if machinePools == nil </span><span class="cov0" title="0">{
                return make([]interface{}, 0)
        }</span>

        <span class="cov0" title="0">ois := make([]interface{}, len(machinePools))

        for i, machinePool := range machinePools </span><span class="cov0" title="0">{
                oi := make(map[string]interface{})

                // Flatten pool configuration (from V1MachinePoolBaseConfig embedded)
                // Note: AdditionalLabels and Taints are now available in the GET response for CloudStack
                FlattenAdditionalLabelsAnnotationsAndTaints(machinePool.AdditionalLabels, machinePool.AdditionalAnnotations, machinePool.Taints, oi)
                FlattenControlPlaneAndRepaveInterval(machinePool.IsControlPlane, oi, machinePool.NodeRepaveInterval)

                if machinePool.UpdateStrategy != nil </span><span class="cov0" title="0">{
                        oi["update_strategy"] = machinePool.UpdateStrategy.Type
                        // Flatten override_Scaling if using OverrideScaling strategy
                        flattenOverrideScaling(machinePool.UpdateStrategy, oi)
                }</span>

                <span class="cov0" title="0">oi["control_plane_as_worker"] = machinePool.UseControlPlaneAsWorker
                oi["name"] = machinePool.Name
                oi["count"] = int(machinePool.Size)

                // Flatten override_kubeadm_configuration (worker pools only)
                if machinePool.IsControlPlane != nil &amp;&amp; !*machinePool.IsControlPlane &amp;&amp; machinePool.OverrideKubeadmConfiguration != "" </span><span class="cov0" title="0">{
                        oi["override_kubeadm_configuration"] = machinePool.OverrideKubeadmConfiguration
                }</span>

                <span class="cov0" title="0">if machinePool.MinSize &gt; 0 </span><span class="cov0" title="0">{
                        oi["min"] = int(machinePool.MinSize)
                }</span>
                <span class="cov0" title="0">if machinePool.MaxSize &gt; 0 </span><span class="cov0" title="0">{
                        oi["max"] = int(machinePool.MaxSize)
                }</span>

                // Note: Labels field contains internal cluster-api labels (like "master"), not user-defined node labels
                // User-defined node labels are managed separately through the node schema

                // Flatten machine configuration (from V1CloudStackMachineConfig embedded)
                // Flatten offering
                <span class="cov0" title="0">if machinePool.Offering != nil </span><span class="cov0" title="0">{
                        oi["offering"] = machinePool.Offering.Name
                }</span>

                // Flatten instance_config
                <span class="cov0" title="0">if machinePool.InstanceConfig != nil </span><span class="cov0" title="0">{
                        instanceConfig := make(map[string]interface{})
                        instanceConfig["disk_gib"] = int(machinePool.InstanceConfig.DiskGiB)
                        instanceConfig["memory_mib"] = int(machinePool.InstanceConfig.MemoryMiB)
                        instanceConfig["num_cpus"] = int(machinePool.InstanceConfig.NumCPUs)
                        instanceConfig["cpu_set"] = int(machinePool.InstanceConfig.CPUSet)
                        if machinePool.InstanceConfig.Name != "" </span><span class="cov0" title="0">{
                                instanceConfig["name"] = machinePool.InstanceConfig.Name
                        }</span>
                        <span class="cov0" title="0">if machinePool.InstanceConfig.Category != "" </span><span class="cov0" title="0">{
                                instanceConfig["category"] = machinePool.InstanceConfig.Category
                        }</span>
                        <span class="cov0" title="0">oi["instance_config"] = []interface{}{instanceConfig}</span>
                }

                // Flatten template
                <span class="cov0" title="0">if machinePool.Template != nil </span><span class="cov0" title="0">{
                        template := make(map[string]interface{})
                        if machinePool.Template.ID != "" </span><span class="cov0" title="0">{
                                template["id"] = machinePool.Template.ID
                        }</span>
                        <span class="cov0" title="0">if machinePool.Template.Name != "" </span><span class="cov0" title="0">{
                                template["name"] = machinePool.Template.Name
                        }</span>
                        <span class="cov0" title="0">oi["template"] = []interface{}{template}</span>
                }

                // Flatten networks
                <span class="cov0" title="0">if len(machinePool.Networks) &gt; 0 </span><span class="cov0" title="0">{
                        networks := make([]interface{}, 0, len(machinePool.Networks))
                        for _, network := range machinePool.Networks </span><span class="cov0" title="0">{
                                netMap := make(map[string]interface{})
                                if network.Name != "" </span><span class="cov0" title="0">{
                                        netMap["network_name"] = network.Name
                                }</span>
                                <span class="cov0" title="0">networks = append(networks, netMap)</span>
                        }
                        <span class="cov0" title="0">oi["network"] = networks</span>
                }

                <span class="cov0" title="0">ois[i] = oi</span>
        }

        <span class="cov0" title="0">return ois</span>
}
</pre>
		
		<pre class="file" id="file127" style="display: none">package spectrocloud

import (
        "context"
        "errors"
        "fmt"
        "strings"
        "time"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"

        "github.com/spectrocloud/palette-sdk-go/api/models"
        "github.com/spectrocloud/palette-sdk-go/client"

        "github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/schemas"
)

func resourceAddonDeployment() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                CreateContext: resourceAddonDeploymentCreate,
                ReadContext:   resourceAddonDeploymentRead,
                UpdateContext: resourceAddonDeploymentUpdate,
                DeleteContext: resourceAddonDeploymentDelete,

                Timeouts: &amp;schema.ResourceTimeout{
                        Create: schema.DefaultTimeout(60 * time.Minute),
                        Update: schema.DefaultTimeout(60 * time.Minute),
                        Delete: schema.DefaultTimeout(60 * time.Minute),
                },

                SchemaVersion: 2,
                Schema: map[string]*schema.Schema{
                        "cluster_uid": {
                                Type:        schema.TypeString,
                                Required:    true,
                                Description: "The UID of the cluster to attach the addon profile to.",
                        },
                        "context": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                ValidateFunc: validation.StringInSlice([]string{"project", "tenant"}, false),
                                Default:      "project",
                                Description: "Specifies cluster context where addon profile is attached. " +
                                        "Allowed values are `project` or `tenant`. Defaults to `project`. " + PROJECT_NAME_NUANCE,
                        },
                        "cluster_profile": schemas.ClusterProfileSchema(),
                        "apply_setting": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "DownloadAndInstall",
                                ValidateFunc: validation.StringInSlice([]string{"DownloadAndInstall", "DownloadAndInstallLater"}, false),
                                Description: "The setting to apply the cluster profile. `DownloadAndInstall` will download and install packs in one action. " +
                                        "`DownloadAndInstallLater` will only download artifact and postpone install for later. " +
                                        "Default value is `DownloadAndInstall`.",
                        },
                },
        }
}</span>

// validateSingleClusterProfile validates that exactly one cluster_profile is specified
func validateSingleClusterProfile(d *schema.ResourceData) error <span class="cov0" title="0">{
        profiles := d.Get("cluster_profile").([]interface{})
        if len(profiles) == 0 </span><span class="cov0" title="0">{
                return errors.New("exactly one cluster_profile is required, but none was specified")
        }</span>
        <span class="cov0" title="0">if len(profiles) &gt; 1 </span><span class="cov0" title="0">{
                return fmt.Errorf("exactly one cluster_profile is allowed per addon deployment, but %d were specified. Use separate spectrocloud_addon_deployment resources for each profile", len(profiles))
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func resourceAddonDeploymentCreate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        // Validate exactly one cluster_profile is specified
        if err := validateSingleClusterProfile(d); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">resourceContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, resourceContext)

        var diags diag.Diagnostics

        clusterUid := d.Get("cluster_uid").(string)

        cluster, err := c.GetCluster(clusterUid)
        if err != nil &amp;&amp; cluster == nil </span><span class="cov0" title="0">{
                return diag.FromErr(fmt.Errorf("cluster not found: %s", clusterUid))
        }</span>

        <span class="cov0" title="0">addonDeployment, err := toAddonDeployment(c, d)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">diagnostics, isError := waitForClusterCreation(ctx, d, clusterUid, diags, c, false)
        if isError </span><span class="cov0" title="0">{
                return diagnostics
        }</span>
        // Clear the ID to skip resource tainted
        <span class="cov0" title="0">d.SetId("")

        if isProfileAttached(cluster, addonDeployment.Profiles[0].UID) </span><span class="cov0" title="0">{
                return updateAddonDeployment(ctx, d, m, c, cluster, clusterUid, diags)
        }</span>

        <span class="cov0" title="0">err = c.CreateAddonDeployment(cluster, addonDeployment)
        if err != nil </span><span class="cov0" title="0">{
                // Clear the ID to skip resource tainted
                d.SetId("")
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">clusterProfile, err := c.GetClusterProfile(addonDeployment.Profiles[0].UID)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">d.SetId(getAddonDeploymentId(clusterUid, clusterProfile))

        diagnostics, isError = waitForAddonDeploymentCreation(ctx, d, *cluster, addonDeployment.Profiles[0].UID, diags, c)
        if isError </span><span class="cov0" title="0">{
                return diagnostics
        }</span>

        <span class="cov0" title="0">return resourceAddonDeploymentRead(ctx, d, m)</span>
}

func getAddonDeploymentId(clusterUid string, clusterProfile *models.V1ClusterProfile) string <span class="cov0" title="0">{
        return clusterUid + "_" + clusterProfile.Metadata.UID
}</span>

func getClusterUID(addonDeploymentId string) string <span class="cov0" title="0">{
        return strings.Split(addonDeploymentId, "_")[0]
}</span>

func getClusterProfileUID(addonDeploymentId string) (string, error) <span class="cov0" title="0">{
        sp := strings.Split(addonDeploymentId, "_")
        if len(sp) &lt; 2 </span><span class="cov0" title="0">{
                return "", errors.New("invalid addon deployment ID format")
        }</span>
        <span class="cov0" title="0">return sp[1], nil</span>
}

func isProfileAttached(cluster *models.V1SpectroCluster, uid string) bool <span class="cov0" title="0">{
        for _, profile := range cluster.Spec.ClusterProfileTemplates </span><span class="cov0" title="0">{
                if profile.UID == uid </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

//goland:noinspection GoUnhandledErrorResult
func resourceAddonDeploymentRead(_ context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        resourceContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, resourceContext)

        var diags diag.Diagnostics

        clusterUid := d.Get("cluster_uid").(string)
        if !strings.Contains(d.Id(), clusterUid) </span><span class="cov0" title="0">{
                d.SetId("")
                return diags
        }</span>

        <span class="cov0" title="0">cluster, err := c.GetCluster(clusterUid)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">diagnostics, done := readAddonDeployment(c, d, cluster)
        if done </span><span class="cov0" title="0">{
                return diagnostics
        }</span>

        <span class="cov0" title="0">return diags</span>
}

func resourceAddonDeploymentUpdate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        // Validate exactly one cluster_profile is specified
        if err := validateSingleClusterProfile(d); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">var diags diag.Diagnostics

        if d.HasChanges("cluster_uid", "cluster_profile") </span><span class="cov0" title="0">{
                resourceContext := d.Get("context").(string)
                c := getV1ClientWithResourceContext(m, resourceContext)

                clusterUid := d.Get("cluster_uid").(string)

                cluster, err := c.GetCluster(clusterUid)
                if err != nil &amp;&amp; cluster == nil </span><span class="cov0" title="0">{
                        return diag.FromErr(fmt.Errorf("cluster not found: %s", clusterUid))
                }</span>

                <span class="cov0" title="0">return updateAddonDeployment(ctx, d, m, c, cluster, clusterUid, diags)</span>
        }

        <span class="cov0" title="0">return diags</span>
}

func updateAddonDeployment(ctx context.Context, d *schema.ResourceData, m interface{}, c *client.V1Client, cluster *models.V1SpectroCluster, clusterUid string, diags diag.Diagnostics) diag.Diagnostics <span class="cov0" title="0">{
        addonDeployment, err := toAddonDeployment(c, d)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">if len(addonDeployment.Profiles) == 0 </span><span class="cov0" title="0">{
                return diag.FromErr(errors.New("cannot convert addon deployment: zero profiles found"))
        }</span>

        <span class="cov0" title="0">newProfile, err := c.GetClusterProfile(addonDeployment.Profiles[0].UID)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">err = c.UpdateAddonDeployment(cluster, addonDeployment, newProfile)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">clusterProfile, err := c.GetClusterProfile(addonDeployment.Profiles[0].UID)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">d.SetId(getAddonDeploymentId(clusterUid, clusterProfile))
        diagnostics, isError := waitForAddonDeploymentUpdate(ctx, d, *cluster, addonDeployment.Profiles[0].UID, diags, c)
        if isError </span><span class="cov0" title="0">{
                return diagnostics
        }</span>

        <span class="cov0" title="0">return resourceAddonDeploymentRead(ctx, d, m)</span>
}

func toAddonDeployment(c *client.V1Client, d *schema.ResourceData) (*models.V1SpectroClusterProfiles, error) <span class="cov0" title="0">{
        profiles, err := toAddonDeplProfiles(c, d)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">settings, err := toSpcApplySettings(d)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;models.V1SpectroClusterProfiles{
                Profiles:         profiles,
                SpcApplySettings: settings,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file128" style="display: none">package spectrocloud

import (
        "context"
        "log"
        "sort"
        "time"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"

        "github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/schemas"
        "github.com/spectrocloud/terraform-provider-spectrocloud/types"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/spectrocloud/palette-sdk-go/api/models"
        "github.com/spectrocloud/palette-sdk-go/client"
)

func resourceClusterAws() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                CreateContext: resourceClusterAwsCreate,
                ReadContext:   resourceClusterAwsRead,
                UpdateContext: resourceClusterAwsUpdate,
                DeleteContext: resourceClusterDelete,
                Importer: &amp;schema.ResourceImporter{
                        StateContext: resourceClusterAwsImport,
                },
                Description: "Resource for managing AWS clusters in Spectro Cloud through Palette.",

                Timeouts: &amp;schema.ResourceTimeout{
                        Create: schema.DefaultTimeout(60 * time.Minute),
                        Update: schema.DefaultTimeout(60 * time.Minute),
                        Delete: schema.DefaultTimeout(60 * time.Minute),
                },

                SchemaVersion: 2,
                Schema: map[string]*schema.Schema{
                        "name": {
                                Type:     schema.TypeString,
                                Required: true,
                                ForceNew: true,
                        },
                        "context": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "project",
                                ValidateFunc: validation.StringInSlice([]string{"", "project", "tenant"}, false),
                                Description: "The context of the AWS cluster. Allowed values are `project` or `tenant`. " +
                                        "Default is `project`. " + PROJECT_NAME_NUANCE,
                        },
                        "tags": {
                                Type:     schema.TypeSet,
                                Optional: true,
                                Set:      schema.HashString,
                                Elem: &amp;schema.Schema{
                                        Type: schema.TypeString,
                                },
                                Description: "A list of tags to be applied to the cluster. Tags must be in the form of `key:value`. The `tags` attribute will soon be deprecated. It is recommended to use `tags_map` instead.",
                        },
                        "tags_map": {
                                Type:          schema.TypeMap,
                                Optional:      true,
                                ConflictsWith: []string{"tags"},
                                Elem: &amp;schema.Schema{
                                        Type: schema.TypeString,
                                },
                                Description: "A map of tags to be applied to the cluster. tags and tags_map are mutually exclusive  only one should be used at a time",
                        },
                        "description": {
                                Type:        schema.TypeString,
                                Optional:    true,
                                Default:     "",
                                Description: "The description of the cluster. Default value is empty string.",
                        },
                        "cluster_meta_attribute": {
                                Type:        schema.TypeString,
                                Optional:    true,
                                Description: "`cluster_meta_attribute` can be used to set additional cluster metadata information, eg `{'nic_name': 'test', 'env': 'stage'}`",
                        },
                        "cluster_profile":  schemas.ClusterProfileSchema(),
                        "cluster_template": schemas.ClusterTemplateSchema(),
                        "cluster_type":     schemas.ClusterTypeSchema(),
                        "apply_setting": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "DownloadAndInstall",
                                ValidateFunc: validation.StringInSlice([]string{"DownloadAndInstall", "DownloadAndInstallLater"}, false),
                                Description: "The setting to apply the cluster profile. `DownloadAndInstall` will download and install packs in one action. " +
                                        "`DownloadAndInstallLater` will only download artifact and postpone install for later. " +
                                        "Default value is `DownloadAndInstall`.",
                        },
                        "cloud_account_id": {
                                Type:     schema.TypeString,
                                Required: true,
                                ForceNew: true,
                        },
                        "cloud_config_id": {
                                Type:        schema.TypeString,
                                Computed:    true,
                                Description: "ID of the cloud config used for the cluster. This cloud config must be of type `azure`.",
                                Deprecated:  "This field is deprecated and will be removed in the future. Use `cloud_config` instead.",
                        },
                        "review_repave_state": {
                                Type:         schema.TypeString,
                                Default:      "",
                                Optional:     true,
                                ValidateFunc: validateReviewRepaveValue,
                                Description:  "To authorize the cluster repave, set the value to `Approved` for approval and `\"\"` to decline. Default value is `\"\"`.",
                        },
                        "pause_agent_upgrades": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "unlock",
                                ValidateFunc: validation.StringInSlice([]string{"lock", "unlock"}, false),
                                Description:  "The pause agent upgrades setting allows to control the automatic upgrade of the Palette component and agent for an individual cluster. The default value is `unlock`, meaning upgrades occur automatically. Setting it to `lock` pauses automatic agent upgrades for the cluster.",
                        },
                        "os_patch_on_boot": {
                                Type:        schema.TypeBool,
                                Optional:    true,
                                Default:     false,
                                Description: "Whether to apply OS patch on boot. Default is `false`.",
                        },
                        "os_patch_schedule": {
                                Type:             schema.TypeString,
                                Optional:         true,
                                ValidateDiagFunc: validateOsPatchSchedule,
                                Description:      "The cron schedule for OS patching. This must be in the form of cron syntax. Ex: `0 0 * * *`.",
                        },
                        "os_patch_after": {
                                Type:             schema.TypeString,
                                Optional:         true,
                                ValidateDiagFunc: validateOsPatchOnDemandAfter,
                                Description:      "Date and time after which to patch cluster `RFC3339: 2006-01-02T15:04:05Z07:00`",
                        },
                        "cluster_timezone": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "",
                                ValidateFunc: validateTimezone,
                                Description:  "Defines the time zone used by this cluster to interpret scheduled operations. Maintenance tasks like upgrades will follow this time zone to ensure they run at the appropriate local time for the cluster. Must be in IANA timezone format (e.g., 'America/New_York', 'Asia/Kolkata', 'Europe/London').",
                        },
                        "kubeconfig": {
                                Type:        schema.TypeString,
                                Computed:    true,
                                Description: "Kubeconfig for the cluster. This can be used to connect to the cluster using `kubectl`.",
                        },
                        "admin_kube_config": {
                                Type:        schema.TypeString,
                                Computed:    true,
                                Description: "Admin Kube-config for the cluster. This can be used to connect to the cluster using `kubectl`, With admin privilege.",
                        },
                        "cloud_config": {
                                Type:     schema.TypeList,
                                ForceNew: true,
                                Required: true,
                                MaxItems: 1,
                                Elem: &amp;schema.Resource{
                                        Schema: map[string]*schema.Schema{
                                                "ssh_key_name": {
                                                        Type:        schema.TypeString,
                                                        ForceNew:    true,
                                                        Required:    true,
                                                        Description: "Public SSH key to be used for the cluster nodes.",
                                                },
                                                "region": {
                                                        Type:        schema.TypeString,
                                                        ForceNew:    true,
                                                        Required:    true,
                                                        Description: "The AWS region to deploy the cluster in.",
                                                },
                                                "vpc_id": {
                                                        Type:        schema.TypeString,
                                                        ForceNew:    true,
                                                        Optional:    true,
                                                        Description: "The VPC ID to deploy the cluster in. If not provided, VPC will be provisioned dynamically.",
                                                },
                                                "control_plane_lb": {
                                                        Type:         schema.TypeString,
                                                        ForceNew:     true,
                                                        Default:      "",
                                                        Optional:     true,
                                                        ValidateFunc: validation.StringInSlice([]string{"", "Internet-facing", "internal"}, false),
                                                        Description:  "Control plane load balancer type. Valid values are `Internet-facing` and `internal`. Defaults to `` (empty string).",
                                                },
                                        },
                                },
                        },
                        "machine_pool": {
                                Type:     schema.TypeSet,
                                Required: true,
                                Set:      resourceMachinePoolAwsHash,
                                Elem: &amp;schema.Resource{
                                        Schema: map[string]*schema.Schema{
                                                "additional_labels": {
                                                        Type:     schema.TypeMap,
                                                        Optional: true,
                                                        Elem: &amp;schema.Schema{
                                                                Type: schema.TypeString,
                                                        },
                                                        Description: "Additional labels to be applied to the machine pool. Labels must be in the form of `key:value`.",
                                                },
                                                "additional_annotations": {
                                                        Type:     schema.TypeMap,
                                                        Optional: true,
                                                        Elem: &amp;schema.Schema{
                                                                Type: schema.TypeString,
                                                        },
                                                        Description: "Additional annotations to be applied to the machine pool. Annotations must be in the form of `key:value`.",
                                                },
                                                "taints": schemas.ClusterTaintsSchema(),
                                                "control_plane": {
                                                        Type:        schema.TypeBool,
                                                        Optional:    true,
                                                        Default:     false,
                                                        Description: "Whether this machine pool is a control plane. Defaults to `false`.",
                                                },
                                                "control_plane_as_worker": {
                                                        Type:     schema.TypeBool,
                                                        Optional: true,
                                                        Default:  false,
                                                        //ForceNew: true,
                                                        Description: "Whether this machine pool is a control plane and a worker. Defaults to `false`.",
                                                },
                                                "name": {
                                                        Type:        schema.TypeString,
                                                        Required:    true,
                                                        Description: "The name of the machine pool.",
                                                },
                                                "count": {
                                                        Type:        schema.TypeInt,
                                                        Required:    true,
                                                        Description: "Number of nodes in the machine pool.",
                                                },
                                                "instance_type": {
                                                        Type:        schema.TypeString,
                                                        Required:    true,
                                                        Description: "The instance type to use for the machine pool nodes.",
                                                },
                                                "min": {
                                                        Type:        schema.TypeInt,
                                                        Optional:    true,
                                                        Description: "Minimum number of nodes in the machine pool. This is used for autoscaling the machine pool.",
                                                },
                                                "max": {
                                                        Type:        schema.TypeInt,
                                                        Optional:    true,
                                                        Description: "Maximum number of nodes in the machine pool. This is used for autoscaling the machine pool.",
                                                },
                                                "node_repave_interval": {
                                                        Type:        schema.TypeInt,
                                                        Optional:    true,
                                                        Default:     0,
                                                        Description: "Minimum number of seconds node should be Ready, before the next node is selected for repave. Default value is `0`, Applicable only for worker pools.",
                                                },
                                                "capacity_type": {
                                                        Type:         schema.TypeString,
                                                        Default:      "on-demand",
                                                        Optional:     true,
                                                        ValidateFunc: validation.StringInSlice([]string{"on-demand", "spot"}, false),
                                                        Description:  "Capacity type is an instance type,  can be 'on-demand' or 'spot'. Defaults to 'on-demand'.",
                                                },
                                                "max_price": {
                                                        Type:        schema.TypeString,
                                                        Optional:    true,
                                                        Description: "Maximum price to bid for spot instances. Only applied when instance type is 'spot'.",
                                                },
                                                "update_strategy": {
                                                        Type:         schema.TypeString,
                                                        Optional:     true,
                                                        Default:      "RollingUpdateScaleOut",
                                                        Description:  "Update strategy for the machine pool. Valid values are `RollingUpdateScaleOut`, `RollingUpdateScaleIn` and `OverrideScaling`. If `OverrideScaling` is used, `override_scaling` must be specified with both `max_surge` and `max_unavailable`.",
                                                        ValidateFunc: validation.StringInSlice([]string{"RollingUpdateScaleOut", "RollingUpdateScaleIn", "OverrideScaling"}, false),
                                                },
                                                "override_scaling": schemas.OverrideScalingSchema(),
                                                "override_kubeadm_configuration": {
                                                        Type:        schema.TypeString,
                                                        Optional:    true,
                                                        Description: "YAML config for kubeletExtraArgs, preKubeadmCommands, postKubeadmCommands. Overrides pack-level settings. Worker pools only.",
                                                },
                                                "disk_size_gb": {
                                                        Type:        schema.TypeInt,
                                                        Optional:    true,
                                                        Default:     65,
                                                        Description: "The disk size in GB for the machine pool nodes.",
                                                },
                                                "azs": {
                                                        Type:        schema.TypeSet,
                                                        Optional:    true,
                                                        Description: "Mutually exclusive with `az_subnets`. Use `azs` for Dynamic provisioning.",
                                                        MinItems:    1,
                                                        Set:         schema.HashString,
                                                        Elem: &amp;schema.Schema{
                                                                Type: schema.TypeString,
                                                        },
                                                },
                                                "az_subnets": {
                                                        Type:        schema.TypeMap,
                                                        Optional:    true,
                                                        Description: "Mutually exclusive with `azs`. Use `az_subnets` for Static provisioning.",
                                                        Elem: &amp;schema.Schema{
                                                                Type:     schema.TypeString,
                                                                Required: true,
                                                        },
                                                },
                                                "additional_security_groups": {
                                                        Type: schema.TypeSet,
                                                        Set:  schema.HashString,
                                                        Elem: &amp;schema.Schema{
                                                                Type: schema.TypeString,
                                                        },
                                                        Optional:    true,
                                                        Description: "Additional security groups to attach to the instance.",
                                                },
                                                "node": schemas.NodeSchema(),
                                        },
                                },
                        },
                        "backup_policy":        schemas.BackupPolicySchema(),
                        "scan_policy":          schemas.ScanPolicySchema(),
                        "cluster_rbac_binding": schemas.ClusterRbacBindingSchema(),
                        "namespaces":           schemas.ClusterNamespacesSchema(),
                        "host_config":          schemas.ClusterHostConfigSchema(),
                        "location_config":      schemas.ClusterLocationSchemaComputed(),
                        "skip_completion": {
                                Type:        schema.TypeBool,
                                Optional:    true,
                                Default:     false,
                                Description: "If `true`, the cluster will be created asynchronously. Default value is `false`.",
                        },
                        "force_delete": {
                                Type:        schema.TypeBool,
                                Optional:    true,
                                Default:     false,
                                Description: "If set to `true`, the cluster will be force deleted and user has to manually clean up the provisioned cloud resources.",
                        },
                        "force_delete_delay": {
                                Type:             schema.TypeInt,
                                Optional:         true,
                                Default:          20,
                                Description:      "Delay duration in minutes to before invoking cluster force delete. Default and minimum is 20.",
                                ValidateDiagFunc: validation.ToDiagFunc(validation.IntAtLeast(20)),
                        },
                },
        }
}</span>

func resourceClusterAwsCreate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        resourceContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, resourceContext)

        // Warning or errors can be collected in a slice type
        var diags diag.Diagnostics

        // Validate override_Scaling configuration
        if err := validateOverrideScaling(d, "machine_pool"); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">cluster, err := toAwsCluster(c, d)

        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">uid, err := c.CreateClusterAws(cluster)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">diagnostics, isError := waitForClusterCreation(ctx, d, uid, diags, c, true)
        if len(diagnostics) &gt; 0 </span><span class="cov0" title="0">{
                diags = append(diags, diagnostics...)
        }</span>
        <span class="cov0" title="0">if isError </span><span class="cov0" title="0">{
                return diagnostics
        }</span>

        <span class="cov0" title="0">resourceClusterAwsRead(ctx, d, m)

        return diags</span>
}

//goland:noinspection GoUnhandledErrorResult
func resourceClusterAwsRead(_ context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        resourceContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, resourceContext)

        var diags diag.Diagnostics

        cluster, err := resourceClusterRead(d, c, diags)
        if err != nil </span><span class="cov0" title="0">{
                return handleReadError(d, err, diags)
        }</span> else<span class="cov0" title="0"> if cluster == nil </span><span class="cov0" title="0">{
                // Deleted - Terraform will recreate it
                d.SetId("")
                return diags
        }</span>

        // verify cluster type
        <span class="cov0" title="0">err = ValidateCloudType("spectrocloud_cluster_aws", cluster)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">diagnostics, done := readCommonFields(c, d, cluster)

        // handling flatten tags_map for aws  cluster
        if _, ok := d.GetOk("tags_map"); ok </span><span class="cov0" title="0">{
                // setting to empty since tags_map is present
                _ = d.Set("tags", []string{})
                tagMaps := flattenTagsMap(cluster.Metadata.Labels)
                if err := d.Set("tags_map", tagMaps); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
        }

        <span class="cov0" title="0">if done </span><span class="cov0" title="0">{
                return diagnostics
        }</span>

        // Flatten cluster_template variables using variables API
        <span class="cov0" title="0">if err := flattenClusterTemplateVariables(c, d, d.Id()); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">return flattenCloudConfigAws(cluster.Spec.CloudConfigRef.UID, d, c)</span>
}

func flattenCloudConfigAws(configUID string, d *schema.ResourceData, c *client.V1Client) diag.Diagnostics <span class="cov0" title="0">{
        var diags diag.Diagnostics
        if err := d.Set("cloud_config_id", configUID); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">if err := ReadCommonAttributes(d); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">if config, err := c.GetCloudConfigAws(configUID); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span> else<span class="cov0" title="0"> {
                if config.Spec != nil &amp;&amp; config.Spec.CloudAccountRef != nil </span><span class="cov0" title="0">{
                        if err := d.Set("cloud_account_id", config.Spec.CloudAccountRef.UID); err != nil </span><span class="cov0" title="0">{
                                return diag.FromErr(err)
                        }</span>
                }
                <span class="cov0" title="0">if err := d.Set("cloud_config", flattenClusterConfigsAws(config)); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
                <span class="cov0" title="0">mp := flattenMachinePoolConfigsAws(config.Spec.MachinePoolConfig)
                mp, err := flattenNodeMaintenanceStatus(c, d, c.GetNodeStatusMapAws, mp, configUID)
                if err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
                <span class="cov0" title="0">if err := d.Set("machine_pool", mp); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
        }
        <span class="cov0" title="0">generalWarningForRepave(&amp;diags)
        return diags</span>
}

func flattenClusterConfigsAws(config *models.V1AwsCloudConfig) []interface{} <span class="cov0" title="0">{
        if config == nil || config.Spec == nil || config.Spec.ClusterConfig == nil </span><span class="cov0" title="0">{
                return make([]interface{}, 0)
        }</span>

        <span class="cov0" title="0">m := make(map[string]interface{})

        if config.Spec.ClusterConfig.SSHKeyName != "" </span><span class="cov0" title="0">{
                m["ssh_key_name"] = config.Spec.ClusterConfig.SSHKeyName
        }</span>
        <span class="cov0" title="0">if config.Spec.ClusterConfig.Region != nil </span><span class="cov0" title="0">{
                m["region"] = *config.Spec.ClusterConfig.Region
        }</span>
        <span class="cov0" title="0">if config.Spec.ClusterConfig.VpcID != "" </span><span class="cov0" title="0">{
                m["vpc_id"] = config.Spec.ClusterConfig.VpcID
        }</span>
        <span class="cov0" title="0">if config.Spec.ClusterConfig.ControlPlaneLoadBalancer != "" </span><span class="cov0" title="0">{
                m["control_plane_lb"] = config.Spec.ClusterConfig.ControlPlaneLoadBalancer
        }</span>

        <span class="cov0" title="0">return []interface{}{m}</span>
}

func flattenMachinePoolConfigsAws(machinePools []*models.V1AwsMachinePoolConfig) []interface{} <span class="cov0" title="0">{
        if machinePools == nil </span><span class="cov0" title="0">{
                return make([]interface{}, 0)
        }</span>

        <span class="cov0" title="0">ois := make([]interface{}, len(machinePools))

        for i, machinePool := range machinePools </span><span class="cov0" title="0">{
                oi := make(map[string]interface{})

                FlattenAdditionalLabelsAnnotationsAndTaints(machinePool.AdditionalLabels, machinePool.AdditionalAnnotations, machinePool.Taints, oi)
                FlattenControlPlaneAndRepaveInterval(machinePool.IsControlPlane, oi, machinePool.NodeRepaveInterval)

                oi["control_plane_as_worker"] = machinePool.UseControlPlaneAsWorker
                oi["name"] = machinePool.Name
                oi["count"] = int(machinePool.Size)
                if machinePool.UpdateStrategy != nil &amp;&amp; machinePool.UpdateStrategy.Type != "" </span><span class="cov0" title="0">{
                        oi["update_strategy"] = machinePool.UpdateStrategy.Type
                        // Flatten override_Scaling if using OverrideScaling strategy
                        flattenOverrideScaling(machinePool.UpdateStrategy, oi)
                }</span> else<span class="cov0" title="0"> {
                        oi["update_strategy"] = "RollingUpdateScaleOut"
                }</span>

                // Flatten override_kubeadm_configuration (worker pools only)
                <span class="cov0" title="0">if machinePool.IsControlPlane != nil &amp;&amp; !*machinePool.IsControlPlane &amp;&amp; machinePool.OverrideKubeadmConfiguration != "" </span><span class="cov0" title="0">{
                        oi["override_kubeadm_configuration"] = machinePool.OverrideKubeadmConfiguration
                }</span>

                <span class="cov0" title="0">oi["min"] = int(machinePool.MinSize)
                oi["max"] = int(machinePool.MaxSize)
                oi["instance_type"] = machinePool.InstanceType
                if machinePool.CapacityType != nil </span><span class="cov0" title="0">{
                        oi["capacity_type"] = machinePool.CapacityType
                }</span>
                <span class="cov0" title="0">if machinePool.SpotMarketOptions != nil </span><span class="cov0" title="0">{
                        oi["max_price"] = machinePool.SpotMarketOptions.MaxPrice
                }</span>
                <span class="cov0" title="0">oi["disk_size_gb"] = int(machinePool.RootDeviceSize)
                if machinePool.SubnetIds != nil </span><span class="cov0" title="0">{
                        oi["az_subnets"] = machinePool.SubnetIds
                }</span> else<span class="cov0" title="0"> {
                        oi["azs"] = machinePool.Azs
                }</span>

                <span class="cov0" title="0">if len(machinePool.AdditionalSecurityGroups) &gt; 0 </span><span class="cov0" title="0">{
                        additionalSecuritygroup := make([]string, 0)
                        for _, sg := range machinePool.AdditionalSecurityGroups </span><span class="cov0" title="0">{
                                additionalSecuritygroup = append(additionalSecuritygroup, sg.ID)
                        }</span>
                        <span class="cov0" title="0">oi["additional_security_groups"] = additionalSecuritygroup</span>
                }
                <span class="cov0" title="0">ois[i] = oi</span>
        }

        <span class="cov0" title="0">sort.SliceStable(ois, func(i, j int) bool </span><span class="cov0" title="0">{
                var controlPlaneI, controlPlaneJ bool
                if ois[i].(map[string]interface{})["control_plane"] != nil </span><span class="cov0" title="0">{
                        controlPlaneI = ois[i].(map[string]interface{})["control_plane"].(bool)
                }</span>
                <span class="cov0" title="0">if ois[j].(map[string]interface{})["control_plane"] != nil </span><span class="cov0" title="0">{
                        controlPlaneJ = ois[j].(map[string]interface{})["control_plane"].(bool)
                }</span>

                // If both are control planes or both are not, sort by name
                <span class="cov0" title="0">if controlPlaneI == controlPlaneJ </span><span class="cov0" title="0">{
                        return ois[i].(map[string]interface{})["name"].(string) &lt; ois[j].(map[string]interface{})["name"].(string)
                }</span>

                // Otherwise, control planes come first
                <span class="cov0" title="0">return controlPlaneI &amp;&amp; !controlPlaneJ</span>
        })

        <span class="cov0" title="0">return ois</span>
}

func resourceClusterAwsUpdate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        resourceContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, resourceContext)

        // Warning or errors can be collected in a slice type
        var diags diag.Diagnostics

        // Validate that cluster_type is not being modified (it's a create-only field)
        if err := ValidateClusterTypeUpdate(d); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">err := validateSystemRepaveApproval(d, c)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">cloudConfigId := d.Get("cloud_config_id").(string)
        //ClusterContext := d.Get("context").(string)
        CloudConfig, err := c.GetCloudConfigAws(cloudConfigId)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">if d.HasChange("machine_pool") </span><span class="cov0" title="0">{
                // Validate override_Scaling configuration
                if err := validateOverrideScaling(d, "machine_pool"); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
                <span class="cov0" title="0">oraw, nraw := d.GetChange("machine_pool")
                if oraw == nil </span><span class="cov0" title="0">{
                        oraw = new(schema.Set)
                }</span>
                <span class="cov0" title="0">if nraw == nil </span><span class="cov0" title="0">{
                        nraw = new(schema.Set)
                }</span>

                <span class="cov0" title="0">os := oraw.(*schema.Set)
                ns := nraw.(*schema.Set)

                osMap := make(map[string]interface{})
                for _, mp := range os.List() </span><span class="cov0" title="0">{
                        machinePool := mp.(map[string]interface{})
                        osMap[machinePool["name"].(string)] = machinePool
                }</span>

                <span class="cov0" title="0">nsMap := make(map[string]interface{})

                for _, mp := range ns.List() </span><span class="cov0" title="0">{
                        machinePoolResource := mp.(map[string]interface{})
                        nsMap[machinePoolResource["name"].(string)] = machinePoolResource
                        // since known issue in TF SDK: https://github.com/hashicorp/terraform-plugin-sdk/issues/588
                        if machinePoolResource["name"].(string) != "" </span><span class="cov0" title="0">{
                                name := machinePoolResource["name"].(string)
                                if name != "" </span><span class="cov0" title="0">{
                                        hash := resourceMachinePoolAwsHash(machinePoolResource)
                                        vpcId := d.Get("cloud_config").([]interface{})[0].(map[string]interface{})["vpc_id"]

                                        var err error
                                        machinePool, err := toMachinePoolAws(machinePoolResource, vpcId.(string))
                                        if err != nil </span><span class="cov0" title="0">{
                                                return diag.FromErr(err)
                                        }</span>

                                        <span class="cov0" title="0">if oldMachinePool, ok := osMap[name]; !ok </span><span class="cov0" title="0">{
                                                log.Printf("Create machine pool %s", name)
                                                err = c.CreateMachinePoolAws(cloudConfigId, machinePool)
                                        }</span> else<span class="cov0" title="0"> if hash != resourceMachinePoolAwsHash(oldMachinePool) </span><span class="cov0" title="0">{
                                                log.Printf("Change in machine pool %s", name)
                                                err = c.UpdateMachinePoolAws(cloudConfigId, machinePool)
                                                // Node Maintenance Actions
                                                err := resourceNodeAction(c, ctx, nsMap[name], c.GetNodeMaintenanceStatusAws, CloudConfig.Kind, cloudConfigId, name)
                                                if err != nil </span><span class="cov0" title="0">{
                                                        return diag.FromErr(err)
                                                }</span>
                                        }

                                        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                                                return diag.FromErr(err)
                                        }</span>

                                        // Processed (if exists)
                                        <span class="cov0" title="0">delete(osMap, name)</span>
                                }
                        }
                }

                // Deleted old machine pools
                <span class="cov0" title="0">for _, mp := range osMap </span><span class="cov0" title="0">{
                        machinePool := mp.(map[string]interface{})
                        name := machinePool["name"].(string)
                        log.Printf("Deleted machine pool %s", name)
                        if err := c.DeleteMachinePoolAws(cloudConfigId, name); err != nil </span><span class="cov0" title="0">{
                                return diag.FromErr(err)
                        }</span>
                }
        }

        <span class="cov0" title="0">diagnostics, done := updateCommonFields(d, c)
        if done </span><span class="cov0" title="0">{
                return diagnostics
        }</span>
        <span class="cov0" title="0">resourceClusterAwsRead(ctx, d, m)
        return diags</span>
}

func toAwsCluster(c *client.V1Client, d *schema.ResourceData) (*models.V1SpectroAwsClusterEntity, error) <span class="cov0" title="0">{
        // gnarly, I know! =/
        cloudConfig := d.Get("cloud_config").([]interface{})[0].(map[string]interface{})

        clusterContext := d.Get("context").(string)
        profiles, err := toProfiles(c, d, clusterContext)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">cluster := &amp;models.V1SpectroAwsClusterEntity{
                Metadata: getClusterMetadata(d),
                Spec: &amp;models.V1SpectroAwsClusterEntitySpec{
                        CloudAccountUID: types.Ptr(d.Get("cloud_account_id").(string)),
                        Profiles:        profiles,
                        ClusterTemplate: toClusterTemplateReference(d),
                        ClusterType:     toClusterType(d),
                        Policies:        toPolicies(d),
                        CloudConfig: &amp;models.V1AwsClusterConfig{
                                SSHKeyName:               cloudConfig["ssh_key_name"].(string),
                                Region:                   types.Ptr(cloudConfig["region"].(string)),
                                VpcID:                    cloudConfig["vpc_id"].(string),
                                ControlPlaneLoadBalancer: cloudConfig["control_plane_lb"].(string),
                        },
                },
        }

        // handling to tags_map for aws cluster
        if _, ok := d.GetOk("tags_map"); ok </span><span class="cov0" title="0">{
                tagMaps := toTagsMap(d)
                cluster.Metadata.Labels = tagMaps
        }</span>

        <span class="cov0" title="0">machinePoolConfigs := make([]*models.V1AwsMachinePoolConfigEntity, 0)
        for _, machinePool := range d.Get("machine_pool").(*schema.Set).List() </span><span class="cov0" title="0">{
                mp, err := toMachinePoolAws(machinePool, cluster.Spec.CloudConfig.VpcID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">machinePoolConfigs = append(machinePoolConfigs, mp)</span>
        }

        <span class="cov0" title="0">sort.SliceStable(machinePoolConfigs, func(i, j int) bool </span><span class="cov0" title="0">{
                controlPlaneI := machinePoolConfigs[i].PoolConfig.IsControlPlane
                controlPlaneJ := machinePoolConfigs[j].PoolConfig.IsControlPlane

                // If both are control planes or both are not, sort by name
                if controlPlaneI == controlPlaneJ </span><span class="cov0" title="0">{
                        return *machinePoolConfigs[i].PoolConfig.Name &lt; *machinePoolConfigs[j].PoolConfig.Name
                }</span>

                // Otherwise, control planes come first
                <span class="cov0" title="0">return controlPlaneI &amp;&amp; !controlPlaneJ</span>
        })

        <span class="cov0" title="0">cluster.Spec.Machinepoolconfig = machinePoolConfigs
        cluster.Spec.ClusterConfig = toClusterConfig(d)

        return cluster, nil</span>
}

func toMachinePoolAws(machinePool interface{}, vpcId string) (*models.V1AwsMachinePoolConfigEntity, error) <span class="cov0" title="0">{
        m := machinePool.(map[string]interface{})

        labels := make([]string, 0)
        controlPlane := m["control_plane"].(bool)
        controlPlaneAsWorker := m["control_plane_as_worker"].(bool)
        if controlPlane </span><span class="cov0" title="0">{
                labels = append(labels, "control-plane")
        }</span> else<span class="cov0" title="0"> {
                labels = append(labels, "worker")
        }</span>

        <span class="cov0" title="0">azs := make([]string, 0)
        capacityType := "on-demand" // on-demand by default.
        if m["capacity_type"] != nil &amp;&amp; len(m["capacity_type"].(string)) &gt; 0 </span><span class="cov0" title="0">{
                capacityType = m["capacity_type"].(string)
        }</span>
        <span class="cov0" title="0">azSubnetsConfigs := make([]*models.V1AwsSubnetEntity, 0)
        if m["az_subnets"] != nil &amp;&amp; len(m["az_subnets"].(map[string]interface{})) &gt; 0 &amp;&amp; vpcId != "" </span><span class="cov0" title="0">{
                for key, azSubnet := range m["az_subnets"].(map[string]interface{}) </span><span class="cov0" title="0">{
                        azs = append(azs, key)
                        azSubnetsConfigs = append(azSubnetsConfigs, &amp;models.V1AwsSubnetEntity{
                                ID: azSubnet.(string),
                                Az: key,
                        })
                }</span>
        }
        <span class="cov0" title="0">if len(azs) == 0 </span><span class="cov0" title="0">{
                for _, az := range m["azs"].(*schema.Set).List() </span><span class="cov0" title="0">{
                        azs = append(azs, az.(string))
                }</span>
        }
        <span class="cov0" title="0">min := SafeInt32(m["count"].(int))
        max := SafeInt32(m["count"].(int))

        if m["min"] != nil </span><span class="cov0" title="0">{
                min = SafeInt32(m["min"].(int))
        }</span>

        <span class="cov0" title="0">if m["max"] != nil </span><span class="cov0" title="0">{
                max = SafeInt32(m["max"].(int))
        }</span>

        <span class="cov0" title="0">mp := &amp;models.V1AwsMachinePoolConfigEntity{
                CloudConfig: &amp;models.V1AwsMachinePoolCloudConfigEntity{
                        Azs:            azs,
                        InstanceType:   types.Ptr(m["instance_type"].(string)),
                        CapacityType:   &amp;capacityType,
                        RootDeviceSize: SafeInt64(m["disk_size_gb"].(int)),
                        Subnets:        azSubnetsConfigs,
                },
                PoolConfig: &amp;models.V1MachinePoolConfigEntity{
                        AdditionalLabels:        toAdditionalNodePoolLabels(m),
                        AdditionalAnnotations:   toAdditionalNodePoolAnnotations(m),
                        Taints:                  toClusterTaints(m),
                        IsControlPlane:          controlPlane,
                        Labels:                  labels,
                        Name:                    types.Ptr(m["name"].(string)),
                        Size:                    types.Ptr(SafeInt32(m["count"].(int))),
                        UpdateStrategy:          toUpdateStrategy(m),
                        MinSize:                 min,
                        MaxSize:                 max,
                        UseControlPlaneAsWorker: controlPlaneAsWorker,
                },
        }

        // Handle override_kubeadm_configuration (worker pools only)
        if !controlPlane </span><span class="cov0" title="0">{
                if overrideKubeadm, ok := m["override_kubeadm_configuration"].(string); ok &amp;&amp; overrideKubeadm != "" </span><span class="cov0" title="0">{
                        mp.PoolConfig.OverrideKubeadmConfiguration = overrideKubeadm
                }</span>
        }

        <span class="cov0" title="0">if !controlPlane </span><span class="cov0" title="0">{
                nodeRepaveInterval := 0
                if m["node_repave_interval"] != nil </span><span class="cov0" title="0">{
                        nodeRepaveInterval = m["node_repave_interval"].(int)
                }</span>
                <span class="cov0" title="0">mp.PoolConfig.NodeRepaveInterval = SafeInt32(nodeRepaveInterval)</span>
        } else<span class="cov0" title="0"> {
                err := ValidationNodeRepaveIntervalForControlPlane(m["node_repave_interval"].(int))
                if err != nil </span><span class="cov0" title="0">{
                        return mp, err
                }</span>
        }

        <span class="cov0" title="0">if capacityType == "spot" </span><span class="cov0" title="0">{
                maxPrice := "0.0" // default value
                if m["max_price"] != nil &amp;&amp; len(m["max_price"].(string)) &gt; 0 </span><span class="cov0" title="0">{
                        maxPrice = m["max_price"].(string)
                }</span>

                <span class="cov0" title="0">mp.CloudConfig.SpotMarketOptions = &amp;models.V1SpotMarketOptions{
                        MaxPrice: maxPrice,
                }</span>
        }

        <span class="cov0" title="0">if m["additional_security_groups"] != nil </span><span class="cov0" title="0">{
                mp.CloudConfig.AdditionalSecurityGroups = setAdditionalSecurityGroups(m)
        }</span>

        <span class="cov0" title="0">return mp, nil</span>
}
</pre>
		
		<pre class="file" id="file129" style="display: none">package spectrocloud

import (
        "context"
        "fmt"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
)

func resourceClusterAwsImport(ctx context.Context, d *schema.ResourceData, m interface{}) ([]*schema.ResourceData, error) <span class="cov0" title="0">{
        c, err := GetCommonCluster(d, m)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">diags := resourceClusterAwsRead(ctx, d, m)
        if diags.HasError() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("could not read cluster for import: %v", diags)
        }</span>

        // cluster profile and common default cluster attribute is get set here
        <span class="cov0" title="0">err = flattenCommonAttributeForClusterImport(c, d)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Return the resource data. In most cases, this method is only used to
        // import one resource at a time, so you should return the resource data
        // in a slice with a single element.
        <span class="cov0" title="0">return []*schema.ResourceData{d}, nil</span>
}
</pre>
		
		<pre class="file" id="file130" style="display: none">package spectrocloud

import (
        "context"
        "fmt"
        "log"
        "time"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"

        "github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/schemas"
        "github.com/spectrocloud/terraform-provider-spectrocloud/types"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

        "github.com/spectrocloud/palette-sdk-go/api/models"
        "github.com/spectrocloud/palette-sdk-go/client"
)

func resourceClusterAzure() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                CreateContext: resourceClusterAzureCreate,
                ReadContext:   resourceClusterAzureRead,
                UpdateContext: resourceClusterAzureUpdate,
                DeleteContext: resourceClusterDelete,
                Importer: &amp;schema.ResourceImporter{
                        StateContext: resourceClusterAzureImport,
                },
                Description: "Resource for managing Azure clusters in Spectro Cloud through Palette.",

                Timeouts: &amp;schema.ResourceTimeout{
                        Create: schema.DefaultTimeout(60 * time.Minute),
                        Update: schema.DefaultTimeout(60 * time.Minute),
                        Delete: schema.DefaultTimeout(60 * time.Minute),
                },

                Schema: map[string]*schema.Schema{
                        "name": {
                                Type:        schema.TypeString,
                                Required:    true,
                                ForceNew:    true,
                                Description: "Name of the cluster. This name will be used to create the cluster in Azure.",
                        },
                        "context": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "project",
                                ValidateFunc: validation.StringInSlice([]string{"", "project", "tenant"}, false),
                                Description: "The context of the Azure cluster. Allowed values are `project` or `tenant`. " +
                                        "Default is `project`. " + PROJECT_NAME_NUANCE,
                        },
                        "tags": {
                                Type:     schema.TypeSet,
                                Optional: true,
                                Set:      schema.HashString,
                                Elem: &amp;schema.Schema{
                                        Type: schema.TypeString,
                                },
                                Description: "A list of tags to be applied to the cluster. Tags must be in the form of `key:value`.",
                        },
                        "description": {
                                Type:        schema.TypeString,
                                Optional:    true,
                                Default:     "",
                                Description: "The description of the cluster. Default value is empty string.",
                        },
                        "cluster_meta_attribute": {
                                Type:        schema.TypeString,
                                Optional:    true,
                                Description: "`cluster_meta_attribute` can be used to set additional cluster metadata information, eg `{'nic_name': 'test', 'env': 'stage'}`",
                        },
                        "cluster_profile":  schemas.ClusterProfileSchema(),
                        "cluster_template": schemas.ClusterTemplateSchema(),
                        "apply_setting": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "DownloadAndInstall",
                                ValidateFunc: validation.StringInSlice([]string{"DownloadAndInstall", "DownloadAndInstallLater"}, false),
                                Description: "The setting to apply the cluster profile. `DownloadAndInstall` will download and install packs in one action. " +
                                        "`DownloadAndInstallLater` will only download artifact and postpone install for later. " +
                                        "Default value is `DownloadAndInstall`.",
                        },
                        "cloud_account_id": {
                                Type:        schema.TypeString,
                                Required:    true,
                                ForceNew:    true,
                                Description: "ID of the cloud account to be used for the cluster. This cloud account must be of type `azure`.",
                        },
                        "cloud_config_id": {
                                Type:        schema.TypeString,
                                Computed:    true,
                                Description: "ID of the cloud config used for the cluster. This cloud config must be of type `azure`.",
                                Deprecated:  "This field is deprecated and will be removed in the future. Use `cloud_config` instead.",
                        },
                        "review_repave_state": {
                                Type:         schema.TypeString,
                                Default:      "",
                                Optional:     true,
                                ValidateFunc: validateReviewRepaveValue,
                                Description:  "To authorize the cluster repave, set the value to `Approved` for approval and `\"\"` to decline. Default value is `\"\"`.",
                        },
                        "pause_agent_upgrades": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "unlock",
                                ValidateFunc: validation.StringInSlice([]string{"lock", "unlock"}, false),
                                Description:  "The pause agent upgrades setting allows to control the automatic upgrade of the Palette component and agent for an individual cluster. The default value is `unlock`, meaning upgrades occur automatically. Setting it to `lock` pauses automatic agent upgrades for the cluster.",
                        },
                        "os_patch_on_boot": {
                                Type:        schema.TypeBool,
                                Optional:    true,
                                Default:     false,
                                Description: "Whether to apply OS patch on boot. Default is `false`.",
                        },
                        "os_patch_schedule": {
                                Type:             schema.TypeString,
                                Optional:         true,
                                ValidateDiagFunc: validateOsPatchSchedule,
                                Description:      "Cron schedule for OS patching. This must be in the form of `0 0 * * *`.",
                        },
                        "os_patch_after": {
                                Type:             schema.TypeString,
                                Optional:         true,
                                ValidateDiagFunc: validateOsPatchOnDemandAfter,
                                Description:      "Date and time after which to patch cluster `RFC3339: 2006-01-02T15:04:05Z07:00`",
                        },
                        "cluster_timezone": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "",
                                ValidateFunc: validateTimezone,
                                Description:  "Defines the time zone used by this cluster to interpret scheduled operations. Maintenance tasks like upgrades will follow this time zone to ensure they run at the appropriate local time for the cluster. Must be in IANA timezone format (e.g., 'America/New_York', 'Asia/Kolkata', 'Europe/London').",
                        },
                        "kubeconfig": {
                                Type:        schema.TypeString,
                                Computed:    true,
                                Description: "Kubeconfig for the cluster. This can be used to connect to the cluster using `kubectl`.",
                        },
                        "admin_kube_config": {
                                Type:        schema.TypeString,
                                Computed:    true,
                                Description: "Admin Kube-config for the cluster. This can be used to connect to the cluster using `kubectl`, With admin privilege.",
                        },
                        "cloud_config": {
                                Type:     schema.TypeList,
                                ForceNew: true,
                                Required: true,
                                MaxItems: 1,
                                Elem: &amp;schema.Resource{
                                        Schema: map[string]*schema.Schema{
                                                "subscription_id": {
                                                        Type:        schema.TypeString,
                                                        Required:    true,
                                                        Description: "Azure subscription ID. This can be found in the Azure portal under `Subscriptions`.",
                                                },
                                                "resource_group": {
                                                        Type:        schema.TypeString,
                                                        Required:    true,
                                                        Description: "Azure resource group. This can be found in the Azure portal under `Resource groups`.",
                                                },
                                                "region": {
                                                        Type:        schema.TypeString,
                                                        Required:    true,
                                                        Description: "Azure region. This can be found in the Azure portal under `Resource groups`.",
                                                },
                                                "ssh_key": {
                                                        Type:        schema.TypeString,
                                                        Required:    true,
                                                        Description: "Public SSH key to be used for the cluster nodes.",
                                                },
                                                "storage_account_name": {
                                                        Type:        schema.TypeString,
                                                        Optional:    true,
                                                        Default:     "",
                                                        Description: "Azure storage account name.",
                                                },
                                                "container_name": {
                                                        Type:        schema.TypeString,
                                                        Optional:    true,
                                                        Default:     "",
                                                        Description: "Container name within your azure storage account.",
                                                },
                                                "network_resource_group": {
                                                        Type:         schema.TypeString,
                                                        Optional:     true,
                                                        RequiredWith: []string{"cloud_config.0.virtual_network_name", "cloud_config.0.virtual_network_cidr_block", "cloud_config.0.control_plane_subnet", "cloud_config.0.worker_node_subnet"},
                                                        Description:  "Azure network resource group in which the cluster is to be provisioned.",
                                                },
                                                "virtual_network_name": {
                                                        Type:         schema.TypeString,
                                                        Optional:     true,
                                                        RequiredWith: []string{"cloud_config.0.network_resource_group", "cloud_config.0.virtual_network_cidr_block", "cloud_config.0.control_plane_subnet", "cloud_config.0.worker_node_subnet"},
                                                        Description:  "Azure virtual network in which the cluster is to be provisioned.",
                                                },
                                                "virtual_network_cidr_block": {
                                                        Type:         schema.TypeString,
                                                        Optional:     true,
                                                        RequiredWith: []string{"cloud_config.0.network_resource_group", "cloud_config.0.virtual_network_name", "cloud_config.0.control_plane_subnet", "cloud_config.0.worker_node_subnet"},
                                                        Description:  "Azure virtual network cidr block in which the cluster is to be provisioned.",
                                                },
                                                "control_plane_subnet": schemas.SubnetSchema(),
                                                "worker_node_subnet":   schemas.SubnetSchema(),
                                                "private_api_server": {
                                                        Type:         schema.TypeList,
                                                        Optional:     true,
                                                        MaxItems:     1,
                                                        RequiredWith: []string{"cloud_config.0.network_resource_group", "cloud_config.0.virtual_network_name", "cloud_config.0.virtual_network_cidr_block"},
                                                        Description:  "Custom private DNS zone for your cluster's API server. For more details, refer to the https://docs.spectrocloud.com/clusters/public-cloud/azure/create-azure-cluster/#private-api-server-lb-settings",
                                                        Elem: &amp;schema.Resource{
                                                                Schema: map[string]*schema.Schema{
                                                                        "resource_group": {
                                                                                Type:        schema.TypeString,
                                                                                Required:    true,
                                                                                Description: "The resource group of the private DNS zone.",
                                                                        },
                                                                        "private_dns_zone": {
                                                                                Type:        schema.TypeString,
                                                                                Optional:    true,
                                                                                Description: "The private DNS zone for the cluster. This is optional. If not provided, a new private DNS zone will be created.",
                                                                        },
                                                                        "static_ip": {
                                                                                Type:        schema.TypeString,
                                                                                Optional:    true,
                                                                                Description: "Static IP address for the private API server load balancer. This is optional. If not provided, Dynamic IP allocation will be used.",
                                                                        },
                                                                },
                                                        },
                                                },
                                        },
                                },
                        },
                        "machine_pool": {
                                Type:     schema.TypeSet,
                                Required: true,
                                Set:      resourceMachinePoolAzureHash,
                                Elem: &amp;schema.Resource{
                                        Schema: map[string]*schema.Schema{
                                                "additional_labels": {
                                                        Type:     schema.TypeMap,
                                                        Optional: true,
                                                        Elem: &amp;schema.Schema{
                                                                Type: schema.TypeString,
                                                        },
                                                        Description: "Additional labels to be applied to the machine pool. Labels must be in the form of `key:value`.",
                                                },
                                                "additional_annotations": {
                                                        Type:     schema.TypeMap,
                                                        Optional: true,
                                                        Elem: &amp;schema.Schema{
                                                                Type: schema.TypeString,
                                                        },
                                                        Description: "Additional annotations to be applied to the machine pool. Annotations must be in the form of `key:value`.",
                                                },
                                                "node":   schemas.NodeSchema(),
                                                "taints": schemas.ClusterTaintsSchema(),
                                                "control_plane": {
                                                        Type:     schema.TypeBool,
                                                        Optional: true,
                                                        Default:  false,
                                                        //ForceNew: true,
                                                        Description: "Whether this machine pool is a control plane. Defaults to `false`.",
                                                },
                                                "control_plane_as_worker": {
                                                        Type:     schema.TypeBool,
                                                        Optional: true,
                                                        Default:  false,
                                                        //ForceNew: true,
                                                        Description: "Whether this machine pool is a control plane and a worker. Defaults to `false`.",
                                                },
                                                "name": {
                                                        Type:     schema.TypeString,
                                                        Required: true,
                                                        //ForceNew: true,
                                                        Description: "Name of the machine pool. This must be unique within the cluster.",
                                                },
                                                "count": {
                                                        Type:        schema.TypeInt,
                                                        Required:    true,
                                                        Description: "Number of nodes in the machine pool.",
                                                },
                                                "node_repave_interval": {
                                                        Type:        schema.TypeInt,
                                                        Optional:    true,
                                                        Default:     0,
                                                        Description: "Minimum number of seconds node should be Ready, before the next node is selected for repave. Default value is `0`, Applicable only for worker pools.",
                                                },
                                                "instance_type": {
                                                        Type:        schema.TypeString,
                                                        Required:    true,
                                                        Description: "Azure instance type from the Azure portal.",
                                                },
                                                "update_strategy": {
                                                        Type:         schema.TypeString,
                                                        Optional:     true,
                                                        Default:      "RollingUpdateScaleOut",
                                                        Description:  "Update strategy for the machine pool. Valid values are `RollingUpdateScaleOut`, `RollingUpdateScaleIn` and `OverrideScaling`. If `OverrideScaling` is used, `override_scaling` must be specified with both `max_surge` and `max_unavailable`.",
                                                        ValidateFunc: validation.StringInSlice([]string{"RollingUpdateScaleOut", "RollingUpdateScaleIn", "OverrideScaling"}, false),
                                                },
                                                "override_scaling": schemas.OverrideScalingSchema(),
                                                "override_kubeadm_configuration": {
                                                        Type:        schema.TypeString,
                                                        Optional:    true,
                                                        Description: "YAML config for kubeletExtraArgs, preKubeadmCommands, postKubeadmCommands. Overrides pack-level settings. Worker pools only.",
                                                },
                                                "disk": {
                                                        Type:     schema.TypeList,
                                                        Optional: true,
                                                        Computed: true,
                                                        // Unfortunately can't do any defaulting
                                                        // https://github.com/hashicorp/terraform-plugin-sdk/issues/142
                                                        //DefaultFunc: func() (interface{}, error) {
                                                        //        disk := map[string]interface{}{
                                                        //                "size_gb": 55,
                                                        //                "type" : "Standard_LRS",
                                                        //        }
                                                        //        //return "us-west", nil
                                                        //        return []interface{}{disk}, nil
                                                        //},
                                                        MaxItems: 1,
                                                        Elem: &amp;schema.Resource{
                                                                Schema: map[string]*schema.Schema{
                                                                        "size_gb": {
                                                                                Type:        schema.TypeInt,
                                                                                Required:    true,
                                                                                Description: "Size of the disk in GB.",
                                                                        },
                                                                        "type": {
                                                                                Type:        schema.TypeString,
                                                                                Required:    true,
                                                                                Description: "Type of the disk. Valid values are `Standard_LRS`, `StandardSSD_LRS`, `Premium_LRS`.",
                                                                        },
                                                                },
                                                        },
                                                        Description: "Disk configuration for the machine pool.",
                                                },
                                                "azs": {
                                                        Type:     schema.TypeSet,
                                                        Optional: true,
                                                        Set:      schema.HashString,
                                                        Elem: &amp;schema.Schema{
                                                                Type: schema.TypeString,
                                                        },
                                                        Description: "Availability zones for the machine pool. Check if your region provides availability zones on [the Azure documentation](https://learn.microsoft.com/en-us/azure/reliability/availability-zones-service-support#azure-regions-with-availability-zone-support). Default value is `[\"\"]`.",
                                                        DefaultFunc: func() (any, error) </span><span class="cov0" title="0">{
                                                                return []string{""}, nil
                                                        }</span>,
                                                },
                                                "is_system_node_pool": {
                                                        Type:        schema.TypeBool,
                                                        Optional:    true,
                                                        Default:     false,
                                                        Description: "Whether this machine pool is a system node pool. Default value is `false'.",
                                                },
                                                "os_type": {
                                                        Type:     schema.TypeString,
                                                        Optional: true,
                                                        DiffSuppressFunc: func(k, old, new string, d *schema.ResourceData) bool <span class="cov0" title="0">{
                                                                return false
                                                        }</span>,
                                                        Default:      "Linux",
                                                        ValidateFunc: validation.StringInSlice([]string{"Linux", "Windows"}, false),
                                                        Description:  "Operating system type for the machine pool. Valid values are `Linux` and `Windows`. Defaults to `Linux`.",
                                                },
                                        },
                                },
                        },
                        "backup_policy":        schemas.BackupPolicySchema(),
                        "scan_policy":          schemas.ScanPolicySchema(),
                        "cluster_rbac_binding": schemas.ClusterRbacBindingSchema(),
                        "namespaces":           schemas.ClusterNamespacesSchema(),
                        "host_config":          schemas.ClusterHostConfigSchema(),
                        "location_config":      schemas.ClusterLocationSchemaComputed(),
                        "skip_completion": {
                                Type:        schema.TypeBool,
                                Optional:    true,
                                Default:     false,
                                Description: "If `true`, the cluster will be created asynchronously. Default value is `false`.",
                        },
                        "force_delete": {
                                Type:        schema.TypeBool,
                                Optional:    true,
                                Default:     false,
                                Description: "If set to `true`, the cluster will be force deleted and user has to manually clean up the provisioned cloud resources.",
                        },
                        "force_delete_delay": {
                                Type:             schema.TypeInt,
                                Optional:         true,
                                Default:          20,
                                Description:      "Delay duration in minutes to before invoking cluster force delete. Default and minimum is 20.",
                                ValidateDiagFunc: validation.ToDiagFunc(validation.IntAtLeast(20)),
                        },
                },
        }
}

func resourceClusterAzureCreate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        resourceContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, resourceContext)

        // Warning or errors can be collected in a slice type
        var diags diag.Diagnostics

        // Validate override_Scaling configuration
        if err := validateOverrideScaling(d, "machine_pool"); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">cluster, err := toAzureCluster(c, d)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">diags = validateCPPoolCount(cluster.Spec.Machinepoolconfig)
        if diags != nil </span><span class="cov0" title="0">{
                return diags
        }</span>

        <span class="cov0" title="0">uid, err := c.CreateClusterAzure(cluster)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">diagnostics, isError := waitForClusterCreation(ctx, d, uid, diags, c, true)
        if len(diagnostics) &gt; 0 </span><span class="cov0" title="0">{
                diags = append(diags, diagnostics...)
        }</span>
        <span class="cov0" title="0">if isError </span><span class="cov0" title="0">{
                return diagnostics
        }</span>

        <span class="cov0" title="0">resourceClusterAzureRead(ctx, d, m)

        return diags</span>
}

//goland:noinspection GoUnhandledErrorResult
func resourceClusterAzureRead(_ context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        resourceContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, resourceContext)

        var diags diag.Diagnostics

        cluster, err := resourceClusterRead(d, c, diags)
        if err != nil </span><span class="cov0" title="0">{
                return handleReadError(d, err, diags)
        }</span> else<span class="cov0" title="0"> if cluster == nil </span><span class="cov0" title="0">{
                // Deleted - Terraform will recreate it
                d.SetId("")
                return diags
        }</span>
        // verify cluster type
        <span class="cov0" title="0">err = ValidateCloudType("spectrocloud_cluster_azure", cluster)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">diagnostics, done := readCommonFields(c, d, cluster)
        if done </span><span class="cov0" title="0">{
                return diagnostics
        }</span>

        // Flatten cluster_template variables using variables API
        <span class="cov0" title="0">if err := flattenClusterTemplateVariables(c, d, d.Id()); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">return flattenCloudConfigAzure(cluster.Spec.CloudConfigRef.UID, d, c)</span>
}
func flattenClusterConfigsAzure(config *models.V1AzureCloudConfig) []interface{} <span class="cov0" title="0">{
        if config == nil || config.Spec == nil || config.Spec.ClusterConfig == nil </span><span class="cov0" title="0">{
                return make([]interface{}, 0)
        }</span>
        <span class="cov0" title="0">m := make(map[string]interface{})
        if config.Spec.ClusterConfig.SubscriptionID != nil </span><span class="cov0" title="0">{
                m["subscription_id"] = config.Spec.ClusterConfig.SubscriptionID
        }</span>
        <span class="cov0" title="0">if config.Spec.ClusterConfig.ResourceGroup != "" </span><span class="cov0" title="0">{
                m["resource_group"] = config.Spec.ClusterConfig.ResourceGroup
        }</span>
        <span class="cov0" title="0">if config.Spec.ClusterConfig.Location != nil </span><span class="cov0" title="0">{
                m["region"] = config.Spec.ClusterConfig.Location
        }</span>
        <span class="cov0" title="0">if config.Spec.ClusterConfig.SSHKey != nil </span><span class="cov0" title="0">{
                m["ssh_key"] = config.Spec.ClusterConfig.SSHKey
        }</span>
        <span class="cov0" title="0">if config.Spec.ClusterConfig.StorageAccountName != "" </span><span class="cov0" title="0">{
                m["storage_account_name"] = config.Spec.ClusterConfig.StorageAccountName
        }</span>
        <span class="cov0" title="0">if config.Spec.ClusterConfig.ContainerName != "" </span><span class="cov0" title="0">{
                m["container_name"] = config.Spec.ClusterConfig.ContainerName
        }</span>
        <span class="cov0" title="0">if config.Spec.ClusterConfig.VnetResourceGroup != "" </span><span class="cov0" title="0">{
                m["network_resource_group"] = config.Spec.ClusterConfig.VnetResourceGroup
        }</span>
        <span class="cov0" title="0">if config.Spec.ClusterConfig.VnetName != "" </span><span class="cov0" title="0">{
                m["virtual_network_name"] = config.Spec.ClusterConfig.VnetName
        }</span>
        <span class="cov0" title="0">if config.Spec.ClusterConfig.VnetCidrBlock != "" </span><span class="cov0" title="0">{
                m["virtual_network_cidr_block"] = config.Spec.ClusterConfig.VnetCidrBlock
        }</span>
        <span class="cov0" title="0">if config.Spec.ClusterConfig.VnetResourceGroup != "" &amp;&amp; config.Spec.ClusterConfig.VnetName != "" &amp;&amp; config.Spec.ClusterConfig.VnetCidrBlock != "" </span><span class="cov0" title="0">{
                if config.Spec.ClusterConfig.ControlPlaneSubnet != nil </span><span class="cov0" title="0">{
                        cpSubnet := map[string]interface{}{
                                "name":                config.Spec.ClusterConfig.ControlPlaneSubnet.Name,
                                "cidr_block":          config.Spec.ClusterConfig.ControlPlaneSubnet.CidrBlock,
                                "security_group_name": config.Spec.ClusterConfig.ControlPlaneSubnet.SecurityGroupName,
                        }
                        m["control_plane_subnet"] = []interface{}{cpSubnet}
                }</span>
                <span class="cov0" title="0">if config.Spec.ClusterConfig.WorkerSubnet != nil </span><span class="cov0" title="0">{
                        workerSubnet := map[string]interface{}{
                                "name":                config.Spec.ClusterConfig.WorkerSubnet.Name,
                                "cidr_block":          config.Spec.ClusterConfig.WorkerSubnet.CidrBlock,
                                "security_group_name": config.Spec.ClusterConfig.WorkerSubnet.SecurityGroupName,
                        }
                        m["worker_node_subnet"] = []interface{}{workerSubnet}
                }</span>
                <span class="cov0" title="0">if config.Spec.ClusterConfig.InfraLBConfig != nil </span><span class="cov0" title="0">{
                        if config.Spec.ClusterConfig.InfraLBConfig.APIServerLB != nil </span><span class="cov0" title="0">{
                                m["private_api_server"] = []interface{}{map[string]interface{}{
                                        "resource_group":   config.Spec.ClusterConfig.InfraLBConfig.APIServerLB.PrivateDNSZoneResourceGroup,
                                        "private_dns_zone": config.Spec.ClusterConfig.InfraLBConfig.APIServerLB.PrivateDNSName,
                                        "static_ip":        config.Spec.ClusterConfig.InfraLBConfig.APIServerLB.APIServerLBStaticIP,
                                }}
                        }</span>
                }
        }

        <span class="cov0" title="0">return []interface{}{m}</span>
}
func flattenCloudConfigAzure(configUID string, d *schema.ResourceData, c *client.V1Client) diag.Diagnostics <span class="cov0" title="0">{
        var diags diag.Diagnostics
        if err := d.Set("cloud_config_id", configUID); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">if config, err := c.GetCloudConfigAzure(configUID); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span> else<span class="cov0" title="0"> {
                if err := d.Set("cloud_account_id", config.Spec.CloudAccountRef.UID); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
                <span class="cov0" title="0">if err := d.Set("cloud_config", flattenClusterConfigsAzure(config)); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
                <span class="cov0" title="0">mp := flattenMachinePoolConfigsAzure(config.Spec.MachinePoolConfig)
                mp, err := flattenNodeMaintenanceStatus(c, d, c.GetNodeStatusMapAzure, mp, configUID)
                if err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
                <span class="cov0" title="0">if err := d.Set("machine_pool", mp); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
        }

        <span class="cov0" title="0">generalWarningForRepave(&amp;diags)
        return diags</span>
}

func flattenMachinePoolConfigsAzure(machinePools []*models.V1AzureMachinePoolConfig) []interface{} <span class="cov0" title="0">{
        if machinePools == nil </span><span class="cov0" title="0">{
                return make([]interface{}, 0)
        }</span>

        <span class="cov0" title="0">ois := make([]interface{}, len(machinePools))

        for i, machinePool := range machinePools </span><span class="cov0" title="0">{
                oi := make(map[string]interface{})

                FlattenAdditionalLabelsAnnotationsAndTaints(machinePool.AdditionalLabels, machinePool.AdditionalAnnotations, machinePool.Taints, oi)
                FlattenControlPlaneAndRepaveInterval(machinePool.IsControlPlane, oi, machinePool.NodeRepaveInterval)

                oi["control_plane_as_worker"] = machinePool.UseControlPlaneAsWorker
                oi["name"] = machinePool.Name
                oi["count"] = machinePool.Size
                if machinePool.UpdateStrategy != nil </span><span class="cov0" title="0">{
                        oi["update_strategy"] = machinePool.UpdateStrategy.Type
                        // Flatten override_Scaling if using OverrideScaling strategy
                        flattenOverrideScaling(machinePool.UpdateStrategy, oi)
                }</span>

                // Flatten override_kubeadm_configuration (worker pools only)
                <span class="cov0" title="0">if machinePool.IsControlPlane != nil &amp;&amp; !*machinePool.IsControlPlane &amp;&amp; machinePool.OverrideKubeadmConfiguration != "" </span><span class="cov0" title="0">{
                        oi["override_kubeadm_configuration"] = machinePool.OverrideKubeadmConfiguration
                }</span>

                <span class="cov0" title="0">oi["instance_type"] = machinePool.InstanceType
                oi["is_system_node_pool"] = machinePool.IsSystemNodePool

                oi["azs"] = machinePool.Azs
                oi["os_type"] = machinePool.OsType
                if machinePool.OsDisk != nil </span><span class="cov0" title="0">{
                        d := make(map[string]interface{})
                        d["size_gb"] = machinePool.OsDisk.DiskSizeGB
                        d["type"] = machinePool.OsDisk.ManagedDisk.StorageAccountType

                        oi["disk"] = []interface{}{d}
                }</span>

                <span class="cov0" title="0">ois[i] = oi</span>
        }

        <span class="cov0" title="0">return ois</span>
}

func resourceClusterAzureUpdate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        resourceContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, resourceContext)

        // Warning or errors can be collected in a slice type
        var diags diag.Diagnostics
        err := validateSystemRepaveApproval(d, c)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">cloudConfigId := d.Get("cloud_config_id").(string)
        //ClusterContext := d.Get("context").(string)
        CloudConfig, err := c.GetCloudConfigAzure(cloudConfigId)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">if d.HasChange("machine_pool") </span><span class="cov0" title="0">{
                // Validate override_Scaling configuration
                if err := validateOverrideScaling(d, "machine_pool"); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>

                <span class="cov0" title="0">cluster, err := toAzureCluster(c, d)
                if err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
                <span class="cov0" title="0">diags = validateCPPoolCount(cluster.Spec.Machinepoolconfig)
                if diags != nil </span><span class="cov0" title="0">{
                        return diags
                }</span>
                <span class="cov0" title="0">oraw, nraw := d.GetChange("machine_pool")
                if oraw == nil </span><span class="cov0" title="0">{
                        oraw = new(schema.Set)
                }</span>
                <span class="cov0" title="0">if nraw == nil </span><span class="cov0" title="0">{
                        nraw = new(schema.Set)
                }</span>

                <span class="cov0" title="0">os := oraw.(*schema.Set)
                ns := nraw.(*schema.Set)

                osMap := make(map[string]interface{})
                for _, mp := range os.List() </span><span class="cov0" title="0">{
                        machinePool := mp.(map[string]interface{})
                        osMap[machinePool["name"].(string)] = machinePool
                }</span>

                <span class="cov0" title="0">nsMap := make(map[string]interface{})

                for _, mp := range ns.List() </span><span class="cov0" title="0">{
                        machinePoolResource := mp.(map[string]interface{})
                        nsMap[machinePoolResource["name"].(string)] = machinePoolResource
                        // since known issue in TF SDK: https://github.com/hashicorp/terraform-plugin-sdk/issues/588
                        if machinePoolResource["name"].(string) != "" </span><span class="cov0" title="0">{
                                name := machinePoolResource["name"].(string)
                                hash := resourceMachinePoolAzureHash(machinePoolResource)
                                var err error
                                machinePool, err := toMachinePoolAzure(machinePoolResource)
                                if err != nil </span><span class="cov0" title="0">{
                                        diag.FromErr(err)
                                }</span>

                                <span class="cov0" title="0">if oldMachinePool, ok := osMap[name]; !ok </span><span class="cov0" title="0">{
                                        log.Printf("Create machine pool %s", name)
                                        err = c.CreateMachinePoolAzure(cloudConfigId, machinePool)
                                }</span> else<span class="cov0" title="0"> if hash != resourceMachinePoolAzureHash(oldMachinePool) </span><span class="cov0" title="0">{
                                        log.Printf("Change in machine pool %s", name)
                                        err = c.UpdateMachinePoolAzure(cloudConfigId, machinePool)
                                        // Node Maintenance Actions
                                        err := resourceNodeAction(c, ctx, nsMap[name], c.GetNodeMaintenanceStatusAzure, CloudConfig.Kind, cloudConfigId, name)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return diag.FromErr(err)
                                        }</span>
                                }

                                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                                        return diag.FromErr(err)
                                }</span>

                                // Processed (if exists)
                                <span class="cov0" title="0">delete(osMap, name)</span>
                        }
                }

                // Deleted old machine pools
                <span class="cov0" title="0">for _, mp := range osMap </span><span class="cov0" title="0">{
                        machinePool := mp.(map[string]interface{})
                        name := machinePool["name"].(string)
                        log.Printf("Deleted machine pool %s", name)
                        if err := c.DeleteMachinePoolAzure(cloudConfigId, name); err != nil </span><span class="cov0" title="0">{
                                return diag.FromErr(err)
                        }</span>
                }
        }

        <span class="cov0" title="0">diagnostics, done := updateCommonFields(d, c)
        if done </span><span class="cov0" title="0">{
                return diagnostics
        }</span>

        <span class="cov0" title="0">resourceClusterAzureRead(ctx, d, m)

        return diags</span>
}

func toAzureCluster(c *client.V1Client, d *schema.ResourceData) (*models.V1SpectroAzureClusterEntity, error) <span class="cov0" title="0">{
        // gnarly, I know! =/
        cloudConfig := d.Get("cloud_config").([]interface{})[0].(map[string]interface{})
        //clientSecret := strfmt.Password(d.Get("azure_client_secret").(string))
        clusterContext := d.Get("context").(string)
        profiles, err := toProfiles(c, d, clusterContext)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">cluster := &amp;models.V1SpectroAzureClusterEntity{
                Metadata: getClusterMetadata(d),
                Spec: &amp;models.V1SpectroAzureClusterEntitySpec{
                        CloudAccountUID: types.Ptr(d.Get("cloud_account_id").(string)),
                        Profiles:        profiles,
                        ClusterTemplate: toClusterTemplateReference(d),
                        Policies:        toPolicies(d),
                        CloudConfig: &amp;models.V1AzureClusterConfig{
                                Location:           types.Ptr(cloudConfig["region"].(string)),
                                SSHKey:             types.Ptr(cloudConfig["ssh_key"].(string)),
                                SubscriptionID:     types.Ptr(cloudConfig["subscription_id"].(string)),
                                ResourceGroup:      cloudConfig["resource_group"].(string),
                                StorageAccountName: cloudConfig["storage_account_name"].(string),
                                ContainerName:      cloudConfig["container_name"].(string),
                        },
                },
        }
        // setting static placements
        toStaticPlacement(cluster, cloudConfig)
        //for _, machinePool := range d.Get("machine_pool").([]interface{}) {
        machinePoolConfigs := make([]*models.V1AzureMachinePoolConfigEntity, 0)
        for _, machinePool := range d.Get("machine_pool").(*schema.Set).List() </span><span class="cov0" title="0">{
                mp, err := toMachinePoolAzure(machinePool)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">machinePoolConfigs = append(machinePoolConfigs, mp)</span>
        }

        <span class="cov0" title="0">cluster.Spec.Machinepoolconfig = machinePoolConfigs
        cluster.Spec.ClusterConfig = toClusterConfig(d)

        return cluster, nil</span>
}

func toStaticPlacement(c *models.V1SpectroAzureClusterEntity, cloudConfig map[string]interface{}) <span class="cov0" title="0">{
        if v, ok := cloudConfig["network_resource_group"]; ok &amp;&amp; v != "" </span><span class="cov0" title="0">{
                c.Spec.CloudConfig.VnetResourceGroup = cloudConfig["network_resource_group"].(string)
                c.Spec.CloudConfig.VnetName = cloudConfig["virtual_network_name"].(string)
                c.Spec.CloudConfig.VnetCidrBlock = cloudConfig["virtual_network_cidr_block"].(string)
                cpSubnet := cloudConfig["control_plane_subnet"].([]interface{})[0].(map[string]interface{})
                c.Spec.CloudConfig.ControlPlaneSubnet = &amp;models.V1Subnet{
                        CidrBlock:         cpSubnet["cidr_block"].(string),
                        Name:              cpSubnet["name"].(string),
                        SecurityGroupName: cpSubnet["security_group_name"].(string),
                }
                workerSubnet := cloudConfig["worker_node_subnet"].([]interface{})[0].(map[string]interface{})
                c.Spec.CloudConfig.WorkerSubnet = &amp;models.V1Subnet{
                        CidrBlock:         workerSubnet["cidr_block"].(string),
                        Name:              workerSubnet["name"].(string),
                        SecurityGroupName: workerSubnet["security_group_name"].(string),
                }

                if v, ok := cloudConfig["private_api_server"]; ok </span><span class="cov0" title="0">{
                        privateApiServer := v.([]interface{})
                        if len(privateApiServer) &gt; 0 </span><span class="cov0" title="0">{
                                privateApiServerConfig := privateApiServer[0].(map[string]interface{})
                                apiServerLB := &amp;models.V1LoadBalancerSpec{
                                        PrivateDNSZoneResourceGroup: privateApiServerConfig["resource_group"].(string),
                                        PrivateDNSName:              privateApiServerConfig["private_dns_zone"].(string),
                                        APIServerLBStaticIP:         privateApiServerConfig["static_ip"].(string),
                                        IPAllocationMethod:          chooseIPMethod(privateApiServerConfig["static_ip"].(string)),
                                        Type:                        StringPtr("Internal"),
                                }
                                c.Spec.CloudConfig.InfraLBConfig = &amp;models.V1InfraLBConfig{
                                        APIServerLB: apiServerLB,
                                }
                        }</span>
                } else<span class="cov0" title="0"> {
                        apiServerLB := &amp;models.V1LoadBalancerSpec{
                                IPAllocationMethod:          chooseIPMethod(""),
                                Type:                        StringPtr("Public"),
                                PrivateDNSZoneResourceGroup: "",
                                PrivateDNSName:              "",
                                APIServerLBStaticIP:         "",
                        }
                        c.Spec.CloudConfig.InfraLBConfig = &amp;models.V1InfraLBConfig{
                                APIServerLB: apiServerLB,
                        }
                }</span>
        }
}

func chooseIPMethod(ip string) *string <span class="cov0" title="0">{
        if ip == "" </span><span class="cov0" title="0">{
                return StringPtr("Dynamic")
        }</span>
        <span class="cov0" title="0">return StringPtr("Static")</span>
}

func toMachinePoolAzure(machinePool interface{}) (*models.V1AzureMachinePoolConfigEntity, error) <span class="cov0" title="0">{
        m := machinePool.(map[string]interface{})

        labels := make([]string, 0)
        controlPlane := m["control_plane"].(bool)
        controlPlaneAsWorker := m["control_plane_as_worker"].(bool)
        if controlPlane </span><span class="cov0" title="0">{
                labels = append(labels, "control-plane")
        }</span> else<span class="cov0" title="0"> {
                labels = append(labels, "worker")
        }</span>

        <span class="cov0" title="0">var diskSize, diskType = DefaultDiskSize, DefaultDiskType
        disks := m["disk"].([]interface{})
        if len(disks) &gt; 0 </span><span class="cov0" title="0">{
                disk0 := disks[0].(map[string]interface{})
                diskSize = disk0["size_gb"].(int)
                diskType = disk0["type"].(string)
        }</span>

        <span class="cov0" title="0">azs := make([]string, 0)
        for _, az := range m["azs"].(*schema.Set).List() </span><span class="cov0" title="0">{
                azs = append(azs, az.(string))
        }</span>

        <span class="cov0" title="0">osType := models.V1OsTypeLinux

        if m["os_type"] != "" </span><span class="cov0" title="0">{
                os_type := m["os_type"].(string)
                if os_type == "Windows" </span><span class="cov0" title="0">{
                        osType = models.V1OsTypeWindows
                }</span>
        }

        <span class="cov0" title="0">mp := &amp;models.V1AzureMachinePoolConfigEntity{
                CloudConfig: &amp;models.V1AzureMachinePoolCloudConfigEntity{
                        Azs:          azs,
                        InstanceType: m["instance_type"].(string),
                        OsDisk: &amp;models.V1AzureOSDisk{
                                DiskSizeGB: SafeInt32(diskSize),
                                ManagedDisk: &amp;models.V1ManagedDisk{
                                        StorageAccountType: diskType,
                                },
                                OsType: &amp;osType,
                        },
                        IsSystemNodePool: m["is_system_node_pool"].(bool),
                },
                ManagedPoolConfig: &amp;models.V1AzureManagedMachinePoolConfig{
                        IsSystemNodePool: m["is_system_node_pool"].(bool),
                },
                PoolConfig: &amp;models.V1MachinePoolConfigEntity{
                        AdditionalLabels:        toAdditionalNodePoolLabels(m),
                        AdditionalAnnotations:   toAdditionalNodePoolAnnotations(m),
                        Taints:                  toClusterTaints(m),
                        IsControlPlane:          controlPlane,
                        Labels:                  labels,
                        Name:                    types.Ptr(m["name"].(string)),
                        Size:                    types.Ptr(SafeInt32(m["count"].(int))),
                        UpdateStrategy:          toUpdateStrategy(m),
                        UseControlPlaneAsWorker: controlPlaneAsWorker,
                },
        }

        // Handle override_kubeadm_configuration (worker pools only)
        if !controlPlane </span><span class="cov0" title="0">{
                if overrideKubeadm, ok := m["override_kubeadm_configuration"].(string); ok &amp;&amp; overrideKubeadm != "" </span><span class="cov0" title="0">{
                        mp.PoolConfig.OverrideKubeadmConfiguration = overrideKubeadm
                }</span>
        }

        <span class="cov0" title="0">if !controlPlane </span><span class="cov0" title="0">{
                nodeRepaveInterval := 0
                if m["node_repave_interval"] != nil </span><span class="cov0" title="0">{
                        nodeRepaveInterval = m["node_repave_interval"].(int)
                }</span>
                <span class="cov0" title="0">mp.PoolConfig.NodeRepaveInterval = SafeInt32(nodeRepaveInterval)</span>
        } else<span class="cov0" title="0"> {
                err := ValidationNodeRepaveIntervalForControlPlane(m["node_repave_interval"].(int))
                if err != nil </span><span class="cov0" title="0">{
                        return mp, err
                }</span>
        }

        <span class="cov0" title="0">return mp, nil</span>
}

func validateCPPoolCount(machinePool []*models.V1AzureMachinePoolConfigEntity) diag.Diagnostics <span class="cov0" title="0">{
        for _, machineConfig := range machinePool </span><span class="cov0" title="0">{
                if machineConfig.PoolConfig.IsControlPlane </span><span class="cov0" title="0">{
                        if *machineConfig.PoolConfig.Size%2 == 0 </span><span class="cov0" title="0">{
                                return diag.FromErr(fmt.Errorf("the control-plane node pool size should be in an odd number, but it set to an even number '%d' in node name '%s'", *machineConfig.PoolConfig.Size, *machineConfig.PoolConfig.Name))
                        }</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file131" style="display: none">package spectrocloud

import (
        "context"
        "fmt"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
)

func resourceClusterAzureImport(ctx context.Context, d *schema.ResourceData, m interface{}) ([]*schema.ResourceData, error) <span class="cov0" title="0">{
        c, err := GetCommonCluster(d, m)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">diags := resourceClusterAzureRead(ctx, d, m)
        if diags.HasError() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("could not read cluster for import: %v", diags)
        }</span>

        // cluster profile and common default cluster attribute is get set here
        <span class="cov0" title="0">err = flattenCommonAttributeForClusterImport(c, d)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return []*schema.ResourceData{d}, nil</span>
}
</pre>
		
		<pre class="file" id="file132" style="display: none">package spectrocloud

import (
        "context"
        "fmt"
        "strings"
        "time"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
        "github.com/spectrocloud/palette-sdk-go/api/models"
        "github.com/spectrocloud/palette-sdk-go/client"
        "github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/schemas"
)

func resourceClusterBrownfield() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                CreateContext: resourceClusterBrownfieldImportCreate,
                ReadContext:   resourceClusterBrownfieldRead,
                UpdateContext: resourceClusterBrownfieldUpdate,
                DeleteContext: resourceClusterDelete,
                Importer: &amp;schema.ResourceImporter{
                        StateContext: resourceClusterBrownfieldImport,
                },
                SchemaVersion: 1,
                Timeouts: &amp;schema.ResourceTimeout{
                        Create: schema.DefaultTimeout(10 * time.Minute),
                        Read:   schema.DefaultTimeout(5 * time.Minute),
                        Update: schema.DefaultTimeout(10 * time.Minute),
                        Delete: schema.DefaultTimeout(10 * time.Minute),
                },
                Description: "Register an existing Kubernetes cluster (brownfield) with Palette. This resource allows you to import and manage existing Kubernetes clusters. Supported cloud platforms: (AWS, Azure, GCP, vSphere, OpenShift, Generic, Apache CloudStack, Edge Native, MAAS, and OpenStack). This feature is currently in preview.",
                Schema: map[string]*schema.Schema{
                        "name": {
                                Type:        schema.TypeString,
                                Required:    true,
                                Description: "The name of the cluster to be registered. This field cannot be updated after creation.",
                        },
                        "tags": {
                                Type:     schema.TypeSet,
                                Optional: true,
                                Set:      schema.HashString,
                                Elem: &amp;schema.Schema{
                                        Type: schema.TypeString,
                                },
                                Description: "A list of tags to be applied to the cluster. Tags must be in the form of `key:value`. The `tags` attribute will soon be deprecated. It is recommended to use `tags_map` instead.",
                        },
                        "description": {
                                Type:        schema.TypeString,
                                Optional:    true,
                                Default:     "",
                                Description: "The description of the cluster. Default value is empty string.",
                        },
                        "cloud_type": {
                                Type:     schema.TypeString,
                                Required: true,
                                ValidateFunc: validation.StringInSlice([]string{
                                        "aws",
                                        "eks-anywhere",
                                        "azure",
                                        "gcp",
                                        "vsphere",
                                        "openshift",
                                        "generic",
                                        "apache-cloudstack",
                                        "edge-native",
                                        "maas",
                                        "openstack",
                                }, false),
                                Description: "The cloud type of the cluster. Supported values: `aws`, `eks-anywhere`, `azure`, `gcp`, `vsphere`, `openshift`, `generic`,`apache-cloudstack`,`edge-native`,`maas`,`openstack`. This field cannot be updated after creation.",
                        },
                        "import_mode": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "",
                                ValidateFunc: validation.StringInSlice([]string{"read_only", "full", ""}, false),
                                Description:  "The import mode for the cluster. Allowed values are `read_only` (imports cluster with read-only permissions) or `full` (imports cluster with full permissions). Defaults to `full`. This field cannot be updated after creation.",
                        },
                        "host_path": {
                                Type:        schema.TypeString,
                                Optional:    true,
                                Default:     "",
                                Description: "Location for Proxy CA cert on host nodes. This is the file path on the host where the Proxy CA certificate is stored. This field cannot be updated after creation.",
                        },
                        "container_mount_path": {
                                Type:        schema.TypeString,
                                Optional:    true,
                                Default:     "",
                                Description: "Location to mount Proxy CA cert inside container. This is the file path inside the container where the Proxy CA certificate will be mounted. This field cannot be updated after creation.",
                        },
                        "context": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "project",
                                ValidateFunc: validation.StringInSlice([]string{"project", "tenant"}, false),
                                Description:  "The context for the cluster registration. Allowed values are `project` or `tenant`. Defaults to `project`. This field cannot be updated after creation." + PROJECT_NAME_NUANCE,
                        },
                        "proxy": {
                                Type:        schema.TypeString,
                                Optional:    true,
                                Default:     "",
                                Description: "Location to mount Proxy CA cert inside container. This field supports vsphere and openshift clusters. This field cannot be updated after creation.",
                        },
                        "no_proxy": {
                                Type:        schema.TypeString,
                                Optional:    true,
                                Default:     "",
                                Description: "Location to mount Proxy CA cert inside container. This field supports vsphere and openshift clusters. This field cannot be updated after creation.",
                        },
                        "manifest_url": {
                                Type:        schema.TypeString,
                                Computed:    true,
                                Description: "The URL of the import manifest that must be applied to your Kubernetes cluster to complete the import into Palette.",
                        },
                        "kubectl_command": {
                                Type:        schema.TypeString,
                                Computed:    true,
                                Description: "The kubectl command that must be executed on your Kubernetes cluster to complete the import process into Palette.",
                        },
                        "status": {
                                Type:        schema.TypeString,
                                Computed:    true,
                                Description: "The current operational state of the cluster. Possible values include: `Pending`, `Provisioning`, `Running`, `Deleting`, `Deleted`, `Error`, `Importing`.",
                        },
                        "health_status": {
                                Type:        schema.TypeString,
                                Computed:    true,
                                Description: "The current health status of the cluster. Possible values include: `Healthy`, `UnHealthy`, `Unknown`.",
                        },
                        "cloud_config_id": {
                                Type:        schema.TypeString,
                                Computed:    true,
                                Description: "ID of the cloud config used for the cluster. This is automatically set from the cluster's cloud config reference.",
                        },
                        "cluster_timezone": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "",
                                ValidateFunc: validateTimezone,
                                Description:  "Defines the time zone used by this cluster to interpret scheduled operations. Maintenance tasks like upgrades will follow this time zone to ensure they run at the appropriate local time for the cluster. Must be in IANA timezone format (e.g., 'America/New_York', 'Asia/Kolkata', 'Europe/London').",
                        },
                        "apply_setting": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "DownloadAndInstall",
                                ValidateFunc: validation.StringInSlice([]string{"DownloadAndInstall", "DownloadAndInstallLater"}, false),
                                Description: "The setting to apply the cluster profile. `DownloadAndInstall` will download and install packs in one action. " +
                                        "`DownloadAndInstallLater` will only download artifact and postpone install for later. " +
                                        "Default value is `DownloadAndInstall`.",
                        },
                        "cluster_profile": schemas.ClusterProfileSchema(),
                        "machine_pool": {
                                Type:     schema.TypeSet,
                                Optional: true,

                                Elem: &amp;schema.Resource{
                                        Schema: map[string]*schema.Schema{
                                                "name": {
                                                        Type:        schema.TypeString,
                                                        Required:    true,
                                                        Description: "The name of the machine pool.",
                                                },
                                                "node": {
                                                        Type:     schema.TypeList,
                                                        Optional: true,
                                                        Elem: &amp;schema.Resource{
                                                                Schema: map[string]*schema.Schema{
                                                                        "node_name": {
                                                                                Type:        schema.TypeString,
                                                                                Optional:    true,
                                                                                Description: "The name of the machine pool.",
                                                                        },
                                                                        "node_id": {
                                                                                Type:        schema.TypeString,
                                                                                Optional:    true,
                                                                                Description: "The node_id of the node, For example `i-07f899a33dee624f7`",
                                                                        },
                                                                        "action": {
                                                                                Type:         schema.TypeString,
                                                                                Required:     true,
                                                                                Description:  "The action to perform on the node. Valid values are: `cordon`, `uncordon`.",
                                                                                ValidateFunc: validation.StringInSlice([]string{"cordon", "uncordon"}, false),
                                                                        },
                                                                },
                                                        },
                                                },
                                        },
                                },
                                Description: "Machine pool configuration for Day-2 node maintenance operations. Used to perform node actions like cordon/uncordon on specific nodes.",
                        },
                        "review_repave_state": {
                                Type:         schema.TypeString,
                                Default:      "",
                                Optional:     true,
                                ValidateFunc: validateReviewRepaveValue,
                                Description:  "To authorize the cluster repave, set the value to `Approved` for approval and `\"\"` to decline. Default value is `\"\"`.",
                        },
                        "pause_agent_upgrades": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "unlock",
                                ValidateFunc: validation.StringInSlice([]string{"lock", "unlock"}, false),
                                Description:  "The pause agent upgrades setting allows to control the automatic upgrade of the Palette component and agent for an individual cluster. The default value is `unlock`, meaning upgrades occur automatically. Setting it to `lock` pauses automatic agent upgrades for the cluster.",
                        },
                        "backup_policy":        schemas.BackupPolicySchema(),
                        "scan_policy":          schemas.ScanPolicySchema(),
                        "cluster_rbac_binding": schemas.ClusterRbacBindingSchema(),
                        "namespaces":           schemas.ClusterNamespacesSchema(),
                        "host_config":          schemas.ClusterHostConfigSchema(),
                        "location_config":      schemas.ClusterLocationSchemaComputed(),
                        "skip_completion": {
                                Type:        schema.TypeBool,
                                Optional:    true,
                                Default:     false,
                                Description: "If `true`, the cluster will be created asynchronously. Default value is `false`.",
                        },
                        "force_delete": {
                                Type:        schema.TypeBool,
                                Optional:    true,
                                Default:     false,
                                Description: "If set to `true`, the cluster will be force deleted and user has to manually clean up the provisioned cloud resources.",
                        },
                        "force_delete_delay": {
                                Type:             schema.TypeInt,
                                Optional:         true,
                                Default:          20,
                                Description:      "Delay duration in minutes to before invoking cluster force delete. Default and minimum is 20.",
                                ValidateDiagFunc: validation.ToDiagFunc(validation.IntAtLeast(20)),
                        },
                },
        }
}</span>

func resourceClusterBrownfieldImportCreate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        resourceContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, resourceContext)
        var diags diag.Diagnostics

        cloudType := d.Get("cloud_type").(string)
        // name := d.Get("name").(string)

        // Build metadata
        metadata := toBrownfieldClusterMetadata(d)

        // Register the cluster based on cloud type
        var clusterUID string
        var err error

        switch cloudType </span>{
        case "aws":<span class="cov0" title="0">
                entity := &amp;models.V1SpectroAwsClusterImportEntity{
                        Metadata: metadata,
                        Spec:     toBrownfieldClusterSpecAws(d),
                }
                clusterUID, err = c.ImportSpectroClusterAws(entity)</span>
        case "azure":<span class="cov0" title="0">
                entity := &amp;models.V1SpectroAzureClusterImportEntity{
                        Metadata: metadata,
                        Spec:     toBrownfieldClusterSpecAzure(d),
                }
                clusterUID, err = c.ImportSpectroClusterAzure(entity)</span>
        case "gcp":<span class="cov0" title="0">
                entity := &amp;models.V1SpectroGcpClusterImportEntity{
                        Metadata: metadata,
                        Spec:     toBrownfieldClusterSpecGcp(d),
                }
                clusterUID, err = c.ImportSpectroClusterGcp(entity)</span>
        case "vsphere", "openshift":<span class="cov0" title="0">
                entity := &amp;models.V1SpectroVsphereClusterImportEntity{
                        Metadata: metadata,
                        Spec:     toBrownfieldClusterSpecVsphere(d),
                }
                clusterUID, err = c.ImportSpectroVsphereCluster(entity)</span>
        case "generic", "eks-anywhere":<span class="cov0" title="0">
                entity := &amp;models.V1SpectroGenericClusterImportEntity{
                        Metadata: metadata,
                        Spec:     toBrownfieldClusterSpecGeneric(d),
                }
                clusterUID, err = c.ImportSpectroClusterGeneric(entity)</span>
        case "apache-cloudstack":<span class="cov0" title="0">
                entity := &amp;models.V1SpectroCloudStackClusterImportEntity{
                        Metadata: metadata,
                        Spec:     toBrownfieldClusterSpecCloudStack(d),
                }
                clusterUID, err = c.ImportSpectroClusterApacheCloudStack(entity)</span>
        case "maas":<span class="cov0" title="0">
                entity := &amp;models.V1SpectroMaasClusterImportEntity{
                        Metadata: metadata,
                        Spec:     toBrownfieldClusterSpecMaas(d),
                }
                clusterUID, err = c.ImportSpectroClusterMaas(entity)</span>
        case "edge-native":<span class="cov0" title="0">
                entity := &amp;models.V1SpectroEdgeNativeClusterImportEntity{
                        Metadata: metadata,
                        Spec:     toBrownfieldClusterSpecEdgeNative(d),
                }
                clusterUID, err = c.ImportSpectroClusterEdgeNative(entity)</span>

        default:<span class="cov0" title="0">
                return diag.FromErr(fmt.Errorf("unsupported cloud type: %s", cloudType))</span>
        }

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(fmt.Errorf("failed to register brownfield cluster: %w", err))
        }</span>

        // Set the cluster UID as the resource ID
        <span class="cov0" title="0">d.SetId(clusterUID)

        // Wait 3 seconds for cluster to be initialized before fetching details
        time.Sleep(5 * time.Second)

        cluster, err := c.GetCluster(clusterUID)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(fmt.Errorf("failed to get cluster: %w", err))
        }</span>
        <span class="cov0" title="0">if cluster == nil </span><span class="cov0" title="0">{
                return diag.FromErr(fmt.Errorf("cluster not found"))
        }</span>

        // Get the import link and manifest URL from cluster object
        <span class="cov0" title="0">kubectlCommand, manifestURL, err := getClusterImportInfo(cluster)

        if err != nil </span><span class="cov0" title="0">{
                // Log warning but don't fail - import link may not be available immediately
                diags = append(diags, diag.Diagnostic{
                        Severity: diag.Warning,
                        Summary:  "Import link not immediately available",
                        Detail:   fmt.Sprintf("Cluster registered successfully, but import link is not yet available: %v. You may need to run 'terraform refresh' to get the import link.", err),
                })
        }</span> else<span class="cov0" title="0"> {
                if err := d.Set("kubectl_command", kubectlCommand); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
                <span class="cov0" title="0">if err := d.Set("manifest_url", manifestURL); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
                // Show warning message about applying manifest
                <span class="cov0" title="0">diags = append(diags, diag.Diagnostic{
                        Severity: diag.Warning,
                        Summary:  "Cluster import submitted",
                        Detail:   "Cluster import is submitted. Please apply the manifest using `manifest_url` and run `kubectl_command` on your cluster to start the import process. Once it becomes Running and Healthy, Day-2 operations will be allowed.",
                })</span>
        }
        <span class="cov0" title="0">updateCommonFieldsForBrownfieldCluster(d, c)

        resourceClusterBrownfieldRead(ctx, d, m)
        return diags</span>
}

// Read function - reads the current state of the cluster
func resourceClusterBrownfieldRead(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        resourceContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, resourceContext)
        var diags diag.Diagnostics
        clusterUID := d.Id()

        // Get the cluster to verify it exists
        cluster, err := c.GetCluster(clusterUID)
        if err != nil </span><span class="cov0" title="0">{
                return handleReadError(d, err, diags)
        }</span>
        <span class="cov0" title="0">if cluster == nil </span><span class="cov0" title="0">{
                // Cluster has been deleted
                d.SetId("")
                return diags
        }</span>

        // Always update computed fields
        // Status - always update from API
        <span class="cov0" title="0">if cluster.Status != nil &amp;&amp; cluster.Status.State != "" </span><span class="cov0" title="0">{
                if err := d.Set("status", cluster.Status.State); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
        } else<span class="cov0" title="0"> {
                // Set empty string if status is not available
                if err := d.Set("status", ""); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
        }

        // Read common fields (wrapped to skip fields not in schema)
        <span class="cov0" title="0">readDiags, hasError := readCommonFieldsBrownfield(c, d, cluster)
        if hasError </span><span class="cov0" title="0">{
                diags = append(diags, readDiags...)
                return diags
        }</span>
        <span class="cov0" title="0">diags = append(diags, readDiags...)

        // Get the import link and manifest URL from cluster object
        kubectlCommand, manifestURL, err := getClusterImportInfo(cluster)
        if err != nil </span><span class="cov0" title="0">{
                // Import link may not be available - show warning
                diags = append(diags, diag.Diagnostic{
                        Severity: diag.Warning,
                        Summary:  "kubectl_command not available",
                        Detail:   fmt.Sprintf("kubectl_command is not yet available for cluster %s: %v", clusterUID, err),
                })
                // Set empty strings for computed fields when not available
                if err := d.Set("kubectl_command", ""); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
                <span class="cov0" title="0">if err := d.Set("manifest_url", ""); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
        } else<span class="cov0" title="0"> {
                // Set computed fields from API
                if err := d.Set("kubectl_command", kubectlCommand); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
                <span class="cov0" title="0">if err := d.Set("manifest_url", manifestURL); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>

                // Show warning if cluster is not Running and kubectl_command is available
                <span class="cov0" title="0">if cluster.Status != nil &amp;&amp; cluster.Status.State != "Running" </span><span class="cov0" title="0">{
                        diags = append(diags, diag.Diagnostic{
                                Severity: diag.Warning,
                                Summary:  "Cluster import pending",
                                Detail:   "Cluster import is submitted. Please apply the manifest using `manifest_url` and run `kubectl_command` on your cluster to start the import process. Once it becomes Running and Healthy, Day-2 operations will be allowed.",
                        })
                }</span>
        }

        // Set cloud_config_id from cluster spec
        <span class="cov0" title="0">if cluster.Spec != nil &amp;&amp; cluster.Spec.CloudConfigRef != nil &amp;&amp; cluster.Spec.CloudConfigRef.UID != "" </span><span class="cov0" title="0">{
                if err := d.Set("cloud_config_id", cluster.Spec.CloudConfigRef.UID); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
        }

        // Set health_status from cluster overview
        <span class="cov0" title="0">clusterSummary, err := c.GetClusterOverview(clusterUID)
        if err != nil </span><span class="cov0" title="0">{
                // If we can't get overview, set to "Unknown"
                if err := d.Set("health_status", "Unknown"); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
        } else<span class="cov0" title="0"> if clusterSummary != nil &amp;&amp; clusterSummary.Status != nil &amp;&amp; clusterSummary.Status.Health != nil &amp;&amp; clusterSummary.Status.Health.State != "" </span><span class="cov0" title="0">{
                // Set health status from cluster overview
                if err := d.Set("health_status", clusterSummary.Status.Health.State); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
        } else<span class="cov0" title="0"> {
                // If health is not available, set to "Unknown"
                if err := d.Set("health_status", "Unknown"); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
        }

        <span class="cov0" title="0">return diags</span>
}

// Update function - handles Day-2 operations
func resourceClusterBrownfieldUpdate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        resourceContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, resourceContext)
        var diags diag.Diagnostics

        // Validate Day-1 fields are immutable
        if day1Diags := validateDay1FieldsImmutable(d); len(day1Diags) &gt; 0 </span><span class="cov0" title="0">{
                return day1Diags
        }</span>

        // Get cluster to check status and get cloud config info
        <span class="cov0" title="0">cluster, err := c.GetCluster(d.Id())
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(fmt.Errorf("failed to get cluster: %w", err))
        }</span>
        <span class="cov0" title="0">if cluster == nil </span><span class="cov0" title="0">{
                return diag.FromErr(fmt.Errorf("cluster not found"))
        }</span>

        // Check if any Day-2 fields have changed
        <span class="cov0" title="0">day2Fields := []string{
                "cluster_profile", "backup_policy", "scan_policy", "cluster_rbac_binding",
                "namespaces", "host_config", "location_config", "cluster_timezone",
                "apply_setting", "review_repave_state", "description", "tags", "machine_pool",
                "pause_agent_upgrades",
        }
        hasDay2Changes := false
        for _, field := range day2Fields </span><span class="cov0" title="0">{
                if d.HasChange(field) </span><span class="cov0" title="0">{
                        hasDay2Changes = true
                        break</span>
                }
        }

        // If Day-2 fields changed, validate cluster is Running-Healthy
        <span class="cov0" title="0">if hasDay2Changes </span><span class="cov0" title="0">{
                isHealthy, currentState := isClusterRunningHealthy(cluster, c)
                if !isHealthy </span><span class="cov0" title="0">{
                        diags = append(diags, diag.Diagnostic{
                                Severity: diag.Warning,
                                Summary:  "Cluster is not in Running-Healthy state",
                                Detail:   fmt.Sprintf("Day-2 operations may not work as expected when the cluster is not in Running-Healthy state. Current state: %s", currentState),
                        })
                }</span>

                // Validate system repave approval if review_repave_state changed
                <span class="cov0" title="0">if d.HasChange("review_repave_state") </span><span class="cov0" title="0">{
                        if err := validateSystemRepaveApproval(d, c); err != nil </span><span class="cov0" title="0">{
                                return diag.FromErr(err)
                        }</span>
                }

                // Handle machine_pool changes for node actions
                <span class="cov0" title="0">if d.HasChange("machine_pool") </span><span class="cov0" title="0">{
                        cloudConfigId := d.Get("cloud_config_id").(string)
                        if cloudConfigId == "" </span><span class="cov0" title="0">{
                                return diag.Errorf("cloud_config_id is required for machine_pool operations but is not available. Please ensure the cluster has been imported and is Running-Healthy.")
                        }</span>

                        <span class="cov0" title="0">cloudType := d.Get("cloud_type").(string)
                        getNodeMaintenanceStatusFn := getNodeMaintenanceStatusForCloudType(c, cloudType)
                        if getNodeMaintenanceStatusFn == nil </span><span class="cov0" title="0">{
                                return diag.Errorf("node maintenance operations are not supported for cloud_type: %s", cloudType)
                        }</span>

                        // Get new machine pools
                        <span class="cov0" title="0">nraw := d.Get("machine_pool")
                        if nraw == nil </span><span class="cov0" title="0">{
                                return diags // No machine pools to process
                        }</span>

                        <span class="cov0" title="0">ns := nraw.(*schema.Set)
                        if ns == nil || ns.Len() == 0 </span><span class="cov0" title="0">{
                                return diags // No machine pools to process
                        }</span>

                        // Get cloud config kind from cluster
                        <span class="cov0" title="0">cloudConfigKind := ""
                        if cluster.Spec != nil &amp;&amp; cluster.Spec.CloudConfigRef != nil </span><span class="cov0" title="0">{
                                cloudConfigKind = cluster.Spec.CloudConfigRef.Kind
                        }</span>
                        <span class="cov0" title="0">if cloudConfigKind == "" </span><span class="cov0" title="0">{
                                cloudConfigKind = cloudType // Fallback to cloud_type
                        }</span>

                        // Process all machine pools
                        <span class="cov0" title="0">for _, mp := range ns.List() </span><span class="cov0" title="0">{
                                machinePool := mp.(map[string]interface{})
                                machinePoolName := machinePool["name"].(string)
                                if machinePoolName == "" </span><span class="cov0" title="0">{
                                        return diag.Errorf("machine_pool.name is required for node actions")
                                }</span>

                                <span class="cov0" title="0">nodes := machinePool["node"]
                                if nodes == nil </span><span class="cov0" title="0">{
                                        continue</span> // Skip machine pools without nodes
                                }

                                <span class="cov0" title="0">nodeList := nodes.([]interface{})
                                if len(nodeList) == 0 </span><span class="cov0" title="0">{
                                        continue</span> // Skip machine pools with empty node lists
                                }

                                // Resolve node_id for each node if not provided
                                <span class="cov0" title="0">for _, n := range nodeList </span><span class="cov0" title="0">{
                                        node := n.(map[string]interface{})
                                        nodeID, hasNodeID := node["node_id"].(string)
                                        nodeName, hasNodeName := node["node_name"].(string)

                                        // If node_id is not provided but node_name is provided, resolve it
                                        if (!hasNodeID || nodeID == "") &amp;&amp; hasNodeName &amp;&amp; nodeName != "" </span><span class="cov0" title="0">{
                                                resolvedNodeID, err := resolveNodeID(c, cloudType, cloudConfigId, machinePoolName, nodeName)
                                                if err != nil </span><span class="cov0" title="0">{
                                                        return diag.FromErr(fmt.Errorf("failed to resolve node_id for node '%s' in machine pool '%s': %w", nodeName, machinePoolName, err))
                                                }</span>
                                                <span class="cov0" title="0">node["node_id"] = resolvedNodeID</span>
                                        } else<span class="cov0" title="0"> if (!hasNodeID || nodeID == "") &amp;&amp; (!hasNodeName || nodeName == "") </span><span class="cov0" title="0">{
                                                return diag.Errorf("either node_id or node_name must be provided for each node in machine_pool '%s'", machinePoolName)
                                        }</span>
                                }

                                // Create a machine pool structure with all nodes
                                <span class="cov0" title="0">machinePoolForAction := map[string]interface{}{
                                        "node": nodeList,
                                }

                                // Call resourceNodeAction for node maintenance operations
                                // Use machinePoolName (from machine_pool.name) as the MachineName parameter
                                if err := resourceNodeAction(c, ctx, machinePoolForAction, getNodeMaintenanceStatusFn, cloudConfigKind, cloudConfigId, machinePoolName); err != nil </span><span class="cov0" title="0">{
                                        return diag.FromErr(fmt.Errorf("failed to perform node action on machine pool %s: %w", machinePoolName, err))
                                }</span>
                        }
                }
        }

        // Update common fields for Day-2 operations
        <span class="cov0" title="0">updateDiags, done := updateCommonFields(d, c)
        if done </span><span class="cov0" title="0">{
                return updateDiags
        }</span>
        <span class="cov0" title="0">diags = append(diags, updateDiags...)

        // Refresh state
        readDiags := resourceClusterBrownfieldRead(ctx, d, m)
        diags = append(diags, readDiags...)

        return diags</span>
}

// Helper Functions

// toBrownfieldClusterMetadata converts Terraform schema to V1ObjectMetaInputEntity
func toBrownfieldClusterMetadata(d *schema.ResourceData) *models.V1ObjectMetaInputEntity <span class="cov0" title="0">{
        metadata := &amp;models.V1ObjectMetaInputEntity{
                Name: d.Get("name").(string),
        }
        return metadata
}</span>

// toBrownfieldClusterSpecGeneric converts Terraform schema to V1SpectroGenericClusterImportEntitySpec
func toBrownfieldClusterSpecGeneric(d *schema.ResourceData) *models.V1SpectroGenericClusterImportEntitySpec <span class="cov0" title="0">{
        spec := &amp;models.V1SpectroGenericClusterImportEntitySpec{}
        spec.ClusterConfig = toImportClusterConfig(d)
        return spec
}</span>

// toBrownfieldClusterSpecCloudStack converts Terraform schema to V1SpectroCloudStackClusterImportEntitySpec
func toBrownfieldClusterSpecCloudStack(d *schema.ResourceData) *models.V1SpectroCloudStackClusterImportEntitySpec <span class="cov0" title="0">{
        spec := &amp;models.V1SpectroCloudStackClusterImportEntitySpec{}
        spec.ClusterConfig = toImportClusterConfig(d)
        return spec
}</span>

// toBrownfieldClusterSpecMaas converts Terraform schema to V1SpectroMaasClusterImportEntitySpec
func toBrownfieldClusterSpecMaas(d *schema.ResourceData) *models.V1SpectroMaasClusterImportEntitySpec <span class="cov0" title="0">{
        spec := &amp;models.V1SpectroMaasClusterImportEntitySpec{}
        spec.ClusterConfig = toImportClusterConfig(d)
        return spec
}</span>

// toBrownfieldClusterSpecEdgeNative converts Terraform schema to V1SpectroEdgeNativeClusterImportEntitySpec
func toBrownfieldClusterSpecEdgeNative(d *schema.ResourceData) *models.V1SpectroEdgeNativeClusterImportEntitySpec <span class="cov0" title="0">{
        spec := &amp;models.V1SpectroEdgeNativeClusterImportEntitySpec{}
        spec.ClusterConfig = toImportClusterConfig(d)
        return spec
}</span>

// toBrownfieldClusterSpecAws converts Terraform schema to V1SpectroAwsClusterImportEntitySpec
func toBrownfieldClusterSpecAws(d *schema.ResourceData) *models.V1SpectroAwsClusterImportEntitySpec <span class="cov0" title="0">{
        spec := &amp;models.V1SpectroAwsClusterImportEntitySpec{}
        spec.ClusterConfig = toImportClusterConfig(d)
        return spec
}</span>

// toBrownfieldClusterSpecAzure converts Terraform schema to V1SpectroAzureClusterImportEntitySpec
func toBrownfieldClusterSpecAzure(d *schema.ResourceData) *models.V1SpectroAzureClusterImportEntitySpec <span class="cov0" title="0">{
        spec := &amp;models.V1SpectroAzureClusterImportEntitySpec{}
        spec.ClusterConfig = toImportClusterConfig(d)
        return spec
}</span>

// toBrownfieldClusterSpecGcp converts Terraform schema to V1SpectroGcpClusterImportEntitySpec
func toBrownfieldClusterSpecGcp(d *schema.ResourceData) *models.V1SpectroGcpClusterImportEntitySpec <span class="cov0" title="0">{
        spec := &amp;models.V1SpectroGcpClusterImportEntitySpec{}
        spec.ClusterConfig = toImportClusterConfig(d)
        return spec
}</span>

// toBrownfieldClusterSpecVsphere converts Terraform schema to V1SpectroVsphereClusterImportEntitySpec
func toBrownfieldClusterSpecVsphere(d *schema.ResourceData) *models.V1SpectroVsphereClusterImportEntitySpec <span class="cov0" title="0">{
        spec := &amp;models.V1SpectroVsphereClusterImportEntitySpec{}
        spec.ClusterConfig = toImportClusterConfig(d)
        return spec
}</span>

// / toImportClusterConfig converts Terraform schema to V1ImportClusterConfig
func toImportClusterConfig(d *schema.ResourceData) *models.V1ImportClusterConfig <span class="cov0" title="0">{
        config := &amp;models.V1ImportClusterConfig{}

        // Set ImportMode if provided
        if importMode, ok := d.GetOk("import_mode"); ok </span><span class="cov0" title="0">{
                mode := importMode.(string)
                // Convert "read_only" to "read-only" for API
                switch mode </span>{
                case "read_only":<span class="cov0" title="0">
                        config.ImportMode = "read-only"</span>
                case "full":<span class="cov0" title="0">
                        // API expects empty string (or not set) for full mode
                        // Leave config.ImportMode as empty string (default)
                        config.ImportMode = ""</span>

                default:<span class="cov0" title="0">
                        config.ImportMode = ""</span>
                }
        } else<span class="cov0" title="0"> {
                // Default is "full" - API expects empty string
                config.ImportMode = ""
        }</span>

        // Set Proxy if any proxy-related fields are provided (for vsphere and openshift clusters)
        <span class="cov0" title="0">_, hasProxy := d.GetOk("proxy")
        _, hasNoProxy := d.GetOk("no_proxy")
        _, hasHostPath := d.GetOk("host_path")
        _, hasContainerMountPath := d.GetOk("container_mount_path")

        if hasProxy || hasNoProxy || hasHostPath || hasContainerMountPath </span><span class="cov0" title="0">{
                proxySpec := &amp;models.V1ClusterProxySpec{}

                if httpProxy, ok := d.GetOk("proxy"); ok </span><span class="cov0" title="0">{
                        proxySpec.HTTPProxy = httpProxy.(string)
                }</span>

                <span class="cov0" title="0">if noProxy, ok := d.GetOk("no_proxy"); ok </span><span class="cov0" title="0">{
                        proxySpec.NoProxy = noProxy.(string)
                }</span>

                <span class="cov0" title="0">if hostPath, ok := d.GetOk("host_path"); ok </span><span class="cov0" title="0">{
                        proxySpec.CaHostPath = hostPath.(string)
                }</span>

                <span class="cov0" title="0">if containerMountPath, ok := d.GetOk("container_mount_path"); ok </span><span class="cov0" title="0">{
                        proxySpec.CaContainerMountPath = containerMountPath.(string)
                }</span>

                // Only set proxy if at least one field is set
                <span class="cov0" title="0">if proxySpec.HTTPProxy != "" || proxySpec.NoProxy != "" || proxySpec.CaHostPath != "" || proxySpec.CaContainerMountPath != "" </span><span class="cov0" title="0">{
                        config.Proxy = proxySpec
                }</span>
        }

        <span class="cov0" title="0">return config</span>
}

// readCommonFieldsBrownfield wraps readCommonFields to skip fields that don't exist in brownfield schema
func readCommonFieldsBrownfield(c *client.V1Client, d *schema.ResourceData, cluster *models.V1SpectroCluster) (diag.Diagnostics, bool) <span class="cov0" title="0">{
        // Set tags (always present)
        if err := d.Set("tags", flattenTags(cluster.Metadata.Labels)); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err), true
        }</span>

        // Set backup_policy if field exists
        <span class="cov0" title="0">if _, ok := d.GetOk("backup_policy"); ok </span><span class="cov0" title="0">{
                if policy, err := c.GetClusterBackupConfig(d.Id()); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err), true
                }</span> else<span class="cov0" title="0"> if policy != nil &amp;&amp; policy.Spec.Config != nil </span><span class="cov0" title="0">{
                        if err := d.Set("backup_policy", flattenBackupPolicy(policy.Spec.Config, d)); err != nil </span><span class="cov0" title="0">{
                                return diag.FromErr(err), true
                        }</span>
                }
        }

        // Set scan_policy if field exists
        <span class="cov0" title="0">if _, ok := d.GetOk("scan_policy"); ok </span><span class="cov0" title="0">{
                if policy, err := c.GetClusterScanConfig(d.Id()); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err), true
                }</span> else<span class="cov0" title="0"> if policy != nil &amp;&amp; policy.Spec.DriverSpec != nil </span><span class="cov0" title="0">{
                        if err := d.Set("scan_policy", flattenScanPolicy(policy.Spec.DriverSpec)); err != nil </span><span class="cov0" title="0">{
                                return diag.FromErr(err), true
                        }</span>
                }
        }

        // Set cluster_rbac_binding if field exists
        <span class="cov0" title="0">if _, ok := d.GetOk("cluster_rbac_binding"); ok </span><span class="cov0" title="0">{
                if rbac, err := c.GetClusterRbacConfig(d.Id()); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err), true
                }</span> else<span class="cov0" title="0"> if rbac != nil &amp;&amp; rbac.Items != nil </span><span class="cov0" title="0">{
                        if err := d.Set("cluster_rbac_binding", flattenClusterRBAC(rbac.Items)); err != nil </span><span class="cov0" title="0">{
                                return diag.FromErr(err), true
                        }</span>
                }
        }

        // Set namespaces if field exists
        <span class="cov0" title="0">if _, ok := d.GetOk("namespaces"); ok </span><span class="cov0" title="0">{
                if namespace, err := c.GetClusterNamespaceConfig(d.Id()); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err), true
                }</span> else<span class="cov0" title="0"> if namespace != nil &amp;&amp; namespace.Items != nil </span><span class="cov0" title="0">{
                        if err := d.Set("namespaces", flattenClusterNamespaces(namespace.Items)); err != nil </span><span class="cov0" title="0">{
                                return diag.FromErr(err), true
                        }</span>
                }
        }

        // Set cluster_timezone if field exists
        <span class="cov0" title="0">if cluster.Spec.ClusterConfig.Timezone != "" </span><span class="cov0" title="0">{
                if err := d.Set("cluster_timezone", cluster.Spec.ClusterConfig.Timezone); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err), true
                }</span>
        }

        // Set host_config if field exists
        <span class="cov0" title="0">if _, ok := d.GetOk("host_config"); ok </span><span class="cov0" title="0">{
                hostConfig := cluster.Spec.ClusterConfig.HostClusterConfig
                if hostConfig != nil &amp;&amp; *hostConfig.IsHostCluster </span><span class="cov0" title="0">{
                        flattenHostConfig := flattenHostConfig(hostConfig)
                        if len(flattenHostConfig) &gt; 0 </span><span class="cov0" title="0">{
                                if err := d.Set("host_config", flattenHostConfig); err != nil </span><span class="cov0" title="0">{
                                        return diag.FromErr(err), true
                                }</span>
                        }
                }
        }

        // Set review_repave_state if field exists
        <span class="cov0" title="0">if _, ok := d.GetOk("review_repave_state"); ok </span><span class="cov0" title="0">{
                if err := d.Set("review_repave_state", cluster.Status.Repave.State); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err), true
                }</span>
        }

        // Set pause_agent_upgrades - always set during read
        <span class="cov0" title="0">if err := d.Set("pause_agent_upgrades", getSpectroComponentsUpgrade(cluster)); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err), true
        }</span>

        // Set location_config (computed field - always set if available)
        <span class="cov0" title="0">if clusterStatus, err := c.GetClusterWithoutStatus(d.Id()); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err), true
        }</span> else<span class="cov0" title="0"> if clusterStatus != nil &amp;&amp; clusterStatus.Status != nil &amp;&amp; clusterStatus.Status.Location != nil </span><span class="cov0" title="0">{
                if err := d.Set("location_config", flattenLocationConfig(clusterStatus.Status.Location)); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err), true
                }</span>
        }

        <span class="cov0" title="0">return diag.Diagnostics{}, false</span>
}

// isClusterRunningHealthy checks if cluster is in Running-Healthy state
func isClusterRunningHealthy(cluster *models.V1SpectroCluster, c *client.V1Client) (bool, string) <span class="cov0" title="0">{
        if cluster == nil || cluster.Status == nil </span><span class="cov0" title="0">{
                return false, "Unknown"
        }</span>

        <span class="cov0" title="0">state := cluster.Status.State
        if state != "Running" </span><span class="cov0" title="0">{
                return false, state
        }</span>

        // Check health status
        <span class="cov0" title="0">clusterSummary, err := c.GetClusterOverview(cluster.Metadata.UID)
        if err != nil </span><span class="cov0" title="0">{
                // If we can't get overview, assume Running is enough
                return true, state
        }</span>

        <span class="cov0" title="0">if clusterSummary != nil &amp;&amp; clusterSummary.Status != nil &amp;&amp; clusterSummary.Status.Health != nil </span><span class="cov0" title="0">{
                healthState := clusterSummary.Status.Health.State
                if healthState == "Healthy" </span><span class="cov0" title="0">{
                        return true, state + "-" + healthState
                }</span>
                <span class="cov0" title="0">return false, state + "-" + healthState</span>
        }

        // If health is not available, Running is considered acceptable
        <span class="cov0" title="0">return true, state</span>
}

// validateDay1FieldsImmutable validates that Day-1 fields are not being changed
func validateDay1FieldsImmutable(d *schema.ResourceData) diag.Diagnostics <span class="cov0" title="0">{
        var diags diag.Diagnostics

        day1Fields := []string{
                "name", "cloud_type", "import_mode", "host_path",
                "container_mount_path", "context", "proxy", "no_proxy",
        }

        changedFields := []string{}
        for _, field := range day1Fields </span><span class="cov0" title="0">{
                if d.HasChange(field) </span><span class="cov0" title="0">{
                        changedFields = append(changedFields, field)
                }</span>
        }

        <span class="cov0" title="0">if len(changedFields) &gt; 0 </span><span class="cov0" title="0">{
                diags = append(diags, diag.Diagnostic{
                        Severity: diag.Error,
                        Summary:  "Day-1 fields cannot be updated",
                        Detail:   fmt.Sprintf("The following Day-1 fields cannot be updated after creation: %v. These fields are immutable. If you need to change these fields, delete and recreate the resource.", changedFields),
                })
        }</span>

        <span class="cov0" title="0">return diags</span>
}

// getNodeMaintenanceStatusForCloudType returns the appropriate GetNodeMaintenanceStatus function based on cloud_type
func getNodeMaintenanceStatusForCloudType(c *client.V1Client, cloudType string) GetMaintenanceStatus <span class="cov0" title="0">{
        switch cloudType </span>{
        case "aws":<span class="cov0" title="0">
                return c.GetNodeMaintenanceStatusAws</span>
        case "azure":<span class="cov0" title="0">
                return c.GetNodeMaintenanceStatusAzure</span>
        case "gcp":<span class="cov0" title="0">
                return c.GetNodeMaintenanceStatusGcp</span>
        case "vsphere", "openshift":<span class="cov0" title="0">
                return c.GetNodeMaintenanceStatusVsphere</span>
        case "generic", "eks-anywhere":<span class="cov0" title="0">
                return c.GetNodeMaintenanceStatusGeneric</span>
        case "apache-cloudstack":<span class="cov0" title="0">
                return c.GetNodeMaintenanceStatusCloudStack</span>
        case "maas":<span class="cov0" title="0">
                return c.GetNodeMaintenanceStatusMaas</span>
        case "edge-native":<span class="cov0" title="0">
                return c.GetNodeMaintenanceStatusEdgeNative</span>
        case "openstack":<span class="cov0" title="0">
                return c.GetNodeMaintenanceStatusOpenStack</span>
        default:<span class="cov0" title="0">
                return nil</span>
        }
}

// getMachinesListForCloudType returns the appropriate GetMachinesList function based on cloud_type
func getMachinesListForCloudType(c *client.V1Client, cloudType string) func(string, string) (map[string]string, error) <span class="cov0" title="0">{
        switch cloudType </span>{
        case "aws":<span class="cov0" title="0">
                return c.GetMachinesListAws</span>
        case "azure":<span class="cov0" title="0">
                return c.GetMachinesListAzure</span>
        case "gcp":<span class="cov0" title="0">
                return c.GetMachinesListGcp</span>
        case "vsphere", "openshift":<span class="cov0" title="0">
                return c.GetMachinesListVsphere</span>
        case "generic", "eks-anywhere":<span class="cov0" title="0">
                return c.GetMachinesListGeneric</span>
        case "apache-cloudstack":<span class="cov0" title="0">
                return c.GetMachinesListApacheCloudstack</span>
        case "maas":<span class="cov0" title="0">
                return c.GetMachinesListMaas</span>
        case "edge-native":<span class="cov0" title="0">
                return c.GetMachinesListEdgeNative</span>
        case "openstack":<span class="cov0" title="0">
                return c.GetMachinesListOpenStack</span>
        default:<span class="cov0" title="0">
                return nil</span>
        }
}

// resolveNodeID resolves node_id from node_name by listing machines from the cloud config
// Returns the node_id (UID) if found, or an error if not found or if resolution fails
func resolveNodeID(c *client.V1Client, cloudType, cloudConfigUID, machinePoolName, nodeName string) (string, error) <span class="cov0" title="0">{
        getMachinesListFn := getMachinesListForCloudType(c, cloudType)
        if getMachinesListFn == nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("node_id resolution is not supported for cloud_type: %s", cloudType)
        }</span>

        <span class="cov0" title="0">machinesMap, err := getMachinesListFn(cloudConfigUID, machinePoolName)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to list machines: %w", err)
        }</span>

        <span class="cov0" title="0">nodeID, found := machinesMap[nodeName]
        if !found </span><span class="cov0" title="0">{
                return "", fmt.Errorf("node with name '%s' not found in machine pool '%s'", nodeName, machinePoolName)
        }</span>

        <span class="cov0" title="0">return nodeID, nil</span>
}

// getClusterImportInfo extracts the kubectl command and manifest URL from a cluster object.
// Returns kubectl_command, manifest_url, and an error if the import link is not available.
func getClusterImportInfo(cluster *models.V1SpectroCluster) (kubectlCommand, manifestURL string, err error) <span class="cov0" title="0">{
        if cluster == nil </span><span class="cov0" title="0">{
                return "", "", fmt.Errorf("cluster is nil")
        }</span>

        <span class="cov0" title="0">if cluster.Status == nil </span><span class="cov0" title="0">{
                return "", "", fmt.Errorf("cluster status is not available")
        }</span>

        <span class="cov0" title="0">if cluster.Status.ClusterImport == nil </span><span class="cov0" title="0">{
                return "", "", fmt.Errorf("cluster import information is not available")
        }</span>

        <span class="cov0" title="0">kubectlCommand = cluster.Status.ClusterImport.ImportLink
        if kubectlCommand == "" </span><span class="cov0" title="0">{
                return "", "", fmt.Errorf("import link is empty")
        }</span>

        // Extract manifest URL from importLink
        // importLink format: "kubectl apply -f https://api.dev.spectrocloud.com/v1/spectroclusters/{uid}/import/manifest"
        <span class="cov0" title="0">manifestURL = extractManifestURL(kubectlCommand)

        return kubectlCommand, manifestURL, nil</span>
}

// extractManifestURL extracts the manifest URL from the importLink string.
// importLink format: "kubectl apply -f https://api.dev.spectrocloud.com/v1/spectroclusters/{uid}/import/manifest"
// Returns: "https://api.dev.spectrocloud.com/v1/spectroclusters/{uid}/import/manifest"
func extractManifestURL(importLink string) string <span class="cov0" title="0">{
        // Remove "kubectl apply -f" prefix and trim whitespace
        prefix := "kubectl apply -f"
        if strings.HasPrefix(importLink, prefix) </span><span class="cov0" title="0">{
                return strings.TrimSpace(strings.TrimPrefix(importLink, prefix))
        }</span>
        // If already a URL or no prefix, return as-is
        <span class="cov0" title="0">return strings.TrimSpace(importLink)</span>
}

// resourceClusterBrownfieldImport imports an existing brownfield cluster into Terraform state
func resourceClusterBrownfieldImport(ctx context.Context, d *schema.ResourceData, m interface{}) ([]*schema.ResourceData, error) <span class="cov0" title="0">{
        clusterID, scope, customCloudName, err := ParseResourceCustomCloudImportID(d)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">d.SetId(clusterID + ":" + scope)
        _ = d.Set("cloud_type", customCloudName)
        c, err := GetCommonCluster(d, m)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">diags := resourceClusterBrownfieldRead(ctx, d, m)
        if diags.HasError() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("could not read cluster for import: %v", diags)
        }</span>

        // cluster profile and common default cluster attribute is get set here
        <span class="cov0" title="0">err = flattenCommonAttributeForBrownfieldClusterImport(c, d)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Return the resource data. In most cases, this method is only used to
        // import one resource at a time, so you should return the resource data
        // in a slice with a single element.
        <span class="cov0" title="0">return []*schema.ResourceData{d}, nil</span>
}

func flattenCommonAttributeForBrownfieldClusterImport(c *client.V1Client, d *schema.ResourceData) error <span class="cov0" title="0">{
        clusterProfiles, err := flattenClusterProfileForImport(c, d)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">err = d.Set("cluster_profile", clusterProfiles)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var diags diag.Diagnostics
        cluster, err := resourceClusterRead(d, c, diags)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">_ = d.Set("import_mode", "")

        if cluster.Spec.ClusterConfig.Timezone != "" </span><span class="cov0" title="0">{
                if err := d.Set("cluster_timezone", cluster.Spec.ClusterConfig.Timezone); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">if cluster.Metadata.Annotations["description"] != "" </span><span class="cov0" title="0">{
                if err := d.Set("description", cluster.Metadata.Annotations["description"]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">if cluster.Status.SpcApply != nil </span><span class="cov0" title="0">{
                err = d.Set("apply_setting", cluster.Status.SpcApply.ActionType)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">err = d.Set("pause_agent_upgrades", getSpectroComponentsUpgrade(cluster))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if cluster.Status.Repave != nil </span><span class="cov0" title="0">{
                if err = d.Set("review_repave_state", cluster.Status.Repave.State); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">err = d.Set("force_delete", false)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">err = d.Set("force_delete_delay", 20)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">err = d.Set("skip_completion", false)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file133" style="display: none">package spectrocloud

import (
        "context"
        "fmt"
        "strings"
        "time"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
        "github.com/spectrocloud/palette-sdk-go/api/models"
)

func resourceClusterConfigPolicy() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                CreateContext: resourceClusterConfigPolicyCreate,
                ReadContext:   resourceClusterConfigPolicyRead,
                UpdateContext: resourceClusterConfigPolicyUpdate,
                DeleteContext: resourceClusterConfigPolicyDelete,
                Importer: &amp;schema.ResourceImporter{
                        StateContext: resourceClusterConfigPolicyImport,
                },
                Description: "A resource for creating and managing cluster config policies (maintenance policies). **Tech Preview**: This resource is in tech preview and may undergo changes.",

                Timeouts: &amp;schema.ResourceTimeout{
                        Create: schema.DefaultTimeout(10 * time.Minute),
                        Update: schema.DefaultTimeout(10 * time.Minute),
                        Delete: schema.DefaultTimeout(10 * time.Minute),
                },

                SchemaVersion: 1,
                Schema: map[string]*schema.Schema{
                        "name": {
                                Type:        schema.TypeString,
                                Required:    true,
                                Description: "The name of the cluster config policy.",
                        },
                        "context": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "project",
                                ValidateFunc: validation.StringInSlice([]string{"project", "tenant"}, false),
                                Description: "The context of the cluster config policy. Allowed values are `project` or `tenant`. " +
                                        "Default value is `project`. " + PROJECT_NAME_NUANCE,
                        },
                        "tags": {
                                Type:     schema.TypeSet,
                                Optional: true,
                                Set:      schema.HashString,
                                Elem: &amp;schema.Schema{
                                        Type: schema.TypeString,
                                },
                                Description: "Assign tags to the cluster config policy. Tags can be in the format `key:value` or just `key`.",
                        },
                        "policy_type": {
                                Type:        schema.TypeString,
                                Optional:    true,
                                Default:     "maintenance",
                                Description: "Type of the policy. Allowed values are `maintenance` or `upgrade`(not supported yet). Default value is `maintenance`.",
                        },
                        "schedules": {
                                Type:        schema.TypeSet,
                                Optional:    true,
                                Description: "Set of maintenance schedules for the policy.",
                                Set:         resourceClusterConfigPolicyScheduleHash,
                                Elem: &amp;schema.Resource{
                                        Schema: map[string]*schema.Schema{
                                                "name": {
                                                        Type:        schema.TypeString,
                                                        Required:    true,
                                                        Description: "Name of the upgrade schedule.",
                                                },
                                                "start_cron": {
                                                        Type:        schema.TypeString,
                                                        Required:    true,
                                                        Description: "Cron expression for the start time of the schedule.",
                                                },
                                                "duration_hrs": {
                                                        Type:        schema.TypeInt,
                                                        Required:    true,
                                                        Description: "Specifies the time window in hours during which the system is allowed to start upgrades on eligible clusters. Valid range: 1-24.",
                                                },
                                        },
                                },
                        },
                },
        }
}</span>

func resourceClusterConfigPolicyCreate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        c := getV1ClientWithResourceContext(m, d.Get("context").(string))

        policy := &amp;models.V1SpcPolicyEntity{
                Metadata: &amp;models.V1ObjectMeta{
                        Name:   d.Get("name").(string),
                        Labels: toTags(d),
                },
                Spec: &amp;models.V1SpcPolicySpec{
                        Schedules: expandClusterConfigPolicySchedules(d.Get("schedules").(*schema.Set).List()),
                },
        }

        uid, err := c.CreateClusterConfigPolicy(policy)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">d.SetId(*uid.UID)
        return resourceClusterConfigPolicyRead(ctx, d, m)</span>
}

func resourceClusterConfigPolicyRead(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        c := getV1ClientWithResourceContext(m, d.Get("context").(string))
        var diags diag.Diagnostics
        uid := d.Id()

        policy, err := c.GetClusterConfigPolicy(uid)
        if err != nil </span><span class="cov0" title="0">{
                return handleReadError(d, err, diags)
        }</span>

        <span class="cov0" title="0">if err := d.Set("name", policy.Metadata.Name); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">if err := d.Set("tags", flattenTags(policy.Metadata.Labels)); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">if policy.Spec != nil </span><span class="cov0" title="0">{
                if err := d.Set("schedules", flattenClusterConfigPolicySchedules(policy.Spec.Schedules)); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func resourceClusterConfigPolicyUpdate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        c := getV1ClientWithResourceContext(m, d.Get("context").(string))

        policy := &amp;models.V1SpcPolicyEntity{
                Metadata: &amp;models.V1ObjectMeta{
                        Name:   d.Get("name").(string),
                        Labels: toTags(d),
                },
                Spec: &amp;models.V1SpcPolicySpec{
                        Schedules: expandClusterConfigPolicySchedules(d.Get("schedules").(*schema.Set).List()),
                },
        }

        err := c.UpdateClusterConfigPolicy(d.Id(), policy)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">return resourceClusterConfigPolicyRead(ctx, d, m)</span>
}

func resourceClusterConfigPolicyDelete(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        c := getV1ClientWithResourceContext(m, d.Get("context").(string))

        err := c.DeleteClusterConfigPolicy(d.Id())
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">d.SetId("")

        return nil</span>
}

func resourceClusterConfigPolicyImport(ctx context.Context, d *schema.ResourceData, m interface{}) ([]*schema.ResourceData, error) <span class="cov0" title="0">{
        // The ID passed in is the UID
        d.SetId(d.Id())

        diags := resourceClusterConfigPolicyRead(ctx, d, m)
        if diags.HasError() </span><span class="cov0" title="0">{
                return nil, diags[0].Validate()
        }</span>

        <span class="cov0" title="0">return []*schema.ResourceData{d}, nil</span>
}

// Helper functions for expanding and flattening

// Hash function for schedule set
func resourceClusterConfigPolicyScheduleHash(v interface{}) int <span class="cov0" title="0">{
        var buf strings.Builder
        m := v.(map[string]interface{})

        if name, ok := m["name"].(string); ok </span><span class="cov0" title="0">{
                buf.WriteString(fmt.Sprintf("%s-", name))
        }</span>
        <span class="cov0" title="0">if startCron, ok := m["start_cron"].(string); ok </span><span class="cov0" title="0">{
                buf.WriteString(fmt.Sprintf("%s-", startCron))
        }</span>
        <span class="cov0" title="0">if durationHrs, ok := m["duration_hrs"].(int); ok </span><span class="cov0" title="0">{
                buf.WriteString(fmt.Sprintf("%d-", durationHrs))
        }</span>

        <span class="cov0" title="0">return schema.HashString(buf.String())</span>
}

func expandClusterConfigPolicySchedules(schedules []interface{}) []*models.V1Schedule <span class="cov0" title="0">{
        if len(schedules) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">result := make([]*models.V1Schedule, len(schedules))
        for i, schedule := range schedules </span><span class="cov0" title="0">{
                s := schedule.(map[string]interface{})
                name := s["name"].(string)
                startCron := s["start_cron"].(string)
                durationHrs := int64(s["duration_hrs"].(int))

                result[i] = &amp;models.V1Schedule{
                        Name:        &amp;name,
                        StartCron:   &amp;startCron,
                        DurationHrs: &amp;durationHrs,
                }
        }</span>

        <span class="cov0" title="0">return result</span>
}

func flattenClusterConfigPolicySchedules(schedules []*models.V1Schedule) *schema.Set <span class="cov0" title="0">{
        if schedules == nil </span><span class="cov0" title="0">{
                return schema.NewSet(resourceClusterConfigPolicyScheduleHash, []interface{}{})
        }</span>

        <span class="cov0" title="0">result := make([]interface{}, len(schedules))
        for i, schedule := range schedules </span><span class="cov0" title="0">{
                m := map[string]interface{}{}
                if schedule.Name != nil </span><span class="cov0" title="0">{
                        m["name"] = *schedule.Name
                }</span>
                <span class="cov0" title="0">if schedule.StartCron != nil </span><span class="cov0" title="0">{
                        m["start_cron"] = *schedule.StartCron
                }</span>
                <span class="cov0" title="0">if schedule.DurationHrs != nil </span><span class="cov0" title="0">{
                        m["duration_hrs"] = int(*schedule.DurationHrs)
                }</span>
                <span class="cov0" title="0">result[i] = m</span>
        }

        <span class="cov0" title="0">return schema.NewSet(resourceClusterConfigPolicyScheduleHash, result)</span>
}
</pre>
		
		<pre class="file" id="file134" style="display: none">package spectrocloud

import (
        "context"
        "fmt"
        "strings"
        "time"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
        "github.com/spectrocloud/palette-sdk-go/api/models"
)

func resourceClusterConfigTemplate() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                CreateContext: resourceClusterConfigTemplateCreate,
                ReadContext:   resourceClusterConfigTemplateRead,
                UpdateContext: resourceClusterConfigTemplateUpdate,
                DeleteContext: resourceClusterConfigTemplateDelete,
                Importer: &amp;schema.ResourceImporter{
                        StateContext: resourceClusterConfigTemplateImport,
                },
                Description: "A resource for creating and managing cluster config templates. **Tech Preview**: This resource is in tech preview and may undergo changes.",

                Timeouts: &amp;schema.ResourceTimeout{
                        Create: schema.DefaultTimeout(10 * time.Minute),
                        Update: schema.DefaultTimeout(10 * time.Minute),
                        Delete: schema.DefaultTimeout(10 * time.Minute),
                },

                SchemaVersion: 1,
                Schema: map[string]*schema.Schema{
                        "name": {
                                Type:        schema.TypeString,
                                Required:    true,
                                Description: "The name of the cluster config template.",
                        },
                        "context": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "project",
                                ValidateFunc: validation.StringInSlice([]string{"project", "tenant"}, false),
                                Description: "The context of the cluster config template. Allowed values are `project` or `tenant`. " +
                                        "Default value is `project`. " + PROJECT_NAME_NUANCE,
                        },
                        "description": {
                                Type:        schema.TypeString,
                                Optional:    true,
                                Description: "The description of the cluster config template.",
                        },
                        "tags": {
                                Type:     schema.TypeSet,
                                Optional: true,
                                Set:      schema.HashString,
                                Elem: &amp;schema.Schema{
                                        Type: schema.TypeString,
                                },
                                Description: "Assign tags to the cluster config template. Tags can be in the format `key:value` or just `key`.",
                        },
                        "cloud_type": {
                                Type:        schema.TypeString,
                                Required:    true,
                                ForceNew:    true,
                                Description: "The cloud type for the cluster template. Examples: 'aws', 'azure', 'gcp', 'vsphere', etc.",
                        },
                        "cluster_profile": {
                                Type:        schema.TypeSet,
                                Optional:    true,
                                Description: "Set of cluster profile references.",
                                Set:         resourceClusterConfigTemplateProfileHash,
                                Elem: &amp;schema.Resource{
                                        Schema: map[string]*schema.Schema{
                                                "id": {
                                                        Type:        schema.TypeString,
                                                        Required:    true,
                                                        Description: "ID of the cluster profile.",
                                                },
                                                "variables": {
                                                        Type:        schema.TypeSet,
                                                        Optional:    true,
                                                        Description: "Set of profile variable values and assignment strategies.",
                                                        Set:         resourceClusterConfigTemplateVariableHash,
                                                        Elem: &amp;schema.Resource{
                                                                Schema: map[string]*schema.Schema{
                                                                        "name": {
                                                                                Type:        schema.TypeString,
                                                                                Required:    true,
                                                                                Description: "Name of the variable.",
                                                                        },
                                                                        "value": {
                                                                                Type:        schema.TypeString,
                                                                                Optional:    true,
                                                                                Description: "Value of the variable to be applied to all clusters launched from this template. This value is used when assign_strategy is set to 'all'.",
                                                                        },
                                                                        "assign_strategy": {
                                                                                Type:         schema.TypeString,
                                                                                Optional:     true,
                                                                                Default:      "all",
                                                                                ValidateFunc: validation.StringInSlice([]string{"all", "cluster"}, false),
                                                                                Description:  "Assignment strategy for the variable. Allowed values are `all` or `cluster`. Default is `all`.",
                                                                        },
                                                                },
                                                        },
                                                },
                                        },
                                },
                        },
                        "policy": {
                                Type:        schema.TypeList,
                                Optional:    true,
                                MaxItems:    1, // Only one policy is supported for now
                                Description: "List of policy references.",
                                Elem: &amp;schema.Resource{
                                        Schema: map[string]*schema.Schema{
                                                "id": {
                                                        Type:        schema.TypeString,
                                                        Required:    true,
                                                        Description: "ID of the policy.",
                                                },
                                                "kind": {
                                                        Type:        schema.TypeString,
                                                        Optional:    true,
                                                        Description: "Kind of the policy.",
                                                },
                                        },
                                },
                        },
                        "attached_cluster": {
                                Type:        schema.TypeList,
                                Computed:    true,
                                Description: "List of clusters attached to this template.",
                                Elem: &amp;schema.Resource{
                                        Schema: map[string]*schema.Schema{
                                                "cluster_uid": {
                                                        Type:        schema.TypeString,
                                                        Computed:    true,
                                                        Description: "UID of the attached cluster.",
                                                },
                                                "name": {
                                                        Type:        schema.TypeString,
                                                        Computed:    true,
                                                        Description: "Name of the attached cluster.",
                                                },
                                        },
                                },
                        },
                        "execution_state": {
                                Type:        schema.TypeString,
                                Computed:    true,
                                Description: "Current execution state of the cluster template. Possible values: `Pending`, `Applied`, `Failed`, `PartiallyApplied`.",
                        },
                        "upgrade_now": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                ValidateFunc: validation.IsRFC3339Time,
                                Description: "Timestamp to trigger an immediate upgrade for all clusters launched from this template. " +
                                        "NOTE: The upgrade executes immediately when this value changes - the timestamp does NOT schedule a future upgrade. " +
                                        "Set this to the current timestamp each time you want to trigger an upgrade. " +
                                        "This field can also be used for tracking when upgrades were triggered by the user. " +
                                        "Format: RFC3339 (e.g., '2024-01-15T10:30:00Z'). " +
                                        "Example: To trigger an upgrade now, set to current time like '2024-11-12T15:30:00Z'.",
                        },
                },
        }
}</span>

func resourceClusterConfigTemplateCreate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        c := getV1ClientWithResourceContext(m, d.Get("context").(string))

        metadata := &amp;models.V1ObjectMetaInputEntity{
                Name:   d.Get("name").(string),
                Labels: toTags(d),
        }

        // Add description to annotations if provided
        if description, ok := d.GetOk("description"); ok </span><span class="cov0" title="0">{
                metadata.Annotations = map[string]string{
                        "description": description.(string),
                }
        }</span>

        <span class="cov0" title="0">template := &amp;models.V1ClusterTemplateEntity{
                Metadata: metadata,
                Spec: &amp;models.V1ClusterTemplateEntitySpec{
                        CloudType: d.Get("cloud_type").(string),
                        Profiles:  expandClusterTemplateProfiles(d.Get("cluster_profile").(*schema.Set).List()),
                        Policies:  expandClusterTemplatePolicies(d.Get("policy").([]interface{})),
                },
        }

        uid, err := c.CreateClusterConfigTemplate(template)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">d.SetId(*uid.UID)
        return resourceClusterConfigTemplateRead(ctx, d, m)</span>
}

func resourceClusterConfigTemplateRead(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        c := getV1ClientWithResourceContext(m, d.Get("context").(string))
        var diags diag.Diagnostics
        uid := d.Id()

        template, err := c.GetClusterConfigTemplate(uid)
        if err != nil </span><span class="cov0" title="0">{
                return handleReadError(d, err, diags)
        }</span>

        <span class="cov0" title="0">if err := d.Set("name", template.Metadata.Name); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">if err := d.Set("tags", flattenTags(template.Metadata.Labels)); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        // Get description from annotations if it exists
        <span class="cov0" title="0">if template.Metadata.Annotations != nil </span><span class="cov0" title="0">{
                if description, found := template.Metadata.Annotations["description"]; found </span><span class="cov0" title="0">{
                        if err := d.Set("description", description); err != nil </span><span class="cov0" title="0">{
                                return diag.FromErr(err)
                        }</span>
                }
        }

        <span class="cov0" title="0">if template.Spec != nil </span><span class="cov0" title="0">{
                if err := d.Set("cloud_type", template.Spec.CloudType); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>

                <span class="cov0" title="0">if err := d.Set("cluster_profile", flattenClusterTemplateProfiles(template.Spec.Profiles)); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>

                <span class="cov0" title="0">if err := d.Set("policy", flattenClusterTemplatePolicies(template.Spec.Policies)); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>

                // Set attached clusters
                <span class="cov0" title="0">if err := d.Set("attached_cluster", flattenAttachedClusters(template.Spec.Clusters)); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
        }

        // Set execution state from status
        <span class="cov0" title="0">if template.Status != nil </span><span class="cov0" title="0">{
                if err := d.Set("execution_state", template.Status.State); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func resourceClusterConfigTemplateUpdate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        c := getV1ClientWithResourceContext(m, d.Get("context").(string))

        // Handle metadata updates (name, tags, description)
        if d.HasChanges("name", "tags", "description") </span><span class="cov0" title="0">{
                metadataEntity := &amp;models.V1ObjectMetaInputEntity{
                        Name:   d.Get("name").(string),
                        Labels: toTags(d),
                }

                // Add description to annotations if provided
                if description, ok := d.GetOk("description"); ok </span><span class="cov0" title="0">{
                        metadataEntity.Annotations = map[string]string{
                                "description": description.(string),
                        }
                }</span>

                <span class="cov0" title="0">metadata := &amp;models.V1ObjectMetaInputEntitySchema{
                        Metadata: metadataEntity,
                }

                err := c.UpdateClusterConfigTemplate(d.Id(), metadata)
                if err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
        }

        // Handle policy updates
        <span class="cov0" title="0">if d.HasChange("policy") </span><span class="cov0" title="0">{
                policies := d.Get("policy").([]interface{})
                policiesEntity := &amp;models.V1ClusterTemplatePoliciesUpdateEntity{
                        Policies: expandClusterTemplatePolicies(policies),
                }

                err := c.UpdateClusterConfigTemplatePolicies(d.Id(), policiesEntity)
                if err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
        }

        // Handle profile updates (add/remove profiles or update variables)
        <span class="cov0" title="0">if d.HasChange("cluster_profile") </span><span class="cov0" title="0">{
                oldProfiles, newProfiles := d.GetChange("cluster_profile")

                // Check if profile set structure changed (IDs added/removed/changed)
                if profileStructureChanged(oldProfiles, newProfiles) </span><span class="cov0" title="0">{
                        // Use PUT endpoint to update entire profiles list
                        profiles := newProfiles.(*schema.Set).List()
                        profilesEntity := &amp;models.V1ClusterTemplateProfilesUpdateEntity{
                                Profiles: expandClusterTemplateProfiles(profiles),
                        }

                        err := c.UpdateClusterConfigTemplateProfiles(d.Id(), profilesEntity)
                        if err != nil </span><span class="cov0" title="0">{
                                return diag.FromErr(err)
                        }</span>
                } else<span class="cov0" title="0"> {
                        // Only variables changed within existing profiles - use PATCH endpoint
                        profiles := newProfiles.(*schema.Set).List()
                        variablesEntity := buildProfilesVariablesBatchEntity(profiles)

                        err := c.UpdateClusterConfigTemplateProfilesVariables(d.Id(), variablesEntity)
                        if err != nil </span><span class="cov0" title="0">{
                                return diag.FromErr(err)
                        }</span>
                }
        }

        // Handle upgrade trigger
        <span class="cov0" title="0">if d.HasChange("upgrade_now") </span><span class="cov0" title="0">{
                // Trigger immediate upgrade for all clusters launched from this template
                err := c.UpgradeClusterConfigTemplateClusters(d.Id())
                if err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
        }

        <span class="cov0" title="0">return resourceClusterConfigTemplateRead(ctx, d, m)</span>
}

func resourceClusterConfigTemplateDelete(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        c := getV1ClientWithResourceContext(m, d.Get("context").(string))

        err := c.DeleteClusterConfigTemplate(d.Id())
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">d.SetId("")

        return nil</span>
}

func resourceClusterConfigTemplateImport(ctx context.Context, d *schema.ResourceData, m interface{}) ([]*schema.ResourceData, error) <span class="cov0" title="0">{
        // The ID passed in is the UID
        d.SetId(d.Id())

        diags := resourceClusterConfigTemplateRead(ctx, d, m)
        if diags.HasError() </span><span class="cov0" title="0">{
                return nil, diags[0].Validate()
        }</span>

        <span class="cov0" title="0">return []*schema.ResourceData{d}, nil</span>
}

// Hash functions for sets

func resourceClusterConfigTemplateProfileHash(v interface{}) int <span class="cov0" title="0">{
        var buf strings.Builder
        m := v.(map[string]interface{})

        if id, ok := m["id"].(string); ok </span><span class="cov0" title="0">{
                buf.WriteString(fmt.Sprintf("%s-", id))
        }</span>

        <span class="cov0" title="0">return schema.HashString(buf.String())</span>
}

func resourceClusterConfigTemplateVariableHash(v interface{}) int <span class="cov0" title="0">{
        var buf strings.Builder
        m := v.(map[string]interface{})

        if name, ok := m["name"].(string); ok </span><span class="cov0" title="0">{
                buf.WriteString(fmt.Sprintf("%s-", name))
        }</span>
        <span class="cov0" title="0">if value, ok := m["value"].(string); ok </span><span class="cov0" title="0">{
                buf.WriteString(fmt.Sprintf("%s-", value))
        }</span>
        <span class="cov0" title="0">if strategy, ok := m["assign_strategy"].(string); ok </span><span class="cov0" title="0">{
                buf.WriteString(fmt.Sprintf("%s-", strategy))
        }</span>

        <span class="cov0" title="0">return schema.HashString(buf.String())</span>
}

// Helper functions for expanding and flattening

// profileStructureChanged checks if the profile set structure changed (IDs added/removed/changed)
// Returns true if profiles were added, removed, or IDs changed
// Returns false if only variables within existing profiles changed
func profileStructureChanged(oldProfilesSet, newProfilesSet interface{}) bool <span class="cov0" title="0">{
        oldProfiles := oldProfilesSet.(*schema.Set).List()
        newProfiles := newProfilesSet.(*schema.Set).List()

        // Different number of profiles = structure changed
        if len(oldProfiles) != len(newProfiles) </span><span class="cov0" title="0">{
                return true
        }</span>

        // Build a set of old profile IDs
        <span class="cov0" title="0">oldIDs := make(map[string]bool)
        for _, p := range oldProfiles </span><span class="cov0" title="0">{
                profile := p.(map[string]interface{})
                oldIDs[profile["id"].(string)] = true
        }</span>

        // Check if all new IDs exist in old IDs
        <span class="cov0" title="0">for _, p := range newProfiles </span><span class="cov0" title="0">{
                profile := p.(map[string]interface{})
                id := profile["id"].(string)
                if !oldIDs[id] </span><span class="cov0" title="0">{
                        // New ID found = structure changed
                        return true
                }</span>
        }

        // Same IDs = only variables changed
        <span class="cov0" title="0">return false</span>
}

// buildProfilesVariablesBatchEntity builds the request body for profile variables patch operation
func buildProfilesVariablesBatchEntity(profiles []interface{}) *models.V1ClusterTemplateProfilesVariablesBatchEntity <span class="cov0" title="0">{
        if len(profiles) == 0 </span><span class="cov0" title="0">{
                return &amp;models.V1ClusterTemplateProfilesVariablesBatchEntity{
                        Profiles: []*models.V1ClusterTemplateProfileVariablesGroup{},
                }
        }</span>

        <span class="cov0" title="0">profileGroups := make([]*models.V1ClusterTemplateProfileVariablesGroup, 0)

        for _, profile := range profiles </span><span class="cov0" title="0">{
                p := profile.(map[string]interface{})
                profileUID := p["id"].(string)

                // Check if this profile has variables (now a set)
                variablesSet, hasVariables := p["variables"].(*schema.Set)
                if !hasVariables || variablesSet.Len() == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">variables := variablesSet.List()

                // Build variable cluster mappings
                variableMappings := make([]*models.V1ClusterTemplateVariableClusterMapping, 0)
                for _, v := range variables </span><span class="cov0" title="0">{
                        varMap := v.(map[string]interface{})
                        varName := varMap["name"].(string)

                        mapping := &amp;models.V1ClusterTemplateVariableClusterMapping{
                                Name:     &amp;varName,
                                Clusters: []*models.V1ClusterVariableValue{},
                        }

                        variableMappings = append(variableMappings, mapping)
                }</span>

                <span class="cov0" title="0">profileGroup := &amp;models.V1ClusterTemplateProfileVariablesGroup{
                        UID:       &amp;profileUID,
                        Variables: variableMappings,
                }

                profileGroups = append(profileGroups, profileGroup)</span>
        }

        <span class="cov0" title="0">return &amp;models.V1ClusterTemplateProfilesVariablesBatchEntity{
                Profiles: profileGroups,
        }</span>
}

func expandClusterTemplateProfiles(profiles []interface{}) []*models.V1ClusterTemplateProfile <span class="cov0" title="0">{
        if len(profiles) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">result := make([]*models.V1ClusterTemplateProfile, len(profiles))
        for i, profile := range profiles </span><span class="cov0" title="0">{
                p := profile.(map[string]interface{})
                profileEntity := &amp;models.V1ClusterTemplateProfile{
                        UID: p["id"].(string),
                }

                // Expand variables if present (now a set)
                if variablesSet, ok := p["variables"].(*schema.Set); ok &amp;&amp; variablesSet.Len() &gt; 0 </span><span class="cov0" title="0">{
                        profileEntity.Variables = expandClusterTemplateProfileVariables(variablesSet.List())
                }</span>

                <span class="cov0" title="0">result[i] = profileEntity</span>
        }

        <span class="cov0" title="0">return result</span>
}

func expandClusterTemplateProfileVariables(variables []interface{}) []*models.V1ClusterTemplateVariable <span class="cov0" title="0">{
        if len(variables) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">result := make([]*models.V1ClusterTemplateVariable, len(variables))
        for i, variable := range variables </span><span class="cov0" title="0">{
                v := variable.(map[string]interface{})
                varEntity := &amp;models.V1ClusterTemplateVariable{
                        Name: v["name"].(string),
                }

                if value, ok := v["value"].(string); ok &amp;&amp; value != "" </span><span class="cov0" title="0">{
                        varEntity.Value = value
                }</span>

                <span class="cov0" title="0">if assignStrategy, ok := v["assign_strategy"].(string); ok &amp;&amp; assignStrategy != "" </span><span class="cov0" title="0">{
                        varEntity.AssignStrategy = assignStrategy
                }</span>

                <span class="cov0" title="0">result[i] = varEntity</span>
        }

        <span class="cov0" title="0">return result</span>
}

func expandClusterTemplatePolicies(policies []interface{}) []*models.V1PolicyRef <span class="cov0" title="0">{
        if len(policies) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">result := make([]*models.V1PolicyRef, len(policies))
        for i, policy := range policies </span><span class="cov0" title="0">{
                p := policy.(map[string]interface{})
                result[i] = &amp;models.V1PolicyRef{
                        UID:  p["id"].(string),
                        Kind: p["kind"].(string),
                }
        }</span>

        <span class="cov0" title="0">return result</span>
}

func flattenClusterTemplateProfiles(profiles []*models.V1ClusterTemplateProfile) *schema.Set <span class="cov0" title="0">{
        if profiles == nil </span><span class="cov0" title="0">{
                return schema.NewSet(resourceClusterConfigTemplateProfileHash, []interface{}{})
        }</span>

        <span class="cov0" title="0">result := make([]interface{}, len(profiles))
        for i, profile := range profiles </span><span class="cov0" title="0">{
                profileMap := map[string]interface{}{
                        "id": profile.UID,
                }

                // Flatten variables if present (now returns a set)
                if len(profile.Variables) &gt; 0 </span><span class="cov0" title="0">{
                        profileMap["variables"] = flattenClusterTemplateProfileVariables(profile.Variables)
                }</span> else<span class="cov0" title="0"> {
                        profileMap["variables"] = schema.NewSet(resourceClusterConfigTemplateVariableHash, []interface{}{})
                }</span>

                <span class="cov0" title="0">result[i] = profileMap</span>
        }

        <span class="cov0" title="0">return schema.NewSet(resourceClusterConfigTemplateProfileHash, result)</span>
}

func flattenClusterTemplateProfileVariables(variables []*models.V1ClusterTemplateVariable) *schema.Set <span class="cov0" title="0">{
        if variables == nil </span><span class="cov0" title="0">{
                return schema.NewSet(resourceClusterConfigTemplateVariableHash, []interface{}{})
        }</span>

        <span class="cov0" title="0">result := make([]interface{}, len(variables))
        for i, variable := range variables </span><span class="cov0" title="0">{
                varMap := map[string]interface{}{
                        "name": variable.Name,
                }

                if variable.Value != "" </span><span class="cov0" title="0">{
                        varMap["value"] = variable.Value
                }</span>

                <span class="cov0" title="0">if variable.AssignStrategy != "" </span><span class="cov0" title="0">{
                        varMap["assign_strategy"] = variable.AssignStrategy
                }</span>

                <span class="cov0" title="0">result[i] = varMap</span>
        }

        <span class="cov0" title="0">return schema.NewSet(resourceClusterConfigTemplateVariableHash, result)</span>
}

func flattenClusterTemplatePolicies(policies []*models.V1PolicyRef) []interface{} <span class="cov0" title="0">{
        if policies == nil </span><span class="cov0" title="0">{
                return []interface{}{}
        }</span>

        <span class="cov0" title="0">result := make([]interface{}, len(policies))
        for i, policy := range policies </span><span class="cov0" title="0">{
                result[i] = map[string]interface{}{
                        "id":   policy.UID,
                        "kind": policy.Kind,
                }
        }</span>

        <span class="cov0" title="0">return result</span>
}

func flattenAttachedClusters(clusters map[string]models.V1ClusterTemplateSpcRef) []interface{} <span class="cov0" title="0">{
        if len(clusters) == 0 </span><span class="cov0" title="0">{
                return []interface{}{}
        }</span>

        <span class="cov0" title="0">result := make([]interface{}, 0, len(clusters))
        for _, cluster := range clusters </span><span class="cov0" title="0">{
                result = append(result, map[string]interface{}{
                        "cluster_uid": cluster.ClusterUID,
                        "name":        cluster.Name,
                })
        }</span>

        <span class="cov0" title="0">return result</span>
}
</pre>
		
		<pre class="file" id="file135" style="display: none">package spectrocloud

import (
        "context"
        "encoding/json"
        "fmt"
        "log"
        "strconv"
        "strings"
        "time"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
        "github.com/spectrocloud/palette-sdk-go/api/models"
        "github.com/spectrocloud/palette-sdk-go/client"
        "github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/schemas"
        "github.com/spectrocloud/terraform-provider-spectrocloud/types"
        "gopkg.in/yaml.v3"
)

func resourceClusterCustomCloud() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                CreateContext: resourceClusterCustomCloudCreate,
                ReadContext:   resourceClusterCustomCloudRead,
                UpdateContext: resourceClusterCustomCloudUpdate,
                DeleteContext: resourceClusterDelete,
                Importer: &amp;schema.ResourceImporter{

                        StateContext: resourceClusterCustomImport,
                },
                Description: "Resource for managing custom cloud clusters in Spectro Cloud through Palette.",

                Timeouts: &amp;schema.ResourceTimeout{
                        Create: schema.DefaultTimeout(60 * time.Minute),
                        Update: schema.DefaultTimeout(60 * time.Minute),
                        Delete: schema.DefaultTimeout(60 * time.Minute),
                },

                SchemaVersion: 3,
                StateUpgraders: []schema.StateUpgrader{
                        {
                                Type:    resourceClusterCustomCloudResourceV2().CoreConfigSchema().ImpliedType(),
                                Upgrade: resourceClusterCustomCloudStateUpgradeV2,
                                Version: 2,
                        },
                },
                Schema: map[string]*schema.Schema{
                        "name": {
                                Type:        schema.TypeString,
                                Required:    true,
                                ForceNew:    true,
                                Description: "The name of the cluster.",
                        },
                        "context": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "project",
                                ValidateFunc: validation.StringInSlice([]string{"", "project", "tenant"}, false),
                                Description: "The context of the EKS cluster. Allowed values are `project` or `tenant`. " +
                                        "Default is `project`. " + PROJECT_NAME_NUANCE,
                        },
                        "cloud": {
                                Type:        schema.TypeString,
                                ForceNew:    true,
                                Required:    true,
                                Description: "The cloud provider name.",
                        },
                        "tags": {
                                Type:     schema.TypeSet,
                                Optional: true,
                                Set:      schema.HashString,
                                Elem: &amp;schema.Schema{
                                        Type: schema.TypeString,
                                },
                                Description: "A list of tags to be applied to the cluster. Tags must be in the form of `key:value`.",
                        },
                        "description": {
                                Type:        schema.TypeString,
                                Optional:    true,
                                Default:     "",
                                Description: "The description of the cluster. Default value is empty string.",
                        },
                        "cluster_profile":  schemas.ClusterProfileSchema(),
                        "cluster_template": schemas.ClusterTemplateSchema(),
                        "cluster_type":     schemas.ClusterTypeSchema(),
                        "apply_setting": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "DownloadAndInstall",
                                ValidateFunc: validation.StringInSlice([]string{"DownloadAndInstall", "DownloadAndInstallLater"}, false),
                                Description: "The setting to apply the cluster profile. `DownloadAndInstall` will download and install packs in one action. " +
                                        "`DownloadAndInstallLater` will only download artifact and postpone install for later. " +
                                        "Default value is `DownloadAndInstall`.",
                        },
                        "cloud_account_id": {
                                Type:        schema.TypeString,
                                Required:    true,
                                ForceNew:    true,
                                Description: "The cloud account id to use for this cluster.",
                        },
                        "cloud_config_id": {
                                Type:       schema.TypeString,
                                Computed:   true,
                                Deprecated: "This field is deprecated and will be removed in the future. Use `cloud_config` instead.",
                        },
                        "cluster_timezone": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "",
                                ValidateFunc: validateTimezone,
                                Description:  "Defines the time zone used by this cluster to interpret scheduled operations. Maintenance tasks like upgrades will follow this time zone to ensure they run at the appropriate local time for the cluster. Must be in IANA timezone format (e.g., 'America/New_York', 'Asia/Kolkata', 'Europe/London').",
                        },
                        "cloud_config": {
                                Type:        schema.TypeList,
                                Required:    true,
                                MaxItems:    1,
                                Description: "The Cloud environment configuration settings such as network parameters and encryption parameters that apply to this cluster.",
                                Elem: &amp;schema.Resource{
                                        Schema: map[string]*schema.Schema{
                                                "values": {
                                                        Type:        schema.TypeString,
                                                        Required:    true,
                                                        Description: "The values of the cloud config. The values are specified in YAML format. ",
                                                        StateFunc: func(val interface{}) string </span><span class="cov0" title="0">{
                                                                // Normalize YAML content to handle formatting differences
                                                                if yamlStr, ok := val.(string); ok </span><span class="cov0" title="0">{
                                                                        return NormalizeYamlContent(yamlStr)
                                                                }</span>
                                                                <span class="cov0" title="0">return val.(string)</span>
                                                        },
                                                },
                                                "overrides": {
                                                        Type:     schema.TypeMap,
                                                        Optional: true,
                                                        Elem:     &amp;schema.Schema{Type: schema.TypeString},
                                                        Description: "Key-value pairs to override specific values in the YAML. Supports template variables, wildcard patterns, field pattern search, document-specific and global overrides.\n\n" +
                                                                "Template variables: Simple identifiers that replace ${var}, {{var}}, or $var patterns in YAML (e.g., 'cluster_name' replaces ${cluster_name})\n" +
                                                                "Wildcard patterns: Patterns starting with '*' that match field names containing the specified substring (e.g., '*cluster-api-autoscaler-node-group-max-size' matches any field containing 'cluster-api-autoscaler-node-group-max-size')\n" +
                                                                "Field pattern search: Patterns that find and update ALL matching nested fields anywhere in YAML (e.g., 'replicas' updates any 'replicas' field, 'rootVolume.size' updates any 'rootVolume.size' pattern)\n" +
                                                                "Document-specific syntax: 'Kind.path' (e.g., 'Cluster.metadata.labels', 'AWSCluster.spec.region')\n" +
                                                                "Global path syntax: 'path' (e.g., 'metadata.name', 'spec.region')\n\n" +
                                                                "Processing order: 1) Template substitution, 2) Wildcard patterns, 3) Field pattern search, 4) Path-based overrides. " +
                                                                "Supports dot notation for nested paths and array indexing with [index]. " +
                                                                "Values are strings but support JSON syntax for arrays/objects.",
                                                },
                                        },
                                },
                        },

                        "machine_pool": {
                                Type:        schema.TypeSet,
                                Required:    true,
                                Set:         resourceMachinePoolCustomCloudHash,
                                Description: "The machine pool configuration for the cluster.",
                                Elem: &amp;schema.Resource{
                                        Schema: map[string]*schema.Schema{
                                                "name": {
                                                        Type:        schema.TypeString,
                                                        Computed:    true,
                                                        Description: "The name of the machine pool. This will be derived from the name value in the `node_pool_config`.",
                                                },
                                                "count": {
                                                        Type:        schema.TypeInt,
                                                        Computed:    true,
                                                        Description: "Number of nodes in the machine pool. This will be derived from the replica value in the 'node_pool_config'.",
                                                },
                                                "taints": schemas.ClusterTaintsSchema(),
                                                "control_plane": {
                                                        Type:        schema.TypeBool,
                                                        Optional:    true,
                                                        Default:     false,
                                                        Description: "Whether this machine pool is a control plane. Defaults to `false`.",
                                                },
                                                "control_plane_as_worker": {
                                                        Type:        schema.TypeBool,
                                                        Optional:    true,
                                                        Default:     false,
                                                        Description: "Whether this machine pool is a control plane and a worker. Defaults to `false`.",
                                                },
                                                "node_pool_config": {
                                                        Type:        schema.TypeString,
                                                        Required:    true,
                                                        Description: "The values of the node pool config. The values are specified in YAML format. ",
                                                        StateFunc: func(val interface{}) string <span class="cov0" title="0">{
                                                                // Normalize YAML content to handle formatting differences
                                                                if yamlStr, ok := val.(string); ok </span><span class="cov0" title="0">{
                                                                        return NormalizeYamlContent(yamlStr)
                                                                }</span>
                                                                <span class="cov0" title="0">return val.(string)</span>
                                                        },
                                                },
                                                "overrides": {
                                                        Type:     schema.TypeMap,
                                                        Optional: true,
                                                        Elem:     &amp;schema.Schema{Type: schema.TypeString},
                                                        Description: "Key-value pairs to override specific values in the node pool config YAML. Supports template variables, wildcard patterns, field pattern search, document-specific and global overrides.\n\n" +
                                                                "Template variables: Simple identifiers that replace ${var}, {{var}}, or $var patterns in YAML (e.g., 'node_count' replaces ${node_count})\n" +
                                                                "Wildcard patterns: Patterns starting with '*' that match field names containing the specified substring (e.g., '*cluster-api-autoscaler-node-group-max-size' matches any field containing 'cluster-api-autoscaler-node-group-max-size')\n" +
                                                                "Field pattern search: Patterns that find and update ALL matching nested fields anywhere in YAML (e.g., 'replicas' updates any 'replicas' field, 'rootVolume.size' updates any 'rootVolume.size' pattern)\n" +
                                                                "Document-specific syntax: 'Kind.path' (e.g., 'AWSMachineTemplate.spec.template.spec.instanceType')\n" +
                                                                "Global path syntax: 'path' (e.g., 'metadata.name', 'spec.instanceType')\n\n" +
                                                                "Processing order: 1) Template substitution, 2) Wildcard patterns, 3) Field pattern search, 4) Path-based overrides. " +
                                                                "Supports dot notation for nested paths and array indexing with [index]. " +
                                                                "Values are strings but support JSON syntax for arrays/objects.",
                                                },
                                                // Planned for support on future release's - "update_strategy", "node_repave_interval"
                                        },
                                },
                        },
                        "pause_agent_upgrades": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "unlock",
                                ValidateFunc: validation.StringInSlice([]string{"lock", "unlock"}, false),
                                Description:  "The pause agent upgrades setting allows to control the automatic upgrade of the Palette component and agent for an individual cluster. The default value is `unlock`, meaning upgrades occur automatically. Setting it to `lock` pauses automatic agent upgrades for the cluster.",
                        },
                        "os_patch_on_boot": {
                                Type:        schema.TypeBool,
                                Optional:    true,
                                Default:     false,
                                Description: "Whether to apply OS patch on boot. Default is `false`.",
                        },
                        "os_patch_schedule": {
                                Type:             schema.TypeString,
                                Optional:         true,
                                ValidateDiagFunc: validateOsPatchSchedule,
                                Description:      "The cron schedule for OS patching. This must be in the form of cron syntax. Ex: `0 0 * * *`.",
                        },
                        "os_patch_after": {
                                Type:             schema.TypeString,
                                Optional:         true,
                                ValidateDiagFunc: validateOsPatchOnDemandAfter,
                                Description:      "Date and time after which to patch cluster `RFC3339: 2006-01-02T15:04:05Z07:00`",
                        },

                        "kubeconfig": {
                                Type:        schema.TypeString,
                                Computed:    true,
                                Description: "Kubeconfig for the cluster. This can be used to connect to the cluster using `kubectl`.",
                        },
                        "admin_kube_config": {
                                Type:        schema.TypeString,
                                Computed:    true,
                                Description: "Admin Kube-config for the cluster. This can be used to connect to the cluster using `kubectl`, With admin privilege.",
                        },
                        "backup_policy":        schemas.BackupPolicySchema(),
                        "scan_policy":          schemas.ScanPolicySchema(),
                        "cluster_rbac_binding": schemas.ClusterRbacBindingSchema(),
                        "namespaces":           schemas.ClusterNamespacesSchema(),
                        "location_config":      schemas.ClusterLocationSchema(),

                        "skip_completion": {
                                Type:        schema.TypeBool,
                                Optional:    true,
                                Default:     false,
                                Description: "If `true`, the cluster will be created asynchronously. Default value is `false`.",
                        },
                        "force_delete": {
                                Type:        schema.TypeBool,
                                Optional:    true,
                                Default:     false,
                                Description: "If set to `true`, the cluster will be force deleted and user has to manually clean up the provisioned cloud resources.",
                        },
                        "force_delete_delay": {
                                Type:             schema.TypeInt,
                                Optional:         true,
                                Default:          20,
                                Description:      "Delay duration in minutes to before invoking cluster force delete. Default and minimum is 20.",
                                ValidateDiagFunc: validation.ToDiagFunc(validation.IntAtLeast(20)),
                        },
                        // Planned for support on future release's - "review_repave_state",
                },
        }
}

func resourceClusterCustomCloudCreate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        resourceContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, resourceContext)

        var diags diag.Diagnostics

        cluster, err := toCustomCloudCluster(c, d)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">cloudType := d.Get("cloud").(string)

        err = c.ValidateCustomCloudType(cloudType)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">uid, err := c.CreateClusterCustomCloud(cluster, cloudType)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">diagnostics, isError := waitForClusterCreation(ctx, d, uid, diags, c, true)
        if len(diagnostics) &gt; 0 </span><span class="cov0" title="0">{
                diags = append(diags, diagnostics...)
        }</span>
        <span class="cov0" title="0">if isError &amp;&amp; diagnostics != nil </span><span class="cov0" title="0">{
                return diagnostics
        }</span>
        <span class="cov0" title="0">resourceClusterCustomCloudRead(ctx, d, m)

        return diags</span>
}

func resourceClusterCustomCloudRead(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        log.Printf("[ERROR] !!!!!!! DEBUG SESSION TEST - CUSTOM CLOUD READ CALLED !!!!!!!")
        log.Printf("[ERROR] ======= CUSTOM CLOUD READ START =======")
        resourceContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, resourceContext)

        var diags diag.Diagnostics

        log.Printf("[ERROR] About to call resourceClusterRead")
        cluster, err := resourceClusterRead(d, c, diags)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[ERROR] resourceClusterRead failed: %v", err)
                return handleReadError(d, err, diags)
        }</span> else<span class="cov0" title="0"> if cluster == nil </span><span class="cov0" title="0">{
                log.Printf("[ERROR] cluster is nil, setting ID to empty")
                d.SetId("")
                return diags
        }</span>
        <span class="cov0" title="0">log.Printf("[ERROR] resourceClusterRead succeeded")

        diagnostics, hasError := readCommonFields(c, d, cluster)
        if hasError </span><span class="cov0" title="0">{
                log.Printf("[ERROR] readCommonFields failed")
                return diagnostics
        }</span>
        <span class="cov0" title="0">log.Printf("[ERROR] About to call flattenCloudConfigCustom")
        diagnostics, hasError = flattenCloudConfigCustom(cluster.Spec.CloudConfigRef.UID, d, c)
        if hasError </span><span class="cov0" title="0">{
                log.Printf("[ERROR] flattenCloudConfigCustom failed")
                return diagnostics
        }</span>
        <span class="cov0" title="0">log.Printf("[ERROR] flattenCloudConfigCustom succeeded")
        log.Printf("[ERROR] ======= CUSTOM CLOUD READ END =======")

        // Flatten cluster_template variables using variables API
        if err := flattenClusterTemplateVariables(c, d, d.Id()); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">return diags</span>
}

func resourceClusterCustomCloudUpdate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        resourceContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, resourceContext)

        // Warning or errors can be collected in a slice type
        var diags diag.Diagnostics

        // Validate that cluster_type is not being modified (it's a create-only field)
        if err := ValidateClusterTypeUpdate(d); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">cloudConfigId := d.Get("cloud_config_id").(string)
        //clusterContext := d.Get("context").(string)
        cloudType := d.Get("cloud").(string)

        _, err := c.GetCloudConfigCustomCloud(cloudConfigId, cloudType)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">if d.HasChange("cloud_config") </span><span class="cov0" title="0">{
                config := toCustomCloudConfig(d)
                configEntity := &amp;models.V1CustomCloudClusterConfigEntity{
                        ClusterConfig: config,
                }
                err = c.UpdateCloudConfigCustomCloud(configEntity, cloudConfigId, cloudType)
                if err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
        }

        <span class="cov0" title="0">if d.HasChange("machine_pool") </span><span class="cov0" title="0">{
                log.Printf("[DEBUG] === MACHINE POOL CHANGE DETECTED ===")
                oraw, nraw := d.GetChange("machine_pool")
                if oraw == nil </span><span class="cov0" title="0">{
                        oraw = new(schema.Set)
                }</span>
                <span class="cov0" title="0">if nraw == nil </span><span class="cov0" title="0">{
                        nraw = new(schema.Set)
                }</span>

                <span class="cov0" title="0">os := oraw.(*schema.Set)
                ns := nraw.(*schema.Set)

                log.Printf("[DEBUG] Old machine pools count: %d, New machine pools count: %d", os.Len(), ns.Len())

                // Create maps by machine pool name for proper comparison
                osMap := make(map[string]interface{})
                for _, mp := range os.List() </span><span class="cov0" title="0">{
                        machinePoolResource := mp.(map[string]interface{})
                        name := extractMachinePoolNameFromYAML(machinePoolResource)
                        if name != "" </span><span class="cov0" title="0">{
                                osMap[name] = machinePoolResource
                        }</span>
                }

                <span class="cov0" title="0">nsMap := make(map[string]interface{})
                for _, mp := range ns.List() </span><span class="cov0" title="0">{
                        machinePoolResource := mp.(map[string]interface{})
                        name := extractMachinePoolNameFromYAML(machinePoolResource)
                        if name != "" </span><span class="cov0" title="0">{
                                nsMap[name] = machinePoolResource

                                // Check if this is a new, updated, or unchanged machine pool
                                if oldMachinePool, exists := osMap[name]; !exists </span><span class="cov0" title="0">{
                                        // NEW machine pool - CREATE
                                        log.Printf("[DEBUG] Creating new machine pool %s", name)
                                        machinePool := toMachinePoolCustomCloud(mp)
                                        if err := c.CreateMachinePoolCustomCloud(machinePool, cloudConfigId, cloudType); err != nil </span><span class="cov0" title="0">{
                                                return diag.FromErr(err)
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        // EXISTING machine pool - check if hash changed
                                        oldHash := resourceMachinePoolCustomCloudHash(oldMachinePool)
                                        newHash := resourceMachinePoolCustomCloudHash(machinePoolResource)

                                        if oldHash != newHash </span><span class="cov0" title="0">{
                                                // MODIFIED machine pool - UPDATE
                                                log.Printf("[DEBUG] Updating machine pool %s (hash changed: %d -&gt; %d)", name, oldHash, newHash)
                                                machinePool := toMachinePoolCustomCloud(mp)
                                                if err := c.UpdateMachinePoolCustomCloud(machinePool, name, cloudConfigId, cloudType); err != nil </span><span class="cov0" title="0">{
                                                        return diag.FromErr(err)
                                                }</span>
                                        } else<span class="cov0" title="0"> {
                                                // UNCHANGED machine pool - no action needed
                                                log.Printf("[DEBUG] Machine pool %s unchanged (hash: %d)", name, oldHash)
                                        }</span>
                                }

                                // Mark as processed
                                <span class="cov0" title="0">delete(osMap, name)</span>
                        } else<span class="cov0" title="0"> {
                                log.Printf("[DEBUG] WARNING: Machine pool has empty name!")
                        }</span>
                }

                // REMOVED machine pools - DELETE
                <span class="cov0" title="0">for name := range osMap </span><span class="cov0" title="0">{
                        log.Printf("[DEBUG] Deleting removed machine pool %s", name)
                        if err := c.DeleteMachinePoolCustomCloud(name, cloudConfigId, cloudType); err != nil </span><span class="cov0" title="0">{
                                return diag.FromErr(err)
                        }</span>
                }
        }

        <span class="cov0" title="0">diagnostics, done := updateCommonFields(d, c)
        if done </span><span class="cov0" title="0">{
                return diagnostics
        }</span>

        <span class="cov0" title="0">resourceClusterCustomCloudRead(ctx, d, m)

        return diags</span>
}

func toCustomCloudCluster(c *client.V1Client, d *schema.ResourceData) (*models.V1SpectroCustomClusterEntity, error) <span class="cov0" title="0">{
        clusterContext := d.Get("context").(string)
        profiles, err := toProfiles(c, d, clusterContext)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // policies in not supported for custom cluster during cluster creation UI also its same.
        // policies := toPolicies(d)

        <span class="cov0" title="0">customCloudConfig := toCustomCloudConfig(d)

        customClusterConfig := toCustomClusterConfig(d)

        machinePoolConfigs := make([]*models.V1CustomMachinePoolConfigEntity, 0)
        machinePoolSet := d.Get("machine_pool").(*schema.Set)
        for _, machinePool := range machinePoolSet.List() </span><span class="cov0" title="0">{
                mp := toMachinePoolCustomCloud(machinePool)
                machinePoolConfigs = append(machinePoolConfigs, mp)
        }</span>

        <span class="cov0" title="0">cluster := &amp;models.V1SpectroCustomClusterEntity{
                Metadata: toClusterMetadataUpdate(d),
                Spec: &amp;models.V1SpectroCustomClusterEntitySpec{
                        CloudAccountUID:   types.Ptr(d.Get("cloud_account_id").(string)),
                        CloudConfig:       customCloudConfig,
                        ClusterConfig:     customClusterConfig,
                        Machinepoolconfig: machinePoolConfigs,
                        Profiles:          profiles,
                        ClusterTemplate:   toClusterTemplateReference(d),
                        ClusterType:       toClusterType(d),
                },
        }

        return cluster, nil</span>
}

func toCustomCloudConfig(d *schema.ResourceData) *models.V1CustomClusterConfig <span class="cov0" title="0">{
        cloudConfig := d.Get("cloud_config").([]interface{})[0].(map[string]interface{})
        valuesYamlStr := strings.TrimSpace(cloudConfig["values"].(string))

        // Apply overrides if they exist
        if overrides, ok := cloudConfig["overrides"].(map[string]interface{}); ok &amp;&amp; len(overrides) &gt; 0 </span><span class="cov0" title="0">{
                log.Printf("[DEBUG] Applying %d YAML overrides to cloud config", len(overrides))
                for path, value := range overrides </span><span class="cov0" title="0">{
                        log.Printf("[DEBUG] Override: %s = %v", path, value)
                }</span>

                <span class="cov0" title="0">processedYaml, err := applyYamlOverridesWithTemplates(valuesYamlStr, overrides)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Warning: Failed to apply YAML overrides: %v", err)
                }</span> else<span class="cov0" title="0"> {
                        log.Printf("[DEBUG] YAML transformation successful. Original length: %d, New length: %d", len(valuesYamlStr), len(processedYaml))
                        // Show a snippet of the transformation for debugging
                        if len(processedYaml) &gt; 0 &amp;&amp; processedYaml != valuesYamlStr </span><span class="cov0" title="0">{
                                log.Printf("[DEBUG] YAML values updated with overrides")
                        }</span>
                        <span class="cov0" title="0">valuesYamlStr = processedYaml</span>
                }
        }

        // Normalize the final YAML content to ensure consistent formatting
        <span class="cov0" title="0">valuesYamlStr = NormalizeYamlContent(valuesYamlStr)

        customCloudConfig := &amp;models.V1CustomClusterConfig{
                Values: StringPtr(valuesYamlStr),
        }

        return customCloudConfig</span>
}

// applyYamlOverrides applies key-value overrides to multi-document YAML
func applyYamlOverrides(yamlContent string, overrides map[string]interface{}) (string, error) <span class="cov0" title="0">{
        // Split multi-document YAML
        documents := strings.Split(yamlContent, "---")
        var processedDocs []string

        for _, doc := range documents </span><span class="cov0" title="0">{
                doc = strings.TrimSpace(doc)
                if doc == "" </span><span class="cov0" title="0">{
                        processedDocs = append(processedDocs, "")
                        continue</span>
                }

                // Parse YAML document
                <span class="cov0" title="0">var yamlData interface{}
                if err := yaml.Unmarshal([]byte(doc), &amp;yamlData); err != nil </span><span class="cov0" title="0">{
                        // If parsing fails, keep original document
                        processedDocs = append(processedDocs, doc)
                        continue</span>
                }

                // Extract document kind for document-specific overrides
                <span class="cov0" title="0">documentKind := extractDocumentKind(yamlData)

                // Apply overrides to this document
                modified := false
                for path, value := range overrides </span><span class="cov0" title="0">{
                        if applyOverrideToDocumentWithKind(&amp;yamlData, path, value, documentKind) </span><span class="cov0" title="0">{
                                log.Printf("[DEBUG] Successfully applied override: %s = %v to %s document", path, value, documentKind)
                                modified = true
                        }</span>
                }

                // Convert back to YAML
                <span class="cov0" title="0">if modified </span><span class="cov0" title="0">{
                        processedYaml, err := yaml.Marshal(yamlData)
                        if err != nil </span><span class="cov0" title="0">{
                                processedDocs = append(processedDocs, doc)
                                continue</span>
                        }
                        <span class="cov0" title="0">processedDocs = append(processedDocs, strings.TrimSpace(string(processedYaml)))</span>
                } else<span class="cov0" title="0"> {
                        processedDocs = append(processedDocs, doc)
                }</span>
        }

        <span class="cov0" title="0">return strings.Join(processedDocs, "\n---\n"), nil</span>
}

// applyYamlOverridesWithTemplates applies template substitution, wildcard patterns, field name overrides, and path-based overrides
func applyYamlOverridesWithTemplates(yamlContent string, overrides map[string]interface{}) (string, error) <span class="cov0" title="0">{
        // Step 1: Separate override types
        templateVars, wildcardPatterns, fieldPatternOverrides, pathOverrides := separateOverrideTypes(yamlContent, overrides)

        processedYaml := yamlContent

        // Step 2: Apply template variable substitution first
        if len(templateVars) &gt; 0 </span><span class="cov0" title="0">{
                log.Printf("[DEBUG] Applying %d template variable substitutions", len(templateVars))
                processedYaml = applyTemplateSubstitution(yamlContent, templateVars)
        }</span>

        // Step 3: Apply wildcard pattern overrides
        <span class="cov0" title="0">if len(wildcardPatterns) &gt; 0 </span><span class="cov0" title="0">{
                log.Printf("[DEBUG] Applying %d wildcard pattern overrides", len(wildcardPatterns))
                var err error
                processedYaml, err = applyWildcardPatternOverrides(processedYaml, wildcardPatterns)
                if err != nil </span><span class="cov0" title="0">{
                        return processedYaml, err
                }</span>
        }

        // Step 4: Apply field pattern overrides
        <span class="cov0" title="0">if len(fieldPatternOverrides) &gt; 0 </span><span class="cov0" title="0">{
                log.Printf("[DEBUG] Applying %d field pattern overrides", len(fieldPatternOverrides))
                var err error
                processedYaml, err = applyFieldPatternOverrides(processedYaml, fieldPatternOverrides)
                if err != nil </span><span class="cov0" title="0">{
                        return processedYaml, err
                }</span>
        }

        // Step 5: Apply path-based overrides on the processed YAML
        <span class="cov0" title="0">if len(pathOverrides) &gt; 0 </span><span class="cov0" title="0">{
                log.Printf("[DEBUG] Applying %d path-based overrides", len(pathOverrides))
                return applyYamlOverrides(processedYaml, pathOverrides)
        }</span>

        <span class="cov0" title="0">return processedYaml, nil</span>
}

// applyFieldPatternOverrides applies field pattern-based overrides to multi-document YAML
func applyFieldPatternOverrides(yamlContent string, fieldOverrides map[string]interface{}) (string, error) <span class="cov0" title="0">{
        // Split multi-document YAML
        documents := strings.Split(yamlContent, "---")
        var processedDocs []string

        for _, doc := range documents </span><span class="cov0" title="0">{
                doc = strings.TrimSpace(doc)
                if doc == "" </span><span class="cov0" title="0">{
                        processedDocs = append(processedDocs, "")
                        continue</span>
                }

                // Parse YAML document
                <span class="cov0" title="0">var yamlData interface{}
                if err := yaml.Unmarshal([]byte(doc), &amp;yamlData); err != nil </span><span class="cov0" title="0">{
                        // If parsing fails, keep original document
                        processedDocs = append(processedDocs, doc)
                        continue</span>
                }

                // Apply field pattern overrides to this document
                <span class="cov0" title="0">modified := false
                for fieldPattern, value := range fieldOverrides </span><span class="cov0" title="0">{
                        convertedValue := convertStringToAppropriateType(value.(string))
                        if applyFieldPatternOverrideToDocument(&amp;yamlData, fieldPattern, convertedValue) </span><span class="cov0" title="0">{
                                log.Printf("[DEBUG] Successfully applied field pattern override: %s = %v", fieldPattern, convertedValue)
                                modified = true
                        }</span>
                }

                // Convert back to YAML
                <span class="cov0" title="0">if modified </span><span class="cov0" title="0">{
                        processedYaml, err := yaml.Marshal(yamlData)
                        if err != nil </span><span class="cov0" title="0">{
                                processedDocs = append(processedDocs, doc)
                                continue</span>
                        }
                        <span class="cov0" title="0">processedDocs = append(processedDocs, strings.TrimSpace(string(processedYaml)))</span>
                } else<span class="cov0" title="0"> {
                        processedDocs = append(processedDocs, doc)
                }</span>
        }

        <span class="cov0" title="0">return strings.Join(processedDocs, "\n---\n"), nil</span>
}

// applyFieldPatternOverrideToDocument applies a field pattern override to all matching patterns in a document
func applyFieldPatternOverrideToDocument(data *interface{}, fieldPattern string, value interface{}) bool <span class="cov0" title="0">{
        modified := false

        // Split the field pattern into parts (e.g., "rootVolume.size" -&gt; ["rootVolume", "size"])
        patternParts := strings.Split(fieldPattern, ".")

        // Try to find and update the pattern starting from current level
        if findAndUpdatePattern(data, patternParts, value, "") </span><span class="cov0" title="0">{
                modified = true
        }</span>

        <span class="cov0" title="0">return modified</span>
}

// findAndUpdatePattern recursively searches for and updates field patterns in YAML data
func findAndUpdatePattern(data *interface{}, patternParts []string, value interface{}, currentPath string) bool <span class="cov0" title="0">{
        if len(patternParts) == 0 </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">modified := false

        switch currentData := (*data).(type) </span>{
        case map[string]interface{}:<span class="cov0" title="0">
                // Check if we can match the pattern starting from this level
                if canMatchPatternFromHere(currentData, patternParts) </span><span class="cov0" title="0">{
                        if applyPatternToMap(currentData, patternParts, value) </span><span class="cov0" title="0">{
                                log.Printf("[DEBUG] Found and updated field pattern '%s' at path '%s'", strings.Join(patternParts, "."), currentPath)
                                modified = true
                        }</span>
                }

                // Recursively search nested structures
                <span class="cov0" title="0">for key, v := range currentData </span><span class="cov0" title="0">{
                        newPath := currentPath
                        if newPath != "" </span><span class="cov0" title="0">{
                                newPath += "."
                        }</span>
                        <span class="cov0" title="0">newPath += key

                        if findAndUpdatePattern(&amp;v, patternParts, value, newPath) </span><span class="cov0" title="0">{
                                modified = true
                        }</span>
                }

        case map[interface{}]interface{}:<span class="cov0" title="0">
                // Convert to string keys and search
                stringMap := make(map[string]interface{})
                for k, v := range currentData </span><span class="cov0" title="0">{
                        if keyStr, ok := k.(string); ok </span><span class="cov0" title="0">{
                                stringMap[keyStr] = v
                        }</span>
                }

                // Check pattern match and recursively search
                <span class="cov0" title="0">if canMatchPatternFromHere(stringMap, patternParts) </span><span class="cov0" title="0">{
                        if applyPatternToMap(stringMap, patternParts, value) </span><span class="cov0" title="0">{
                                log.Printf("[DEBUG] Found and updated field pattern '%s' at path '%s'", strings.Join(patternParts, "."), currentPath)
                                *data = stringMap
                                modified = true
                        }</span>
                }

                <span class="cov0" title="0">for key, v := range stringMap </span><span class="cov0" title="0">{
                        newPath := currentPath
                        if newPath != "" </span><span class="cov0" title="0">{
                                newPath += "."
                        }</span>
                        <span class="cov0" title="0">newPath += key

                        if findAndUpdatePattern(&amp;v, patternParts, value, newPath) </span><span class="cov0" title="0">{
                                modified = true
                        }</span>
                }

        case []interface{}:<span class="cov0" title="0">
                // Search in array elements
                for i := range currentData </span><span class="cov0" title="0">{
                        arrayPath := fmt.Sprintf("%s[%d]", currentPath, i)
                        if findAndUpdatePattern(&amp;currentData[i], patternParts, value, arrayPath) </span><span class="cov0" title="0">{
                                modified = true
                        }</span>
                }
        }

        <span class="cov0" title="0">return modified</span>
}

// canMatchPatternFromHere checks if a field pattern can be matched starting from the given map
func canMatchPatternFromHere(data map[string]interface{}, patternParts []string) bool <span class="cov0" title="0">{
        current := data

        for i, part := range patternParts </span><span class="cov0" title="0">{
                if i == len(patternParts)-1 </span><span class="cov0" title="0">{
                        // Last part - just check if key exists
                        _, exists := current[part]
                        return exists
                }</span>

                // Intermediate part - must exist and be a map
                <span class="cov0" title="0">if val, exists := current[part]; exists </span><span class="cov0" title="0">{
                        if nextMap, ok := val.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                current = nextMap
                        }</span> else<span class="cov0" title="0"> {
                                return false
                        }</span>
                } else<span class="cov0" title="0"> {
                        return false
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

// applyPatternToMap applies a pattern to a map by navigating the nested structure
func applyPatternToMap(data map[string]interface{}, patternParts []string, value interface{}) bool <span class="cov0" title="0">{
        current := data

        for i, part := range patternParts </span><span class="cov0" title="0">{
                if i == len(patternParts)-1 </span><span class="cov0" title="0">{
                        // Last part - update the value
                        current[part] = value
                        return true
                }</span>

                // Intermediate part - navigate deeper
                <span class="cov0" title="0">if val, exists := current[part]; exists </span><span class="cov0" title="0">{
                        if nextMap, ok := val.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                current = nextMap
                        }</span> else<span class="cov0" title="0"> {
                                return false
                        }</span>
                } else<span class="cov0" title="0"> {
                        return false
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

// // separateTemplateAndPathOverrides separates template variables from path-based overrides and field name searches
// func separateTemplateAndPathOverrides(overrides map[string]interface{}) (map[string]interface{}, map[string]interface{}) {
//         templateVars := make(map[string]interface{})
//         pathOverrides := make(map[string]interface{})

//         for key, value := range overrides {
//                 if isTemplateVariable(key) {
//                         templateVars[key] = value
//                 } else {
//                         pathOverrides[key] = value
//                 }
//         }

//         return templateVars, pathOverrides
// }

// separateOverrideTypes separates overrides into template variables, wildcard patterns, field pattern searches, and path-based overrides
func separateOverrideTypes(yamlContent string, overrides map[string]interface{}) (map[string]interface{}, map[string]interface{}, map[string]interface{}, map[string]interface{}) <span class="cov0" title="0">{
        templateVars := make(map[string]interface{})
        wildcardPatterns := make(map[string]interface{})
        fieldPatternOverrides := make(map[string]interface{})
        pathOverrides := make(map[string]interface{})

        for key, value := range overrides </span><span class="cov0" title="0">{
                if isActualTemplateVariable(yamlContent, key) </span><span class="cov0" title="0">{
                        templateVars[key] = value
                }</span> else<span class="cov0" title="0"> if isWildcardPattern(key) </span><span class="cov0" title="0">{
                        wildcardPatterns[key] = value
                }</span> else<span class="cov0" title="0"> if isFieldPattern(key) </span><span class="cov0" title="0">{
                        fieldPatternOverrides[key] = value
                }</span> else<span class="cov0" title="0"> {
                        pathOverrides[key] = value
                }</span>
        }

        <span class="cov0" title="0">return templateVars, wildcardPatterns, fieldPatternOverrides, pathOverrides</span>
}

// isActualTemplateVariable checks if a key is actually used as a template variable in the YAML content
func isActualTemplateVariable(yamlContent string, key string) bool <span class="cov0" title="0">{
        // Template variables must be simple identifiers without dots
        if strings.Contains(key, ".") || strings.Contains(key, "[") || strings.Contains(key, "]") </span><span class="cov0" title="0">{
                return false
        }</span>

        // Must be a valid identifier
        <span class="cov0" title="0">for _, char := range key </span><span class="cov0" title="0">{
                if !((char &gt;= 'a' &amp;&amp; char &lt;= 'z') ||
                        (char &gt;= 'A' &amp;&amp; char &lt;= 'Z') ||
                        (char &gt;= '0' &amp;&amp; char &lt;= '9') ||
                        char == '_' || char == '-') </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">if len(key) == 0 </span><span class="cov0" title="0">{
                return false
        }</span>

        // Check if the key is actually used as a template variable in the YAML
        <span class="cov0" title="0">patterns := []string{
                "${" + key + "}",  // ${key}
                "{{" + key + "}}", // {{key}}
                "$" + key,         // $key (simple)
        }

        for _, pattern := range patterns </span><span class="cov0" title="0">{
                if strings.Contains(yamlContent, pattern) </span><span class="cov0" title="0">{
                        log.Printf("[DEBUG] Found template variable pattern '%s' for key '%s'", pattern, key)
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

// isFieldPattern determines if a key represents a field pattern for field pattern search
func isFieldPattern(key string) bool <span class="cov0" title="0">{
        // Must not contain array notation
        if strings.Contains(key, "[") || strings.Contains(key, "]") </span><span class="cov0" title="0">{
                return false
        }</span>

        // Allow field patterns with any case - the distinction between document-specific
        // paths and field patterns will be made based on dot notation presence

        // Split by dots to validate each part
        <span class="cov0" title="0">parts := strings.Split(key, ".")
        for _, part := range parts </span><span class="cov0" title="0">{
                if part == "" </span><span class="cov0" title="0">{
                        return false // Empty parts not allowed
                }</span>

                // Each part must be a valid identifier (letters, numbers, underscore, hyphen)
                <span class="cov0" title="0">for _, char := range part </span><span class="cov0" title="0">{
                        if !((char &gt;= 'a' &amp;&amp; char &lt;= 'z') ||
                                (char &gt;= 'A' &amp;&amp; char &lt;= 'Z') ||
                                (char &gt;= '0' &amp;&amp; char &lt;= '9') ||
                                char == '_' || char == '-') </span><span class="cov0" title="0">{
                                return false
                        }</span>
                }
        }

        <span class="cov0" title="0">return len(key) &gt; 0</span>
}

// // isTemplateVariable determines if a key represents a template variable
// // Template variables are simple identifiers without dots, colons, or uppercase prefixes
// func isTemplateVariable(key string) bool {
//         // Must not contain dots (path separators)
//         if strings.Contains(key, ".") {
//                 return false
//         }

//         // Must not contain array notation
//         if strings.Contains(key, "[") || strings.Contains(key, "]") {
//                 return false
//         }

//         // Must not start with uppercase (Kind prefixes)
//         if len(key) &gt; 0 &amp;&amp; key[0] &gt;= 'A' &amp;&amp; key[0] &lt;= 'Z' {
//                 return false
//         }

//         // Must be a valid identifier (letters, numbers, underscore, hyphen)
//         for _, char := range key {
//                 if !((char &gt;= 'a' &amp;&amp; char &lt;= 'z') ||
//                         (char &gt;= 'A' &amp;&amp; char &lt;= 'Z') ||
//                         (char &gt;= '0' &amp;&amp; char &lt;= '9') ||
//                         char == '_' || char == '-') {
//                         return false
//                 }
//         }

//         return len(key) &gt; 0
// }

// isWildcardPattern determines if a key represents a wildcard pattern (starts with *)
func isWildcardPattern(key string) bool <span class="cov0" title="0">{
        return strings.HasPrefix(key, "*") &amp;&amp; len(key) &gt; 1
}</span>

// applyWildcardPatternOverrides applies wildcard pattern-based overrides to multi-document YAML
func applyWildcardPatternOverrides(yamlContent string, wildcardOverrides map[string]interface{}) (string, error) <span class="cov0" title="0">{
        // Split multi-document YAML
        documents := strings.Split(yamlContent, "---")
        var processedDocs []string

        for _, doc := range documents </span><span class="cov0" title="0">{
                doc = strings.TrimSpace(doc)
                if doc == "" </span><span class="cov0" title="0">{
                        processedDocs = append(processedDocs, "")
                        continue</span>
                }

                // Parse YAML document
                <span class="cov0" title="0">var yamlData interface{}
                if err := yaml.Unmarshal([]byte(doc), &amp;yamlData); err != nil </span><span class="cov0" title="0">{
                        // If parsing fails, keep original document
                        processedDocs = append(processedDocs, doc)
                        continue</span>
                }

                // Apply wildcard pattern overrides to this document
                <span class="cov0" title="0">modified := false
                for wildcardPattern, value := range wildcardOverrides </span><span class="cov0" title="0">{
                        // Remove the * prefix to get the actual pattern to match
                        pattern := strings.TrimPrefix(wildcardPattern, "*")
                        convertedValue := convertStringToAppropriateType(value.(string))

                        if applyWildcardPatternToDocument(&amp;yamlData, pattern, convertedValue) </span><span class="cov0" title="0">{
                                log.Printf("[DEBUG] Successfully applied wildcard pattern override: %s = %v", wildcardPattern, convertedValue)
                                modified = true
                        }</span>
                }

                // Convert back to YAML
                <span class="cov0" title="0">if modified </span><span class="cov0" title="0">{
                        processedYaml, err := yaml.Marshal(yamlData)
                        if err != nil </span><span class="cov0" title="0">{
                                processedDocs = append(processedDocs, doc)
                                continue</span>
                        }
                        <span class="cov0" title="0">processedDocs = append(processedDocs, strings.TrimSpace(string(processedYaml)))</span>
                } else<span class="cov0" title="0"> {
                        processedDocs = append(processedDocs, doc)
                }</span>
        }

        <span class="cov0" title="0">return strings.Join(processedDocs, "\n---\n"), nil</span>
}

// applyWildcardPatternToDocument applies a wildcard pattern override to all matching field names in a document
func applyWildcardPatternToDocument(data *interface{}, pattern string, value interface{}) bool <span class="cov0" title="0">{
        modified := false

        // Recursively search for field names that contain the pattern
        if findAndUpdateWildcardPattern(data, pattern, value, "") </span><span class="cov0" title="0">{
                modified = true
        }</span>

        <span class="cov0" title="0">return modified</span>
}

// findAndUpdateWildcardPattern recursively searches for field names containing the pattern and updates their values
func findAndUpdateWildcardPattern(data *interface{}, pattern string, value interface{}, currentPath string) bool <span class="cov0" title="0">{
        if pattern == "" </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">modified := false

        switch currentData := (*data).(type) </span>{
        case map[string]interface{}:<span class="cov0" title="0">
                // Check all keys in the current map for pattern matches
                for key, v := range currentData </span><span class="cov0" title="0">{
                        // Check if this key contains the pattern
                        if strings.Contains(key, pattern) </span><span class="cov0" title="0">{
                                log.Printf("[DEBUG] Found wildcard pattern match: field '%s' contains pattern '%s' at path '%s'", key, pattern, currentPath)
                                currentData[key] = value
                                modified = true
                        }</span>

                        // Recursively search nested structures
                        <span class="cov0" title="0">newPath := currentPath
                        if newPath != "" </span><span class="cov0" title="0">{
                                newPath += "."
                        }</span>
                        <span class="cov0" title="0">newPath += key

                        if findAndUpdateWildcardPattern(&amp;v, pattern, value, newPath) </span><span class="cov0" title="0">{
                                modified = true
                        }</span>
                }

        case map[interface{}]interface{}:<span class="cov0" title="0">
                // Convert to string keys and search
                stringMap := make(map[string]interface{})
                for k, v := range currentData </span><span class="cov0" title="0">{
                        if keyStr, ok := k.(string); ok </span><span class="cov0" title="0">{
                                stringMap[keyStr] = v
                        }</span>
                }

                // Check all keys for pattern matches
                <span class="cov0" title="0">for key, v := range stringMap </span><span class="cov0" title="0">{
                        if strings.Contains(key, pattern) </span><span class="cov0" title="0">{
                                log.Printf("[DEBUG] Found wildcard pattern match: field '%s' contains pattern '%s' at path '%s'", key, pattern, currentPath)
                                stringMap[key] = value
                                *data = stringMap
                                modified = true
                        }</span>

                        // Recursively search nested structures
                        <span class="cov0" title="0">newPath := currentPath
                        if newPath != "" </span><span class="cov0" title="0">{
                                newPath += "."
                        }</span>
                        <span class="cov0" title="0">newPath += key

                        if findAndUpdateWildcardPattern(&amp;v, pattern, value, newPath) </span><span class="cov0" title="0">{
                                modified = true
                        }</span>
                }

        case []interface{}:<span class="cov0" title="0">
                // Search in array elements
                for i := range currentData </span><span class="cov0" title="0">{
                        arrayPath := fmt.Sprintf("%s[%d]", currentPath, i)
                        if findAndUpdateWildcardPattern(&amp;currentData[i], pattern, value, arrayPath) </span><span class="cov0" title="0">{
                                modified = true
                        }</span>
                }
        }

        <span class="cov0" title="0">return modified</span>
}

// applyTemplateSubstitution replaces template variables in the YAML content
func applyTemplateSubstitution(yamlContent string, templateVars map[string]interface{}) string <span class="cov0" title="0">{
        result := yamlContent

        for varName, value := range templateVars </span><span class="cov0" title="0">{
                valueStr := value.(string) // Type assertion safe since we control input

                // Support multiple template syntaxes
                patterns := []string{
                        "${" + varName + "}",  // ${var_name}
                        "{{" + varName + "}}", // {{var_name}}
                        "$" + varName,         // $var_name (simple)
                }

                for _, pattern := range patterns </span><span class="cov0" title="0">{
                        if strings.Contains(result, pattern) </span><span class="cov0" title="0">{
                                log.Printf("[DEBUG] Replacing template variable: %s -&gt; %s", pattern, valueStr)
                                result = strings.ReplaceAll(result, pattern, valueStr)
                        }</span>
                }
        }

        <span class="cov0" title="0">return result</span>
}

// extractDocumentKind extracts the 'kind' field from a YAML document
func extractDocumentKind(data interface{}) string <span class="cov0" title="0">{
        if dataMap, ok := data.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                if kind, exists := dataMap["kind"]; exists </span><span class="cov0" title="0">{
                        if kindStr, ok := kind.(string); ok </span><span class="cov0" title="0">{
                                return kindStr
                        }</span>
                }
        }
        <span class="cov0" title="0">if dataMap, ok := data.(map[interface{}]interface{}); ok </span><span class="cov0" title="0">{
                if kind, exists := dataMap["kind"]; exists </span><span class="cov0" title="0">{
                        if kindStr, ok := kind.(string); ok </span><span class="cov0" title="0">{
                                return kindStr
                        }</span>
                }
        }
        <span class="cov0" title="0">return ""</span>
}

// parseDocumentSpecificPath splits document-specific path into kind and path components
// Examples: "Cluster.metadata.labels" -&gt; ("Cluster", "metadata.labels")
//
//        "metadata.labels" -&gt; ("", "metadata.labels")
func parseDocumentSpecificPath(path string) (string, string) <span class="cov0" title="0">{
        parts := strings.SplitN(path, ".", 2)
        if len(parts) == 2 </span><span class="cov0" title="0">{
                // Check if first part looks like a Kubernetes kind (starts with uppercase)
                if len(parts[0]) &gt; 0 &amp;&amp; parts[0][0] &gt;= 'A' &amp;&amp; parts[0][0] &lt;= 'Z' </span><span class="cov0" title="0">{
                        return parts[0], parts[1]
                }</span>
        }
        // Not document-specific, return empty kind and full path
        <span class="cov0" title="0">return "", path</span>
}

// applyOverrideToDocumentWithKind applies a single override to a YAML document with kind matching
func applyOverrideToDocumentWithKind(data *interface{}, path string, value interface{}, documentKind string) bool <span class="cov0" title="0">{
        // Parse document-specific path
        targetKind, actualPath := parseDocumentSpecificPath(path)

        // If target kind is specified and doesn't match document kind, skip
        if targetKind != "" &amp;&amp; targetKind != documentKind </span><span class="cov0" title="0">{
                return false
        }</span>

        // Apply the override using the actual path (without kind prefix)
        <span class="cov0" title="0">pathParts := parsePath(actualPath)
        if len(pathParts) == 0 </span><span class="cov0" title="0">{
                return false
        }</span>

        // Convert string value to appropriate type (TypeMap only supports strings)
        <span class="cov0" title="0">convertedValue := convertStringToAppropriateType(value.(string))

        return setValueAtPath(data, pathParts, convertedValue)</span>
}

// // applyOverrideToDocument applies a single override to a YAML document (legacy function for backward compatibility)
// func applyOverrideToDocument(data *interface{}, path string, value interface{}) bool {
//         return applyOverrideToDocumentWithKind(data, path, value, "")
// }

// parsePath splits a dot-notation path into components, handling array indices
func parsePath(path string) []string <span class="cov0" title="0">{
        // Replace array notation [index] with .index for consistent splitting
        path = strings.ReplaceAll(path, "[", ".")
        path = strings.ReplaceAll(path, "]", "")

        parts := strings.Split(path, ".")
        var result []string
        for _, part := range parts </span><span class="cov0" title="0">{
                if part != "" </span><span class="cov0" title="0">{
                        result = append(result, part)
                }</span>
        }
        <span class="cov0" title="0">return result</span>
}

// // convertOverrideValueFromInterface handles values that come as interface{} from Terraform
// func convertOverrideValueFromInterface(value interface{}) interface{} {
//         switch v := value.(type) {
//         case string:
//                 // If it's a string, try to parse it as JSON for complex types
//                 return convertStringToAppropriateType(v)
//         case bool, int, int64, float64:
//                 // Native types are returned as-is
//                 return v
//         case []interface{}, map[string]interface{}:
//                 // Complex types are returned as-is
//                 return v
//         default:
//                 // Fallback to string representation
//                 return fmt.Sprintf("%v", v)
//         }
// }

// convertStringToAppropriateType tries to convert a string to a more appropriate type
func convertStringToAppropriateType(value string) interface{} <span class="cov0" title="0">{
        value = strings.TrimSpace(value)

        // Try to parse as JSON first (for arrays and objects)
        var jsonValue interface{}
        if err := json.Unmarshal([]byte(value), &amp;jsonValue); err == nil </span><span class="cov0" title="0">{
                return jsonValue
        }</span>

        // Try boolean
        <span class="cov0" title="0">if boolVal, err := strconv.ParseBool(value); err == nil </span><span class="cov0" title="0">{
                return boolVal
        }</span>

        // Try integer
        <span class="cov0" title="0">if intVal, err := strconv.ParseInt(value, 10, 64); err == nil </span><span class="cov0" title="0">{
                return intVal
        }</span>

        // Try float
        <span class="cov0" title="0">if floatVal, err := strconv.ParseFloat(value, 64); err == nil </span><span class="cov0" title="0">{
                return floatVal
        }</span>

        // Return as string if nothing else works
        <span class="cov0" title="0">return value</span>
}

// // convertOverrideValue converts a string value to its appropriate type (kept for backward compatibility)
// func convertOverrideValue(value string) (interface{}, error) {
//         return convertStringToAppropriateType(value), nil
// }

// setValueAtPath sets a value at the specified path in a nested structure
func setValueAtPath(data *interface{}, pathParts []string, value interface{}) bool <span class="cov0" title="0">{
        if len(pathParts) == 0 </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">current := *data

        for i, part := range pathParts </span><span class="cov0" title="0">{
                isLast := i == len(pathParts)-1

                switch currentData := current.(type) </span>{
                case map[string]interface{}:<span class="cov0" title="0">
                        if isLast </span><span class="cov0" title="0">{
                                currentData[part] = value
                                return true
                        }</span>

                        // Create nested structure if it doesn't exist
                        <span class="cov0" title="0">if _, exists := currentData[part]; !exists </span><span class="cov0" title="0">{
                                // Determine if next part is an array index
                                if i+1 &lt; len(pathParts) </span><span class="cov0" title="0">{
                                        if _, err := strconv.Atoi(pathParts[i+1]); err == nil </span><span class="cov0" title="0">{
                                                currentData[part] = make([]interface{}, 0)
                                        }</span> else<span class="cov0" title="0"> {
                                                currentData[part] = make(map[string]interface{})
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        currentData[part] = make(map[string]interface{})
                                }</span>
                        }
                        <span class="cov0" title="0">current = currentData[part]</span>

                case map[interface{}]interface{}:<span class="cov0" title="0">
                        // Convert to map[string]interface{} for easier handling
                        stringMap := make(map[string]interface{})
                        for k, v := range currentData </span><span class="cov0" title="0">{
                                if keyStr, ok := k.(string); ok </span><span class="cov0" title="0">{
                                        stringMap[keyStr] = v
                                }</span>
                        }

                        <span class="cov0" title="0">if isLast </span><span class="cov0" title="0">{
                                stringMap[part] = value
                                *data = stringMap
                                return true
                        }</span>

                        <span class="cov0" title="0">if _, exists := stringMap[part]; !exists </span><span class="cov0" title="0">{
                                if i+1 &lt; len(pathParts) </span><span class="cov0" title="0">{
                                        if _, err := strconv.Atoi(pathParts[i+1]); err == nil </span><span class="cov0" title="0">{
                                                stringMap[part] = make([]interface{}, 0)
                                        }</span> else<span class="cov0" title="0"> {
                                                stringMap[part] = make(map[string]interface{})
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        stringMap[part] = make(map[string]interface{})
                                }</span>
                        }
                        <span class="cov0" title="0">current = stringMap[part]</span>

                case []interface{}:<span class="cov0" title="0">
                        index, err := strconv.Atoi(part)
                        if err != nil </span><span class="cov0" title="0">{
                                return false
                        }</span>

                        // Extend array if necessary
                        <span class="cov0" title="0">for len(currentData) &lt;= index </span><span class="cov0" title="0">{
                                currentData = append(currentData, nil)
                        }</span>

                        <span class="cov0" title="0">if isLast </span><span class="cov0" title="0">{
                                currentData[index] = value
                                return true
                        }</span>

                        // Create nested structure if it doesn't exist
                        <span class="cov0" title="0">if currentData[index] == nil </span><span class="cov0" title="0">{
                                if i+1 &lt; len(pathParts) </span><span class="cov0" title="0">{
                                        if _, err := strconv.Atoi(pathParts[i+1]); err == nil </span><span class="cov0" title="0">{
                                                currentData[index] = make([]interface{}, 0)
                                        }</span> else<span class="cov0" title="0"> {
                                                currentData[index] = make(map[string]interface{})
                                        }</span>
                                }
                        }
                        <span class="cov0" title="0">current = currentData[index]</span>

                default:<span class="cov0" title="0">
                        // Cannot traverse further
                        return false</span>
                }
        }

        <span class="cov0" title="0">return false</span>
}

func toCustomClusterConfig(d *schema.ResourceData) *models.V1CustomClusterConfigEntity <span class="cov0" title="0">{
        customClusterConfig := &amp;models.V1CustomClusterConfigEntity{
                Location:                toClusterLocationConfigs(d),
                MachineManagementConfig: toMachineManagementConfig(d),
                Resources:               toClusterResourceConfig(d),
        }

        return customClusterConfig
}</span>

// extractMachinePoolNameFromYAML extracts the machine pool name from YAML content
func extractMachinePoolNameFromYAML(machinePoolResource map[string]interface{}) string <span class="cov0" title="0">{
        nodePoolConfigYaml, ok := machinePoolResource["node_pool_config"].(string)
        if !ok || nodePoolConfigYaml == "" </span><span class="cov0" title="0">{
                log.Printf("[DEBUG] No node_pool_config found in machine pool resource")
                return ""
        }</span>

        // Parse multi-document YAML to find the machine pool name
        <span class="cov0" title="0">decoder := yaml.NewDecoder(strings.NewReader(nodePoolConfigYaml))

        for </span><span class="cov0" title="0">{
                var doc map[string]interface{}
                if err := decoder.Decode(&amp;doc); err != nil </span><span class="cov0" title="0">{
                        if err.Error() == "EOF" </span><span class="cov0" title="0">{
                                break</span>
                        }
                        <span class="cov0" title="0">log.Printf("[DEBUG] Failed to parse YAML document: %v", err)
                        continue</span>
                }

                // Look for metadata.name in each document
                <span class="cov0" title="0">if metadata, ok := doc["metadata"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                        if name, ok := metadata["name"].(string); ok &amp;&amp; name != "" </span><span class="cov0" title="0">{
                                // Check if this is the main MachineDeployment (has spec.replicas or spec.template)
                                if spec, hasSpec := doc["spec"].(map[string]interface{}); hasSpec </span><span class="cov0" title="0">{
                                        if _, hasReplicas := spec["replicas"]; hasReplicas </span><span class="cov0" title="0">{
                                                log.Printf("[DEBUG] Found machine pool name '%s' from MachineDeployment", name)
                                                return name
                                        }</span>
                                        <span class="cov0" title="0">if _, hasTemplate := spec["template"]; hasTemplate </span><span class="cov0" title="0">{
                                                log.Printf("[DEBUG] Found machine pool name '%s' from document with template", name)
                                                return name
                                        }</span>
                                }
                        }
                }
        }

        <span class="cov0" title="0">log.Printf("[DEBUG] Could not extract machine pool name from YAML")
        return ""</span>
}

func toMachinePoolCustomCloud(machinePool interface{}) *models.V1CustomMachinePoolConfigEntity <span class="cov0" title="0">{
        mp := &amp;models.V1CustomMachinePoolConfigEntity{}
        node := machinePool.(map[string]interface{})
        controlPlaneAsWorker, _ := node["control_plane_as_worker"].(bool)

        // Get node pool config YAML
        nodePoolConfigYaml := strings.TrimSpace(node["node_pool_config"].(string))

        log.Printf("[DEBUG] === MACHINE POOL OVERRIDE PROCESSING ===")
        log.Printf("[DEBUG] Original node pool config YAML length: %d", len(nodePoolConfigYaml))
        log.Printf("[DEBUG] Original YAML preview: %s", nodePoolConfigYaml[:min(300, len(nodePoolConfigYaml))])

        // Check if YAML contains KubeadmControlPlane (indicates control plane)
        var controlPlane bool
        if strings.Contains(nodePoolConfigYaml, "kind: KubeadmControlPlane") </span><span class="cov0" title="0">{
                controlPlane = true
                log.Printf("[DEBUG] Detected control plane from YAML (KubeadmControlPlane found)")
        }</span> else<span class="cov0" title="0"> {
                controlPlane = false
                log.Printf("[DEBUG] Detected worker pool from YAML (MachineDeployment)")
        }</span>

        // Taints are now handled directly via API, no YAML injection needed

        // Check if overrides exist in the node map
        <span class="cov0" title="0">log.Printf("[DEBUG] Checking for overrides in node map. Keys: %v", getMapKeys(node))
        if overrideValue, exists := node["overrides"]; exists </span><span class="cov0" title="0">{
                log.Printf("[DEBUG] Raw overrides value: %v (type: %T)", overrideValue, overrideValue)
        }</span> else<span class="cov0" title="0"> {
                log.Printf("[DEBUG] No 'overrides' key found in node map")
        }</span>

        // Apply overrides if they exist
        <span class="cov0" title="0">if overrides, ok := node["overrides"].(map[string]interface{}); ok &amp;&amp; len(overrides) &gt; 0 </span><span class="cov0" title="0">{
                log.Printf("[DEBUG] Successfully cast overrides. Applying %d YAML overrides to node pool config", len(overrides))
                for path, value := range overrides </span><span class="cov0" title="0">{
                        log.Printf("[DEBUG] Node pool override: %s = %v (type: %T)", path, value, value)
                }</span>

                <span class="cov0" title="0">processedYaml, err := applyYamlOverridesWithTemplates(nodePoolConfigYaml, overrides)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("[ERROR] Failed to apply YAML overrides to node pool config: %v", err)
                }</span> else<span class="cov0" title="0"> {
                        log.Printf("[DEBUG] Node pool YAML transformation successful. Original length: %d, New length: %d", len(nodePoolConfigYaml), len(processedYaml))
                        if len(processedYaml) &gt; 0 &amp;&amp; processedYaml != nodePoolConfigYaml </span><span class="cov0" title="0">{
                                log.Printf("[DEBUG] Node pool YAML values updated with overrides")
                                log.Printf("[DEBUG] Processed YAML preview: %s", processedYaml[:min(300, len(processedYaml))])
                        }</span> else<span class="cov0" title="0"> {
                                log.Printf("[DEBUG] WARNING: Processed YAML is identical to original - overrides may not have applied")
                        }</span>
                        <span class="cov0" title="0">nodePoolConfigYaml = processedYaml</span>
                }
        } else<span class="cov0" title="0"> {
                log.Printf("[DEBUG] No overrides found for node pool config or failed to cast to map[string]interface{}")
                if overrideValue, exists := node["overrides"]; exists </span><span class="cov0" title="0">{
                        log.Printf("[DEBUG] Override value exists but type assertion failed. Type: %T, Value: %v", overrideValue, overrideValue)
                }</span>
        }

        // Normalize the final YAML content to ensure consistent formatting
        <span class="cov0" title="0">nodePoolConfigYaml = NormalizeYamlContent(nodePoolConfigYaml)
        log.Printf("[DEBUG] Final normalized node pool YAML length: %d", len(nodePoolConfigYaml))

        mp.CloudConfig = &amp;models.V1CustomMachinePoolCloudConfigEntity{
                Values: nodePoolConfigYaml,
        }
        mp.PoolConfig = &amp;models.V1CustomMachinePoolBaseConfigEntity{
                Taints:                  toClusterTaints(node),
                IsControlPlane:          controlPlane,
                UseControlPlaneAsWorker: controlPlaneAsWorker,
        }
        return mp</span>
}

func flattenMachinePoolConfigsCustomCloud(machinePools []*models.V1CustomMachinePoolConfig) []interface{} <span class="cov0" title="0">{
        if len(machinePools) == 0 </span><span class="cov0" title="0">{
                return make([]interface{}, 0)
        }</span>
        <span class="cov0" title="0">mps := make([]interface{}, len(machinePools))

        for i, machinePool := range machinePools </span><span class="cov0" title="0">{
                mp := make(map[string]interface{})

                // Handle taints directly from API response
                taints := flattenClusterTaints(machinePool.Taints)
                if len(taints) &gt; 0 </span><span class="cov0" title="0">{
                        mp["taints"] = taints
                }</span>

                <span class="cov0" title="0">mp["control_plane_as_worker"] = machinePool.UseControlPlaneAsWorker
                mp["control_plane"] = machinePool.IsControlPlane
                mp["node_pool_config"] = machinePool.Values
                mp["name"] = machinePool.Name
                mp["count"] = machinePool.Size
                mps[i] = mp</span>
        }

        <span class="cov0" title="0">return mps</span>
}

func flattenMachinePoolConfigsCustomCloudWithOverrides(machinePools []*models.V1CustomMachinePoolConfig, d *schema.ResourceData) []interface{} <span class="cov0" title="0">{
        if len(machinePools) == 0 </span><span class="cov0" title="0">{
                return make([]interface{}, 0)
        }</span>

        // Get current machine pool configuration from state
        <span class="cov0" title="0">currentMachinePoolsRaw := d.Get("machine_pool")
        currentMPMap := make(map[string]map[string]interface{})

        // Handle both TypeSet (new) and TypeList (during migration) formats
        var currentMachinePools []interface{}
        if machinePoolSet, ok := currentMachinePoolsRaw.(*schema.Set); ok </span><span class="cov0" title="0">{
                // TypeSet format
                currentMachinePools = machinePoolSet.List()
        }</span> else<span class="cov0" title="0"> if machinePoolList, ok := currentMachinePoolsRaw.([]interface{}); ok </span><span class="cov0" title="0">{
                // TypeList format (legacy/migration)
                currentMachinePools = machinePoolList
        }</span>

        <span class="cov0" title="0">for _, mp := range currentMachinePools </span><span class="cov0" title="0">{
                if mpMap, ok := mp.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                        if name, exists := mpMap["name"]; exists </span><span class="cov0" title="0">{
                                currentMPMap[name.(string)] = mpMap
                        }</span>
                }
        }

        <span class="cov0" title="0">mps := make([]interface{}, len(machinePools))

        for i, machinePool := range machinePools </span><span class="cov0" title="0">{
                mp := make(map[string]interface{})

                // Get current configuration for this machine pool from Terraform state
                var currentNodePoolConfig string
                var currentOverrides map[string]interface{}

                if currentMP, exists := currentMPMap[machinePool.Name]; exists </span><span class="cov0" title="0">{
                        if config, exists := currentMP["node_pool_config"]; exists </span><span class="cov0" title="0">{
                                currentNodePoolConfig = config.(string)
                        }</span>
                        <span class="cov0" title="0">if overrides, exists := currentMP["overrides"]; exists </span><span class="cov0" title="0">{
                                if overridesMap, ok := overrides.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                        currentOverrides = overridesMap
                                }</span>
                        }
                }

                // Handle taints directly from API response
                <span class="cov0" title="0">taints := flattenClusterTaints(machinePool.Taints)
                if len(taints) &gt; 0 </span><span class="cov0" title="0">{
                        mp["taints"] = taints
                }</span>

                <span class="cov0" title="0">mp["control_plane_as_worker"] = machinePool.UseControlPlaneAsWorker
                mp["control_plane"] = machinePool.IsControlPlane
                mp["name"] = machinePool.Name
                mp["count"] = machinePool.Size

                // Handle node_pool_config with override reconciliation (existing logic)
                apiNodePoolConfig := machinePool.Values

                if currentNodePoolConfig != "" &amp;&amp; len(currentOverrides) &gt; 0 </span><span class="cov0" title="0">{
                        // Apply current overrides to current config to get expected result
                        expectedConfig, err := applyYamlOverridesWithTemplates(currentNodePoolConfig, currentOverrides)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Printf("[DEBUG] Failed to apply overrides for machine pool state comparison: %v", err)
                                nodeConfig := NormalizeYamlContent(apiNodePoolConfig)
                                mp["node_pool_config"] = nodeConfig
                                if isMultiLineYAML(nodeConfig) </span><span class="cov0" title="0">{
                                        log.Printf("[INFO] Machine pool '%s' contains multi-line YAML. Consider using heredoc syntax (&lt;&lt;EOT...EOT) for better readability after import.", machinePool.Name)
                                }</span>
                        } else<span class="cov0" title="0"> {
                                // Simple YAML comparison - taints are now handled separately via API
                                expectedNormalized := NormalizeYamlContent(expectedConfig)
                                apiNormalized := NormalizeYamlContent(apiNodePoolConfig)

                                if expectedNormalized == apiNormalized </span><span class="cov0" title="0">{
                                        // No drift detected - use normalized original config (before overrides)
                                        log.Printf("[DEBUG] No drift detected for machine pool %s, preserving original configuration", machinePool.Name)
                                        nodeConfig := NormalizeYamlContent(currentNodePoolConfig)
                                        mp["node_pool_config"] = nodeConfig
                                        if isMultiLineYAML(nodeConfig) </span><span class="cov0" title="0">{
                                                log.Printf("[INFO] Machine pool '%s' contains multi-line YAML. Consider using heredoc syntax (&lt;&lt;EOT...EOT) for better readability after import.", machinePool.Name)
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        // Drift detected - use normalized API config
                                        log.Printf("[DEBUG] Drift detected for machine pool %s, using API config", machinePool.Name)
                                        nodeConfig := NormalizeYamlContent(apiNodePoolConfig)
                                        mp["node_pool_config"] = nodeConfig
                                        if isMultiLineYAML(nodeConfig) </span><span class="cov0" title="0">{
                                                log.Printf("[INFO] Machine pool '%s' contains multi-line YAML. Consider using heredoc syntax (&lt;&lt;EOT...EOT) for better readability after import.", machinePool.Name)
                                        }</span>
                                }
                        }

                        // Always preserve overrides from current state
                        <span class="cov0" title="0">mp["overrides"] = currentOverrides</span>
                } else<span class="cov0" title="0"> {
                        // No overrides, use normalized API config directly
                        nodeConfig := NormalizeYamlContent(apiNodePoolConfig)
                        mp["node_pool_config"] = nodeConfig
                        if isMultiLineYAML(nodeConfig) </span><span class="cov0" title="0">{
                                log.Printf("[INFO] Machine pool '%s' contains multi-line YAML. Consider using heredoc syntax (&lt;&lt;EOT...EOT) for better readability after import.", machinePool.Name)
                        }</span>

                        // Preserve any existing overrides from state
                        <span class="cov0" title="0">if currentMP, exists := currentMPMap[machinePool.Name]; exists </span><span class="cov0" title="0">{
                                if overrides, exists := currentMP["overrides"]; exists </span><span class="cov0" title="0">{
                                        mp["overrides"] = overrides
                                }</span>
                        }
                }

                <span class="cov0" title="0">mps[i] = mp</span>
        }

        <span class="cov0" title="0">return mps</span>
}

func flattenCloudConfigCustom(configUID string, d *schema.ResourceData, c *client.V1Client) (diag.Diagnostics, bool) <span class="cov0" title="0">{
        log.Printf("[ERROR] ======= FLATTEN CLOUD CONFIG CUSTOM START =======")
        cloudType := d.Get("cloud").(string)
        if err := d.Set("cloud_config_id", configUID); err != nil </span><span class="cov0" title="0">{
                log.Printf("[ERROR] Failed to set cloud_config_id: %v", err)
                return diag.FromErr(err), true
        }</span>

        <span class="cov0" title="0">if err := ReadCommonAttributes(d); err != nil </span><span class="cov0" title="0">{
                log.Printf("[ERROR] ReadCommonAttributes failed: %v", err)
                return diag.FromErr(err), true
        }</span>
        <span class="cov0" title="0">log.Printf("[ERROR] About to call GetCloudConfigCustomCloud")
        if config, err := c.GetCloudConfigCustomCloud(configUID, cloudType); err != nil </span><span class="cov0" title="0">{
                log.Printf("[ERROR] GetCloudConfigCustomCloud failed: %v", err)
                return diag.FromErr(err), true
        }</span> else<span class="cov0" title="0"> {
                log.Printf("[ERROR] GetCloudConfigCustomCloud succeeded, config has %d machine pools", len(config.Spec.MachinePoolConfig))
                if config.Spec != nil &amp;&amp; config.Spec.CloudAccountRef != nil </span><span class="cov0" title="0">{
                        if err := d.Set("cloud_account_id", config.Spec.CloudAccountRef.UID); err != nil </span><span class="cov0" title="0">{
                                log.Printf("[ERROR] Failed to set cloud_account_id: %v", err)
                                return diag.FromErr(err), true
                        }</span>
                }
                <span class="cov0" title="0">if err := d.Set("cloud_config", flattenCloudConfigsValuesCustomCloudWithOverrides(config, d)); err != nil </span><span class="cov0" title="0">{
                        log.Printf("[ERROR] Failed to set cloud_config: %v", err)
                        return diag.FromErr(err), true
                }</span>
                <span class="cov0" title="0">log.Printf("[ERROR] About to call flattenMachinePoolConfigsCustomCloudWithOverrides")
                if err := d.Set("machine_pool", schema.NewSet(resourceMachinePoolCustomCloudHash, flattenMachinePoolConfigsCustomCloudWithOverrides(config.Spec.MachinePoolConfig, d))); err != nil </span><span class="cov0" title="0">{
                        log.Printf("[ERROR] Failed to set machine_pool: %v", err)
                        return diag.FromErr(err), true
                }</span>
                <span class="cov0" title="0">log.Printf("[ERROR] Successfully set machine_pool")</span>
        }
        <span class="cov0" title="0">log.Printf("[ERROR] ======= FLATTEN CLOUD CONFIG CUSTOM END =======")

        return nil, false</span>
}

func flattenCloudConfigsValuesCustomCloud(config *models.V1CustomCloudConfig) []interface{} <span class="cov0" title="0">{
        if config == nil || config.Spec == nil || config.Spec.ClusterConfig == nil </span><span class="cov0" title="0">{
                return make([]interface{}, 0)
        }</span>

        <span class="cov0" title="0">m := make(map[string]interface{})

        if String(config.Spec.ClusterConfig.Values) != "" </span><span class="cov0" title="0">{
                m["values"] = String(config.Spec.ClusterConfig.Values)
        }</span>

        <span class="cov0" title="0">return []interface{}{m}</span>
}

func flattenCloudConfigsValuesCustomCloudWithOverrides(config *models.V1CustomCloudConfig, d *schema.ResourceData) []interface{} <span class="cov0" title="0">{
        if config == nil || config.Spec == nil || config.Spec.ClusterConfig == nil </span><span class="cov0" title="0">{
                return make([]interface{}, 0)
        }</span>

        <span class="cov0" title="0">m := make(map[string]interface{})

        // Get the current configuration values and overrides
        currentConfig := d.Get("cloud_config").([]interface{})
        var currentValues string
        var currentOverrides map[string]interface{}

        if len(currentConfig) &gt; 0 </span><span class="cov0" title="0">{
                if currentConfigMap, ok := currentConfig[0].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                        if values, exists := currentConfigMap["values"]; exists </span><span class="cov0" title="0">{
                                currentValues = values.(string)
                        }</span>
                        <span class="cov0" title="0">if overrides, exists := currentConfigMap["overrides"]; exists </span><span class="cov0" title="0">{
                                if overridesMap, ok := overrides.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                        currentOverrides = overridesMap
                                }</span>
                        }
                }
        }

        // Get the actual values from API
        <span class="cov0" title="0">apiValues := String(config.Spec.ClusterConfig.Values)

        var finalValues string
        if currentValues != "" &amp;&amp; len(currentOverrides) &gt; 0 </span><span class="cov0" title="0">{
                // Apply current overrides to current config values to get expected result
                expectedValues, err := applyYamlOverridesWithTemplates(currentValues, currentOverrides)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("[DEBUG] Failed to apply overrides for state comparison: %v", err)
                        // Fall back to using normalized API values
                        finalValues = NormalizeYamlContent(apiValues)
                }</span> else<span class="cov0" title="0"> {
                        // Normalize both for comparison
                        expectedNormalized := NormalizeYamlContent(expectedValues)
                        apiNormalized := NormalizeYamlContent(apiValues)

                        if expectedNormalized == apiNormalized </span><span class="cov0" title="0">{
                                // No drift detected - use normalized original values (before overrides)
                                log.Printf("[DEBUG] No drift detected, preserving original configuration values")
                                finalValues = NormalizeYamlContent(currentValues)
                        }</span> else<span class="cov0" title="0"> {
                                // Drift detected - use normalized API values
                                log.Printf("[DEBUG] Drift detected, using API values")
                                finalValues = NormalizeYamlContent(apiValues)
                        }</span>
                }

                // Always preserve overrides from current state
                <span class="cov0" title="0">m["overrides"] = currentOverrides</span>
        } else<span class="cov0" title="0"> {
                // No overrides, use normalized API values directly
                finalValues = NormalizeYamlContent(apiValues)

                // Preserve any existing overrides from state
                if len(currentConfig) &gt; 0 </span><span class="cov0" title="0">{
                        if currentConfigMap, ok := currentConfig[0].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                if overrides, exists := currentConfigMap["overrides"]; exists </span><span class="cov0" title="0">{
                                        m["overrides"] = overrides
                                }</span>
                        }
                }
        }

        // Check if this is multi-line YAML that would benefit from heredoc formatting
        <span class="cov0" title="0">if isMultiLineYAML(finalValues) </span><span class="cov0" title="0">{
                // Add the values with a hint that heredoc would be better for readability
                m["values"] = finalValues
                // Note: We could add metadata here but Terraform generate-config-out will still escape it
                log.Printf("[INFO] Generated configuration contains multi-line YAML. Consider using heredoc syntax (&lt;&lt;EOT...EOT) for better readability after import.")
        }</span> else<span class="cov0" title="0"> {
                m["values"] = finalValues
        }</span>

        <span class="cov0" title="0">return []interface{}{m}</span>
}

// isMultiLineYAML checks if the content is multi-line YAML that would benefit from heredoc formatting
func isMultiLineYAML(content string) bool <span class="cov0" title="0">{
        // Check for multiple lines and YAML document separators or typical YAML structure
        lines := strings.Split(strings.TrimSpace(content), "\n")
        return len(lines) &gt; 5 &amp;&amp; (strings.Contains(content, "---") || strings.Contains(content, "apiVersion:"))
}</span>

// Helper function to get map keys for debugging
func getMapKeys(m map[string]interface{}) []string <span class="cov0" title="0">{
        keys := make([]string, 0, len(m))
        for k := range m </span><span class="cov0" title="0">{
                keys = append(keys, k)
        }</span>
        <span class="cov0" title="0">return keys</span>
}

// Helper function for min
func min(a, b int) int <span class="cov0" title="0">{
        if a &lt; b </span><span class="cov0" title="0">{
                return a
        }</span>
        <span class="cov0" title="0">return b</span>
}

// resourceClusterCustomCloudStateUpgradeV2 migrates state from version 2 to version 3
func resourceClusterCustomCloudStateUpgradeV2(ctx context.Context, rawState map[string]interface{}, meta interface{}) (map[string]interface{}, error) <span class="cov0" title="0">{
        log.Printf("[DEBUG] Upgrading cluster custom cloud state from version 2 to 3")

        // Convert machine_pool from TypeList to TypeSet
        // Note: We keep the data as a list in rawState and let Terraform's schema processing
        // convert it to TypeSet during normal resource loading. This avoids JSON serialization
        // issues with schema.Set objects that contain hash functions.
        if machinePoolRaw, exists := rawState["machine_pool"]; exists </span><span class="cov0" title="0">{
                if machinePoolList, ok := machinePoolRaw.([]interface{}); ok </span><span class="cov0" title="0">{
                        log.Printf("[DEBUG] Keeping machine_pool as list during state upgrade with %d items", len(machinePoolList))

                        // Keep the machine pool data as-is (as a list)
                        // Terraform will convert it to TypeSet when loading the resource using the schema
                        rawState["machine_pool"] = machinePoolList

                        log.Printf("[DEBUG] Successfully prepared machine_pool for TypeSet conversion")
                }</span> else<span class="cov0" title="0"> {
                        log.Printf("[DEBUG] machine_pool is not a list, skipping conversion")
                }</span>
        } else<span class="cov0" title="0"> {
                log.Printf("[DEBUG] No machine_pool found in state, skipping conversion")
        }</span>

        <span class="cov0" title="0">return rawState, nil</span>
}
</pre>
		
		<pre class="file" id="file136" style="display: none">package spectrocloud

import (
        "context"
        "fmt"
        "strings"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
)

func resourceClusterCustomImport(ctx context.Context, d *schema.ResourceData, m interface{}) ([]*schema.ResourceData, error) <span class="cov0" title="0">{
        clusterID, scope, customCloudName, err := ParseResourceCustomCloudImportID(d)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">d.SetId(clusterID + ":" + scope)
        _ = d.Set("cloud", customCloudName)
        c, err := GetCommonCluster(d, m)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">diags := resourceClusterCustomCloudRead(ctx, d, m)
        if diags.HasError() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("could not read cluster for import: %v", diags)
        }</span>

        // cluster profile and common default cluster attribute is get set here
        <span class="cov0" title="0">err = flattenCommonAttributeForCustomClusterImport(c, d)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return []*schema.ResourceData{d}, nil</span>
}

func ParseResourceCustomCloudImportID(d *schema.ResourceData) (string, string, string, error) <span class="cov0" title="0">{
        // Example: If the ID is a combination of ClusterId, then name of context/scope: `project` or `tenant` and then cloud type
        // and if scope is then followed by projectID  "cluster456:project:nutanix" or "cluster456:tenant:oracle"
        parts := strings.Split(d.Id(), ":")

        scope := "invalid"
        clusterID := ""
        customCloudName := ""
        if len(parts) == 3 &amp;&amp; (parts[1] == "tenant" || parts[1] == "project") </span><span class="cov0" title="0">{
                clusterID, scope, customCloudName = parts[0], parts[1], parts[2]
        }</span>
        <span class="cov0" title="0">if scope == "invalid" </span><span class="cov0" title="0">{
                return "", "", "", fmt.Errorf("invalid cluster ID format specified for import custom cloud %s, Ex: it should cluster_id:context:custom_cloud_name, `cluster456:project:nutanix`", d.Id())
        }</span>
        <span class="cov0" title="0">return clusterID, scope, customCloudName, nil</span>
}
</pre>
		
		<pre class="file" id="file137" style="display: none">package spectrocloud

import (
        "context"
        "fmt"
        "log"
        "net"
        "time"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"

        schemas "github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/schemas"
        "github.com/spectrocloud/terraform-provider-spectrocloud/types"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/spectrocloud/palette-sdk-go/api/models"
        "github.com/spectrocloud/palette-sdk-go/client"
)

func resourceClusterEdgeNative() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                CreateContext: resourceClusterEdgeNativeCreate,
                ReadContext:   resourceClusterEdgeNativeRead,
                UpdateContext: resourceClusterEdgeNativeUpdate,
                DeleteContext: resourceClusterDelete,
                Importer: &amp;schema.ResourceImporter{
                        StateContext: resourceClusterEdgeNativeImport,
                },
                Description: "Resource for managing Edge Native clusters in Spectro Cloud through Palette.",

                Timeouts: &amp;schema.ResourceTimeout{
                        Create: schema.DefaultTimeout(60 * time.Minute),
                        Update: schema.DefaultTimeout(60 * time.Minute),
                        Delete: schema.DefaultTimeout(60 * time.Minute),
                },

                SchemaVersion: 3,
                StateUpgraders: []schema.StateUpgrader{
                        {
                                Type:    resourceClusterEdgeNativeResourceV2().CoreConfigSchema().ImpliedType(),
                                Upgrade: resourceClusterEdgeNativeStateUpgradeV2,
                                Version: 2,
                        },
                },
                Schema: map[string]*schema.Schema{
                        "name": {
                                Type:     schema.TypeString,
                                Required: true,
                                ForceNew: true,
                        },
                        "context": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "project",
                                ValidateFunc: validation.StringInSlice([]string{"", "project", "tenant"}, false),
                                Description: "The context of the Edge cluster. Allowed values are `project` or `tenant`. " +
                                        "Default is `project`. " + PROJECT_NAME_NUANCE,
                        },
                        "tags": {
                                Type:     schema.TypeSet,
                                Optional: true,
                                Set:      schema.HashString,
                                Elem: &amp;schema.Schema{
                                        Type: schema.TypeString,
                                },
                                Description: "A list of tags to be applied to the cluster. Tags must be in the form of `key:value`.",
                        },
                        "description": {
                                Type:        schema.TypeString,
                                Optional:    true,
                                Default:     "",
                                Description: "The description of the cluster. Default value is empty string.",
                        },
                        "cluster_meta_attribute": {
                                Type:        schema.TypeString,
                                Optional:    true,
                                Description: "`cluster_meta_attribute` can be used to set additional cluster metadata information, eg `{'nic_name': 'test', 'env': 'stage'}`",
                        },
                        "cluster_profile":  schemas.ClusterProfileSchema(),
                        "cluster_template": schemas.ClusterTemplateSchema(),
                        "apply_setting": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "DownloadAndInstall",
                                ValidateFunc: validation.StringInSlice([]string{"DownloadAndInstall", "DownloadAndInstallLater"}, false),
                                Description: "The setting to apply the cluster profile. `DownloadAndInstall` will download and install packs in one action. " +
                                        "`DownloadAndInstallLater` will only download artifact and postpone install for later. " +
                                        "Default value is `DownloadAndInstall`.",
                        },
                        "cloud_account_id": {
                                Type:     schema.TypeString,
                                Optional: true,
                                ForceNew: true,
                        },
                        "cloud_config_id": {
                                Type:        schema.TypeString,
                                Computed:    true,
                                Description: "ID of the cloud config used for the cluster. This cloud config must be of type `azure`.",
                                Deprecated:  "This field is deprecated and will be removed in the future. Use `cloud_config` instead.",
                        },
                        "review_repave_state": {
                                Type:         schema.TypeString,
                                Default:      "",
                                Optional:     true,
                                ValidateFunc: validateReviewRepaveValue,
                                Description:  "To authorize the cluster repave, set the value to `Approved` for approval and `\"\"` to decline. Default value is `\"\"`.",
                        },
                        "os_patch_on_boot": {
                                Type:        schema.TypeBool,
                                Optional:    true,
                                Default:     false,
                                Description: "Whether to apply OS patch on boot. Default is `false`.",
                        },
                        "os_patch_schedule": {
                                Type:             schema.TypeString,
                                Optional:         true,
                                ValidateDiagFunc: validateOsPatchSchedule,
                                Description:      "The cron schedule for OS patching. This must be in the form of cron syntax. Ex: `0 0 * * *`.",
                        },
                        "os_patch_after": {
                                Type:             schema.TypeString,
                                Optional:         true,
                                ValidateDiagFunc: validateOsPatchOnDemandAfter,
                                Description:      "Date and time after which to patch cluster `RFC3339: 2006-01-02T15:04:05Z07:00`",
                        },
                        "cluster_timezone": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "",
                                ValidateFunc: validateTimezone,
                                Description:  "Defines the time zone used by this cluster to interpret scheduled operations. Maintenance tasks like upgrades will follow this time zone to ensure they run at the appropriate local time for the cluster. Must be in IANA timezone format (e.g., 'America/New_York', 'Asia/Kolkata', 'Europe/London').",
                        },
                        "kubeconfig": {
                                Type:        schema.TypeString,
                                Computed:    true,
                                Description: "Kubeconfig for the cluster. This can be used to connect to the cluster using `kubectl`.",
                        },
                        "admin_kube_config": {
                                Type:        schema.TypeString,
                                Computed:    true,
                                Description: "Admin Kube-config for the cluster. This can be used to connect to the cluster using `kubectl`, With admin privilege.",
                        },
                        "cloud_config": {
                                Type:     schema.TypeList,
                                ForceNew: true,
                                Required: true,
                                MinItems: 1,
                                MaxItems: 1,
                                Elem: &amp;schema.Resource{
                                        Schema: map[string]*schema.Schema{
                                                "ssh_keys": {
                                                        Type:     schema.TypeSet,
                                                        Optional: true,
                                                        Set:      schema.HashString,
                                                        Elem: &amp;schema.Schema{
                                                                Type: schema.TypeString,
                                                        },
                                                        Description: "List of public SSH (Secure Shell) to establish, administer, and communicate with remote clusters.",
                                                },
                                                "vip": {
                                                        Type:        schema.TypeString,
                                                        Optional:    true,
                                                        Description: "The `vip` can be specified as either an IP address or a fully qualified domain name (FQDN). If `overlay_cidr_range` is set, the `vip` should be within the specified `overlay_cidr_range`. By default, the `vip` is set to the first IP address within the given `overlay_cidr_range`.",
                                                },
                                                "overlay_cidr_range": {
                                                        Type:        schema.TypeString,
                                                        Optional:    true,
                                                        ForceNew:    true,
                                                        Description: "The Overlay (VPN) creates a virtual network, using techniques like VxLAN. It overlays the existing network infrastructure, enhancing connectivity either at Layer 2 or Layer 3, making it flexible and adaptable for various needs. For example, `100.64.192.0/24`",
                                                },
                                                "is_two_node_cluster": {
                                                        Type:        schema.TypeBool,
                                                        Optional:    true,
                                                        Default:     false,
                                                        Description: "Set to `true` to enable a two-node cluster.",
                                                },
                                                "ntp_servers": {
                                                        Type:     schema.TypeSet,
                                                        Optional: true,
                                                        Set:      schema.HashString,
                                                        Elem: &amp;schema.Schema{
                                                                Type: schema.TypeString,
                                                        },
                                                        Description: "A list of NTP servers to be used by the cluster.",
                                                },
                                        },
                                },
                        },
                        "machine_pool": {
                                Type:     schema.TypeSet,
                                Required: true,
                                Set:      resourceMachinePoolEdgeNativeHash,
                                Elem: &amp;schema.Resource{
                                        Schema: map[string]*schema.Schema{
                                                "name": {
                                                        Type:     schema.TypeString,
                                                        Required: true,
                                                        //ForceNew: true,
                                                },
                                                "additional_labels": {
                                                        Type:     schema.TypeMap,
                                                        Optional: true,
                                                        Elem: &amp;schema.Schema{
                                                                Type: schema.TypeString,
                                                        },
                                                        Description: "Additional labels to be applied to the machine pool. Labels must be in the form of `key:value`.",
                                                },
                                                "additional_annotations": {
                                                        Type:     schema.TypeMap,
                                                        Optional: true,
                                                        Elem: &amp;schema.Schema{
                                                                Type: schema.TypeString,
                                                        },
                                                        Description: "Additional annotations to be applied to the machine pool. Annotations must be in the form of `key:value`.",
                                                },
                                                "node":   schemas.NodeSchema(),
                                                "taints": schemas.ClusterTaintsSchema(),
                                                "control_plane": {
                                                        Type:     schema.TypeBool,
                                                        Optional: true,
                                                        Default:  false,
                                                        //ForceNew: true,
                                                        Description: "Whether this machine pool is a control plane. Defaults to `false`.",
                                                },
                                                "control_plane_as_worker": {
                                                        Type:     schema.TypeBool,
                                                        Optional: true,
                                                        Default:  false,
                                                        //ForceNew: true,
                                                        Description: "Whether this machine pool is a control plane and a worker. Defaults to `false`.",
                                                },
                                                "node_repave_interval": {
                                                        Type:        schema.TypeInt,
                                                        Optional:    true,
                                                        Default:     0,
                                                        Description: "Minimum number of seconds node should be Ready, before the next node is selected for repave. Default value is `0`, Applicable only for worker pools.",
                                                },
                                                "update_strategy": {
                                                        Type:         schema.TypeString,
                                                        Optional:     true,
                                                        Default:      "RollingUpdateScaleOut",
                                                        Description:  "Update strategy for the machine pool. Valid values are `RollingUpdateScaleOut`, `RollingUpdateScaleIn` and `OverrideScaling`. If `OverrideScaling` is used, `override_scaling` must be specified with both `max_surge` and `max_unavailable`.",
                                                        ValidateFunc: validation.StringInSlice([]string{"RollingUpdateScaleOut", "RollingUpdateScaleIn", "OverrideScaling"}, false),
                                                },
                                                "override_scaling": schemas.OverrideScalingSchema(),
                                                "override_kubeadm_configuration": {
                                                        Type:        schema.TypeString,
                                                        Optional:    true,
                                                        Description: "YAML config for kubeletExtraArgs, preKubeadmCommands, postKubeadmCommands. Overrides pack-level settings. Worker pools only.",
                                                },
                                                "edge_host": {
                                                        Type:     schema.TypeSet,
                                                        Required: true,
                                                        Set:      resourceEdgeHostHash,
                                                        Elem: &amp;schema.Resource{
                                                                Schema: map[string]*schema.Schema{
                                                                        "host_name": {
                                                                                Type:        schema.TypeString,
                                                                                Optional:    true,
                                                                                Default:     "",
                                                                                Description: "Edge host name",
                                                                        },
                                                                        "host_uid": {
                                                                                Type:        schema.TypeString,
                                                                                Description: "Edge host id",
                                                                                Required:    true,
                                                                        },
                                                                        "static_ip": {
                                                                                Type:        schema.TypeString,
                                                                                Description: "Edge host static IP address",
                                                                                Optional:    true,
                                                                        },
                                                                        "nic_name": {
                                                                                Type:        schema.TypeString,
                                                                                Description: "NIC Name for edge host.",
                                                                                Optional:    true,
                                                                        },
                                                                        "default_gateway": {
                                                                                Type:        schema.TypeString,
                                                                                Description: "Edge host default gateway",
                                                                                Optional:    true,
                                                                        },
                                                                        "subnet_mask": {
                                                                                Type:        schema.TypeString,
                                                                                Description: "Edge host subnet mask",
                                                                                Optional:    true,
                                                                        },
                                                                        "dns_servers": {
                                                                                Type:        schema.TypeSet,
                                                                                Optional:    true,
                                                                                Set:         schema.HashString,
                                                                                Description: "Edge host DNS servers",
                                                                                Elem: &amp;schema.Schema{
                                                                                        Type: schema.TypeString,
                                                                                },
                                                                        },
                                                                        "two_node_role": {
                                                                                Type:         schema.TypeString,
                                                                                Description:  "Two node role for edge host. Valid values are `primary` and `secondary`.",
                                                                                Optional:     true,
                                                                                ValidateFunc: validation.StringInSlice([]string{"primary", "secondary"}, false),
                                                                        },
                                                                },
                                                        },
                                                },
                                        },
                                },
                        },
                        "pause_agent_upgrades": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "unlock",
                                ValidateFunc: validation.StringInSlice([]string{"lock", "unlock"}, false),
                                Description:  "The pause agent upgrades setting allows to control the automatic upgrade of the Palette component and agent for an individual cluster. The default value is `unlock`, meaning upgrades occur automatically. Setting it to `lock` pauses automatic agent upgrades for the cluster.",
                        },
                        "backup_policy":        schemas.BackupPolicySchema(),
                        "scan_policy":          schemas.ScanPolicySchema(),
                        "cluster_rbac_binding": schemas.ClusterRbacBindingSchema(),
                        "namespaces":           schemas.ClusterNamespacesSchema(),
                        "host_config":          schemas.ClusterHostConfigSchema(),
                        "location_config":      schemas.ClusterLocationSchema(),
                        "skip_completion": {
                                Type:        schema.TypeBool,
                                Optional:    true,
                                Default:     false,
                                Description: "If `true`, the cluster will be created asynchronously. Default value is `false`.",
                        },
                        "force_delete": {
                                Type:        schema.TypeBool,
                                Optional:    true,
                                Default:     false,
                                Description: "If set to `true`, the cluster will be force deleted and user has to manually clean up the provisioned cloud resources.",
                        },
                        "force_delete_delay": {
                                Type:             schema.TypeInt,
                                Optional:         true,
                                Default:          20,
                                Description:      "Delay duration in minutes to before invoking cluster force delete. Default and minimum is 20.",
                                ValidateDiagFunc: validation.ToDiagFunc(validation.IntAtLeast(20)),
                        },
                },
        }
}</span>

func resourceClusterEdgeNativeCreate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        resourceContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, resourceContext)

        // Warning or errors can be collected in a slice type
        var diags diag.Diagnostics

        // Validate override_Scaling configuration
        if err := validateOverrideScaling(d, "machine_pool"); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">cluster, err := toEdgeNativeCluster(c, d)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">uid, err := c.CreateClusterEdgeNative(cluster)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">diagnostics, isError := waitForClusterCreation(ctx, d, uid, diags, c, true)
        if len(diagnostics) &gt; 0 </span><span class="cov0" title="0">{
                diags = append(diags, diagnostics...)
        }</span>
        <span class="cov0" title="0">if isError </span><span class="cov0" title="0">{
                return diagnostics
        }</span>
        <span class="cov0" title="0">resourceClusterEdgeNativeRead(ctx, d, m)

        return diags</span>
}

//goland:noinspection GoUnhandledErrorResult
func resourceClusterEdgeNativeRead(_ context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        resourceContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, resourceContext)

        var diags diag.Diagnostics

        cluster, err := resourceClusterRead(d, c, diags)
        if err != nil </span><span class="cov0" title="0">{
                return handleReadError(d, err, diags)
        }</span> else<span class="cov0" title="0"> if cluster == nil </span><span class="cov0" title="0">{
                // Deleted - Terraform will recreate it
                d.SetId("")
                return diags
        }</span>

        // verify cluster type
        <span class="cov0" title="0">err = ValidateCloudType("spectrocloud_cluster_edge_native", cluster)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        // Update the kubeconfig
        <span class="cov0" title="0">diagnostics, errorSet := readCommonFields(c, d, cluster)
        if errorSet </span><span class="cov0" title="0">{
                return diagnostics
        }</span>

        // Flatten cluster_template variables using variables API
        <span class="cov0" title="0">if err := flattenClusterTemplateVariables(c, d, d.Id()); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">diags = flattenCloudConfigEdgeNative(cluster.Spec.CloudConfigRef.UID, d, c)
        generalWarningForRepave(&amp;diags)
        return diags</span>
}

func flattenCloudConfigEdgeNative(configUID string, d *schema.ResourceData, c *client.V1Client) diag.Diagnostics <span class="cov0" title="0">{
        //ClusterContext := d.Get("context").(string)
        if err := d.Set("cloud_config_id", configUID); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">if err := ReadCommonAttributes(d); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">if config, err := c.GetCloudConfigEdgeNative(configUID); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span> else<span class="cov0" title="0"> {
                cloudConfig := map[string]interface{}{}
                if _, ok := d.GetOk("cloud_config"); ok </span><span class="cov0" title="0">{
                        cloudConfig = d.Get("cloud_config").([]interface{})[0].(map[string]interface{})
                }</span>

                <span class="cov0" title="0">if err := d.Set("cloud_config", flattenClusterConfigsEdgeNative(cloudConfig, config)); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
                <span class="cov0" title="0">mp := flattenMachinePoolConfigsEdgeNative(config.Spec.MachinePoolConfig)
                mp, err := flattenNodeMaintenanceStatus(c, d, c.GetNodeStatusMapEdgeNative, mp, configUID)
                if err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
                <span class="cov0" title="0">if err := d.Set("machine_pool", mp); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
        }

        <span class="cov0" title="0">return diag.Diagnostics{}</span>
}

func flattenClusterConfigsEdgeNative(cloudConfig map[string]interface{}, config *models.V1EdgeNativeCloudConfig) []interface{} <span class="cov0" title="0">{
        if config == nil || config.Spec == nil || config.Spec.ClusterConfig == nil </span><span class="cov0" title="0">{
                return make([]interface{}, 0)
        }</span>

        <span class="cov0" title="0">m := make(map[string]interface{})
        if config.Spec.ClusterConfig.SSHKeys != nil </span><span class="cov0" title="0">{
                m["ssh_keys"] = config.Spec.ClusterConfig.SSHKeys
        }</span>
        <span class="cov0" title="0">if config.Spec.ClusterConfig.ControlPlaneEndpoint.Host != "" </span><span class="cov0" title="0">{
                if v, ok := cloudConfig["vip"]; ok &amp;&amp; v.(string) != "" </span><span class="cov0" title="0">{
                        m["vip"] = config.Spec.ClusterConfig.ControlPlaneEndpoint.Host
                }</span>
        }
        <span class="cov0" title="0">if config.Spec.ClusterConfig.NtpServers != nil </span><span class="cov0" title="0">{
                m["ntp_servers"] = config.Spec.ClusterConfig.NtpServers
        }</span>
        <span class="cov0" title="0">if config.Spec.ClusterConfig.OverlayNetworkConfiguration.Cidr != "" </span><span class="cov0" title="0">{
                m["overlay_cidr_range"] = config.Spec.ClusterConfig.OverlayNetworkConfiguration.Cidr
        }</span>
        <span class="cov0" title="0">if config.Spec.ClusterConfig != nil </span><span class="cov0" title="0">{
                m["is_two_node_cluster"] = config.Spec.ClusterConfig.IsTwoNodeCluster
        }</span>

        <span class="cov0" title="0">return []interface{}{m}</span>
}

func flattenMachinePoolConfigsEdgeNative(machinePools []*models.V1EdgeNativeMachinePoolConfig) []interface{} <span class="cov0" title="0">{
        if machinePools == nil </span><span class="cov0" title="0">{
                return make([]interface{}, 0)
        }</span>

        <span class="cov0" title="0">ois := make([]interface{}, 0)

        for _, machinePool := range machinePools </span><span class="cov0" title="0">{
                oi := make(map[string]interface{})

                FlattenAdditionalLabelsAnnotationsAndTaints(machinePool.AdditionalLabels, machinePool.AdditionalAnnotations, machinePool.Taints, oi)
                FlattenControlPlaneAndRepaveInterval(&amp;machinePool.IsControlPlane, oi, machinePool.NodeRepaveInterval)
                oi["control_plane"] = machinePool.IsControlPlane
                oi["control_plane_as_worker"] = machinePool.UseControlPlaneAsWorker
                oi["name"] = machinePool.Name
                if machinePool.UpdateStrategy != nil </span><span class="cov0" title="0">{
                        oi["update_strategy"] = machinePool.UpdateStrategy.Type
                        // Flatten override_Scaling if using OverrideScaling strategy
                        flattenOverrideScaling(machinePool.UpdateStrategy, oi)
                }</span>

                // Flatten override_kubeadm_configuration (worker pools only)
                <span class="cov0" title="0">if !machinePool.IsControlPlane &amp;&amp; machinePool.OverrideKubeadmConfiguration != "" </span><span class="cov0" title="0">{
                        oi["override_kubeadm_configuration"] = machinePool.OverrideKubeadmConfiguration
                }</span>

                <span class="cov0" title="0">var hosts []interface{}
                for _, host := range machinePool.Hosts </span><span class="cov0" title="0">{
                        rawHost := map[string]interface{}{
                                "host_name":       host.HostName,
                                "host_uid":        *host.HostUID,
                                "static_ip":       host.Nic.IP,
                                "nic_name":        host.Nic.NicName,
                                "default_gateway": host.Nic.Gateway,
                                "subnet_mask":     host.Nic.Subnet,
                                "dns_servers":     host.Nic.DNS,
                        }
                        if host.TwoNodeCandidatePriority != "" </span><span class="cov0" title="0">{
                                rawHost["two_node_role"] = host.TwoNodeCandidatePriority
                        }</span>
                        <span class="cov0" title="0">hosts = append(hosts, rawHost)</span>
                }
                <span class="cov0" title="0">oi["edge_host"] = schema.NewSet(resourceEdgeHostHash, hosts)
                flattenUpdateStrategy(machinePool.UpdateStrategy, oi)

                ois = append(ois, oi)</span>
        }

        <span class="cov0" title="0">return ois</span>
}

func resourceClusterEdgeNativeUpdate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        resourceContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, resourceContext)
        warningMessageForNodeDeletion := false

        // Warning or errors can be collected in a slice type
        var diags diag.Diagnostics
        err := validateSystemRepaveApproval(d, c)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">cloudConfigId := d.Get("cloud_config_id").(string)

        if d.HasChange("machine_pool") </span><span class="cov0" title="0">{
                // Validate override_Scaling configuration
                if err := validateOverrideScaling(d, "machine_pool"); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>

                <span class="cov0" title="0">oraw, nraw := d.GetChange("machine_pool")
                if oraw == nil </span><span class="cov0" title="0">{
                        oraw = new(schema.Set)
                }</span>
                <span class="cov0" title="0">if nraw == nil </span><span class="cov0" title="0">{
                        nraw = new(schema.Set)
                }</span>

                <span class="cov0" title="0">os := oraw.(*schema.Set)
                ns := nraw.(*schema.Set)

                osMap := make(map[string]interface{})
                for _, mp := range os.List() </span><span class="cov0" title="0">{
                        machinePool := mp.(map[string]interface{})
                        osMap[machinePool["name"].(string)] = machinePool
                }</span>

                <span class="cov0" title="0">nsMap := make(map[string]interface{})

                for _, mp := range ns.List() </span><span class="cov0" title="0">{
                        machinePoolResource := mp.(map[string]interface{})
                        nsMap[machinePoolResource["name"].(string)] = machinePoolResource
                        // since known issue in TF SDK: https://github.com/hashicorp/terraform-plugin-sdk/issues/588
                        if machinePoolResource["name"].(string) != "" </span><span class="cov0" title="0">{
                                name := machinePoolResource["name"].(string)
                                if name == "" </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov0" title="0">hash := resourceMachinePoolEdgeNativeHash(machinePoolResource)
                                var err error
                                machinePool, err := toMachinePoolEdgeNative(machinePoolResource)
                                if err != nil </span><span class="cov0" title="0">{
                                        return diag.FromErr(err)
                                }</span>

                                <span class="cov0" title="0">if oldMachinePool, ok := osMap[name]; !ok </span><span class="cov0" title="0">{
                                        log.Printf("Create machine pool %s", name)
                                        err = c.CreateMachinePoolEdgeNative(cloudConfigId, machinePool)
                                }</span> else<span class="cov0" title="0"> if hash != resourceMachinePoolEdgeNativeHash(oldMachinePool) </span><span class="cov0" title="0">{
                                        log.Printf("Change in machine pool %s", name)

                                        // Logic for delete machine in node pool starts
                                        deletedHosts := make([]string, 0)
                                        var oldEdgeHostList, newEdgeHostList []interface{}
                                        oldMachinePoolMap := osMap[name].(map[string]interface{})
                                        newMachinePoolMap := nsMap[name].(map[string]interface{})
                                        // Extract old edge_host list
                                        if oldEdgeHostRaw := oldMachinePoolMap["edge_host"]; oldEdgeHostRaw != nil </span><span class="cov0" title="0">{
                                                if oldSet, ok := oldEdgeHostRaw.(*schema.Set); ok </span><span class="cov0" title="0">{
                                                        oldEdgeHostList = oldSet.List()
                                                }</span> else<span class="cov0" title="0"> if oldList, ok := oldEdgeHostRaw.([]interface{}); ok </span><span class="cov0" title="0">{
                                                        oldEdgeHostList = oldList
                                                }</span>
                                        }
                                        // Extract new edge_host list
                                        <span class="cov0" title="0">if newEdgeHostRaw := newMachinePoolMap["edge_host"]; newEdgeHostRaw != nil </span><span class="cov0" title="0">{
                                                if newSet, ok := newEdgeHostRaw.(*schema.Set); ok </span><span class="cov0" title="0">{
                                                        newEdgeHostList = newSet.List()
                                                }</span> else<span class="cov0" title="0"> if newList, ok := newEdgeHostRaw.([]interface{}); ok </span><span class="cov0" title="0">{
                                                        newEdgeHostList = newList
                                                }</span>
                                        }
                                        // Compare old vs new to find deleted hosts
                                        <span class="cov0" title="0">for _, oEdgeHost := range oldEdgeHostList </span><span class="cov0" title="0">{
                                                oHostName := oEdgeHost.(map[string]interface{})["host_name"].(string)
                                                isPresent := false
                                                for _, nEdgeHost := range newEdgeHostList </span><span class="cov0" title="0">{
                                                        nHostName := nEdgeHost.(map[string]interface{})["host_name"].(string)
                                                        if oHostName == nHostName </span><span class="cov0" title="0">{
                                                                // Found the host, so it's not deleted
                                                                isPresent = true
                                                                break</span>
                                                        }
                                                }
                                                <span class="cov0" title="0">if !isPresent </span><span class="cov0" title="0">{
                                                        deletedHosts = append(deletedHosts, oHostName)
                                                }</span>
                                        }
                                        // Get actual machine list from API
                                        <span class="cov0" title="0">machineList, err := c.GetNodeListInEdgeNativeMachinePool(cloudConfigId, name)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return diag.FromErr(err)
                                        }</span>
                                        // Delete nodes for removed hosts
                                        <span class="cov0" title="0">for _, existingMachine := range machineList.Items </span><span class="cov0" title="0">{
                                                found := false
                                                for _, host := range deletedHosts </span><span class="cov0" title="0">{
                                                        if existingMachine.Metadata.Name == host </span><span class="cov0" title="0">{
                                                                found = true
                                                                break</span>
                                                        }
                                                }
                                                <span class="cov0" title="0">if found </span><span class="cov0" title="0">{
                                                        err := c.DeleteNodeInEdgeNativeMachinePool(cloudConfigId, name, existingMachine.Metadata.UID)
                                                        if err != nil </span><span class="cov0" title="0">{
                                                                return diag.FromErr(err)
                                                        }</span>
                                                }
                                        }
                                        // Logic for delete machine in node pool ends
                                        //  Update machine pool
                                        <span class="cov0" title="0">err = c.UpdateMachinePoolEdgeNative(cloudConfigId, machinePool)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return diag.FromErr(err)
                                        }</span>
                                        <span class="cov0" title="0">err = resourceNodeAction(c, ctx, nsMap[name], c.GetNodeMaintenanceStatusEdgeNative, "edge-native", cloudConfigId, name)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return diag.FromErr(err)
                                        }</span>
                                }

                                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                                        return diag.FromErr(err)
                                }</span>

                                // Processed (if exists)
                                <span class="cov0" title="0">delete(osMap, name)</span>
                        }
                }

                // Deleted old machine pools
                <span class="cov0" title="0">for _, mp := range osMap </span><span class="cov0" title="0">{
                        machinePool := mp.(map[string]interface{})
                        name := machinePool["name"].(string)
                        log.Printf("Deleted machine pool %s", name)
                        machineList, err := c.GetNodeListInEdgeNativeMachinePool(cloudConfigId, name)
                        if err != nil </span><span class="cov0" title="0">{
                                return diag.FromErr(err)
                        }</span>
                        <span class="cov0" title="0">for _, existingMachine := range machineList.Items </span><span class="cov0" title="0">{
                                err := c.DeleteNodeInEdgeNativeMachinePool(cloudConfigId, name, existingMachine.Metadata.UID)
                                if err != nil </span><span class="cov0" title="0">{
                                        return diag.FromErr(err)
                                }</span>
                                <span class="cov0" title="0">warningMessageForNodeDeletion = true</span>
                        }
                }
        }

        <span class="cov0" title="0">diagnostics, errorSet := updateCommonFields(d, c)
        if errorSet </span><span class="cov0" title="0">{
                return diagnostics
        }</span>

        <span class="cov0" title="0">if warningMessageForNodeDeletion </span><span class="cov0" title="0">{
                diags = append(diags, diag.Diagnostic{
                        Severity: diag.Warning,
                        Detail:   "The Machine pool node deletion has been triggered. This is an asynchronous operation and may take some time to complete.",
                })
        }</span>
        <span class="cov0" title="0">readDiags := resourceClusterEdgeNativeRead(ctx, d, m)
        if len(readDiags) &gt; 0 </span><span class="cov0" title="0">{
                diags = append(diags, readDiags...)
        }</span>

        <span class="cov0" title="0">return diags</span>
}

func toEdgeNativeCluster(c *client.V1Client, d *schema.ResourceData) (*models.V1SpectroEdgeNativeClusterEntity, error) <span class="cov0" title="0">{
        cloudConfig := d.Get("cloud_config").([]interface{})[0].(map[string]interface{})
        sshKeys, _ := toSSHKeys(cloudConfig)
        isTwoNodeCluster := cloudConfig["is_two_node_cluster"]

        clusterContext := d.Get("context").(string)
        profiles, err := toProfiles(c, d, clusterContext)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">controlPlaneEndpoint, overlayConfig, err := toOverlayNetworkConfigAndVip(cloudConfig)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">cluster := &amp;models.V1SpectroEdgeNativeClusterEntity{
                Metadata: getClusterMetadata(d),
                Spec: &amp;models.V1SpectroEdgeNativeClusterEntitySpec{
                        Profiles:        profiles,
                        ClusterTemplate: toClusterTemplateReference(d),
                        Policies:        toPolicies(d),
                        CloudConfig: &amp;models.V1EdgeNativeClusterConfig{
                                NtpServers:                  toNtpServers(cloudConfig),
                                SSHKeys:                     sshKeys,
                                ControlPlaneEndpoint:        controlPlaneEndpoint,
                                OverlayNetworkConfiguration: overlayConfig,
                                IsTwoNodeCluster:            isTwoNodeCluster.(bool),
                        },
                },
        }

        machinePoolConfigs := make([]*models.V1EdgeNativeMachinePoolConfigEntity, 0)
        for _, machinePool := range d.Get("machine_pool").(*schema.Set).List() </span><span class="cov0" title="0">{
                mp, err := toMachinePoolEdgeNative(machinePool)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">machinePoolConfigs = append(machinePoolConfigs, mp)</span>
        }
        <span class="cov0" title="0">cluster.Spec.Machinepoolconfig = machinePoolConfigs
        cluster.Spec.ClusterConfig = toClusterConfig(d)

        return cluster, nil</span>
}

func toMachinePoolEdgeNative(machinePool interface{}) (*models.V1EdgeNativeMachinePoolConfigEntity, error) <span class="cov0" title="0">{
        m := machinePool.(map[string]interface{})

        labels := make([]string, 0)
        controlPlane := m["control_plane"].(bool)
        controlPlaneAsWorker := m["control_plane_as_worker"].(bool)
        if controlPlane </span><span class="cov0" title="0">{
                labels = append(labels, "control-plane")
        }</span> else<span class="cov0" title="0"> {
                labels = append(labels, "worker")
        }</span>

        <span class="cov0" title="0">cloudConfig, err := toEdgeHosts(m)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">mp := &amp;models.V1EdgeNativeMachinePoolConfigEntity{
                CloudConfig: cloudConfig,
                PoolConfig: &amp;models.V1MachinePoolConfigEntity{
                        AdditionalLabels:        toAdditionalNodePoolLabels(m),
                        AdditionalAnnotations:   toAdditionalNodePoolAnnotations(m),
                        Taints:                  toClusterTaints(m),
                        IsControlPlane:          controlPlane,
                        Labels:                  labels,
                        Name:                    types.Ptr(m["name"].(string)),
                        Size:                    types.Ptr(SafeInt32(len(cloudConfig.EdgeHosts))),
                        UpdateStrategy:          toUpdateStrategy(m),
                        UseControlPlaneAsWorker: controlPlaneAsWorker,
                },
        }

        // Handle override_kubeadm_configuration (worker pools only)
        if !controlPlane </span><span class="cov0" title="0">{
                if overrideKubeadm, ok := m["override_kubeadm_configuration"].(string); ok &amp;&amp; overrideKubeadm != "" </span><span class="cov0" title="0">{
                        mp.PoolConfig.OverrideKubeadmConfiguration = overrideKubeadm
                }</span>
        }

        <span class="cov0" title="0">nodeRepaveInterval := 0
        if m["node_repave_interval"] != nil </span><span class="cov0" title="0">{
                nodeRepaveInterval = m["node_repave_interval"].(int)
        }</span>
        <span class="cov0" title="0">if !controlPlane </span><span class="cov0" title="0">{
                mp.PoolConfig.NodeRepaveInterval = SafeInt32(nodeRepaveInterval)
        }</span> else<span class="cov0" title="0"> {
                err := ValidationNodeRepaveIntervalForControlPlane(nodeRepaveInterval)
                if err != nil </span><span class="cov0" title="0">{
                        return mp, err
                }</span>
        }

        <span class="cov0" title="0">return mp, nil</span>
}

func toEdgeHosts(m map[string]interface{}) (*models.V1EdgeNativeMachinePoolCloudConfigEntity, error) <span class="cov0" title="0">{
        edgeHosts := make([]*models.V1EdgeNativeMachinePoolHostEntity, 0)
        var edgeHostSet *schema.Set
        if edgeHostRaw, ok := m["edge_host"]; ok &amp;&amp; edgeHostRaw != nil </span><span class="cov0" title="0">{
                if edgeHostSet, ok = edgeHostRaw.(*schema.Set); !ok </span><span class="cov0" title="0">{
                        // Fallback: try to convert from list (for backward compatibility)
                        if edgeHostList, ok := edgeHostRaw.([]interface{}); ok </span><span class="cov0" title="0">{
                                edgeHostSet = schema.NewSet(schema.HashResource(resourceClusterEdgeNative().Schema["machine_pool"].Elem.(*schema.Resource).Schema["edge_host"].Elem.(*schema.Resource)), edgeHostList)
                        }</span> else<span class="cov0" title="0"> {
                                return nil, fmt.Errorf("edge_host must be a set or list")
                        }</span>
                }
        }

        <span class="cov0" title="0">if edgeHostSet == nil || edgeHostSet.Len() == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        // if m["edge_host"] == nil || edgeHostIdsLen == 0 {
        //         return nil, nil
        // }

        <span class="cov0" title="0">twoNodeHostRoles := make(map[string]string)
        // edgeHostSet = m["edge_host"].(*schema.Set)
        for _, host := range edgeHostSet.List() </span><span class="cov0" title="0">{
                hostName := ""
                if v, ok := host.(map[string]interface{})["host_name"].(string); ok </span><span class="cov0" title="0">{
                        hostName = v
                }</span>
                <span class="cov0" title="0">hostId := host.(map[string]interface{})["host_uid"].(string)
                edgeHost := &amp;models.V1EdgeNativeMachinePoolHostEntity{
                        HostName: hostName,
                        HostUID:  &amp;hostId,
                        Nic:      &amp;models.V1Nic{},
                        // Hubble deprecated it and need to set it inside nic
                        // StaticIP: host.(map[string]interface{})["static_ip"].(string),
                }
                if v, ok := host.(map[string]interface{})["dns_servers"].(*schema.Set); ok </span><span class="cov0" title="0">{
                        if v.Len() &gt; 0 </span><span class="cov0" title="0">{
                                var result []string
                                for _, val := range v.List() </span><span class="cov0" title="0">{
                                        result = append(result, val.(string)) // Type assertion
                                }</span>
                                <span class="cov0" title="0">edgeHost.Nic.DNS = result</span>
                        }
                }
                <span class="cov0" title="0">if v, ok := host.(map[string]interface{})["default_gateway"]; ok </span><span class="cov0" title="0">{
                        edgeHost.Nic.Gateway = v.(string)
                }</span>
                <span class="cov0" title="0">if v, ok := host.(map[string]interface{})["static_ip"]; ok </span><span class="cov0" title="0">{
                        edgeHost.Nic.IP = v.(string)
                }</span>
                <span class="cov0" title="0">if v, ok := host.(map[string]interface{})["nic_name"]; ok </span><span class="cov0" title="0">{
                        edgeHost.Nic.NicName = v.(string)
                }</span>
                <span class="cov0" title="0">if v, ok := host.(map[string]interface{})["subnet_mask"]; ok </span><span class="cov0" title="0">{
                        edgeHost.Nic.Subnet = v.(string)
                }</span>

                <span class="cov0" title="0">if v, ok := host.(map[string]interface{})["two_node_role"].(string); ok </span><span class="cov0" title="0">{
                        if v != "" </span><span class="cov0" title="0">{
                                if _, ok := twoNodeHostRoles[v]; ok </span><span class="cov0" title="0">{
                                        // return nil, fmt.Errorf("two node role '%s' already assigned to edge host '%s'; roles must be unique", v, hostId)
                                        return nil, fmt.Errorf("two node role '%s' already assigned to edge host '%s'; roles must be unique", v, twoNodeHostRoles[v])
                                }</span>
                                <span class="cov0" title="0">edgeHost.TwoNodeCandidatePriority = v
                                twoNodeHostRoles[v] = hostId</span>
                        }
                }
                <span class="cov0" title="0">edgeHosts = append(edgeHosts, edgeHost)</span>
        }

        <span class="cov0" title="0">leaderId, leaderOk := twoNodeHostRoles["primary"]
        followerId, followerOk := twoNodeHostRoles["secondary"]
        if leaderOk &amp;&amp; !followerOk </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("primary edge host '%s' specified, but missing secondary edge host", leaderId)
        }</span> else<span class="cov0" title="0"> if !leaderOk &amp;&amp; followerOk </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("secondary edge host '%s' specified, but missing primary edge host", followerId)
        }</span>

        <span class="cov0" title="0">return &amp;models.V1EdgeNativeMachinePoolCloudConfigEntity{
                EdgeHosts: edgeHosts,
        }, nil</span>
}

func toOverlayNetworkConfigAndVip(cloudConfig map[string]interface{}) (*models.V1EdgeNativeControlPlaneEndPoint, *models.V1EdgeNativeOverlayNetworkConfiguration, error) <span class="cov0" title="0">{
        controlPlaneEndpoint := &amp;models.V1EdgeNativeControlPlaneEndPoint{}
        overlayConfig := &amp;models.V1EdgeNativeOverlayNetworkConfiguration{}
        if (cloudConfig["overlay_cidr_range"] != nil) &amp;&amp; (cloudConfig["overlay_cidr_range"].(string) != "") </span><span class="cov0" title="0">{
                overlayConfig.Cidr = cloudConfig["overlay_cidr_range"].(string)
                overlayConfig.Enable = true
        }</span> else<span class="cov0" title="0"> {
                overlayConfig.Cidr = ""
                overlayConfig.Enable = false
        }</span>

        <span class="cov0" title="0">if (cloudConfig["vip"] != nil) &amp;&amp; (cloudConfig["vip"].(string) != "") </span><span class="cov0" title="0">{
                vip := cloudConfig["vip"].(string)
                controlPlaneEndpoint =
                        &amp;models.V1EdgeNativeControlPlaneEndPoint{
                                Host: vip,
                                Type: "VIP",
                        }
        }</span> else<span class="cov0" title="0"> {
                if overlayConfig.Enable </span><span class="cov0" title="0">{
                        autoGenVip, err := getFirstIPRange(overlayConfig.Cidr)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, nil, err
                        }</span>
                        <span class="cov0" title="0">controlPlaneEndpoint =
                                &amp;models.V1EdgeNativeControlPlaneEndPoint{
                                        Host: autoGenVip,
                                        Type: "VIP",
                                }</span>
                }
        }

        <span class="cov0" title="0">return controlPlaneEndpoint, overlayConfig, nil</span>
}

func getFirstIPRange(cidr string) (string, error) <span class="cov0" title="0">{
        // Parse the CIDR string
        _, ipNet, err := net.ParseCIDR(cidr)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Get the network address from the parsed CIDR
        <span class="cov0" title="0">networkIP := ipNet.IP

        // Ensure that the subnet mask is applied correctly
        firstIP := make(net.IP, len(networkIP))
        copy(firstIP, networkIP)
        for i := range firstIP </span><span class="cov0" title="0">{
                firstIP[i] &amp;= ipNet.Mask[i]
        }</span>

        // Increment the last octet to get the first usable IP
        <span class="cov0" title="0">firstIP[len(firstIP)-1]++

        // Convert the IP address to a string
        firstIPString := firstIP.String()

        return firstIPString, nil</span>
}

// resourceClusterEdgeNativeStateUpgradeV2 upgrades state from version 2 to 3
// Converts edge_host from TypeList to TypeSet
func resourceClusterEdgeNativeStateUpgradeV2(ctx context.Context, rawState map[string]interface{}, meta interface{}) (map[string]interface{}, error) <span class="cov0" title="0">{
        log.Printf("[DEBUG] Upgrading cluster Edge Native state from version 2 to 3")

        // Convert edge_host from TypeList to TypeSet within machine_pool
        if machinePoolRaw, exists := rawState["machine_pool"]; exists </span><span class="cov0" title="0">{
                if machinePoolSet, ok := machinePoolRaw.(*schema.Set); ok </span><span class="cov0" title="0">{
                        machinePoolList := machinePoolSet.List()
                        for _, mpRaw := range machinePoolList </span><span class="cov0" title="0">{
                                if mp, ok := mpRaw.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                        if edgeHostRaw, exists := mp["edge_host"]; exists </span><span class="cov0" title="0">{
                                                if edgeHostList, ok := edgeHostRaw.([]interface{}); ok </span><span class="cov0" title="0">{
                                                        log.Printf("[DEBUG] Converting edge_host from TypeList to TypeSet with %d items", len(edgeHostList))
                                                        // Keep as list - Terraform will convert to TypeSet when loading using schema
                                                        mp["edge_host"] = edgeHostList
                                                }</span>
                                        }
                                }
                        }
                        <span class="cov0" title="0">rawState["machine_pool"] = machinePoolList</span>
                } else<span class="cov0" title="0"> if machinePoolList, ok := machinePoolRaw.([]interface{}); ok </span><span class="cov0" title="0">{
                        // Handle case where machine_pool is still a list
                        for _, mpRaw := range machinePoolList </span><span class="cov0" title="0">{
                                if mp, ok := mpRaw.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                        if edgeHostRaw, exists := mp["edge_host"]; exists </span><span class="cov0" title="0">{
                                                if edgeHostList, ok := edgeHostRaw.([]interface{}); ok </span><span class="cov0" title="0">{
                                                        log.Printf("[DEBUG] Converting edge_host from TypeList to TypeSet with %d items", len(edgeHostList))
                                                        mp["edge_host"] = edgeHostList
                                                }</span>
                                        }
                                }
                        }
                        <span class="cov0" title="0">rawState["machine_pool"] = machinePoolList</span>
                }
        }

        <span class="cov0" title="0">return rawState, nil</span>
}
</pre>
		
		<pre class="file" id="file138" style="display: none">package spectrocloud

import (
        "context"
        "fmt"
        "strings"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
)

func resourceClusterEdgeNativeImport(ctx context.Context, d *schema.ResourceData, m interface{}) ([]*schema.ResourceData, error) <span class="cov0" title="0">{
        c, err := GetCommonCluster(d, m)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">diags := resourceClusterEdgeNativeRead(ctx, d, m)
        if diags.HasError() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("could not read cluster for import: %v", diags)
        }</span>

        // cluster profile and common default cluster attribute is get set here
        <span class="cov0" title="0">err = flattenCommonAttributeForClusterImport(c, d)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Return the resource data. In most cases, this method is only used to
        // import one resource at a time, so you should return the resource data
        // in a slice with a single element.
        <span class="cov0" title="0">return []*schema.ResourceData{d}, nil</span>
}

func ParseResourceID(d *schema.ResourceData) (string, string, error) <span class="cov0" title="0">{
        // d.Id() will contain the ID of the resource to import. This ID is provided by the user
        // during the import command, and should be parsed to find the existing resource.
        // Example: `terraform import spectrocloud_cluster.my_cluster [id]`

        // Parse the ID to find the existing resource. This might involve making API requests
        // to your infrastructure with the client `c`.
        // Example: If the ID is a combination of ClusterId, then name of context/scope: `project` or `tenant`
        // and if scope is then followed by projectID  "cluster456:project" or "cluster456:tenant"
        parts := strings.Split(d.Id(), ":")
        // if 2 parts - last part should be `tenant`
        scope := "invalid"
        clusterID := ""
        if len(parts) == 2 &amp;&amp; (parts[1] == "tenant" || parts[1] == "project") </span><span class="cov0" title="0">{
                clusterID, scope = parts[0], parts[1]
        }</span>
        <span class="cov0" title="0">if scope == "invalid" </span><span class="cov0" title="0">{
                return "", "", fmt.Errorf("invalid cluster ID format specified for import %s", d.Id())
        }</span>
        <span class="cov0" title="0">return scope, clusterID, nil</span>
}
</pre>
		
		<pre class="file" id="file139" style="display: none">package spectrocloud

import (
        "context"
        "log"
        "time"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"

        "github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/schemas"
        "github.com/spectrocloud/terraform-provider-spectrocloud/types"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/spectrocloud/palette-sdk-go/api/models"
        "github.com/spectrocloud/palette-sdk-go/client"
)

func resourceClusterEdgeVsphere() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                CreateContext: resourceClusterEdgeVsphereCreate,
                ReadContext:   resourceClusterEdgeVsphereRead,
                UpdateContext: resourceClusterEdgeVsphereUpdate,
                DeleteContext: resourceClusterDelete,
                Importer: &amp;schema.ResourceImporter{
                        StateContext: resourceClusterEdgeVsphereImport,
                },

                Timeouts: &amp;schema.ResourceTimeout{
                        Create: schema.DefaultTimeout(180 * time.Minute),
                        Update: schema.DefaultTimeout(180 * time.Minute),
                        Delete: schema.DefaultTimeout(180 * time.Minute),
                },

                Schema: map[string]*schema.Schema{
                        "name": {
                                Type:     schema.TypeString,
                                Required: true,
                                ForceNew: true,
                        },
                        "context": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "project",
                                ValidateFunc: validation.StringInSlice([]string{"", "project", "tenant"}, false),
                                Description: "The context of the Edge cluster. Allowed values are `project` or `tenant`. " +
                                        "Default is `project`. " + PROJECT_NAME_NUANCE,
                        },
                        "edge_host_uid": {
                                Type:     schema.TypeString,
                                Required: true,
                                ForceNew: true,
                        },
                        "tags": {
                                Type:     schema.TypeSet,
                                Optional: true,
                                Set:      schema.HashString,
                                Elem: &amp;schema.Schema{
                                        Type: schema.TypeString,
                                },
                                Description: "A list of tags to be applied to the cluster. Tags must be in the form of `key:value`.",
                        },
                        "description": {
                                Type:        schema.TypeString,
                                Optional:    true,
                                Default:     "",
                                Description: "The description of the cluster. Default value is empty string.",
                        },
                        "cluster_meta_attribute": {
                                Type:        schema.TypeString,
                                Optional:    true,
                                Description: "`cluster_meta_attribute` can be used to set additional cluster metadata information, eg `{'nic_name': 'test', 'env': 'stage'}`",
                        },
                        "cluster_profile":  schemas.ClusterProfileSchema(),
                        "cluster_template": schemas.ClusterTemplateSchema(),
                        "cloud_config_id": {
                                Type:        schema.TypeString,
                                Computed:    true,
                                Description: "ID of the cloud config used for the cluster. This cloud config must be of type `azure`.",
                                Deprecated:  "This field is deprecated and will be removed in the future. Use `cloud_config` instead.",
                        },
                        "review_repave_state": {
                                Type:         schema.TypeString,
                                Default:      "",
                                Optional:     true,
                                ValidateFunc: validateReviewRepaveValue,
                                Description:  "To authorize the cluster repave, set the value to `Approved` for approval and `\"\"` to decline. Default value is `\"\"`.",
                        },
                        "pause_agent_upgrades": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "unlock",
                                ValidateFunc: validation.StringInSlice([]string{"lock", "unlock"}, false),
                                Description:  "The pause agent upgrades setting allows to control the automatic upgrade of the Palette component and agent for an individual cluster. The default value is `unlock`, meaning upgrades occur automatically. Setting it to `lock` pauses automatic agent upgrades for the cluster.",
                        },
                        "os_patch_on_boot": {
                                Type:        schema.TypeBool,
                                Optional:    true,
                                Default:     false,
                                Description: "Whether to apply OS patch on boot. Default is `false`.",
                        },
                        "os_patch_schedule": {
                                Type:             schema.TypeString,
                                Optional:         true,
                                ValidateDiagFunc: validateOsPatchSchedule,
                                Description:      "Cron schedule for OS patching. This must be in the form of `0 0 * * *`.",
                        },
                        "os_patch_after": {
                                Type:             schema.TypeString,
                                Optional:         true,
                                ValidateDiagFunc: validateOsPatchOnDemandAfter,
                                Description:      "Date and time after which to patch cluster `RFC3339: 2006-01-02T15:04:05Z07:00`",
                        },
                        "cluster_timezone": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "",
                                ValidateFunc: validateTimezone,
                                Description:  "Defines the time zone used by this cluster to interpret scheduled operations. Maintenance tasks like upgrades will follow this time zone to ensure they run at the appropriate local time for the cluster. Must be in IANA timezone format (e.g., 'America/New_York', 'Asia/Kolkata', 'Europe/London').",
                        },
                        "kubeconfig": {
                                Type:        schema.TypeString,
                                Computed:    true,
                                Description: "Kubeconfig for the cluster. This can be used to connect to the cluster using `kubectl`.",
                        },
                        "admin_kube_config": {
                                Type:        schema.TypeString,
                                Computed:    true,
                                Description: "Admin Kube-config for the cluster. This can be used to connect to the cluster using `kubectl`, With admin privilege.",
                        },
                        "cloud_config": {
                                Type:     schema.TypeList,
                                ForceNew: true,
                                Required: true,
                                MaxItems: 1,
                                Elem: &amp;schema.Resource{
                                        Schema: map[string]*schema.Schema{
                                                "datacenter": {
                                                        Type:     schema.TypeString,
                                                        Required: true,
                                                },
                                                "folder": {
                                                        Type:     schema.TypeString,
                                                        Required: true,
                                                },
                                                "image_template_folder": {
                                                        Type:     schema.TypeString,
                                                        Optional: true,
                                                },

                                                "ssh_key": {
                                                        Type:         schema.TypeString,
                                                        Optional:     true,
                                                        ExactlyOneOf: []string{"cloud_config.0.ssh_key", "cloud_config.0.ssh_keys"},
                                                        Description:  "Public SSH Key (Secure Shell) to establish, administer, and communicate with remote clusters, `ssh_key &amp; ssh_keys` are mutually exclusive.",
                                                },
                                                "ssh_keys": {
                                                        Type:         schema.TypeSet,
                                                        Optional:     true,
                                                        Set:          schema.HashString,
                                                        ExactlyOneOf: []string{"cloud_config.0.ssh_key", "cloud_config.0.ssh_keys"},
                                                        Elem: &amp;schema.Schema{
                                                                Type: schema.TypeString,
                                                        },
                                                        Description: "List of public SSH (Secure Shell) keys to establish, administer, and communicate with remote clusters, `ssh_key &amp; ssh_keys` are mutually exclusive.",
                                                },
                                                "vip": {
                                                        Type:     schema.TypeString,
                                                        Required: true,
                                                },

                                                "static_ip": {
                                                        Type:     schema.TypeBool,
                                                        Optional: true,
                                                        Default:  false,
                                                },

                                                "network_type": {
                                                        Type:     schema.TypeString,
                                                        Optional: true,
                                                },
                                                "network_search_domain": {
                                                        Type:     schema.TypeString,
                                                        Optional: true,
                                                },
                                        },
                                },
                        },
                        "machine_pool": {
                                Type:     schema.TypeList,
                                Required: true,
                                // disable hash to preserve machine pool order PE-255
                                // Set:      resourceMachinePoolVsphereHash,
                                Elem: &amp;schema.Resource{
                                        Schema: map[string]*schema.Schema{
                                                "name": {
                                                        Type:     schema.TypeString,
                                                        Required: true,
                                                },
                                                "additional_labels": {
                                                        Type:     schema.TypeMap,
                                                        Optional: true,
                                                        Elem: &amp;schema.Schema{
                                                                Type: schema.TypeString,
                                                        },
                                                        Description: "Additional labels to be applied to the machine pool. Labels must be in the form of `key:value`.",
                                                },
                                                "additional_annotations": {
                                                        Type:     schema.TypeMap,
                                                        Optional: true,
                                                        Elem: &amp;schema.Schema{
                                                                Type: schema.TypeString,
                                                        },
                                                        Description: "Additional annotations to be applied to the machine pool. Annotations must be in the form of `key:value`.",
                                                },
                                                "node":   schemas.NodeSchema(),
                                                "taints": schemas.ClusterTaintsSchema(),
                                                "control_plane": {
                                                        Type:        schema.TypeBool,
                                                        Optional:    true,
                                                        Default:     false,
                                                        Description: "Whether this machine pool is a control plane. Defaults to `false`.",
                                                },
                                                "control_plane_as_worker": {
                                                        Type:     schema.TypeBool,
                                                        Optional: true,
                                                        Default:  false,
                                                        //ForceNew: true,
                                                        Description: "Whether this machine pool is a control plane and a worker. Defaults to `false`.",
                                                },
                                                "count": {
                                                        Type:        schema.TypeInt,
                                                        Required:    true,
                                                        Description: "Number of nodes in the machine pool.",
                                                },
                                                "node_repave_interval": {
                                                        Type:        schema.TypeInt,
                                                        Optional:    true,
                                                        Default:     0,
                                                        Description: "Minimum number of seconds node should be Ready, before the next node is selected for repave. Default value is `0`, Applicable only for worker pools.",
                                                },
                                                "update_strategy": {
                                                        Type:         schema.TypeString,
                                                        Optional:     true,
                                                        Default:      "RollingUpdateScaleOut",
                                                        Description:  "Update strategy for the machine pool. Valid values are `RollingUpdateScaleOut`, `RollingUpdateScaleIn` and `OverrideScaling`. If `OverrideScaling` is used, `override_scaling` must be specified with both `max_surge` and `max_unavailable`.",
                                                        ValidateFunc: validation.StringInSlice([]string{"RollingUpdateScaleOut", "RollingUpdateScaleIn", "OverrideScaling"}, false),
                                                },
                                                "override_scaling": schemas.OverrideScalingSchema(),
                                                "override_kubeadm_configuration": {
                                                        Type:        schema.TypeString,
                                                        Optional:    true,
                                                        Description: "YAML config for kubeletExtraArgs, preKubeadmCommands, postKubeadmCommands. Overrides pack-level settings. Worker pools only.",
                                                },
                                                "instance_type": {
                                                        Type:     schema.TypeList,
                                                        Required: true,
                                                        MaxItems: 1,
                                                        Elem: &amp;schema.Resource{
                                                                Schema: map[string]*schema.Schema{
                                                                        "disk_size_gb": {
                                                                                Type:     schema.TypeInt,
                                                                                Required: true,
                                                                        },
                                                                        "memory_mb": {
                                                                                Type:     schema.TypeInt,
                                                                                Required: true,
                                                                        },
                                                                        "cpu": {
                                                                                Type:     schema.TypeInt,
                                                                                Required: true,
                                                                        },
                                                                },
                                                        },
                                                },
                                                "placement": {
                                                        Type:     schema.TypeList,
                                                        Required: true,
                                                        Elem: &amp;schema.Resource{
                                                                Schema: map[string]*schema.Schema{
                                                                        "id": {
                                                                                Type:     schema.TypeString,
                                                                                Computed: true,
                                                                        },
                                                                        "cluster": {
                                                                                Type:     schema.TypeString,
                                                                                Required: true,
                                                                        },
                                                                        "resource_pool": {
                                                                                Type:     schema.TypeString,
                                                                                Required: true,
                                                                        },
                                                                        "datastore": {
                                                                                Type:     schema.TypeString,
                                                                                Required: true,
                                                                        },
                                                                        "network": {
                                                                                Type:     schema.TypeString,
                                                                                Required: true,
                                                                        },
                                                                        "static_ip_pool_id": {
                                                                                Type:     schema.TypeString,
                                                                                Optional: true,
                                                                        },
                                                                },
                                                        },
                                                },
                                        },
                                },
                        },
                        "backup_policy":        schemas.BackupPolicySchema(),
                        "scan_policy":          schemas.ScanPolicySchema(),
                        "cluster_rbac_binding": schemas.ClusterRbacBindingSchema(),
                        "namespaces":           schemas.ClusterNamespacesSchema(),
                        "host_config":          schemas.ClusterHostConfigSchema(),
                        "location_config":      schemas.ClusterLocationSchema(),
                        "skip_completion": {
                                Type:        schema.TypeBool,
                                Optional:    true,
                                Default:     false,
                                Description: "If `true`, the cluster will be created asynchronously. Default value is `false`.",
                        },
                        "force_delete": {
                                Type:        schema.TypeBool,
                                Optional:    true,
                                Default:     false,
                                Description: "If set to `true`, the cluster will be force deleted and user has to manually clean up the provisioned cloud resources.",
                        },
                        "force_delete_delay": {
                                Type:             schema.TypeInt,
                                Optional:         true,
                                Default:          20,
                                Description:      "Delay duration in minutes to before invoking cluster force delete. Default and minimum is 20.",
                                ValidateDiagFunc: validation.ToDiagFunc(validation.IntAtLeast(20)),
                        },
                },
        }
}</span>

func resourceClusterEdgeVsphereCreate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        resourceContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, resourceContext)

        var diags diag.Diagnostics

        // Validate override_Scaling configuration
        if err := validateOverrideScaling(d, "machine_pool"); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">cluster, err := toEdgeVsphereCluster(c, d)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">uid, err := c.CreateClusterEdgeVsphere(cluster)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">diagnostics, isError := waitForClusterCreation(ctx, d, uid, diags, c, true)
        if len(diagnostics) &gt; 0 </span><span class="cov0" title="0">{
                diags = append(diags, diagnostics...)
        }</span>
        <span class="cov0" title="0">if isError </span><span class="cov0" title="0">{
                return diagnostics
        }</span>
        <span class="cov0" title="0">resourceClusterEdgeVsphereRead(ctx, d, m)

        return diags</span>
}

func resourceClusterEdgeVsphereRead(_ context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        resourceContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, resourceContext)

        var diags diag.Diagnostics

        cluster, err := resourceClusterRead(d, c, diags)
        if err != nil </span><span class="cov0" title="0">{
                return handleReadError(d, err, diags)
        }</span> else<span class="cov0" title="0"> if cluster == nil </span><span class="cov0" title="0">{
                // Deleted - Terraform will recreate it
                d.SetId("")
                return diags
        }</span>

        <span class="cov0" title="0">diagnostics, done := readCommonFields(c, d, cluster)
        if done </span><span class="cov0" title="0">{
                return diagnostics
        }</span>

        // Flatten cluster_template variables using variables API
        <span class="cov0" title="0">if err := flattenClusterTemplateVariables(c, d, d.Id()); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">return flattenCloudConfigEdgeVsphere(cluster.Spec.CloudConfigRef.UID, d, c)</span>
}

func flattenCloudConfigEdgeVsphere(configUID string, d *schema.ResourceData, c *client.V1Client) diag.Diagnostics <span class="cov0" title="0">{
        var diags diag.Diagnostics
        if err := d.Set("cloud_config_id", configUID); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        //ClusterContext := d.Get("context").(string)
        <span class="cov0" title="0">if config, err := c.GetCloudConfigVsphere(configUID); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span> else<span class="cov0" title="0"> {
                mp := flattenMachinePoolConfigsEdgeVsphere(config.Spec.MachinePoolConfig)
                mp, err := flattenNodeMaintenanceStatus(c, d, c.GetNodeStatusMapEdgeVsphere, mp, configUID)
                if err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
                <span class="cov0" title="0">if err := d.Set("machine_pool", mp); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
        }
        <span class="cov0" title="0">generalWarningForRepave(&amp;diags)
        return diags</span>
}

func flattenMachinePoolConfigsEdgeVsphere(machinePools []*models.V1VsphereMachinePoolConfig) []interface{} <span class="cov0" title="0">{
        if machinePools == nil </span><span class="cov0" title="0">{
                return make([]interface{}, 0)
        }</span>

        <span class="cov0" title="0">ois := make([]interface{}, 0)

        for _, machinePool := range machinePools </span><span class="cov0" title="0">{
                oi := make(map[string]interface{})

                FlattenAdditionalLabelsAnnotationsAndTaints(machinePool.AdditionalLabels, machinePool.AdditionalAnnotations, machinePool.Taints, oi)
                FlattenControlPlaneAndRepaveInterval(machinePool.IsControlPlane, oi, machinePool.NodeRepaveInterval)

                oi["control_plane_as_worker"] = machinePool.UseControlPlaneAsWorker
                oi["name"] = machinePool.Name
                oi["count"] = machinePool.Size
                if machinePool.UpdateStrategy != nil </span><span class="cov0" title="0">{
                        oi["update_strategy"] = machinePool.UpdateStrategy.Type
                        // Flatten override_Scaling if using OverrideScaling strategy
                        flattenOverrideScaling(machinePool.UpdateStrategy, oi)
                }</span>

                // Flatten override_kubeadm_configuration (worker pools only)
                <span class="cov0" title="0">if machinePool.IsControlPlane != nil &amp;&amp; !*machinePool.IsControlPlane &amp;&amp; machinePool.OverrideKubeadmConfiguration != "" </span><span class="cov0" title="0">{
                        oi["override_kubeadm_configuration"] = machinePool.OverrideKubeadmConfiguration
                }</span>

                <span class="cov0" title="0">if machinePool.InstanceType != nil </span><span class="cov0" title="0">{
                        s := make(map[string]interface{})
                        s["disk_size_gb"] = int(*machinePool.InstanceType.DiskGiB)
                        s["memory_mb"] = int(*machinePool.InstanceType.MemoryMiB)
                        s["cpu"] = int(*machinePool.InstanceType.NumCPUs)

                        oi["instance_type"] = []interface{}{s}
                }</span>

                <span class="cov0" title="0">placements := make([]interface{}, len(machinePool.Placements))
                for j, p := range machinePool.Placements </span><span class="cov0" title="0">{
                        pj := make(map[string]interface{})
                        pj["id"] = p.UID
                        pj["cluster"] = p.Cluster
                        pj["resource_pool"] = p.ResourcePool
                        pj["datastore"] = p.Datastore
                        pj["network"] = p.Network.NetworkName

                        poolID := ""
                        if p.Network.ParentPoolRef != nil </span><span class="cov0" title="0">{
                                poolID = p.Network.ParentPoolRef.UID
                        }</span>
                        <span class="cov0" title="0">pj["static_ip_pool_id"] = poolID

                        placements[j] = pj</span>
                }
                <span class="cov0" title="0">oi["placement"] = placements

                ois = append(ois, oi)</span>
        }

        <span class="cov0" title="0">return ois</span>
}

func resourceClusterEdgeVsphereUpdate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        resourceContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, resourceContext)

        var diags diag.Diagnostics
        err := validateSystemRepaveApproval(d, c)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">cloudConfigId := d.Get("cloud_config_id").(string)
        CloudConfig, err := c.GetCloudConfigEdgeVsphere(cloudConfigId)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">if d.HasChange("machine_pool") </span><span class="cov0" title="0">{
                // Validate override_Scaling configuration
                if err := validateOverrideScaling(d, "machine_pool"); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>

                <span class="cov0" title="0">oraw, nraw := d.GetChange("machine_pool")
                if oraw == nil </span><span class="cov0" title="0">{
                        oraw = new(schema.Set)
                }</span>
                <span class="cov0" title="0">if nraw == nil </span><span class="cov0" title="0">{
                        nraw = new(schema.Set)
                }</span>

                <span class="cov0" title="0">os := oraw.([]interface{})
                ns := nraw.([]interface{})

                osMap := make(map[string]interface{})
                for _, mp := range os </span><span class="cov0" title="0">{
                        machinePool := mp.(map[string]interface{})
                        osMap[machinePool["name"].(string)] = machinePool
                }</span>

                <span class="cov0" title="0">nsMap := make(map[string]interface{})

                for _, mp := range ns </span><span class="cov0" title="0">{
                        machinePoolResource := mp.(map[string]interface{})
                        nsMap[machinePoolResource["name"].(string)] = machinePoolResource
                        // since known issue in TF SDK: https://github.com/hashicorp/terraform-plugin-sdk/issues/588
                        if machinePoolResource["name"].(string) != "" </span><span class="cov0" title="0">{
                                name := machinePoolResource["name"].(string)
                                hash := resourceMachinePoolVsphereHash(machinePoolResource)
                                var err error
                                machinePool, err := toMachinePoolEdgeVsphere(machinePoolResource)
                                if err != nil </span><span class="cov0" title="0">{
                                        return diag.FromErr(err)
                                }</span>

                                <span class="cov0" title="0">if oldMachinePool, ok := osMap[name]; !ok </span><span class="cov0" title="0">{
                                        log.Printf("Create machine pool %s", name)
                                        err = c.CreateMachinePoolVsphere(cloudConfigId, machinePool)
                                }</span> else<span class="cov0" title="0"> if hash != resourceMachinePoolVsphereHash(oldMachinePool) </span><span class="cov0" title="0">{
                                        log.Printf("Change in machine pool %s", name)
                                        oldMachinePool, _ := toMachinePoolEdgeVsphere(oldMachinePool)
                                        oldPlacements := oldMachinePool.CloudConfig.Placements

                                        for i, p := range machinePool.CloudConfig.Placements </span><span class="cov0" title="0">{
                                                if len(oldPlacements) &gt; i </span><span class="cov0" title="0">{
                                                        p.UID = oldPlacements[i].UID
                                                }</span>
                                        }

                                        <span class="cov0" title="0">err = c.UpdateMachinePoolVsphere(cloudConfigId, machinePool)
                                        // Node Maintenance Actions
                                        err := resourceNodeAction(c, ctx, nsMap[name], c.GetNodeMaintenanceStatusEdgeVsphere, CloudConfig.Kind, cloudConfigId, name)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return diag.FromErr(err)
                                        }</span>
                                }

                                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                                        return diag.FromErr(err)
                                }</span>

                                <span class="cov0" title="0">delete(osMap, name)</span>
                        }
                }

                <span class="cov0" title="0">for _, mp := range osMap </span><span class="cov0" title="0">{
                        machinePool := mp.(map[string]interface{})
                        name := machinePool["name"].(string)
                        log.Printf("Deleted machine pool %s", name)
                        if err := c.DeleteMachinePoolVsphere(cloudConfigId, name); err != nil </span><span class="cov0" title="0">{
                                return diag.FromErr(err)
                        }</span>
                }
        }

        <span class="cov0" title="0">diagnostics, done := updateCommonFields(d, c)
        if done </span><span class="cov0" title="0">{
                return diagnostics
        }</span>

        <span class="cov0" title="0">resourceClusterEdgeVsphereRead(ctx, d, m)

        return diags</span>
}

func toEdgeVsphereCluster(c *client.V1Client, d *schema.ResourceData) (*models.V1SpectroVsphereClusterEntity, error) <span class="cov0" title="0">{
        cloudConfig := d.Get("cloud_config").([]interface{})[0].(map[string]interface{})

        vip := cloudConfig["vip"].(string)

        clusterContext := d.Get("context").(string)
        profiles, err := toProfiles(c, d, clusterContext)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">cluster := &amp;models.V1SpectroVsphereClusterEntity{
                Metadata: getClusterMetadata(d),
                Spec: &amp;models.V1SpectroVsphereClusterEntitySpec{
                        EdgeHostUID:     d.Get("edge_host_uid").(string),
                        Profiles:        profiles,
                        ClusterTemplate: toClusterTemplateReference(d),
                        Policies:        toPolicies(d),
                        CloudConfig:     getClusterConfigEntity(cloudConfig),
                },
        }

        cluster.Spec.CloudConfig.ControlPlaneEndpoint = &amp;models.V1ControlPlaneEndPoint{
                Host:             vip,
                Type:             cloudConfig["network_type"].(string),
                DdnsSearchDomain: cloudConfig["network_search_domain"].(string),
        }

        machinePoolConfigs := make([]*models.V1VsphereMachinePoolConfigEntity, 0)
        for _, machinePool := range d.Get("machine_pool").([]interface{}) </span><span class="cov0" title="0">{
                mp, err := toMachinePoolEdgeVsphere(machinePool)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">machinePoolConfigs = append(machinePoolConfigs, mp)</span>
        }

        /*sort.SliceStable(machinePoolConfigs, func(i, j int) bool {
                return machinePoolConfigs[i].PoolConfig.IsControlPlane
        })*/

        <span class="cov0" title="0">cluster.Spec.Machinepoolconfig = machinePoolConfigs
        cluster.Spec.ClusterConfig = toClusterConfig(d)

        return cluster, nil</span>
}

func getImageTemplateFolder(cloudConfig map[string]interface{}) string <span class="cov0" title="0">{
        imageTemplateFolder := "spectro-templates"
        if cloudConfig["image_template_folder"] != nil </span><span class="cov0" title="0">{
                imageTemplateFolder = cloudConfig["image_template_folder"].(string)
        }</span>
        <span class="cov0" title="0">return imageTemplateFolder</span>
}

func toMachinePoolEdgeVsphere(machinePool interface{}) (*models.V1VsphereMachinePoolConfigEntity, error) <span class="cov0" title="0">{
        m := machinePool.(map[string]interface{})

        labels := make([]string, 0)
        controlPlane := m["control_plane"].(bool)
        controlPlaneAsWorker := m["control_plane_as_worker"].(bool)
        if controlPlane </span><span class="cov0" title="0">{
                labels = append(labels, "control-plane")
        }</span> else<span class="cov0" title="0"> {
                labels = append(labels, "worker")
        }</span>

        <span class="cov0" title="0">placements := make([]*models.V1VspherePlacementConfigEntity, 0)
        for _, pos := range m["placement"].([]interface{}) </span><span class="cov0" title="0">{
                p := pos.(map[string]interface{})
                poolID := p["static_ip_pool_id"].(string)
                staticIP := false
                if len(poolID) &gt; 0 </span><span class="cov0" title="0">{
                        staticIP = true
                }</span>

                <span class="cov0" title="0">placements = append(placements, &amp;models.V1VspherePlacementConfigEntity{
                        UID:          p["id"].(string),
                        Cluster:      p["cluster"].(string),
                        ResourcePool: p["resource_pool"].(string),
                        Datastore:    p["datastore"].(string),
                        Network: &amp;models.V1VsphereNetworkConfigEntity{
                                NetworkName:   types.Ptr(p["network"].(string)),
                                ParentPoolUID: poolID,
                                StaticIP:      staticIP,
                        },
                })</span>
        }

        <span class="cov0" title="0">ins := m["instance_type"].([]interface{})[0].(map[string]interface{})
        instanceType := models.V1VsphereInstanceType{
                DiskGiB:   types.Ptr(SafeInt32(ins["disk_size_gb"].(int))),
                MemoryMiB: types.Ptr(SafeInt64(ins["memory_mb"].(int))),
                NumCPUs:   types.Ptr(SafeInt32(ins["cpu"].(int))),
        }

        mp := &amp;models.V1VsphereMachinePoolConfigEntity{
                CloudConfig: &amp;models.V1VsphereMachinePoolCloudConfigEntity{
                        Placements:   placements,
                        InstanceType: &amp;instanceType,
                },
                PoolConfig: &amp;models.V1MachinePoolConfigEntity{
                        AdditionalLabels:        toAdditionalNodePoolLabels(m),
                        AdditionalAnnotations:   toAdditionalNodePoolAnnotations(m),
                        Taints:                  toClusterTaints(m),
                        IsControlPlane:          controlPlane,
                        Labels:                  labels,
                        Name:                    types.Ptr(m["name"].(string)),
                        Size:                    types.Ptr(SafeInt32(m["count"].(int))),
                        UpdateStrategy:          toUpdateStrategy(m),
                        UseControlPlaneAsWorker: controlPlaneAsWorker,
                },
        }

        // Handle override_kubeadm_configuration (worker pools only)
        if !controlPlane </span><span class="cov0" title="0">{
                if overrideKubeadm, ok := m["override_kubeadm_configuration"].(string); ok &amp;&amp; overrideKubeadm != "" </span><span class="cov0" title="0">{
                        mp.PoolConfig.OverrideKubeadmConfiguration = overrideKubeadm
                }</span>
        }

        <span class="cov0" title="0">if !controlPlane </span><span class="cov0" title="0">{
                nodeRepaveInterval := 0
                if m["node_repave_interval"] != nil </span><span class="cov0" title="0">{
                        nodeRepaveInterval = m["node_repave_interval"].(int)
                }</span>
                <span class="cov0" title="0">mp.PoolConfig.NodeRepaveInterval = SafeInt32(nodeRepaveInterval)</span>
        } else<span class="cov0" title="0"> {
                err := ValidationNodeRepaveIntervalForControlPlane(m["node_repave_interval"].(int))
                if err != nil </span><span class="cov0" title="0">{
                        return mp, err
                }</span>
        }

        <span class="cov0" title="0">return mp, nil</span>
}
</pre>
		
		<pre class="file" id="file140" style="display: none">package spectrocloud

import (
        "context"
        "fmt"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
)

func resourceClusterEdgeVsphereImport(ctx context.Context, d *schema.ResourceData, m interface{}) ([]*schema.ResourceData, error) <span class="cov0" title="0">{
        c, err := GetCommonCluster(d, m)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">diags := resourceClusterEdgeVsphereRead(ctx, d, m)
        if diags.HasError() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("could not read cluster for import: %v", diags)
        }</span>

        // cluster profile and common default cluster attribute is get set here
        <span class="cov0" title="0">err = flattenCommonAttributeForClusterImport(c, d)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Return the resource data. In most cases, this method is only used to
        // import one resource at a time, so you should return the resource data
        // in a slice with a single element.
        <span class="cov0" title="0">return []*schema.ResourceData{d}, nil</span>
}
</pre>
		
		<pre class="file" id="file141" style="display: none">package spectrocloud

import (
        "context"
        "log"
        "strings"
        "time"

        "github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/schemas"
        "github.com/spectrocloud/terraform-provider-spectrocloud/types"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"

        "github.com/spectrocloud/palette-sdk-go/api/models"
        "github.com/spectrocloud/palette-sdk-go/client"
)

func resourceClusterEks() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                CreateContext: resourceClusterEksCreate,
                ReadContext:   resourceClusterEksRead,
                UpdateContext: resourceClusterEksUpdate,
                DeleteContext: resourceClusterDelete,
                Importer: &amp;schema.ResourceImporter{
                        StateContext: resourceClusterEksImport,
                },
                Description: "Resource for managing EKS clusters in Spectro Cloud through Palette.",

                Timeouts: &amp;schema.ResourceTimeout{
                        Create: schema.DefaultTimeout(60 * time.Minute),
                        Update: schema.DefaultTimeout(60 * time.Minute),
                        Delete: schema.DefaultTimeout(60 * time.Minute),
                },

                SchemaVersion: 3,
                StateUpgraders: []schema.StateUpgrader{
                        {
                                Type:    resourceClusterEksResourceV2().CoreConfigSchema().ImpliedType(),
                                Upgrade: resourceClusterEksStateUpgradeV2,
                                Version: 2,
                        },
                },
                Schema: map[string]*schema.Schema{
                        "name": {
                                Type:        schema.TypeString,
                                Required:    true,
                                ForceNew:    true,
                                Description: "The name of the cluster.",
                        },
                        "context": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "project",
                                ValidateFunc: validation.StringInSlice([]string{"", "project", "tenant"}, false),
                                Description: "The context of the EKS cluster. Allowed values are `project` or `tenant`. " +
                                        "Default is `project`. " + PROJECT_NAME_NUANCE,
                        },
                        "tags": {
                                Type:     schema.TypeSet,
                                Optional: true,
                                Set:      schema.HashString,
                                Elem: &amp;schema.Schema{
                                        Type: schema.TypeString,
                                },
                                Description: "A list of tags to be applied to the cluster. Tags must be in the form of `key:value`. The `tags` attribute will soon be deprecated. It is recommended to use `tags_map` instead.",
                        },
                        "tags_map": {
                                Type:          schema.TypeMap,
                                Optional:      true,
                                ConflictsWith: []string{"tags"},
                                Elem: &amp;schema.Schema{
                                        Type: schema.TypeString,
                                },
                                Description: "A map of tags to be applied to the cluster. tags and tags_map are mutually exclusive  only one should be used at a time",
                        },
                        "description": {
                                Type:        schema.TypeString,
                                Optional:    true,
                                Default:     "",
                                Description: "The description of the cluster. Default value is empty string.",
                        },
                        "cluster_meta_attribute": {
                                Type:        schema.TypeString,
                                Optional:    true,
                                Description: "`cluster_meta_attribute` can be used to set additional cluster metadata information, eg `{'nic_name': 'test', 'env': 'stage'}`",
                        },
                        "cluster_profile":  schemas.ClusterProfileSchema(),
                        "cluster_template": schemas.ClusterTemplateSchema(),
                        "apply_setting": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "DownloadAndInstall",
                                ValidateFunc: validation.StringInSlice([]string{"DownloadAndInstall", "DownloadAndInstallLater"}, false),
                                Description: "The setting to apply the cluster profile. `DownloadAndInstall` will download and install packs in one action. " +
                                        "`DownloadAndInstallLater` will only download artifact and postpone install for later. " +
                                        "Default value is `DownloadAndInstall`.",
                        },
                        "cloud_account_id": {
                                Type:        schema.TypeString,
                                Required:    true,
                                ForceNew:    true,
                                Description: "The AWS cloud account id to use for this cluster.",
                        },
                        "cloud_config_id": {
                                Type:        schema.TypeString,
                                Computed:    true,
                                Description: "ID of the cloud config used for the cluster. This cloud config must be of type `azure`.",
                                Deprecated:  "This field is deprecated and will be removed in the future. Use `cloud_config` instead.",
                        },
                        "review_repave_state": {
                                Type:         schema.TypeString,
                                Default:      "",
                                Optional:     true,
                                ValidateFunc: validateReviewRepaveValue,
                                Description:  "To authorize the cluster repave, set the value to `Approved` for approval and `\"\"` to decline. Default value is `\"\"`.",
                        },
                        "pause_agent_upgrades": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "unlock",
                                ValidateFunc: validation.StringInSlice([]string{"lock", "unlock"}, false),
                                Description:  "The pause agent upgrades setting allows to control the automatic upgrade of the Palette component and agent for an individual cluster. The default value is `unlock`, meaning upgrades occur automatically. Setting it to `lock` pauses automatic agent upgrades for the cluster.",
                        },
                        "os_patch_on_boot": {
                                Type:        schema.TypeBool,
                                Optional:    true,
                                Default:     false,
                                Description: "Whether to apply OS patch on boot. Default is `false`.",
                        },
                        "os_patch_schedule": {
                                Type:             schema.TypeString,
                                Optional:         true,
                                ValidateDiagFunc: validateOsPatchSchedule,
                                Description:      "Cron schedule for OS patching. This must be in the form of `0 0 * * *`.",
                        },
                        "os_patch_after": {
                                Type:             schema.TypeString,
                                Optional:         true,
                                ValidateDiagFunc: validateOsPatchOnDemandAfter,
                                Description:      "Date and time after which to patch cluster `RFC3339: 2006-01-02T15:04:05Z07:00`",
                        },
                        "cluster_timezone": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "",
                                ValidateFunc: validateTimezone,
                                Description:  "Defines the time zone used by this cluster to interpret scheduled operations. Maintenance tasks like upgrades will follow this time zone to ensure they run at the appropriate local time for the cluster. Must be in IANA timezone format (e.g., 'America/New_York', 'Asia/Kolkata', 'Europe/London').",
                        },
                        "kubeconfig": {
                                Type:        schema.TypeString,
                                Computed:    true,
                                Description: "Kubeconfig for the cluster. This can be used to connect to the cluster using `kubectl`.",
                        },
                        "admin_kube_config": {
                                Type:        schema.TypeString,
                                Computed:    true,
                                Description: "Admin Kube-config for the cluster. This can be used to connect to the cluster using `kubectl`, With admin privilege.",
                        },
                        "cloud_config": {
                                Type:        schema.TypeList,
                                Required:    true,
                                MaxItems:    1,
                                Description: "The AWS environment configuration settings such as network parameters and encryption parameters that apply to this cluster.",
                                Elem: &amp;schema.Resource{
                                        Schema: map[string]*schema.Schema{
                                                "ssh_key_name": {
                                                        Type:        schema.TypeString,
                                                        ForceNew:    true,
                                                        Optional:    true,
                                                        Description: "Public SSH key to be used for the cluster nodes.",
                                                },
                                                "region": {
                                                        Type:     schema.TypeString,
                                                        ForceNew: true,
                                                        Required: true,
                                                },
                                                "vpc_id": {
                                                        Type:     schema.TypeString,
                                                        ForceNew: true,
                                                        Optional: true,
                                                },
                                                "azs": {
                                                        Type:        schema.TypeList,
                                                        Description: "Mutually exclusive with `az_subnets`. Use for Dynamic provisioning.",
                                                        Optional:    true,
                                                        ForceNew:    true,
                                                        Elem: &amp;schema.Schema{
                                                                Type: schema.TypeString,
                                                        },
                                                },
                                                "az_subnets": {
                                                        Type:        schema.TypeMap,
                                                        Description: "Mutually exclusive with `azs`. Use for Static provisioning.",
                                                        Optional:    true,
                                                        ForceNew:    true,
                                                        DiffSuppressFunc: func(k, old, new string, d *schema.ResourceData) bool </span><span class="cov0" title="0">{
                                                                // UI strips the trailing newline on save
                                                                return strings.TrimSpace(old) == strings.TrimSpace(new)
                                                        }</span>,
                                                        Elem: &amp;schema.Schema{
                                                                Type: schema.TypeString,
                                                        },
                                                },
                                                "endpoint_access": {
                                                        Type:         schema.TypeString,
                                                        Optional:     true,
                                                        ForceNew:     true,
                                                        ValidateFunc: validation.StringInSlice([]string{"public", "private", "private_and_public"}, false),
                                                        Description:  "Choose between `private`, `public`, or `private_and_public` to define how communication is established with the endpoint for the managed Kubernetes API server and your cluster. The default value is `public`.",
                                                        Default:      "public",
                                                },
                                                "public_access_cidrs": {
                                                        Type:        schema.TypeSet,
                                                        Optional:    true,
                                                        Set:         schema.HashString,
                                                        Description: "List of CIDR blocks that define the allowed public access to the resource. Requests originating from addresses within these CIDR blocks will be permitted to access the resource. All other addresses will be denied access.",
                                                        Elem: &amp;schema.Schema{
                                                                Type: schema.TypeString,
                                                        },
                                                },
                                                "private_access_cidrs": {
                                                        Type:        schema.TypeSet,
                                                        Optional:    true,
                                                        Set:         schema.HashString,
                                                        Description: "List of CIDR blocks that define the allowed private access to the resource. Only requests originating from addresses within these CIDR blocks will be permitted to access the resource.",
                                                        Elem: &amp;schema.Schema{
                                                                Type: schema.TypeString,
                                                        },
                                                },
                                                "encryption_config_arn": {
                                                        Type:        schema.TypeString,
                                                        Description: "The ARN of the KMS encryption key to use for the cluster. Refer to the [Enable Secrets Encryption for EKS Cluster](https://docs.spectrocloud.com/clusters/public-cloud/aws/enable-secrets-encryption-kms-key/) for additional guidance.",
                                                        ForceNew:    true,
                                                        Optional:    true,
                                                },
                                        },
                                },
                        },
                        "machine_pool": {
                                Type:        schema.TypeSet,
                                Required:    true,
                                Set:         resourceMachinePoolEksHash,
                                Description: "The machine pool configuration for the cluster.",
                                Elem: &amp;schema.Resource{
                                        Schema: map[string]*schema.Schema{
                                                "name": {
                                                        Type:     schema.TypeString,
                                                        Required: true,
                                                        //ForceNew: true,
                                                },
                                                "additional_labels": {
                                                        Type:     schema.TypeMap,
                                                        Optional: true,
                                                        Elem: &amp;schema.Schema{
                                                                Type: schema.TypeString,
                                                        },
                                                        Description: "Additional labels to be applied to the machine pool. Labels must be in the form of `key:value`.",
                                                },
                                                "additional_annotations": {
                                                        Type:     schema.TypeMap,
                                                        Optional: true,
                                                        Elem: &amp;schema.Schema{
                                                                Type: schema.TypeString,
                                                        },
                                                        Description: "Additional annotations to be applied to the machine pool. Annotations must be in the form of `key:value`.",
                                                },
                                                "node":   schemas.NodeSchema(),
                                                "taints": schemas.ClusterTaintsSchema(),
                                                "disk_size_gb": {
                                                        Type:     schema.TypeInt,
                                                        Required: true,
                                                },
                                                "count": {
                                                        Type:        schema.TypeInt,
                                                        Required:    true,
                                                        Description: "Number of nodes in the machine pool.",
                                                },
                                                "update_strategy": {
                                                        Type:         schema.TypeString,
                                                        Optional:     true,
                                                        Default:      "RollingUpdateScaleOut",
                                                        Description:  "Update strategy for the machine pool. Valid values are `RollingUpdateScaleOut`, `RollingUpdateScaleIn` and `OverrideScaling`. If `OverrideScaling` is used, `override_scaling` must be specified with both `max_surge` and `max_unavailable`.",
                                                        ValidateFunc: validation.StringInSlice([]string{"RollingUpdateScaleOut", "RollingUpdateScaleIn", "OverrideScaling"}, false),
                                                },
                                                "override_scaling": schemas.OverrideScalingSchema(),
                                                "override_kubeadm_configuration": {
                                                        Type:        schema.TypeString,
                                                        Optional:    true,
                                                        Description: "YAML config for kubeletExtraArgs, preKubeadmCommands, postKubeadmCommands. Overrides pack-level settings. Worker pools only.",
                                                },
                                                "min": {
                                                        Type:        schema.TypeInt,
                                                        Optional:    true,
                                                        Description: "Minimum number of nodes in the machine pool. This is used for autoscaling the machine pool.",
                                                },
                                                "max": {
                                                        Type:        schema.TypeInt,
                                                        Optional:    true,
                                                        Description: "Maximum number of nodes in the machine pool. This is used for autoscaling the machine pool.",
                                                },
                                                "instance_type": {
                                                        Type:     schema.TypeString,
                                                        Required: true,
                                                },
                                                "ami_type": {
                                                        Type:        schema.TypeString,
                                                        Optional:    true,
                                                        Default:     "AL2023_x86_64_STANDARD",
                                                        Description: "Specifies the type of Amazon Machine Image (AMI) to use for the machine pool. Valid values are [`AL2_x86_64`, `AL2_x86_64_GPU`, `AL2023_x86_64_STANDARD`, `AL2023_x86_64_NEURON` and `AL2023_x86_64_NVIDIA`]. Defaults to `AL2023_x86_64_STANDARD`.",
                                                },
                                                "capacity_type": {
                                                        Type:         schema.TypeString,
                                                        Default:      "on-demand",
                                                        Optional:     true,
                                                        ValidateFunc: validation.StringInSlice([]string{"on-demand", "spot"}, false),
                                                        Description:  "Capacity type is an instance type,  can be 'on-demand' or 'spot'. Defaults to 'on-demand'.",
                                                },
                                                "max_price": {
                                                        Type:     schema.TypeString,
                                                        Optional: true,
                                                        Default:  "",
                                                },
                                                "azs": {
                                                        Type:        schema.TypeList,
                                                        Optional:    true,
                                                        Description: "Mutually exclusive with `az_subnets`.",
                                                        Elem: &amp;schema.Schema{
                                                                Type: schema.TypeString,
                                                        },
                                                },
                                                "az_subnets": {
                                                        Type:        schema.TypeMap,
                                                        Optional:    true,
                                                        Description: "Mutually exclusive with `azs`. Use for Static provisioning.",
                                                        Elem: &amp;schema.Schema{
                                                                Type: schema.TypeString,
                                                        },
                                                },
                                                "eks_launch_template": schemas.AwsLaunchTemplate(),
                                        },
                                },
                        },
                        "fargate_profile": {
                                Type:     schema.TypeList,
                                Optional: true,
                                Elem: &amp;schema.Resource{
                                        Schema: map[string]*schema.Schema{
                                                "name": {
                                                        Type:     schema.TypeString,
                                                        Required: true,
                                                },
                                                "subnets": {
                                                        Type:     schema.TypeList,
                                                        Optional: true,
                                                        Elem: &amp;schema.Schema{
                                                                Type: schema.TypeString,
                                                        },
                                                },
                                                "additional_tags": {
                                                        Type:     schema.TypeMap,
                                                        Optional: true,
                                                        Elem: &amp;schema.Schema{
                                                                Type: schema.TypeString,
                                                        },
                                                },
                                                "selector": {
                                                        Type:     schema.TypeList,
                                                        Required: true,
                                                        //MinItems: 1,
                                                        Elem: &amp;schema.Resource{
                                                                Schema: map[string]*schema.Schema{
                                                                        "namespace": {
                                                                                Type:     schema.TypeString,
                                                                                Required: true,
                                                                        },
                                                                        "labels": {
                                                                                Type:     schema.TypeMap,
                                                                                Optional: true,
                                                                                Elem: &amp;schema.Schema{
                                                                                        Type: schema.TypeString,
                                                                                },
                                                                        },
                                                                },
                                                        },
                                                },
                                        },
                                },
                        },
                        "backup_policy":        schemas.BackupPolicySchema(),
                        "scan_policy":          schemas.ScanPolicySchema(),
                        "cluster_rbac_binding": schemas.ClusterRbacBindingSchema(),
                        "namespaces":           schemas.ClusterNamespacesSchema(),
                        "host_config":          schemas.ClusterHostConfigSchema(),
                        "location_config":      schemas.ClusterLocationSchemaComputed(),
                        "skip_completion": {
                                Type:        schema.TypeBool,
                                Optional:    true,
                                Default:     false,
                                Description: "If `true`, the cluster will be created asynchronously. Default value is `false`.",
                        },
                        "force_delete": {
                                Type:        schema.TypeBool,
                                Optional:    true,
                                Default:     false,
                                Description: "If set to `true`, the cluster will be force deleted and user has to manually clean up the provisioned cloud resources.",
                        },
                        "force_delete_delay": {
                                Type:             schema.TypeInt,
                                Optional:         true,
                                Default:          20,
                                Description:      "Delay duration in minutes to before invoking cluster force delete. Default and minimum is 20.",
                                ValidateDiagFunc: validation.ToDiagFunc(validation.IntAtLeast(20)),
                        },
                },
        }
}

func resourceClusterEksCreate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        resourceContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, resourceContext)

        // Warning or errors can be collected in a slice type
        var diags diag.Diagnostics

        // Validate override_Scaling configuration
        if err := validateOverrideScaling(d, "machine_pool"); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">cluster, err := toEksCluster(c, d)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">uid, err := c.CreateClusterEks(cluster)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">diagnostics, isError := waitForClusterCreation(ctx, d, uid, diags, c, true)
        if len(diagnostics) &gt; 0 </span><span class="cov0" title="0">{
                diags = append(diags, diagnostics...)
        }</span>
        <span class="cov0" title="0">if isError </span><span class="cov0" title="0">{
                return diagnostics
        }</span>

        <span class="cov0" title="0">resourceClusterEksRead(ctx, d, m)

        return diags</span>
}

func resourceClusterEksRead(_ context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        resourceContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, resourceContext)

        var diags diag.Diagnostics

        cluster, err := resourceClusterRead(d, c, diags)
        if err != nil </span><span class="cov0" title="0">{
                return handleReadError(d, err, diags)
        }</span> else<span class="cov0" title="0"> if cluster == nil </span><span class="cov0" title="0">{
                // Deleted - Terraform will recreate it
                d.SetId("")
                return diags
        }</span>

        <span class="cov0" title="0">configUID := cluster.Spec.CloudConfigRef.UID
        if err := d.Set("cloud_config_id", configUID); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">var config *models.V1EksCloudConfig
        if config, err = c.GetCloudConfigEks(configUID); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">if err := d.Set("cloud_account_id", config.Spec.CloudAccountRef.UID); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">cloudConfigFlatten := flattenClusterConfigsEKS(config)
        if err := d.Set("cloud_config", cloudConfigFlatten); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">mp := flattenMachinePoolConfigsEks(config.Spec.MachinePoolConfig)

        mp, err = flattenNodeMaintenanceStatus(c, d, c.GetNodeStatusMapEks, mp, configUID)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">if err := d.Set("machine_pool", mp); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">fp := flattenFargateProfilesEks(config.Spec.FargateProfiles)
        if err := d.Set("fargate_profile", fp); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        // verify cluster type
        <span class="cov0" title="0">err = ValidateCloudType("spectrocloud_cluster_eks", cluster)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">diagnostics, done := readCommonFields(c, d, cluster)

        // handling flatten tags_map for aws  cluster
        if _, ok := d.GetOk("tags_map"); ok </span><span class="cov0" title="0">{
                // setting to empty since tags_map is present
                _ = d.Set("tags", []string{})
                tagMaps := flattenTagsMap(cluster.Metadata.Labels)
                if err := d.Set("tags_map", tagMaps); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
        }

        <span class="cov0" title="0">if done </span><span class="cov0" title="0">{
                return diagnostics
        }</span>

        // Flatten cluster_template variables using variables API
        <span class="cov0" title="0">if err := flattenClusterTemplateVariables(c, d, d.Id()); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">generalWarningForRepave(&amp;diags)
        return diags</span>
}

func flattenClusterConfigsEKS(cloudConfig *models.V1EksCloudConfig) interface{} <span class="cov0" title="0">{
        cloudConfigFlatten := make([]interface{}, 0)
        if cloudConfig == nil </span><span class="cov0" title="0">{
                return cloudConfigFlatten
        }</span>

        <span class="cov0" title="0">ret := make(map[string]interface{})

        ret["region"] = cloudConfig.Spec.ClusterConfig.Region

        ret["public_access_cidrs"] = make([]string, 0)
        if cloudConfig.Spec.ClusterConfig.EndpointAccess.PublicCIDRs != nil </span><span class="cov0" title="0">{
                ret["public_access_cidrs"] = cloudConfig.Spec.ClusterConfig.EndpointAccess.PublicCIDRs
        }</span>

        <span class="cov0" title="0">ret["private_access_cidrs"] = make([]string, 0)
        if cloudConfig.Spec.ClusterConfig.EndpointAccess.PrivateCIDRs != nil </span><span class="cov0" title="0">{
                ret["private_access_cidrs"] = cloudConfig.Spec.ClusterConfig.EndpointAccess.PrivateCIDRs
        }</span>

        <span class="cov0" title="0">for _, pool := range cloudConfig.Spec.MachinePoolConfig </span><span class="cov0" title="0">{
                if pool.Name == "cp-pool" </span><span class="cov0" title="0">{
                        ret["az_subnets"] = pool.SubnetIds
                }</span>
        }

        <span class="cov0" title="0">if cloudConfig.Spec.ClusterConfig.EncryptionConfig != nil &amp;&amp; cloudConfig.Spec.ClusterConfig.EncryptionConfig.IsEnabled </span><span class="cov0" title="0">{
                ret["encryption_config_arn"] = cloudConfig.Spec.ClusterConfig.EncryptionConfig.Provider
        }</span>

        <span class="cov0" title="0">if cloudConfig.Spec.ClusterConfig.EndpointAccess.Private &amp;&amp; cloudConfig.Spec.ClusterConfig.EndpointAccess.Public </span><span class="cov0" title="0">{
                ret["endpoint_access"] = "private_and_public"
        }</span>
        <span class="cov0" title="0">if cloudConfig.Spec.ClusterConfig.EndpointAccess.Private &amp;&amp; !cloudConfig.Spec.ClusterConfig.EndpointAccess.Public </span><span class="cov0" title="0">{
                ret["endpoint_access"] = "private"
        }</span>
        <span class="cov0" title="0">if !cloudConfig.Spec.ClusterConfig.EndpointAccess.Private &amp;&amp; cloudConfig.Spec.ClusterConfig.EndpointAccess.Public </span><span class="cov0" title="0">{
                ret["endpoint_access"] = "public"
        }</span>
        <span class="cov0" title="0">ret["region"] = *cloudConfig.Spec.ClusterConfig.Region
        ret["vpc_id"] = cloudConfig.Spec.ClusterConfig.VpcID
        ret["ssh_key_name"] = cloudConfig.Spec.ClusterConfig.SSHKeyName

        cloudConfigFlatten = append(cloudConfigFlatten, ret)

        return cloudConfigFlatten</span>
}

// isKarpenterManagedPool checks if a machine pool is managed by Karpenter
// by checking if the Labels array contains "spectrocloud.com/managed-by:karpenter"
func isKarpenterManagedPool(machinePool *models.V1EksMachinePoolConfig) bool <span class="cov0" title="0">{
        if machinePool == nil || machinePool.Labels == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">for _, label := range machinePool.Labels </span><span class="cov0" title="0">{
                if strings.Contains(label, "spectrocloud.com/managed-by:karpenter") </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

func flattenMachinePoolConfigsEks(machinePools []*models.V1EksMachinePoolConfig) []interface{} <span class="cov0" title="0">{
        if machinePools == nil </span><span class="cov0" title="0">{
                return make([]interface{}, 0)
        }</span>

        <span class="cov0" title="0">ois := make([]interface{}, 0)

        for _, machinePool := range machinePools </span><span class="cov0" title="0">{
                oi := make(map[string]interface{})

                // Skip Karpenter-managed machine pools
                if isKarpenterManagedPool(machinePool) </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">if machinePool.IsControlPlane != nil &amp;&amp; *machinePool.IsControlPlane </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">FlattenAdditionalLabelsAnnotationsAndTaints(machinePool.AdditionalLabels, machinePool.AdditionalAnnotations, machinePool.Taints, oi)

                oi["name"] = machinePool.Name
                oi["count"] = int(machinePool.Size)
                if machinePool.UpdateStrategy != nil &amp;&amp; machinePool.UpdateStrategy.Type != "" </span><span class="cov0" title="0">{
                        oi["update_strategy"] = machinePool.UpdateStrategy.Type
                        // Flatten override_Scaling if using OverrideScaling strategy
                        flattenOverrideScaling(machinePool.UpdateStrategy, oi)
                }</span> else<span class="cov0" title="0"> {
                        oi["update_strategy"] = "RollingUpdateScaleOut"
                }</span>

                // Flatten override_kubeadm_configuration (worker pools only)
                <span class="cov0" title="0">if machinePool.OverrideKubeadmConfiguration != "" </span><span class="cov0" title="0">{
                        oi["override_kubeadm_configuration"] = machinePool.OverrideKubeadmConfiguration
                }</span>

                <span class="cov0" title="0">oi["min"] = int(machinePool.MinSize)
                oi["max"] = int(machinePool.MaxSize)
                oi["instance_type"] = machinePool.InstanceType
                oi["ami_type"] = machinePool.AmiType
                if machinePool.CapacityType != nil </span><span class="cov0" title="0">{
                        oi["capacity_type"] = machinePool.CapacityType
                }</span>
                <span class="cov0" title="0">if machinePool.SpotMarketOptions != nil </span><span class="cov0" title="0">{
                        if machinePool.SpotMarketOptions.MaxPrice != "" </span><span class="cov0" title="0">{
                                oi["max_price"] = machinePool.SpotMarketOptions.MaxPrice
                        }</span> else<span class="cov0" title="0"> {
                                oi["max_price"] = ""
                        }</span>
                }
                <span class="cov0" title="0">oi["disk_size_gb"] = int(machinePool.RootDeviceSize)
                if len(machinePool.SubnetIds) &gt; 0 </span><span class="cov0" title="0">{
                        oi["az_subnets"] = machinePool.SubnetIds
                }</span> else<span class="cov0" title="0"> {
                        oi["azs"] = machinePool.Azs
                }</span>
                <span class="cov0" title="0">eksLaunchTemplates := flattenEksLaunchTemplate(machinePool.AwsLaunchTemplate)

                if eksLaunchTemplates != nil </span><span class="cov0" title="0">{
                        oi["eks_launch_template"] = flattenEksLaunchTemplate(machinePool.AwsLaunchTemplate)
                }</span>

                <span class="cov0" title="0">ois = append(ois, oi)</span>
        }

        <span class="cov0" title="0">return ois</span>
}

func flattenEksLaunchTemplate(launchTemplate *models.V1AwsLaunchTemplate) []interface{} <span class="cov0" title="0">{
        if launchTemplate == nil </span><span class="cov0" title="0">{
                return make([]interface{}, 0)
        }</span>

        <span class="cov0" title="0">lt := make(map[string]interface{})

        if launchTemplate.Ami != nil </span><span class="cov0" title="0">{
                lt["ami_id"] = launchTemplate.Ami.ID
        }</span>
        <span class="cov0" title="0">if launchTemplate.RootVolume != nil </span><span class="cov0" title="0">{
                lt["root_volume_type"] = launchTemplate.RootVolume.Type
                lt["root_volume_iops"] = launchTemplate.RootVolume.Iops
                lt["root_volume_throughput"] = launchTemplate.RootVolume.Throughput
        }</span>
        <span class="cov0" title="0">if len(launchTemplate.AdditionalSecurityGroups) &gt; 0 </span><span class="cov0" title="0">{
                var additionalSecurityGroups []string
                for _, sg := range launchTemplate.AdditionalSecurityGroups </span><span class="cov0" title="0">{
                        additionalSecurityGroups = append(additionalSecurityGroups, sg.ID)
                }</span>
                <span class="cov0" title="0">lt["additional_security_groups"] = additionalSecurityGroups</span>
        }
        // handling eks template flatten with this code eks template will not set back to schema
        <span class="cov0" title="0">if lt["ami_id"].(string) != "" ||
                lt["root_volume_type"].(string) != "" ||
                lt["root_volume_iops"].(int64) != 0 ||
                lt["root_volume_throughput"].(int64) != 0 ||
                len(launchTemplate.AdditionalSecurityGroups) &gt; 0 </span><span class="cov0" title="0">{
                return []interface{}{lt}
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func flattenFargateProfilesEks(fargateProfiles []*models.V1FargateProfile) []interface{} <span class="cov0" title="0">{
        if fargateProfiles == nil </span><span class="cov0" title="0">{
                return make([]interface{}, 0)
        }</span>

        <span class="cov0" title="0">ois := make([]interface{}, 0)

        for _, fargateProfile := range fargateProfiles </span><span class="cov0" title="0">{
                oi := make(map[string]interface{})

                oi["name"] = fargateProfile.Name
                oi["subnets"] = fargateProfile.SubnetIds
                oi["additional_tags"] = fargateProfile.AdditionalTags

                selectors := make([]interface{}, 0)
                for _, selector := range fargateProfile.Selectors </span><span class="cov0" title="0">{
                        s := make(map[string]interface{})
                        s["namespace"] = selector.Namespace
                        s["labels"] = selector.Labels
                        selectors = append(selectors, s)
                }</span>
                <span class="cov0" title="0">oi["selector"] = selectors

                ois = append(ois, oi)</span>
        }

        <span class="cov0" title="0">return ois</span>
}

func resourceClusterEksUpdate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        resourceContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, resourceContext)

        // Warning or errors can be collected in a slice type
        var diags diag.Diagnostics

        err := validateSystemRepaveApproval(d, c)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">cloudConfigId := d.Get("cloud_config_id").(string)

        if d.HasChange("cloud_config") </span><span class="cov0" title="0">{
                cloudConfig := d.Get("cloud_config").([]interface{})[0].(map[string]interface{})
                cloudConfigEntity := toCloudConfigEks(cloudConfig)
                err := c.UpdateCloudConfigEks(cloudConfigId, cloudConfigEntity)
                if err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
        }

        <span class="cov0" title="0">CloudConfig, err := c.GetCloudConfigEks(cloudConfigId)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">if d.HasChange("fargate_profile") </span><span class="cov0" title="0">{
                fargateProfiles := make([]*models.V1FargateProfile, 0)
                for _, fargateProfile := range d.Get("fargate_profile").([]interface{}) </span><span class="cov0" title="0">{
                        f := toFargateProfileEks(fargateProfile)
                        fargateProfiles = append(fargateProfiles, f)
                }</span>

                <span class="cov0" title="0">log.Printf("Updating fargate profiles")
                fargateProfilesList := &amp;models.V1EksFargateProfiles{
                        FargateProfiles: fargateProfiles,
                }

                err := c.UpdateFargateProfilesEks(cloudConfigId, fargateProfilesList)
                if err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
        }

        <span class="cov0" title="0">_ = d.Get("machine_pool")

        if d.HasChange("machine_pool") </span><span class="cov0" title="0">{
                // Validate override_Scaling configuration
                if err := validateOverrideScaling(d, "machine_pool"); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>

                <span class="cov0" title="0">log.Printf("[DEBUG] === MACHINE POOL CHANGE DETECTED ===")
                oraw, nraw := d.GetChange("machine_pool")
                if oraw == nil </span><span class="cov0" title="0">{
                        oraw = new(schema.Set)
                }</span>
                <span class="cov0" title="0">if nraw == nil </span><span class="cov0" title="0">{
                        nraw = new(schema.Set)
                }</span>

                <span class="cov0" title="0">os := oraw.(*schema.Set)
                ns := nraw.(*schema.Set)

                log.Printf("[DEBUG] Old machine pools count: %d, New machine pools count: %d", os.Len(), ns.Len())

                // Create maps by machine pool name for proper comparison
                osMap := make(map[string]interface{})
                for _, mp := range os.List() </span><span class="cov0" title="0">{
                        machinePoolResource := mp.(map[string]interface{})
                        name := machinePoolResource["name"].(string)
                        if name != "" </span><span class="cov0" title="0">{
                                osMap[name] = machinePoolResource
                        }</span>
                }

                <span class="cov0" title="0">nsMap := make(map[string]interface{})
                for _, mp := range ns.List() </span><span class="cov0" title="0">{
                        machinePoolResource := mp.(map[string]interface{})
                        name := machinePoolResource["name"].(string)
                        if name != "" </span><span class="cov0" title="0">{
                                nsMap[name] = machinePoolResource

                                // Check if this is a new, updated, or unchanged machine pool
                                if oldMachinePool, exists := osMap[name]; !exists </span><span class="cov0" title="0">{
                                        // NEW machine pool - CREATE
                                        log.Printf("[DEBUG] Creating new machine pool %s", name)
                                        machinePool := toMachinePoolEks(machinePoolResource)
                                        if err := c.CreateMachinePoolEks(cloudConfigId, machinePool); err != nil </span><span class="cov0" title="0">{
                                                return diag.FromErr(err)
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        // EXISTING machine pool - check if hash changed
                                        oldHash := resourceMachinePoolEksHash(oldMachinePool)
                                        newHash := resourceMachinePoolEksHash(machinePoolResource)

                                        if oldHash != newHash </span><span class="cov0" title="0">{
                                                // MODIFIED machine pool - UPDATE
                                                log.Printf("[DEBUG] Updating machine pool %s (hash changed: %d -&gt; %d)", name, oldHash, newHash)
                                                machinePool := toMachinePoolEks(machinePoolResource)
                                                if err := c.UpdateMachinePoolEks(cloudConfigId, machinePool); err != nil </span><span class="cov0" title="0">{
                                                        return diag.FromErr(err)
                                                }</span>
                                                // Node Maintenance Actions
                                                <span class="cov0" title="0">err := resourceNodeAction(c, ctx, machinePoolResource, c.GetNodeMaintenanceStatusEks, CloudConfig.Kind, cloudConfigId, name)
                                                if err != nil </span><span class="cov0" title="0">{
                                                        return diag.FromErr(err)
                                                }</span>
                                        } else<span class="cov0" title="0"> {
                                                // UNCHANGED machine pool - no action needed
                                                log.Printf("[DEBUG] Machine pool %s unchanged (hash: %d)", name, oldHash)
                                        }</span>
                                }

                                // Mark as processed
                                <span class="cov0" title="0">delete(osMap, name)</span>
                        } else<span class="cov0" title="0"> {
                                log.Printf("[DEBUG] WARNING: Machine pool has empty name!")
                        }</span>
                }

                // REMOVED machine pools - DELETE
                <span class="cov0" title="0">for name := range osMap </span><span class="cov0" title="0">{
                        log.Printf("[DEBUG] Deleting removed machine pool %s", name)
                        if err := c.DeleteMachinePoolEks(cloudConfigId, name); err != nil </span><span class="cov0" title="0">{
                                return diag.FromErr(err)
                        }</span>
                }
        }

        <span class="cov0" title="0">diagnostics, done := updateCommonFields(d, c)
        if done </span><span class="cov0" title="0">{
                return diagnostics
        }</span>

        <span class="cov0" title="0">resourceClusterEksRead(ctx, d, m)

        return diags</span>
}

// to create
func toEksCluster(c *client.V1Client, d *schema.ResourceData) (*models.V1SpectroEksClusterEntity, error) <span class="cov0" title="0">{
        // gnarly, I know! =/
        cloudConfig := d.Get("cloud_config").([]interface{})[0].(map[string]interface{})
        //clientSecret := strfmt.Password(d.Get("Eks_client_secret").(string))
        var encryptionConfig *models.V1EncryptionConfig

        if cloudConfig["encryption_config_arn"] != nil </span><span class="cov0" title="0">{
                encryptionConfig = &amp;models.V1EncryptionConfig{
                        IsEnabled: true,
                        Provider:  cloudConfig["encryption_config_arn"].(string),
                }
        }</span>

        <span class="cov0" title="0">clusterContext := d.Get("context").(string)
        profiles, err := toProfiles(c, d, clusterContext)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">cluster := &amp;models.V1SpectroEksClusterEntity{
                Metadata: getClusterMetadata(d),
                Spec: &amp;models.V1SpectroEksClusterEntitySpec{
                        CloudAccountUID: types.Ptr(d.Get("cloud_account_id").(string)),
                        Profiles:        profiles,
                        ClusterTemplate: toClusterTemplateReference(d),
                        Policies:        toPolicies(d),
                        CloudConfig: &amp;models.V1EksClusterConfig{
                                BastionDisabled:  true,
                                VpcID:            cloudConfig["vpc_id"].(string),
                                Region:           types.Ptr(cloudConfig["region"].(string)),
                                SSHKeyName:       cloudConfig["ssh_key_name"].(string),
                                EncryptionConfig: encryptionConfig,
                        },
                },
        }

        // handling to tags_map for eks cluster
        if _, ok := d.GetOk("tags_map"); ok </span><span class="cov0" title="0">{
                tagMaps := toTagsMap(d)
                cluster.Metadata.Labels = tagMaps
        }</span>

        <span class="cov0" title="0">access := &amp;models.V1EksClusterConfigEndpointAccess{}
        switch cloudConfig["endpoint_access"].(string) </span>{
        case "public":<span class="cov0" title="0">
                access.Public = true
                access.Private = false</span>
        case "private":<span class="cov0" title="0">
                access.Public = false
                access.Private = true</span>
        case "private_and_public":<span class="cov0" title="0">
                access.Public = true
                access.Private = true</span>
        }

        <span class="cov0" title="0">if cloudConfig["public_access_cidrs"] != nil </span><span class="cov0" title="0">{
                cidrs := make([]string, 0, 1)
                for _, cidr := range cloudConfig["public_access_cidrs"].(*schema.Set).List() </span><span class="cov0" title="0">{
                        cidrs = append(cidrs, cidr.(string))
                }</span>
                <span class="cov0" title="0">access.PublicCIDRs = cidrs</span>
        }

        <span class="cov0" title="0">if cloudConfig["private_access_cidrs"] != nil </span><span class="cov0" title="0">{
                cidrs := make([]string, 0, 1)
                for _, cidr := range cloudConfig["private_access_cidrs"].(*schema.Set).List() </span><span class="cov0" title="0">{
                        cidrs = append(cidrs, cidr.(string))
                }</span>
                <span class="cov0" title="0">access.PrivateCIDRs = cidrs</span>
        }

        <span class="cov0" title="0">cluster.Spec.CloudConfig.EndpointAccess = access

        machinePoolConfigs := make([]*models.V1EksMachinePoolConfigEntity, 0)

        // Following same logic as UI for setting up control plane for static cluster
        // Only add cp-pool for dynamic cluster provisioning when az_subnets is not empty and has more than one element
        if cloudConfig["az_subnets"] != nil &amp;&amp; len(cloudConfig["az_subnets"].(map[string]interface{})) &gt; 0 </span><span class="cov0" title="0">{
                cpPool := map[string]interface{}{
                        "control_plane": true,
                        "name":          "cp-pool",
                        "az_subnets":    cloudConfig["az_subnets"],
                        "capacity_type": "spot",
                        "count":         0,
                }
                machinePoolConfigs = append(machinePoolConfigs, toMachinePoolEks(cpPool))
        }</span>

        <span class="cov0" title="0">for _, machinePool := range d.Get("machine_pool").(*schema.Set).List() </span><span class="cov0" title="0">{
                mp := toMachinePoolEks(machinePool)
                machinePoolConfigs = append(machinePoolConfigs, mp)
        }</span>

        <span class="cov0" title="0">cluster.Spec.Machinepoolconfig = machinePoolConfigs
        cluster.Spec.ClusterConfig = toClusterConfig(d)

        fargateProfiles := make([]*models.V1FargateProfile, 0)
        for _, fargateProfile := range d.Get("fargate_profile").([]interface{}) </span><span class="cov0" title="0">{
                f := toFargateProfileEks(fargateProfile)
                fargateProfiles = append(fargateProfiles, f)
        }</span>

        <span class="cov0" title="0">cluster.Spec.FargateProfiles = fargateProfiles

        return cluster, nil</span>
}

func toMachinePoolEks(machinePool interface{}) *models.V1EksMachinePoolConfigEntity <span class="cov0" title="0">{
        m := machinePool.(map[string]interface{})

        labels := make([]string, 0)
        controlPlane, _ := m["control_plane"].(bool)
        if controlPlane </span><span class="cov0" title="0">{
                labels = append(labels, "control-plane")
        }</span> else<span class="cov0" title="0"> {
                labels = append(labels, "worker")
        }</span>

        <span class="cov0" title="0">azs := make([]string, 0)
        subnets := make([]*models.V1EksSubnetEntity, 0)
        for k, val := range m["az_subnets"].(map[string]interface{}) </span><span class="cov0" title="0">{
                azs = append(azs, k)
                if val.(string) != "" &amp;&amp; val.(string) != "-" </span><span class="cov0" title="0">{
                        subnets = append(subnets, &amp;models.V1EksSubnetEntity{
                                Az: k,
                                ID: val.(string),
                        })
                }</span>
        }
        <span class="cov0" title="0">if len(azs) == 0 </span><span class="cov0" title="0">{
                if _, ok := m["azs"]; ok </span><span class="cov0" title="0">{
                        for _, az := range m["azs"].([]interface{}) </span><span class="cov0" title="0">{
                                azs = append(azs, az.(string))
                        }</span>
                }
        }

        <span class="cov0" title="0">capacityType := "on-demand" // on-demand by default.
        if m["capacity_type"] != nil &amp;&amp; len(m["capacity_type"].(string)) &gt; 0 </span><span class="cov0" title="0">{
                capacityType = m["capacity_type"].(string)
        }</span>

        <span class="cov0" title="0">min := SafeInt32(m["count"].(int))
        max := SafeInt32(m["count"].(int))

        if m["min"] != nil </span><span class="cov0" title="0">{
                min = SafeInt32(m["min"].(int))
        }</span>

        <span class="cov0" title="0">if m["max"] != nil </span><span class="cov0" title="0">{
                max = SafeInt32(m["max"].(int))
        }</span>
        <span class="cov0" title="0">instanceType := ""
        if val, ok := m["instance_type"]; ok </span><span class="cov0" title="0">{
                instanceType = val.(string)
        }</span>
        <span class="cov0" title="0">amiType := ""
        if val, ok := m["ami_type"]; ok </span><span class="cov0" title="0">{
                amiType = val.(string)
        }</span>
        <span class="cov0" title="0">diskSizeGb := SafeInt64(0)
        if dVal, ok := m["disk_size_gb"]; ok </span><span class="cov0" title="0">{
                diskSizeGb = SafeInt64(dVal.(int))
        }</span>
        <span class="cov0" title="0">mp := &amp;models.V1EksMachinePoolConfigEntity{
                CloudConfig: &amp;models.V1EksMachineCloudConfigEntity{
                        RootDeviceSize: diskSizeGb,
                        InstanceType:   instanceType,
                        CapacityType:   &amp;capacityType,
                        Azs:            azs,
                        Subnets:        subnets,
                        AmiType:        amiType,
                },
                PoolConfig: &amp;models.V1MachinePoolConfigEntity{
                        AdditionalLabels:      toAdditionalNodePoolLabels(m),
                        AdditionalAnnotations: toAdditionalNodePoolAnnotations(m),
                        Taints:                toClusterTaints(m),
                        IsControlPlane:        controlPlane,
                        Labels:                labels,
                        Name:                  types.Ptr(m["name"].(string)),
                        Size:                  types.Ptr(SafeInt32(m["count"].(int))),
                        UpdateStrategy:        toUpdateStrategy(m),
                        MinSize:               min,
                        MaxSize:               max,
                },
        }

        // Handle override_kubeadm_configuration (worker pools only)
        if !controlPlane </span><span class="cov0" title="0">{
                if overrideKubeadm, ok := m["override_kubeadm_configuration"].(string); ok &amp;&amp; overrideKubeadm != "" </span><span class="cov0" title="0">{
                        mp.PoolConfig.OverrideKubeadmConfiguration = overrideKubeadm
                }</span>
        }

        <span class="cov0" title="0">if capacityType == "spot" </span><span class="cov0" title="0">{
                maxPrice := "0.0" // default value
                if m["max_price"] != nil &amp;&amp; len(m["max_price"].(string)) &gt; 0 </span><span class="cov0" title="0">{
                        maxPrice = m["max_price"].(string)
                }</span>

                <span class="cov0" title="0">mp.CloudConfig.SpotMarketOptions = &amp;models.V1SpotMarketOptions{
                        MaxPrice: maxPrice,
                }</span>
        }

        <span class="cov0" title="0">mp.CloudConfig.AwsLaunchTemplate = setEksLaunchTemplate(m)

        return mp</span>
}

func setEksLaunchTemplate(machinePool map[string]interface{}) *models.V1AwsLaunchTemplate <span class="cov0" title="0">{
        var launchTemplate *models.V1AwsLaunchTemplate

        if machinePool["eks_launch_template"] != nil </span><span class="cov0" title="0">{
                eksLaunchTemplateList := machinePool["eks_launch_template"].([]interface{})
                if len(eksLaunchTemplateList) == 0 </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov0" title="0">eksLaunchTemplate := eksLaunchTemplateList[0].(map[string]interface{})

                keys := []string{"ami_id", "root_volume_type", "root_volume_iops", "root_volume_throughput", "additional_security_groups"}

                // if at least one key is present continue function body, otherwise return launchTemplate
                if hasNoneOfKeys(eksLaunchTemplate, keys) </span><span class="cov0" title="0">{
                        return launchTemplate
                }</span>

                <span class="cov0" title="0">launchTemplate = &amp;models.V1AwsLaunchTemplate{
                        RootVolume: &amp;models.V1AwsRootVolume{},
                }

                if eksLaunchTemplate["ami_id"] != nil </span><span class="cov0" title="0">{
                        launchTemplate.Ami = &amp;models.V1AwsAmiReference{
                                ID: eksLaunchTemplate["ami_id"].(string),
                        }
                }</span>

                <span class="cov0" title="0">if eksLaunchTemplate["root_volume_type"] != nil </span><span class="cov0" title="0">{
                        launchTemplate.RootVolume.Type = eksLaunchTemplate["root_volume_type"].(string)
                }</span>

                <span class="cov0" title="0">if eksLaunchTemplate["root_volume_iops"] != nil </span><span class="cov0" title="0">{
                        launchTemplate.RootVolume.Iops = int64(eksLaunchTemplate["root_volume_iops"].(int))
                }</span>

                <span class="cov0" title="0">if eksLaunchTemplate["root_volume_throughput"] != nil </span><span class="cov0" title="0">{
                        launchTemplate.RootVolume.Throughput = int64(eksLaunchTemplate["root_volume_throughput"].(int))
                }</span>

                <span class="cov0" title="0">launchTemplate.AdditionalSecurityGroups = setAdditionalSecurityGroups(eksLaunchTemplate)</span>
        }

        <span class="cov0" title="0">return launchTemplate</span>
}

func setAdditionalSecurityGroups(eksLaunchTemplate map[string]interface{}) []*models.V1AwsResourceReference <span class="cov0" title="0">{
        if eksLaunchTemplate["additional_security_groups"] != nil </span><span class="cov0" title="0">{
                securityGroups := expandStringList(eksLaunchTemplate["additional_security_groups"].(*schema.Set).List())
                additionalSecurityGroups := make([]*models.V1AwsResourceReference, 0)
                for _, securityGroup := range securityGroups </span><span class="cov0" title="0">{
                        additionalSecurityGroups = append(additionalSecurityGroups, &amp;models.V1AwsResourceReference{
                                ID: securityGroup,
                        })
                }</span>
                <span class="cov0" title="0">return additionalSecurityGroups</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func hasNoneOfKeys(m map[string]interface{}, keys []string) bool <span class="cov0" title="0">{
        for _, key := range keys </span><span class="cov0" title="0">{
                if m[key] != nil </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov0" title="0">return true</span>
}

func toFargateProfileEks(fargateProfile interface{}) *models.V1FargateProfile <span class="cov0" title="0">{
        m := fargateProfile.(map[string]interface{})

        selectors := make([]*models.V1FargateSelector, 0)
        for _, val := range m["selector"].([]interface{}) </span><span class="cov0" title="0">{
                s := val.(map[string]interface{})

                selectors = append(selectors, &amp;models.V1FargateSelector{
                        Labels:    expandStringMap(s["labels"].(map[string]interface{})),
                        Namespace: types.Ptr(s["namespace"].(string)),
                })
        }</span>

        <span class="cov0" title="0">f := &amp;models.V1FargateProfile{
                Name:           types.Ptr(m["name"].(string)),
                AdditionalTags: expandStringMap(m["additional_tags"].(map[string]interface{})),
                Selectors:      selectors,
                SubnetIds:      expandStringList(m["subnets"].([]interface{})),
        }

        return f</span>
}

func toCloudConfigEks(cloudConfig map[string]interface{}) *models.V1EksCloudClusterConfigEntity <span class="cov0" title="0">{
        var encryptionConfig *models.V1EncryptionConfig
        if cloudConfig["encryption_config_arn"] != nil &amp;&amp; cloudConfig["encryption_config_arn"].(string) != "" </span><span class="cov0" title="0">{
                encryptionConfig = &amp;models.V1EncryptionConfig{
                        IsEnabled: true,
                        Provider:  cloudConfig["encryption_config_arn"].(string),
                }
        }</span>

        <span class="cov0" title="0">access := &amp;models.V1EksClusterConfigEndpointAccess{}
        switch cloudConfig["endpoint_access"].(string) </span>{
        case "public":<span class="cov0" title="0">
                access.Public = true
                access.Private = false</span>
        case "private":<span class="cov0" title="0">
                access.Public = false
                access.Private = true</span>
        case "private_and_public":<span class="cov0" title="0">
                access.Public = true
                access.Private = true</span>
        }

        <span class="cov0" title="0">if cloudConfig["public_access_cidrs"] != nil </span><span class="cov0" title="0">{
                cidrs := make([]string, 0)
                for _, cidr := range cloudConfig["public_access_cidrs"].(*schema.Set).List() </span><span class="cov0" title="0">{
                        cidrs = append(cidrs, cidr.(string))
                }</span>
                <span class="cov0" title="0">access.PublicCIDRs = cidrs</span>
        }

        <span class="cov0" title="0">if cloudConfig["private_access_cidrs"] != nil </span><span class="cov0" title="0">{
                cidrs := make([]string, 0)
                for _, cidr := range cloudConfig["private_access_cidrs"].(*schema.Set).List() </span><span class="cov0" title="0">{
                        cidrs = append(cidrs, cidr.(string))
                }</span>
                <span class="cov0" title="0">access.PrivateCIDRs = cidrs</span>
        }

        <span class="cov0" title="0">clusterConfigEntity := &amp;models.V1EksCloudClusterConfigEntity{
                ClusterConfig: &amp;models.V1EksClusterConfig{
                        BastionDisabled:  true,
                        VpcID:            cloudConfig["vpc_id"].(string),
                        Region:           types.Ptr(cloudConfig["region"].(string)),
                        SSHKeyName:       cloudConfig["ssh_key_name"].(string),
                        EncryptionConfig: encryptionConfig,
                        EndpointAccess:   access,
                },
        }

        return clusterConfigEntity</span>
}

func resourceClusterEksStateUpgradeV2(ctx context.Context, rawState map[string]interface{}, meta interface{}) (map[string]interface{}, error) <span class="cov0" title="0">{
        log.Printf("[DEBUG] Upgrading cluster custom cloud state from version 2 to 3")

        // Convert machine_pool from TypeList to TypeSet
        // Note: We keep the data as a list in rawState and let Terraform's schema processing
        // convert it to TypeSet during normal resource loading. This avoids JSON serialization
        // issues with schema.Set objects that contain hash functions.
        if machinePoolRaw, exists := rawState["machine_pool"]; exists </span><span class="cov0" title="0">{
                if machinePoolList, ok := machinePoolRaw.([]interface{}); ok </span><span class="cov0" title="0">{
                        log.Printf("[DEBUG] Keeping machine_pool as list during state upgrade with %d items", len(machinePoolList))

                        // Keep the machine pool data as-is (as a list)
                        // Terraform will convert it to TypeSet when loading the resource using the schema
                        rawState["machine_pool"] = machinePoolList

                        log.Printf("[DEBUG] Successfully prepared machine_pool for TypeSet conversion")
                }</span> else<span class="cov0" title="0"> {
                        log.Printf("[DEBUG] machine_pool is not a list, skipping conversion")
                }</span>
        } else<span class="cov0" title="0"> {
                log.Printf("[DEBUG] No machine_pool found in state, skipping conversion")
        }</span>

        <span class="cov0" title="0">return rawState, nil</span>
}
</pre>
		
		<pre class="file" id="file142" style="display: none">package spectrocloud

import (
        "context"
        "fmt"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
)

func resourceClusterEksImport(ctx context.Context, d *schema.ResourceData, m interface{}) ([]*schema.ResourceData, error) <span class="cov0" title="0">{
        c, err := GetCommonCluster(d, m)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">diags := resourceClusterEksRead(ctx, d, m)
        if diags.HasError() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("could not read cluster for import: %v", diags)
        }</span>

        // cluster profile and common default cluster attribute is get set here
        <span class="cov0" title="0">err = flattenCommonAttributeForClusterImport(c, d)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Return the resource data. In most cases, this method is only used to
        // import one resource at a time, so you should return the resource data
        // in a slice with a single element.
        <span class="cov0" title="0">return []*schema.ResourceData{d}, nil</span>
}
</pre>
		
		<pre class="file" id="file143" style="display: none">package spectrocloud

import (
        "context"
        "log"
        "time"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"

        "github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/schemas"
        "github.com/spectrocloud/terraform-provider-spectrocloud/types"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/spectrocloud/palette-sdk-go/api/models"
        "github.com/spectrocloud/palette-sdk-go/client"
)

func resourceClusterGcp() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                CreateContext: resourceClusterGcpCreate,
                ReadContext:   resourceClusterGcpRead,
                UpdateContext: resourceClusterGcpUpdate,
                DeleteContext: resourceClusterDelete,
                Importer: &amp;schema.ResourceImporter{
                        StateContext: resourceClusterGcpImport,
                },
                Description: "Resource for managing GCP clusters in Spectro Cloud through Palette.",

                Timeouts: &amp;schema.ResourceTimeout{
                        Create: schema.DefaultTimeout(60 * time.Minute),
                        Update: schema.DefaultTimeout(60 * time.Minute),
                        Delete: schema.DefaultTimeout(60 * time.Minute),
                },

                SchemaVersion: 2,
                Schema: map[string]*schema.Schema{
                        "name": {
                                Type:     schema.TypeString,
                                Required: true,
                                ForceNew: true,
                        },
                        "context": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "project",
                                ValidateFunc: validation.StringInSlice([]string{"", "project", "tenant"}, false),
                                Description: "The context of the GCP cluster. Allowed values are `project` or `tenant`. " +
                                        "Default is `project`. " + PROJECT_NAME_NUANCE,
                        },
                        "tags": {
                                Type:     schema.TypeSet,
                                Optional: true,
                                Set:      schema.HashString,
                                Elem: &amp;schema.Schema{
                                        Type: schema.TypeString,
                                },
                                Description: "A list of tags to be applied to the cluster. Tags must be in the form of `key:value`.",
                        },
                        "description": {
                                Type:        schema.TypeString,
                                Optional:    true,
                                Default:     "",
                                Description: "The description of the cluster. Default value is empty string.",
                        },
                        "cluster_meta_attribute": {
                                Type:        schema.TypeString,
                                Optional:    true,
                                Description: "`cluster_meta_attribute` can be used to set additional cluster metadata information, eg `{'nic_name': 'test', 'env': 'stage'}`",
                        },
                        "cluster_profile":  schemas.ClusterProfileSchema(),
                        "cluster_template": schemas.ClusterTemplateSchema(),
                        "apply_setting": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "DownloadAndInstall",
                                ValidateFunc: validation.StringInSlice([]string{"DownloadAndInstall", "DownloadAndInstallLater"}, false),
                                Description: "The setting to apply the cluster profile. `DownloadAndInstall` will download and install packs in one action. " +
                                        "`DownloadAndInstallLater` will only download artifact and postpone install for later. " +
                                        "Default value is `DownloadAndInstall`.",
                        },
                        "cloud_account_id": {
                                Type:     schema.TypeString,
                                Required: true,
                                ForceNew: true,
                        },
                        "cloud_config_id": {
                                Type:        schema.TypeString,
                                Computed:    true,
                                Description: "ID of the cloud config used for the cluster. This cloud config must be of type `azure`.",
                                Deprecated:  "This field is deprecated and will be removed in the future. Use `cloud_config` instead.",
                        },
                        "review_repave_state": {
                                Type:         schema.TypeString,
                                Default:      "",
                                Optional:     true,
                                ValidateFunc: validateReviewRepaveValue,
                                Description:  "To authorize the cluster repave, set the value to `Approved` for approval and `\"\"` to decline. Default value is `\"\"`.",
                        },
                        "pause_agent_upgrades": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "unlock",
                                ValidateFunc: validation.StringInSlice([]string{"lock", "unlock"}, false),
                                Description:  "The pause agent upgrades setting allows to control the automatic upgrade of the Palette component and agent for an individual cluster. The default value is `unlock`, meaning upgrades occur automatically. Setting it to `lock` pauses automatic agent upgrades for the cluster.",
                        },
                        "os_patch_on_boot": {
                                Type:        schema.TypeBool,
                                Optional:    true,
                                Default:     false,
                                Description: "Whether to apply OS patch on boot. Default is `false`.",
                        },
                        "os_patch_schedule": {
                                Type:             schema.TypeString,
                                Optional:         true,
                                ValidateDiagFunc: validateOsPatchSchedule,
                                Description:      "Cron schedule for OS patching. This must be in the form of `0 0 * * *`.",
                        },
                        "os_patch_after": {
                                Type:             schema.TypeString,
                                Optional:         true,
                                ValidateDiagFunc: validateOsPatchOnDemandAfter,
                                Description:      "Date and time after which to patch cluster `RFC3339: 2006-01-02T15:04:05Z07:00`",
                        },
                        "cluster_timezone": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "",
                                ValidateFunc: validateTimezone,
                                Description:  "Defines the time zone used by this cluster to interpret scheduled operations. Maintenance tasks like upgrades will follow this time zone to ensure they run at the appropriate local time for the cluster. Must be in IANA timezone format (e.g., 'America/New_York', 'Asia/Kolkata', 'Europe/London').",
                        },
                        "kubeconfig": {
                                Type:        schema.TypeString,
                                Computed:    true,
                                Description: "Kubeconfig for the cluster. This can be used to connect to the cluster using `kubectl`.",
                        },
                        "admin_kube_config": {
                                Type:        schema.TypeString,
                                Computed:    true,
                                Description: "Admin Kube-config for the cluster. This can be used to connect to the cluster using `kubectl`, With admin privilege.",
                        },
                        "cloud_config": {
                                Type:     schema.TypeList,
                                ForceNew: true,
                                Required: true,
                                MaxItems: 1,
                                Elem: &amp;schema.Resource{
                                        Schema: map[string]*schema.Schema{
                                                "network": {
                                                        Type:     schema.TypeString,
                                                        Optional: true,
                                                },
                                                "project": {
                                                        Type:     schema.TypeString,
                                                        Required: true,
                                                },
                                                "region": {
                                                        Type:     schema.TypeString,
                                                        Required: true,
                                                },
                                        },
                                },
                        },
                        "machine_pool": {
                                Type:     schema.TypeSet,
                                Required: true,
                                Set:      resourceMachinePoolGcpHash,
                                Elem: &amp;schema.Resource{
                                        Schema: map[string]*schema.Schema{
                                                "additional_labels": {
                                                        Type:     schema.TypeMap,
                                                        Optional: true,
                                                        Elem: &amp;schema.Schema{
                                                                Type: schema.TypeString,
                                                        },
                                                        Description: "Additional labels to be applied to the machine pool. Labels must be in the form of `key:value`.",
                                                },
                                                "additional_annotations": {
                                                        Type:     schema.TypeMap,
                                                        Optional: true,
                                                        Elem: &amp;schema.Schema{
                                                                Type: schema.TypeString,
                                                        },
                                                        Description: "Additional annotations to be applied to the machine pool. Annotations must be in the form of `key:value`.",
                                                },
                                                "node":   schemas.NodeSchema(),
                                                "taints": schemas.ClusterTaintsSchema(),
                                                "control_plane": {
                                                        Type:     schema.TypeBool,
                                                        Optional: true,
                                                        Default:  false,
                                                        //ForceNew: true,
                                                        Description: "Whether this machine pool is a control plane. Defaults to `false`.",
                                                },
                                                "control_plane_as_worker": {
                                                        Type:     schema.TypeBool,
                                                        Optional: true,
                                                        Default:  false,
                                                        //ForceNew: true,
                                                        Description: "Whether this machine pool is a control plane and a worker. Defaults to `false`.",
                                                },
                                                "name": {
                                                        Type:     schema.TypeString,
                                                        Required: true,
                                                        //ForceNew: true,
                                                },
                                                "count": {
                                                        Type:        schema.TypeInt,
                                                        Required:    true,
                                                        Description: "Number of nodes in the machine pool.",
                                                },
                                                "node_repave_interval": {
                                                        Type:        schema.TypeInt,
                                                        Optional:    true,
                                                        Default:     0,
                                                        Description: "Minimum number of seconds node should be Ready, before the next node is selected for repave. Default value is `0`, Applicable only for worker pools.",
                                                },
                                                "instance_type": {
                                                        Type:     schema.TypeString,
                                                        Required: true,
                                                },
                                                "update_strategy": {
                                                        Type:         schema.TypeString,
                                                        Optional:     true,
                                                        Default:      "RollingUpdateScaleOut",
                                                        Description:  "Update strategy for the machine pool. Valid values are `RollingUpdateScaleOut`, `RollingUpdateScaleIn` and `OverrideScaling`. If `OverrideScaling` is used, `override_scaling` must be specified with both `max_surge` and `max_unavailable`.",
                                                        ValidateFunc: validation.StringInSlice([]string{"RollingUpdateScaleOut", "RollingUpdateScaleIn", "OverrideScaling"}, false),
                                                },
                                                "override_scaling": schemas.OverrideScalingSchema(),
                                                "override_kubeadm_configuration": {
                                                        Type:        schema.TypeString,
                                                        Optional:    true,
                                                        Description: "YAML config for kubeletExtraArgs, preKubeadmCommands, postKubeadmCommands. Overrides pack-level settings. Worker pools only.",
                                                },
                                                "disk_size_gb": {
                                                        Type:     schema.TypeInt,
                                                        Optional: true,
                                                        Default:  65,
                                                },
                                                "azs": {
                                                        Type:     schema.TypeSet,
                                                        Required: true,
                                                        MinItems: 1,
                                                        Set:      schema.HashString,
                                                        Elem: &amp;schema.Schema{
                                                                Type: schema.TypeString,
                                                        },
                                                },
                                        },
                                },
                        },
                        "backup_policy":        schemas.BackupPolicySchema(),
                        "scan_policy":          schemas.ScanPolicySchema(),
                        "cluster_rbac_binding": schemas.ClusterRbacBindingSchema(),
                        "namespaces":           schemas.ClusterNamespacesSchema(),
                        "host_config":          schemas.ClusterHostConfigSchema(),
                        "location_config":      schemas.ClusterLocationSchemaComputed(),
                        "skip_completion": {
                                Type:        schema.TypeBool,
                                Optional:    true,
                                Default:     false,
                                Description: "If `true`, the cluster will be created asynchronously. Default value is `false`.",
                        },
                        "force_delete": {
                                Type:        schema.TypeBool,
                                Optional:    true,
                                Default:     false,
                                Description: "If set to `true`, the cluster will be force deleted and user has to manually clean up the provisioned cloud resources.",
                        },
                        "force_delete_delay": {
                                Type:             schema.TypeInt,
                                Optional:         true,
                                Default:          20,
                                Description:      "Delay duration in minutes to before invoking cluster force delete. Default and minimum is 20.",
                                ValidateDiagFunc: validation.ToDiagFunc(validation.IntAtLeast(20)),
                        },
                },
        }
}</span>

func resourceClusterGcpCreate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        resourceContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, resourceContext)

        // Warning or errors can be collected in a slice type
        var diags diag.Diagnostics

        // Validate override_Scaling configuration
        if err := validateOverrideScaling(d, "machine_pool"); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">cluster, err := toGcpCluster(c, d)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">uid, err := c.CreateClusterGcp(cluster)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">diagnostics, isError := waitForClusterCreation(ctx, d, uid, diags, c, true)
        if len(diagnostics) &gt; 0 </span><span class="cov0" title="0">{
                diags = append(diags, diagnostics...)
        }</span>
        <span class="cov0" title="0">if isError </span><span class="cov0" title="0">{
                return diagnostics
        }</span>

        <span class="cov0" title="0">resourceClusterGcpRead(ctx, d, m)

        return diags</span>
}

//goland:noinspection GoUnhandledErrorResult
func resourceClusterGcpRead(_ context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        resourceContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, resourceContext)

        var diags diag.Diagnostics

        cluster, err := resourceClusterRead(d, c, diags)
        if err != nil </span><span class="cov0" title="0">{
                return handleReadError(d, err, diags)
        }</span> else<span class="cov0" title="0"> if cluster == nil </span><span class="cov0" title="0">{
                // Deleted - Terraform will recreate it
                d.SetId("")
                return diags
        }</span>

        <span class="cov0" title="0">configUID := cluster.Spec.CloudConfigRef.UID
        if err := d.Set("cloud_config_id", configUID); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        // verify cluster type
        <span class="cov0" title="0">err = ValidateCloudType("spectrocloud_cluster_gcp", cluster)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">diagnostics, done := readCommonFields(c, d, cluster)
        if done </span><span class="cov0" title="0">{
                return diagnostics
        }</span>

        // Flatten cluster_template variables using variables API
        <span class="cov0" title="0">if err := flattenClusterTemplateVariables(c, d, d.Id()); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">return flattenCloudConfigGcp(cluster.Spec.CloudConfigRef.UID, d, c)</span>
}

func flattenCloudConfigGcp(configUID string, d *schema.ResourceData, c *client.V1Client) diag.Diagnostics <span class="cov0" title="0">{
        var diags diag.Diagnostics
        if err := d.Set("cloud_config_id", configUID); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">if config, err := c.GetCloudConfigGcp(configUID); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span> else<span class="cov0" title="0"> {
                if err := d.Set("cloud_account_id", config.Spec.CloudAccountRef.UID); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
                <span class="cov0" title="0">if err := d.Set("cloud_config", flattenClusterConfigsGcp(config)); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
                <span class="cov0" title="0">mp := flattenMachinePoolConfigsGcp(config.Spec.MachinePoolConfig)
                mp, err := flattenNodeMaintenanceStatus(c, d, c.GetNodeStatusMapGcp, mp, configUID)
                if err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
                <span class="cov0" title="0">if err := d.Set("machine_pool", mp); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
        }
        <span class="cov0" title="0">generalWarningForRepave(&amp;diags)
        return diags</span>
}

func flattenClusterConfigsGcp(config *models.V1GcpCloudConfig) []interface{} <span class="cov0" title="0">{
        if config == nil || config.Spec == nil || config.Spec.ClusterConfig == nil </span><span class="cov0" title="0">{
                return make([]interface{}, 0)
        }</span>
        <span class="cov0" title="0">m := make(map[string]interface{})

        if config.Spec.ClusterConfig.Project != nil </span><span class="cov0" title="0">{
                m["project"] = config.Spec.ClusterConfig.Project
        }</span>
        <span class="cov0" title="0">if config.Spec.ClusterConfig.Network != "" </span><span class="cov0" title="0">{
                m["network"] = config.Spec.ClusterConfig.Network
        }</span>
        <span class="cov0" title="0">if String(config.Spec.ClusterConfig.Region) != "" </span><span class="cov0" title="0">{
                m["region"] = String(config.Spec.ClusterConfig.Region)
        }</span>
        <span class="cov0" title="0">return []interface{}{m}</span>
}

func flattenMachinePoolConfigsGcp(machinePools []*models.V1GcpMachinePoolConfig) []interface{} <span class="cov0" title="0">{
        if machinePools == nil </span><span class="cov0" title="0">{
                return make([]interface{}, 0)
        }</span>

        <span class="cov0" title="0">ois := make([]interface{}, len(machinePools))

        for i, machinePool := range machinePools </span><span class="cov0" title="0">{
                oi := make(map[string]interface{})

                FlattenAdditionalLabelsAnnotationsAndTaints(machinePool.AdditionalLabels, machinePool.AdditionalAnnotations, machinePool.Taints, oi)
                FlattenControlPlaneAndRepaveInterval(machinePool.IsControlPlane, oi, machinePool.NodeRepaveInterval)

                oi["control_plane_as_worker"] = machinePool.UseControlPlaneAsWorker
                oi["name"] = machinePool.Name
                oi["count"] = int(machinePool.Size)
                if machinePool.UpdateStrategy != nil </span><span class="cov0" title="0">{
                        oi["update_strategy"] = machinePool.UpdateStrategy.Type
                        // Flatten override_Scaling if using OverrideScaling strategy
                        flattenOverrideScaling(machinePool.UpdateStrategy, oi)
                }</span>

                // Flatten override_kubeadm_configuration (worker pools only)
                <span class="cov0" title="0">if machinePool.IsControlPlane != nil &amp;&amp; !*machinePool.IsControlPlane &amp;&amp; machinePool.OverrideKubeadmConfiguration != "" </span><span class="cov0" title="0">{
                        oi["override_kubeadm_configuration"] = machinePool.OverrideKubeadmConfiguration
                }</span>

                <span class="cov0" title="0">oi["instance_type"] = *machinePool.InstanceType

                oi["disk_size_gb"] = int(machinePool.RootDeviceSize)

                oi["azs"] = machinePool.Azs
                ois[i] = oi</span>
        }

        <span class="cov0" title="0">return ois</span>
}

func resourceClusterGcpUpdate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        resourceContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, resourceContext)

        // Warning or errors can be collected in a slice type
        var diags diag.Diagnostics
        err := validateSystemRepaveApproval(d, c)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">cloudConfigId := d.Get("cloud_config_id").(string)
        CloudConfig, err := c.GetCloudConfigGcp(cloudConfigId)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">if d.HasChange("machine_pool") </span><span class="cov0" title="0">{
                // Validate override_Scaling configuration
                if err := validateOverrideScaling(d, "machine_pool"); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>

                <span class="cov0" title="0">oraw, nraw := d.GetChange("machine_pool")
                if oraw == nil </span><span class="cov0" title="0">{
                        oraw = new(schema.Set)
                }</span>
                <span class="cov0" title="0">if nraw == nil </span><span class="cov0" title="0">{
                        nraw = new(schema.Set)
                }</span>

                <span class="cov0" title="0">os := oraw.(*schema.Set)
                ns := nraw.(*schema.Set)

                osMap := make(map[string]interface{})
                for _, mp := range os.List() </span><span class="cov0" title="0">{
                        machinePool := mp.(map[string]interface{})
                        osMap[machinePool["name"].(string)] = machinePool
                }</span>
                <span class="cov0" title="0">nsMap := make(map[string]interface{})
                for _, mp := range ns.List() </span><span class="cov0" title="0">{
                        machinePoolResource := mp.(map[string]interface{})
                        nsMap[machinePoolResource["name"].(string)] = machinePoolResource
                        // since known issue in TF SDK: https://github.com/hashicorp/terraform-plugin-sdk/issues/588
                        if machinePoolResource["name"].(string) != "" </span><span class="cov0" title="0">{
                                name := machinePoolResource["name"].(string)
                                hash := resourceMachinePoolGcpHash(machinePoolResource)
                                var err error
                                machinePool, err := toMachinePoolGcp(machinePoolResource)
                                if err != nil </span><span class="cov0" title="0">{
                                        return diag.FromErr(err)
                                }</span>

                                <span class="cov0" title="0">if oldMachinePool, ok := osMap[name]; !ok </span><span class="cov0" title="0">{
                                        log.Printf("Create machine pool %s", name)
                                        err = c.CreateMachinePoolGcp(cloudConfigId, machinePool)
                                }</span> else<span class="cov0" title="0"> if hash != resourceMachinePoolGcpHash(oldMachinePool) </span><span class="cov0" title="0">{
                                        log.Printf("Change in machine pool %s", name)
                                        err = c.UpdateMachinePoolGcp(cloudConfigId, machinePool)
                                        // Node Maintenance Actions
                                        err := resourceNodeAction(c, ctx, nsMap[name], c.GetNodeMaintenanceStatusGcp, CloudConfig.Kind, cloudConfigId, name)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return diag.FromErr(err)
                                        }</span>
                                }

                                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                                        return diag.FromErr(err)
                                }</span>

                                // Processed (if exists)
                                <span class="cov0" title="0">delete(osMap, name)</span>
                        }
                }

                // Deleted old machine pools
                <span class="cov0" title="0">for _, mp := range osMap </span><span class="cov0" title="0">{
                        machinePool := mp.(map[string]interface{})
                        name := machinePool["name"].(string)
                        log.Printf("Deleted machine pool %s", name)
                        if err := c.DeleteMachinePoolGcp(cloudConfigId, name); err != nil </span><span class="cov0" title="0">{
                                return diag.FromErr(err)
                        }</span>
                }
        }

        <span class="cov0" title="0">diagnostics, done := updateCommonFields(d, c)
        if done </span><span class="cov0" title="0">{
                return diagnostics
        }</span>

        <span class="cov0" title="0">resourceClusterGcpRead(ctx, d, m)

        return diags</span>
}

func toGcpCluster(c *client.V1Client, d *schema.ResourceData) (*models.V1SpectroGcpClusterEntity, error) <span class="cov0" title="0">{
        // gnarly, I know! =/
        cloudConfig := d.Get("cloud_config").([]interface{})[0].(map[string]interface{})
        //clientSecret := strfmt.Password(d.Get("gcp_client_secret").(string))

        clusterContext := d.Get("context").(string)
        profiles, err := toProfiles(c, d, clusterContext)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">cluster := &amp;models.V1SpectroGcpClusterEntity{
                Metadata: getClusterMetadata(d),
                Spec: &amp;models.V1SpectroGcpClusterEntitySpec{
                        CloudAccountUID: types.Ptr(d.Get("cloud_account_id").(string)),
                        Profiles:        profiles,
                        ClusterTemplate: toClusterTemplateReference(d),
                        Policies:        toPolicies(d),
                        CloudConfig: &amp;models.V1GcpClusterConfig{
                                Network: cloudConfig["network"].(string),
                                Project: types.Ptr(cloudConfig["project"].(string)),
                                Region:  types.Ptr(cloudConfig["region"].(string)),
                        },
                },
        }

        machinePoolConfigs := make([]*models.V1GcpMachinePoolConfigEntity, 0)
        for _, machinePool := range d.Get("machine_pool").(*schema.Set).List() </span><span class="cov0" title="0">{
                mp, err := toMachinePoolGcp(machinePool)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">machinePoolConfigs = append(machinePoolConfigs, mp)</span>
        }

        <span class="cov0" title="0">cluster.Spec.Machinepoolconfig = machinePoolConfigs
        cluster.Spec.ClusterConfig = toClusterConfig(d)

        return cluster, nil</span>
}

func toMachinePoolGcp(machinePool interface{}) (*models.V1GcpMachinePoolConfigEntity, error) <span class="cov0" title="0">{
        m := machinePool.(map[string]interface{})

        labels := make([]string, 0)
        controlPlane := m["control_plane"].(bool)
        controlPlaneAsWorker := m["control_plane_as_worker"].(bool)
        if controlPlane </span><span class="cov0" title="0">{
                labels = append(labels, "control-plane")
        }</span> else<span class="cov0" title="0"> {
                labels = append(labels, "worker")
        }</span>

        <span class="cov0" title="0">azs := make([]string, 0)
        for _, az := range m["azs"].(*schema.Set).List() </span><span class="cov0" title="0">{
                azs = append(azs, az.(string))
        }</span>

        <span class="cov0" title="0">mp := &amp;models.V1GcpMachinePoolConfigEntity{
                CloudConfig: &amp;models.V1GcpMachinePoolCloudConfigEntity{
                        Azs:            azs,
                        InstanceType:   types.Ptr(m["instance_type"].(string)),
                        RootDeviceSize: SafeInt64(m["disk_size_gb"].(int)),
                },
                PoolConfig: &amp;models.V1MachinePoolConfigEntity{
                        AdditionalLabels:        toAdditionalNodePoolLabels(m),
                        AdditionalAnnotations:   toAdditionalNodePoolAnnotations(m),
                        Taints:                  toClusterTaints(m),
                        IsControlPlane:          controlPlane,
                        Labels:                  labels,
                        Name:                    types.Ptr(m["name"].(string)),
                        Size:                    types.Ptr(SafeInt32(m["count"].(int))),
                        UpdateStrategy:          toUpdateStrategy(m),
                        UseControlPlaneAsWorker: controlPlaneAsWorker,
                },
        }

        // Handle override_kubeadm_configuration (worker pools only)
        if !controlPlane </span><span class="cov0" title="0">{
                if overrideKubeadm, ok := m["override_kubeadm_configuration"].(string); ok &amp;&amp; overrideKubeadm != "" </span><span class="cov0" title="0">{
                        mp.PoolConfig.OverrideKubeadmConfiguration = overrideKubeadm
                }</span>
        }

        <span class="cov0" title="0">if !controlPlane </span><span class="cov0" title="0">{
                nodeRepaveInterval := 0
                if m["node_repave_interval"] != nil </span><span class="cov0" title="0">{
                        nodeRepaveInterval = m["node_repave_interval"].(int)
                }</span>
                <span class="cov0" title="0">mp.PoolConfig.NodeRepaveInterval = SafeInt32(nodeRepaveInterval)</span>
        } else<span class="cov0" title="0"> {
                err := ValidationNodeRepaveIntervalForControlPlane(m["node_repave_interval"].(int))
                if err != nil </span><span class="cov0" title="0">{
                        return mp, err
                }</span>
        }

        <span class="cov0" title="0">return mp, nil</span>
}
</pre>
		
		<pre class="file" id="file144" style="display: none">package spectrocloud

import (
        "context"
        "fmt"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
)

func resourceClusterGcpImport(ctx context.Context, d *schema.ResourceData, m interface{}) ([]*schema.ResourceData, error) <span class="cov0" title="0">{
        c, err := GetCommonCluster(d, m)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">diags := resourceClusterGcpRead(ctx, d, m)
        if diags.HasError() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("could not read cluster for import: %v", diags)
        }</span>

        // cluster profile and common default cluster attribute is get set here
        <span class="cov0" title="0">err = flattenCommonAttributeForClusterImport(c, d)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Return the resource data. In most cases, this method is only used to
        // import one resource at a time, so you should return the resource data
        // in a slice with a single element.
        <span class="cov0" title="0">return []*schema.ResourceData{d}, nil</span>
}
</pre>
		
		<pre class="file" id="file145" style="display: none">package spectrocloud

import (
        "context"
        "log"
        "time"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
        "github.com/spectrocloud/palette-sdk-go/api/models"
        "github.com/spectrocloud/palette-sdk-go/client"
        "github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/schemas"
        "github.com/spectrocloud/terraform-provider-spectrocloud/types"
)

func resourceClusterGke() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                CreateContext: resourceClusterGkeCreate,
                ReadContext:   resourceClusterGkeRead,
                UpdateContext: resourceClusterGkeUpdate,
                DeleteContext: resourceClusterDelete,
                Importer: &amp;schema.ResourceImporter{
                        StateContext: resourceClusterGkeImport,
                },
                Description: "Resource for managing GKE clusters through Palette.",

                Timeouts: &amp;schema.ResourceTimeout{
                        Create: schema.DefaultTimeout(60 * time.Minute),
                        Update: schema.DefaultTimeout(60 * time.Minute),
                        Delete: schema.DefaultTimeout(60 * time.Minute),
                },

                SchemaVersion: 2,
                StateUpgraders: []schema.StateUpgrader{
                        {
                                Type:    resourceClusterGkeResourceV1().CoreConfigSchema().ImpliedType(),
                                Upgrade: resourceClusterGkeStateUpgradeV1,
                                Version: 1,
                        },
                },
                Schema: map[string]*schema.Schema{
                        "name": {
                                Type:        schema.TypeString,
                                Required:    true,
                                ForceNew:    true,
                                Description: "The name of the cluster.",
                        },
                        "context": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "project",
                                ValidateFunc: validation.StringInSlice([]string{"", "project", "tenant"}, false),
                                Description: "The context of the GKE cluster. Allowed values are `project` or `tenant`. " +
                                        "Default is `project`. " + PROJECT_NAME_NUANCE,
                        },
                        "description": {
                                Type:        schema.TypeString,
                                Optional:    true,
                                Default:     "",
                                Description: "The description of the cluster. Default value is empty string.",
                        },
                        "tags": {
                                Type:     schema.TypeSet,
                                Optional: true,
                                Set:      schema.HashString,
                                Elem: &amp;schema.Schema{
                                        Type: schema.TypeString,
                                },
                                Description: "A list of tags to be applied to the cluster. Tags must be in the form of `key:value`.",
                        },
                        "cluster_meta_attribute": {
                                Type:        schema.TypeString,
                                Optional:    true,
                                Description: "`cluster_meta_attribute` can be used to set additional cluster metadata information, eg `{'nic_name': 'test', 'env': 'stage'}`",
                        },
                        "cluster_profile":  schemas.ClusterProfileSchema(),
                        "cluster_template": schemas.ClusterTemplateSchema(),
                        "apply_setting": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "DownloadAndInstall",
                                ValidateFunc: validation.StringInSlice([]string{"DownloadAndInstall", "DownloadAndInstallLater"}, false),
                                Description: "The setting to apply the cluster profile. `DownloadAndInstall` will download and install packs in one action. " +
                                        "`DownloadAndInstallLater` will only download artifact and postpone install for later. " +
                                        "Default value is `DownloadAndInstall`.",
                        },
                        "cloud_account_id": {
                                Type:     schema.TypeString,
                                Required: true,
                                ForceNew: true,
                        },
                        "cloud_config_id": {
                                Type:        schema.TypeString,
                                Computed:    true,
                                Description: "ID of the cloud config used for the cluster. This cloud config must be of type `azure`.",
                                Deprecated:  "This field is deprecated and will be removed in the future. Use `cloud_config` instead.",
                        },

                        "cloud_config": {
                                Type:        schema.TypeList,
                                ForceNew:    true,
                                Required:    true,
                                MaxItems:    1,
                                Description: "The GKE environment configuration settings such as project parameters and region parameters that apply to this cluster.",
                                Elem: &amp;schema.Resource{
                                        Schema: map[string]*schema.Schema{
                                                "project": {
                                                        Type:        schema.TypeString,
                                                        ForceNew:    true,
                                                        Required:    true,
                                                        Description: "GCP project name.",
                                                },
                                                "region": {
                                                        Type:     schema.TypeString,
                                                        ForceNew: true,
                                                        Required: true,
                                                },
                                        },
                                },
                        },
                        "update_worker_pool_in_parallel": {
                                Type:     schema.TypeBool,
                                Optional: true,
                                Default:  true,
                        },
                        "cluster_timezone": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "",
                                ValidateFunc: validateTimezone,
                                Description:  "Defines the time zone used by this cluster to interpret scheduled operations. Maintenance tasks like upgrades will follow this time zone to ensure they run at the appropriate local time for the cluster. Must be in IANA timezone format (e.g., 'America/New_York', 'Asia/Kolkata', 'Europe/London').",
                        },
                        "machine_pool": {
                                Type:        schema.TypeSet,
                                Required:    true,
                                Set:         resourceMachinePoolGkeHash,
                                Description: "The machine pool configuration for the cluster.",
                                Elem: &amp;schema.Resource{
                                        Schema: map[string]*schema.Schema{
                                                "name": {
                                                        Type:     schema.TypeString,
                                                        Required: true,
                                                },
                                                "count": {
                                                        Type:        schema.TypeInt,
                                                        Required:    true,
                                                        Description: "Number of nodes in the machine pool.",
                                                },
                                                "disk_size_gb": {
                                                        Type:     schema.TypeInt,
                                                        Optional: true,
                                                        Default:  60,
                                                },
                                                "additional_labels": {
                                                        Type:     schema.TypeMap,
                                                        Optional: true,
                                                        Elem: &amp;schema.Schema{
                                                                Type: schema.TypeString,
                                                        },
                                                        Description: "Additional labels to be applied to the machine pool. Labels must be in the form of `key:value`.",
                                                },
                                                "additional_annotations": {
                                                        Type:     schema.TypeMap,
                                                        Optional: true,
                                                        Elem: &amp;schema.Schema{
                                                                Type: schema.TypeString,
                                                        },
                                                        Description: "Additional annotations to be applied to the machine pool. Annotations must be in the form of `key:value`.",
                                                },
                                                "instance_type": {
                                                        Type:     schema.TypeString,
                                                        Required: true,
                                                },
                                                "update_strategy": {
                                                        Type:         schema.TypeString,
                                                        Optional:     true,
                                                        Default:      "RollingUpdateScaleOut",
                                                        Description:  "Update strategy for the machine pool. Valid values are `RollingUpdateScaleOut`, `RollingUpdateScaleIn` and `OverrideScaling`. If `OverrideScaling` is used, `override_scaling` must be specified with both `max_surge` and `max_unavailable`.",
                                                        ValidateFunc: validation.StringInSlice([]string{"RollingUpdateScaleOut", "RollingUpdateScaleIn", "OverrideScaling"}, false),
                                                },
                                                "override_scaling": schemas.OverrideScalingSchema(),
                                                "override_kubeadm_configuration": {
                                                        Type:        schema.TypeString,
                                                        Optional:    true,
                                                        Description: "YAML config for kubeletExtraArgs, preKubeadmCommands, postKubeadmCommands. Overrides pack-level settings. Worker pools only.",
                                                },
                                                "node":   schemas.NodeSchema(),
                                                "taints": schemas.ClusterTaintsSchema(),
                                        },
                                },
                        },
                        "pause_agent_upgrades": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "unlock",
                                ValidateFunc: validation.StringInSlice([]string{"lock", "unlock"}, false),
                                Description:  "The pause agent upgrades setting allows to control the automatic upgrade of the Palette component and agent for an individual cluster. The default value is `unlock`, meaning upgrades occur automatically. Setting it to `lock` pauses automatic agent upgrades for the cluster.",
                        },
                        "review_repave_state": {
                                Type:         schema.TypeString,
                                Default:      "",
                                Optional:     true,
                                ValidateFunc: validation.StringInSlice([]string{"", "Approved", "Pending"}, false),
                                Description:  "To authorize the cluster repave, set the value to `Approved` for approval and `\"\"` to decline. Default value is `\"\"`.",
                        },
                        "os_patch_on_boot": {
                                Type:        schema.TypeBool,
                                Optional:    true,
                                Default:     false,
                                Description: "Whether to apply OS patch on boot. Default is `false`.",
                        },
                        "os_patch_schedule": {
                                Type:             schema.TypeString,
                                Optional:         true,
                                ValidateDiagFunc: validateOsPatchSchedule,
                                Description:      "Cron schedule for OS patching. This must be in the form of `0 0 * * *`.",
                        },
                        "os_patch_after": {
                                Type:             schema.TypeString,
                                Optional:         true,
                                ValidateDiagFunc: validateOsPatchOnDemandAfter,
                                Description:      "Date and time after which to patch cluster `RFC3339: 2006-01-02T15:04:05Z07:00`",
                        },
                        "kubeconfig": {
                                Type:        schema.TypeString,
                                Computed:    true,
                                Description: "Kubeconfig for the cluster. This can be used to connect to the cluster using `kubectl`.",
                        },
                        "admin_kube_config": {
                                Type:        schema.TypeString,
                                Computed:    true,
                                Description: "Admin Kube-config for the cluster. This can be used to connect to the cluster using `kubectl`, With admin privilege.",
                        },
                        "backup_policy":        schemas.BackupPolicySchema(),
                        "scan_policy":          schemas.ScanPolicySchema(),
                        "cluster_rbac_binding": schemas.ClusterRbacBindingSchema(),
                        "namespaces":           schemas.ClusterNamespacesSchema(),
                        "host_config":          schemas.ClusterHostConfigSchema(),
                        "location_config":      schemas.ClusterLocationSchemaComputed(),
                        "skip_completion": {
                                Type:        schema.TypeBool,
                                Optional:    true,
                                Default:     false,
                                Description: "If `true`, the cluster will be created asynchronously. Default value is `false`.",
                        },
                        "force_delete": {
                                Type:        schema.TypeBool,
                                Optional:    true,
                                Default:     false,
                                Description: "If set to `true`, the cluster will be force deleted and user has to manually clean up the provisioned cloud resources.",
                        },
                        "force_delete_delay": {
                                Type:             schema.TypeInt,
                                Optional:         true,
                                Default:          20,
                                Description:      "Delay duration in minutes to before invoking cluster force delete. Default and minimum is 20.",
                                ValidateDiagFunc: validation.ToDiagFunc(validation.IntAtLeast(20)),
                        },
                },
        }
}</span>

func resourceClusterGkeCreate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        resourceContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, resourceContext)

        // Warning or errors can be collected in a slice type
        var diags diag.Diagnostics

        // Validate override_Scaling configuration
        if err := validateOverrideScaling(d, "machine_pool"); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">cluster, err := toGkeCluster(c, d)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">uid, err := c.CreateClusterGke(cluster)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">diagnostics, isError := waitForClusterCreation(ctx, d, uid, diags, c, true)
        if len(diagnostics) &gt; 0 </span><span class="cov0" title="0">{
                diags = append(diags, diagnostics...)
        }</span>
        <span class="cov0" title="0">if isError </span><span class="cov0" title="0">{
                return diagnostics
        }</span>
        <span class="cov0" title="0">resourceClusterGkeRead(ctx, d, m)
        return diags</span>
}

func resourceClusterGkeRead(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        resourceContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, resourceContext)

        var diags diag.Diagnostics
        cluster, err := resourceClusterRead(d, c, diags)
        if err != nil </span><span class="cov0" title="0">{
                return handleReadError(d, err, diags)
        }</span> else<span class="cov0" title="0"> if cluster == nil </span><span class="cov0" title="0">{
                // Deleted - Terraform will recreate it
                d.SetId("")
                return diags
        }</span>

        <span class="cov0" title="0">configUID := cluster.Spec.CloudConfigRef.UID
        if err := d.Set("cloud_config_id", configUID); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        // verify cluster type
        <span class="cov0" title="0">err = ValidateCloudType("spectrocloud_cluster_gke", cluster)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">diagnostics, done := readCommonFields(c, d, cluster)
        if done </span><span class="cov0" title="0">{
                return diagnostics
        }</span>

        // Flatten cluster_template variables using variables API
        <span class="cov0" title="0">if err := flattenClusterTemplateVariables(c, d, d.Id()); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">return flattenCloudConfigGke(cluster.Spec.CloudConfigRef.UID, d, c)</span>
}

func resourceClusterGkeUpdate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        resourceContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, resourceContext)

        var diags diag.Diagnostics
        err := validateSystemRepaveApproval(d, c)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">cloudConfigId := d.Get("cloud_config_id").(string)

        CloudConfig, err := c.GetCloudConfigGke(cloudConfigId)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">if d.HasChange("machine_pool") </span><span class="cov0" title="0">{
                // Validate override_Scaling configuration
                if err := validateOverrideScaling(d, "machine_pool"); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>

                <span class="cov0" title="0">log.Printf("[DEBUG] === MACHINE POOL CHANGE DETECTED ===")
                oraw, nraw := d.GetChange("machine_pool")
                if oraw == nil </span><span class="cov0" title="0">{
                        oraw = new(schema.Set)
                }</span>
                <span class="cov0" title="0">if nraw == nil </span><span class="cov0" title="0">{
                        nraw = new(schema.Set)
                }</span>

                <span class="cov0" title="0">os := oraw.(*schema.Set)
                ns := nraw.(*schema.Set)

                log.Printf("[DEBUG] Old machine pools count: %d, New machine pools count: %d", os.Len(), ns.Len())

                // Create maps by machine pool name for proper comparison
                osMap := make(map[string]interface{})
                for _, mp := range os.List() </span><span class="cov0" title="0">{
                        machinePoolResource := mp.(map[string]interface{})
                        name := machinePoolResource["name"].(string)
                        if name != "" </span><span class="cov0" title="0">{
                                osMap[name] = machinePoolResource
                        }</span>
                }

                <span class="cov0" title="0">nsMap := make(map[string]interface{})
                for _, mp := range ns.List() </span><span class="cov0" title="0">{
                        machinePoolResource := mp.(map[string]interface{})
                        name := machinePoolResource["name"].(string)
                        if name != "" </span><span class="cov0" title="0">{
                                nsMap[name] = machinePoolResource

                                // Check if this is a new, updated, or unchanged machine pool
                                if oldMachinePool, exists := osMap[name]; !exists </span><span class="cov0" title="0">{
                                        // NEW machine pool - CREATE
                                        log.Printf("[DEBUG] Creating new machine pool %s", name)
                                        machinePool, err := toMachinePoolGke(machinePoolResource)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return diag.FromErr(err)
                                        }</span>
                                        <span class="cov0" title="0">if err := c.CreateMachinePoolGke(cloudConfigId, machinePool); err != nil </span><span class="cov0" title="0">{
                                                return diag.FromErr(err)
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        // EXISTING machine pool - check if hash changed
                                        oldHash := resourceMachinePoolGkeHash(oldMachinePool)
                                        newHash := resourceMachinePoolGkeHash(machinePoolResource)

                                        if oldHash != newHash </span><span class="cov0" title="0">{
                                                // MODIFIED machine pool - UPDATE
                                                log.Printf("[DEBUG] Updating machine pool %s (hash changed: %d -&gt; %d)", name, oldHash, newHash)
                                                machinePool, err := toMachinePoolGke(machinePoolResource)
                                                if err != nil </span><span class="cov0" title="0">{
                                                        return diag.FromErr(err)
                                                }</span>
                                                <span class="cov0" title="0">if err := c.UpdateMachinePoolGke(cloudConfigId, machinePool); err != nil </span><span class="cov0" title="0">{
                                                        return diag.FromErr(err)
                                                }</span>
                                                // Node Maintenance Actions
                                                <span class="cov0" title="0">err = resourceNodeAction(c, ctx, machinePoolResource, c.GetNodeMaintenanceStatusGke, CloudConfig.Kind, cloudConfigId, name)
                                                if err != nil </span><span class="cov0" title="0">{
                                                        return diag.FromErr(err)
                                                }</span>
                                        } else<span class="cov0" title="0"> {
                                                // UNCHANGED machine pool - no action needed
                                                log.Printf("[DEBUG] Machine pool %s unchanged (hash: %d)", name, oldHash)
                                        }</span>
                                }

                                // Mark as processed
                                <span class="cov0" title="0">delete(osMap, name)</span>
                        } else<span class="cov0" title="0"> {
                                log.Printf("[DEBUG] WARNING: Machine pool has empty name!")
                        }</span>
                }

                // REMOVED machine pools - DELETE
                <span class="cov0" title="0">for name := range osMap </span><span class="cov0" title="0">{
                        log.Printf("[DEBUG] Deleting removed machine pool %s", name)
                        if err := c.DeleteMachinePoolGke(cloudConfigId, name); err != nil </span><span class="cov0" title="0">{
                                return diag.FromErr(err)
                        }</span>
                }
        }
        <span class="cov0" title="0">diagnostics, done := updateCommonFields(d, c)
        if done </span><span class="cov0" title="0">{
                return diagnostics
        }</span>

        <span class="cov0" title="0">resourceClusterGkeRead(ctx, d, m)

        return diags</span>
}

func flattenCloudConfigGke(configUID string, d *schema.ResourceData, c *client.V1Client) diag.Diagnostics <span class="cov0" title="0">{
        var diags diag.Diagnostics
        if err := d.Set("cloud_config_id", configUID); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">if config, err := c.GetCloudConfigGke(configUID); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span> else<span class="cov0" title="0"> {
                if err := d.Set("cloud_account_id", config.Spec.CloudAccountRef.UID); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
                <span class="cov0" title="0">if err := d.Set("cloud_config", flattenClusterConfigsGke(config)); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
                <span class="cov0" title="0">mp := flattenMachinePoolConfigsGke(config.Spec.MachinePoolConfig)
                mp, err := flattenNodeMaintenanceStatus(c, d, c.GetNodeStatusMapGke, mp, configUID)
                if err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>

                <span class="cov0" title="0">if err := d.Set("machine_pool", mp); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
        }

        <span class="cov0" title="0">generalWarningForRepave(&amp;diags)
        return diags</span>
}

func flattenClusterConfigsGke(config *models.V1GcpCloudConfig) []interface{} <span class="cov0" title="0">{
        if config == nil || config.Spec == nil || config.Spec.ClusterConfig == nil </span><span class="cov0" title="0">{
                return make([]interface{}, 0)
        }</span>
        <span class="cov0" title="0">m := make(map[string]interface{})

        if config.Spec.ClusterConfig.Project != nil </span><span class="cov0" title="0">{
                m["project"] = config.Spec.ClusterConfig.Project
        }</span>
        <span class="cov0" title="0">if String(config.Spec.ClusterConfig.Region) != "" </span><span class="cov0" title="0">{
                m["region"] = String(config.Spec.ClusterConfig.Region)
        }</span>
        <span class="cov0" title="0">return []interface{}{m}</span>
}

func flattenMachinePoolConfigsGke(machinePools []*models.V1GcpMachinePoolConfig) []interface{} <span class="cov0" title="0">{
        if machinePools == nil </span><span class="cov0" title="0">{
                return make([]interface{}, 0)
        }</span>

        <span class="cov0" title="0">ois := make([]interface{}, len(machinePools))

        for i, machinePool := range machinePools </span><span class="cov0" title="0">{
                oi := make(map[string]interface{})

                FlattenAdditionalLabelsAnnotationsAndTaints(machinePool.AdditionalLabels, machinePool.AdditionalAnnotations, machinePool.Taints, oi)
                oi["name"] = machinePool.Name
                oi["count"] = int(machinePool.Size)
                if machinePool.UpdateStrategy != nil </span><span class="cov0" title="0">{
                        oi["update_strategy"] = machinePool.UpdateStrategy.Type
                        // Flatten override_Scaling if using OverrideScaling strategy
                        flattenOverrideScaling(machinePool.UpdateStrategy, oi)
                }</span>

                // Flatten override_kubeadm_configuration (worker pools only)
                <span class="cov0" title="0">if machinePool.IsControlPlane != nil &amp;&amp; !*machinePool.IsControlPlane &amp;&amp; machinePool.OverrideKubeadmConfiguration != "" </span><span class="cov0" title="0">{
                        oi["override_kubeadm_configuration"] = machinePool.OverrideKubeadmConfiguration
                }</span>

                <span class="cov0" title="0">oi["instance_type"] = *machinePool.InstanceType

                oi["disk_size_gb"] = int(machinePool.RootDeviceSize)
                ois[i] = oi</span>
        }

        <span class="cov0" title="0">return ois</span>
}

func toGkeCluster(c *client.V1Client, d *schema.ResourceData) (*models.V1SpectroGcpClusterEntity, error) <span class="cov0" title="0">{
        cloudConfig := d.Get("cloud_config").([]interface{})[0].(map[string]interface{})

        clusterContext := d.Get("context").(string)
        profiles, err := toProfiles(c, d, clusterContext)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">cluster := &amp;models.V1SpectroGcpClusterEntity{
                Metadata: getClusterMetadata(d),
                Spec: &amp;models.V1SpectroGcpClusterEntitySpec{
                        CloudAccountUID: types.Ptr(d.Get("cloud_account_id").(string)),
                        Profiles:        profiles,
                        ClusterTemplate: toClusterTemplateReference(d),
                        Policies:        toPolicies(d),
                        CloudConfig: &amp;models.V1GcpClusterConfig{
                                Project: types.Ptr(cloudConfig["project"].(string)),
                                Region:  types.Ptr(cloudConfig["region"].(string)),
                                ManagedClusterConfig: &amp;models.V1GcpManagedClusterConfig{
                                        Location: cloudConfig["region"].(string),
                                },
                        },
                },
        }

        machinePoolConfigs := make([]*models.V1GcpMachinePoolConfigEntity, 0)
        for _, machinePool := range d.Get("machine_pool").(*schema.Set).List() </span><span class="cov0" title="0">{
                mp, err := toMachinePoolGke(machinePool)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">machinePoolConfigs = append(machinePoolConfigs, mp)</span>
        }
        <span class="cov0" title="0">cluster.Spec.Machinepoolconfig = machinePoolConfigs
        cluster.Spec.ClusterConfig = toClusterConfig(d)
        return cluster, err</span>
}

func toMachinePoolGke(machinePool interface{}) (*models.V1GcpMachinePoolConfigEntity, error) <span class="cov0" title="0">{
        m := machinePool.(map[string]interface{})

        mp := &amp;models.V1GcpMachinePoolConfigEntity{
                CloudConfig: &amp;models.V1GcpMachinePoolCloudConfigEntity{
                        InstanceType:   types.Ptr(m["instance_type"].(string)),
                        RootDeviceSize: SafeInt64(m["disk_size_gb"].(int)),
                },
                PoolConfig: &amp;models.V1MachinePoolConfigEntity{
                        AdditionalLabels:      toAdditionalNodePoolLabels(m),
                        AdditionalAnnotations: toAdditionalNodePoolAnnotations(m),
                        Taints:                toClusterTaints(m),
                        Name:                  types.Ptr(m["name"].(string)),
                        Size:                  types.Ptr(SafeInt32(m["count"].(int))),
                        UpdateStrategy:        toUpdateStrategy(m),
                },
        }
        if !mp.PoolConfig.IsControlPlane </span><span class="cov0" title="0">{
                mp.PoolConfig.Labels = []string{"worker"}
                // Handle override_kubeadm_configuration (worker pools only)
                if overrideKubeadm, ok := m["override_kubeadm_configuration"].(string); ok &amp;&amp; overrideKubeadm != "" </span><span class="cov0" title="0">{
                        mp.PoolConfig.OverrideKubeadmConfiguration = overrideKubeadm
                }</span>
        }
        <span class="cov0" title="0">return mp, nil</span>
}

func resourceClusterGkeStateUpgradeV1(ctx context.Context, rawState map[string]interface{}, meta interface{}) (map[string]interface{}, error) <span class="cov0" title="0">{
        log.Printf("[DEBUG] Upgrading cluster GKE state from version 1 to 2")

        // Convert machine_pool from TypeList to TypeSet
        // Note: We keep the data as a list in rawState and let Terraform's schema processing
        // convert it to TypeSet during normal resource loading. This avoids JSON serialization
        // issues with schema.Set objects that contain hash functions.
        if machinePoolRaw, exists := rawState["machine_pool"]; exists </span><span class="cov0" title="0">{
                if machinePoolList, ok := machinePoolRaw.([]interface{}); ok </span><span class="cov0" title="0">{
                        log.Printf("[DEBUG] Keeping machine_pool as list during state upgrade with %d items", len(machinePoolList))

                        // Keep the machine pool data as-is (as a list)
                        // Terraform will convert it to TypeSet when loading the resource using the schema
                        rawState["machine_pool"] = machinePoolList

                        log.Printf("[DEBUG] Successfully prepared machine_pool for TypeSet conversion")
                }</span> else<span class="cov0" title="0"> {
                        log.Printf("[DEBUG] machine_pool is not a list, skipping conversion")
                }</span>
        } else<span class="cov0" title="0"> {
                log.Printf("[DEBUG] No machine_pool found in state, skipping conversion")
        }</span>

        <span class="cov0" title="0">return rawState, nil</span>
}
</pre>
		
		<pre class="file" id="file146" style="display: none">package spectrocloud

import (
        "context"
        "fmt"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
)

func resourceClusterGkeImport(ctx context.Context, d *schema.ResourceData, m interface{}) ([]*schema.ResourceData, error) <span class="cov0" title="0">{
        c, err := GetCommonCluster(d, m)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">diags := resourceClusterGkeRead(ctx, d, m)
        if diags.HasError() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("could not read cluster for import: %v", diags)
        }</span>

        // cluster profile and common default cluster attribute is get set here
        <span class="cov0" title="0">err = flattenCommonAttributeForClusterImport(c, d)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Return the resource data. In most cases, this method is only used to
        // import one resource at a time, so you should return the resource data
        // in a slice with a single element.
        <span class="cov0" title="0">return []*schema.ResourceData{d}, nil</span>
}
</pre>
		
		<pre class="file" id="file147" style="display: none">package spectrocloud

import (
        "context"
        "time"

        "github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/schemas"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"

        "github.com/spectrocloud/palette-sdk-go/api/models"
        "github.com/spectrocloud/palette-sdk-go/client"
)

func resourceClusterGroup() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                CreateContext: resourceClusterGroupCreate,
                ReadContext:   resourceClusterGroupRead,
                UpdateContext: resourceClusterGroupUpdate,
                DeleteContext: resourceClusterGroupDelete,
                Importer: &amp;schema.ResourceImporter{
                        StateContext: resourceClusterGroupImport,
                },

                Timeouts: &amp;schema.ResourceTimeout{
                        Create: schema.DefaultTimeout(60 * time.Minute),
                        Update: schema.DefaultTimeout(60 * time.Minute),
                        Delete: schema.DefaultTimeout(60 * time.Minute),
                },

                SchemaVersion: 2,
                Schema: map[string]*schema.Schema{
                        "name": {
                                Type:        schema.TypeString,
                                Required:    true,
                                Description: "Name of the cluster group",
                        },
                        "context": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "tenant",
                                ValidateFunc: validation.StringInSlice([]string{"", "project", "tenant"}, false),
                                Description: "The context of the Cluster group. Allowed values are `project` or `tenant`. " +
                                        "Defaults to `tenant`. " + PROJECT_NAME_NUANCE,
                        },
                        "tags": {
                                Type:     schema.TypeSet,
                                Optional: true,
                                Set:      schema.HashString,
                                Elem: &amp;schema.Schema{
                                        Type: schema.TypeString,
                                },
                                Description: "A list of tags to be applied to the cluster group. Tags must be in the form of `key:value`.",
                        },
                        "description": {
                                Type:        schema.TypeString,
                                Optional:    true,
                                Default:     "",
                                Description: "The description of the cluster. Default value is empty string.",
                        },
                        "config": {
                                Type:     schema.TypeList,
                                Required: true,
                                MaxItems: 1,
                                Elem: &amp;schema.Resource{
                                        Schema: map[string]*schema.Schema{
                                                "host_endpoint_type": {
                                                        Type:         schema.TypeString,
                                                        Optional:     true,
                                                        Default:      "Ingress",
                                                        ValidateFunc: validation.StringInSlice([]string{"Ingress", "LoadBalancer"}, false),
                                                        Description:  "The host endpoint type. Allowed values are 'Ingress' or 'LoadBalancer'. Defaults to 'Ingress'.",
                                                },
                                                "cpu_millicore": {
                                                        Type:        schema.TypeInt,
                                                        Optional:    true,
                                                        Description: "The CPU limit in millicores.",
                                                },
                                                "memory_in_mb": {
                                                        Type:        schema.TypeInt,
                                                        Optional:    true,
                                                        Description: "The memory limit in megabytes (MB).",
                                                },
                                                "storage_in_gb": {
                                                        Type:        schema.TypeInt,
                                                        Optional:    true,
                                                        Description: "The storage limit in gigabytes (GB).",
                                                },
                                                "oversubscription_percent": {
                                                        Type:        schema.TypeInt,
                                                        Optional:    true,
                                                        Description: "The allowed oversubscription percentage.",
                                                },
                                                "values": {
                                                        Type:     schema.TypeString,
                                                        Optional: true,
                                                        Default:  "",
                                                },
                                                "k8s_distribution": {
                                                        Type:        schema.TypeString,
                                                        Optional:    true,
                                                        Default:     "vcluster-generic",
                                                        ForceNew:    true,
                                                        Description: "The Kubernetes distribution, allowed values are `vcluster-generic`,`k3s` and `cncf_k8s`.",
                                                },
                                        },
                                },
                        },
                        "cluster_profile": schemas.ClusterProfileSchema(),
                        "clusters": {
                                Type:        schema.TypeList,
                                Optional:    true,
                                Description: "A list of clusters to include in the cluster group.",
                                Elem: &amp;schema.Resource{
                                        Schema: map[string]*schema.Schema{
                                                "cluster_uid": {
                                                        Type:        schema.TypeString,
                                                        Required:    true,
                                                        Description: "The UID of the host cluster.",
                                                },
                                                "host_dns": {
                                                        Type:        schema.TypeString,
                                                        Optional:    true,
                                                        Description: "The host DNS wildcard for the cluster. i.e. `*.dev` or `*test.com`",
                                                },
                                        },
                                },
                        },
                },
        }
}</span>

func resourceClusterGroupCreate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        resourceContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, resourceContext)

        // Warning or errors can be collected in a slice type
        var diags diag.Diagnostics
        cluster := toClusterGroup(c, d)

        uid, err := c.CreateClusterGroup(cluster)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">d.SetId(uid)

        resourceClusterGroupRead(ctx, d, m)

        return diags</span>
}

//goland:noinspection GoUnhandledErrorResult
func resourceClusterGroupRead(_ context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        resourceContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, resourceContext)

        var diags diag.Diagnostics
        uid := d.Id()
        clusterGroup, err := c.GetClusterGroup(uid)
        if err != nil </span><span class="cov0" title="0">{
                return handleReadError(d, err, diags)
        }</span> else<span class="cov0" title="0"> if clusterGroup == nil </span><span class="cov0" title="0">{
                // Deleted - Terraform will recreate it
                d.SetId("")
                return diags
        }</span>

        <span class="cov0" title="0">return flattenClusterGroup(clusterGroup, d)</span>
}

func flattenClusterGroup(clusterGroup *models.V1ClusterGroup, d *schema.ResourceData) diag.Diagnostics <span class="cov0" title="0">{
        if clusterGroup == nil </span><span class="cov0" title="0">{
                return diag.Diagnostics{}
        }</span>

        <span class="cov0" title="0">d.SetId(clusterGroup.Metadata.UID)
        err := d.Set("name", clusterGroup.Metadata.Name)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">if err := d.Set("tags", flattenTags(clusterGroup.Metadata.Labels)); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">clusterGroupSpec := clusterGroup.Spec
        if clusterGroupSpec != nil </span><span class="cov0" title="0">{
                clusterConfig := clusterGroupSpec.ClustersConfig
                if clusterConfig != nil </span><span class="cov0" title="0">{
                        limitConfig := clusterConfig.LimitConfig
                        if limitConfig != nil </span><span class="cov0" title="0">{
                                err := d.Set("config", []map[string]interface{}{
                                        {
                                                "host_endpoint_type":       clusterConfig.EndpointType,
                                                "cpu_millicore":            limitConfig.CPUMilliCore,
                                                "memory_in_mb":             limitConfig.MemoryMiB,
                                                "storage_in_gb":            limitConfig.StorageGiB,
                                                "oversubscription_percent": limitConfig.OverSubscription,
                                                "k8s_distribution":         clusterConfig.KubernetesDistroType,
                                        },
                                })
                                if err != nil </span><span class="cov0" title="0">{
                                        return diag.FromErr(err)
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">if clusterGroupSpec != nil </span><span class="cov0" title="0">{
                clusterConfig := clusterGroupSpec.ClustersConfig
                if clusterConfig != nil </span><span class="cov0" title="0">{
                        hostConfig := clusterConfig.HostClustersConfig
                        if hostConfig != nil </span><span class="cov0" title="0">{
                                // set cluster uid and host
                                clusters := make([]map[string]interface{}, 0)
                                for _, cluster := range hostConfig </span><span class="cov0" title="0">{
                                        // if it's ingress config set ingress if it's loadbalancer set loadbalancer
                                        var host string
                                        if cluster.EndpointConfig.IngressConfig != nil </span><span class="cov0" title="0">{
                                                host = cluster.EndpointConfig.IngressConfig.Host
                                        }</span>
                                        <span class="cov0" title="0">clusters = append(clusters, map[string]interface{}{
                                                "cluster_uid": cluster.ClusterUID,
                                                "host_dns":    host,
                                        })</span>
                                }
                                // set clusters in the schema
                                <span class="cov0" title="0">err = d.Set("clusters", clusters)
                                if err != nil </span><span class="cov0" title="0">{
                                        return diag.FromErr(err)
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">return diag.Diagnostics{}</span>
}

func resourceClusterGroupUpdate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        resourceContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, resourceContext)
        // Warning or errors can be collected in a slice type
        var diags diag.Diagnostics
        // if there are changes in the name of  cluster group, update it using UpdateClusterGroupMeta()
        clusterGroup := toClusterGroup(c, d)
        err := c.UpdateClusterGroupMeta(clusterGroup)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">if d.HasChanges("config", "clusters") </span><span class="cov0" title="0">{
                clusterGroup := toClusterGroup(c, d)

                err := c.UpdateClusterGroup(clusterGroup.Metadata.UID, toClusterGroupUpdate(clusterGroup))
                if err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
        }
        <span class="cov0" title="0">if d.HasChange("cluster_profile") </span><span class="cov0" title="0">{
                clusterGroupContext := d.Get("context").(string)
                profiles, _ := toProfilesCommon(c, d, "", clusterGroupContext)
                profilesBody := &amp;models.V1SpectroClusterProfiles{
                        Profiles: profiles,
                }
                err := c.UpdateClusterProfileInClusterGroup(d.Id(), profilesBody)
                if err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
        }

        <span class="cov0" title="0">resourceClusterGroupRead(ctx, d, m)

        return diags</span>
}

func toClusterGroup(c *client.V1Client, d *schema.ResourceData) *models.V1ClusterGroupEntity <span class="cov0" title="0">{
        clusterRefs := make([]*models.V1ClusterGroupClusterRef, 0)
        clusterRefObj, ok := d.GetOk("clusters")
        clusterGroupContext := d.Get("context").(string)
        if ok </span><span class="cov0" title="0">{
                for i := range clusterRefObj.([]interface{}) </span><span class="cov0" title="0">{
                        resources := clusterRefObj.([]interface{})[i].(map[string]interface{})
                        mp := toClusterRef(resources)
                        clusterRefs = append(clusterRefs, mp)
                }</span>
        }

        <span class="cov0" title="0">var clusterGroupLimitConfig *models.V1ClusterGroupLimitConfig
        var values string
        resourcesObj, ok := d.GetOk("config")
        endpointType := "Ingress" // default endpoint type is ingress
        var k8Distro string
        if ok </span><span class="cov0" title="0">{
                resources := resourcesObj.([]interface{})[0].(map[string]interface{})
                clusterGroupLimitConfig = toClusterGroupLimitConfig(resources)
                if resources["values"] != nil </span><span class="cov0" title="0">{
                        values = resources["values"].(string)
                }</span>
                <span class="cov0" title="0">if resources["host_endpoint_type"] != nil </span><span class="cov0" title="0">{
                        endpointType = resources["host_endpoint_type"].(string)
                }</span>
                <span class="cov0" title="0">if resources["k8s_distribution"] != nil </span><span class="cov0" title="0">{
                        k8Distro = resources["k8s_distribution"].(string)
                }</span>
        }
        <span class="cov0" title="0">hostClusterConfig := toHostClusterConfigs(clusterRefObj.([]interface{}))

        ret := &amp;models.V1ClusterGroupEntity{
                Metadata: getClusterMetadata(d),
                Spec: &amp;models.V1ClusterGroupSpecEntity{
                        Type:           "hostCluster",
                        ClusterRefs:    clusterRefs,
                        ClustersConfig: GetClusterGroupConfig(clusterGroupLimitConfig, hostClusterConfig, endpointType, values, k8Distro),
                },
        }
        profiles, _ := toProfilesCommon(c, d, "", clusterGroupContext)
        if len(profiles) &gt; 0 </span><span class="cov0" title="0">{
                ret.Spec.Profiles = profiles
        }</span>

        <span class="cov0" title="0">return ret</span>
}

func GetClusterGroupConfig(clusterGroupLimitConfig *models.V1ClusterGroupLimitConfig, hostClusterConfig []*models.V1ClusterGroupHostClusterConfig, endpointType, values, k8Distro string) *models.V1ClusterGroupClustersConfig <span class="cov0" title="0">{
        if values != "" </span><span class="cov0" title="0">{
                return &amp;models.V1ClusterGroupClustersConfig{
                        EndpointType:         endpointType,
                        LimitConfig:          clusterGroupLimitConfig,
                        HostClustersConfig:   hostClusterConfig,
                        Values:               values,
                        KubernetesDistroType: models.V1ClusterKubernetesDistroType(k8Distro).Pointer(),
                }
        }</span> else<span class="cov0" title="0"> {
                return &amp;models.V1ClusterGroupClustersConfig{
                        EndpointType:         endpointType,
                        LimitConfig:          clusterGroupLimitConfig,
                        HostClustersConfig:   hostClusterConfig,
                        KubernetesDistroType: models.V1ClusterKubernetesDistroType(k8Distro).Pointer(),
                }
        }</span>
}

func toHostClusterConfigs(clusterConfig []interface{}) []*models.V1ClusterGroupHostClusterConfig <span class="cov0" title="0">{
        var hostClusterConfigs []*models.V1ClusterGroupHostClusterConfig
        for _, obj := range clusterConfig </span><span class="cov0" title="0">{
                resources := obj.(map[string]interface{})
                hostCluster := &amp;models.V1ClusterGroupHostClusterConfig{
                        ClusterUID: resources["cluster_uid"].(string),
                        EndpointConfig: &amp;models.V1HostClusterEndpointConfig{
                                IngressConfig: &amp;models.V1IngressConfig{
                                        Host: resources["host_dns"].(string),
                                },
                        },
                }
                hostClusterConfigs = append(hostClusterConfigs, hostCluster)
        }</span>
        <span class="cov0" title="0">return hostClusterConfigs</span>
}

func toClusterGroupUpdate(clusterGroupEntity *models.V1ClusterGroupEntity) *models.V1ClusterGroupHostClusterEntity <span class="cov0" title="0">{
        ret := &amp;models.V1ClusterGroupHostClusterEntity{
                ClusterRefs:    clusterGroupEntity.Spec.ClusterRefs,
                ClustersConfig: clusterGroupEntity.Spec.ClustersConfig,
        }

        return ret
}</span>

func toClusterRef(resources map[string]interface{}) *models.V1ClusterGroupClusterRef <span class="cov0" title="0">{
        cluster_uid := resources["cluster_uid"].(string)

        ret := &amp;models.V1ClusterGroupClusterRef{
                ClusterUID: cluster_uid,
        }

        return ret
}</span>

func toClusterGroupLimitConfig(resources map[string]interface{}) *models.V1ClusterGroupLimitConfig <span class="cov0" title="0">{
        cpu_milli := resources["cpu_millicore"].(int)
        mem_in_mb := resources["memory_in_mb"].(int)
        storage_in_gb := resources["storage_in_gb"].(int)
        oversubscription := resources["oversubscription_percent"].(int)

        ret := &amp;models.V1ClusterGroupLimitConfig{

                CPUMilliCore:     SafeInt32(cpu_milli),
                MemoryMiB:        SafeInt32(mem_in_mb),
                StorageGiB:       SafeInt32(storage_in_gb),
                OverSubscription: SafeInt32(oversubscription),
        }

        return ret
}</span>

func resourceClusterGroupDelete(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        resourceContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, resourceContext)

        var diags diag.Diagnostics
        err := c.DeleteClusterGroup(d.Id())
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">return diags</span>
}
</pre>
		
		<pre class="file" id="file148" style="display: none">package spectrocloud

import (
        "context"
        "fmt"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/spectrocloud/palette-sdk-go/client"
)

func resourceClusterGroupImport(ctx context.Context, d *schema.ResourceData, m interface{}) ([]*schema.ResourceData, error) <span class="cov0" title="0">{
        _, err := GetCommonClusterGroup(d, m)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Read all cluster group data to populate the state
        <span class="cov0" title="0">diags := resourceClusterGroupRead(ctx, d, m)
        if diags.HasError() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("could not read cluster group for import: %v", diags)
        }</span>

        <span class="cov0" title="0">return []*schema.ResourceData{d}, nil</span>
}

func GetCommonClusterGroup(d *schema.ResourceData, m interface{}) (*client.V1Client, error) <span class="cov0" title="0">{
        // Parse resource ID and scope
        resourceContext, clusterGroupID, err := ParseResourceID(d)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">c := getV1ClientWithResourceContext(m, resourceContext)

        // Use the ID to retrieve the cluster group data from the API
        clusterGroup, err := c.GetClusterGroup(clusterGroupID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unable to retrieve cluster group data: %s", err)
        }</span>
        <span class="cov0" title="0">if clusterGroup == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cluster group with ID %s not found", clusterGroupID)
        }</span>

        // Set the cluster group name from the retrieved cluster group
        <span class="cov0" title="0">if err := d.Set("name", clusterGroup.Metadata.Name); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Set the context from the cluster group metadata
        <span class="cov0" title="0">if err := d.Set("context", clusterGroup.Metadata.Annotations["scope"]); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Set the ID of the resource in the state. This ID is used to track the
        // resource and must be set in the state during the import.
        <span class="cov0" title="0">d.SetId(clusterGroup.Metadata.UID)

        return c, nil</span>
}
</pre>
		
		<pre class="file" id="file149" style="display: none">package spectrocloud

import (
        "context"
        "log"
        "time"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"

        "github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/schemas"
        "github.com/spectrocloud/terraform-provider-spectrocloud/types"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/spectrocloud/palette-sdk-go/api/models"
        "github.com/spectrocloud/palette-sdk-go/client"
)

func resourceClusterMaas() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                CreateContext: resourceClusterMaasCreate,
                ReadContext:   resourceClusterMaasRead,
                UpdateContext: resourceClusterMaasUpdate,
                DeleteContext: resourceClusterDelete,
                Importer: &amp;schema.ResourceImporter{
                        StateContext: resourceClusterMaasImport,
                },
                Description: "Resource for managing MAAS clusters in Spectro Cloud through Palette.",

                Timeouts: &amp;schema.ResourceTimeout{
                        Create: schema.DefaultTimeout(60 * time.Minute),
                        Update: schema.DefaultTimeout(60 * time.Minute),
                        Delete: schema.DefaultTimeout(60 * time.Minute),
                },

                SchemaVersion: 2,
                Schema: map[string]*schema.Schema{
                        "name": {
                                Type:        schema.TypeString,
                                Required:    true,
                                ForceNew:    true,
                                Description: "The name of the cluster.",
                        },
                        "context": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "project",
                                ValidateFunc: validation.StringInSlice([]string{"", "project", "tenant"}, false),
                                Description: "The context of the MAAS configuration. Allowed values are `project` or `tenant`. " +
                                        "Default is `project`. " + PROJECT_NAME_NUANCE,
                        },
                        "tags": {
                                Type:     schema.TypeSet,
                                Optional: true,
                                Set:      schema.HashString,
                                Elem: &amp;schema.Schema{
                                        Type: schema.TypeString,
                                },
                                Description: "A list of tags to be applied to the cluster. Tags must be in the form of `key:value`.",
                        },
                        "description": {
                                Type:        schema.TypeString,
                                Optional:    true,
                                Default:     "",
                                Description: "The description of the cluster. Default value is empty string.",
                        },
                        "cluster_meta_attribute": {
                                Type:        schema.TypeString,
                                Optional:    true,
                                Description: "`cluster_meta_attribute` can be used to set additional cluster metadata information, eg `{'nic_name': 'test', 'env': 'stage'}`",
                        },
                        "cluster_profile":  schemas.ClusterProfileSchema(),
                        "cluster_template": schemas.ClusterTemplateSchema(),
                        "cluster_type":     schemas.ClusterTypeSchema(),
                        "apply_setting": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "DownloadAndInstall",
                                ValidateFunc: validation.StringInSlice([]string{"DownloadAndInstall", "DownloadAndInstallLater"}, false),
                                Description: "The setting to apply the cluster profile. `DownloadAndInstall` will download and install packs in one action. " +
                                        "`DownloadAndInstallLater` will only download artifact and postpone install for later. " +
                                        "Default value is `DownloadAndInstall`.",
                        },
                        "cloud_account_id": {
                                Type:        schema.TypeString,
                                Optional:    true,
                                ForceNew:    true,
                                Description: "ID of the Maas cloud account used for the cluster. This cloud account must be of type `maas`.",
                        },
                        "cloud_config_id": {
                                Type:        schema.TypeString,
                                Computed:    true,
                                Description: "ID of the cloud config used for the cluster. This cloud config must be of type `maas`.",
                                Deprecated:  "This field is deprecated and will be removed in the future. Use `cloud_config` instead.",
                        },
                        "review_repave_state": {
                                Type:         schema.TypeString,
                                Default:      "",
                                Optional:     true,
                                ValidateFunc: validateReviewRepaveValue,
                                Description:  "To authorize the cluster repave, set the value to `Approved` for approval and `\"\"` to decline. Default value is `\"\"`.",
                        },
                        "pause_agent_upgrades": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "unlock",
                                ValidateFunc: validation.StringInSlice([]string{"lock", "unlock"}, false),
                                Description:  "The pause agent upgrades setting allows to control the automatic upgrade of the Palette component and agent for an individual cluster. The default value is `unlock`, meaning upgrades occur automatically. Setting it to `lock` pauses automatic agent upgrades for the cluster.",
                        },
                        "os_patch_on_boot": {
                                Type:        schema.TypeBool,
                                Optional:    true,
                                Default:     false,
                                Description: "Whether to apply OS patch on boot. Default is `false`.",
                        },
                        "os_patch_schedule": {
                                Type:             schema.TypeString,
                                Optional:         true,
                                ValidateDiagFunc: validateOsPatchSchedule,
                                Description:      "Cron schedule for OS patching. This must be in the form of `0 0 * * *`.",
                        },
                        "os_patch_after": {
                                Type:             schema.TypeString,
                                Optional:         true,
                                ValidateDiagFunc: validateOsPatchOnDemandAfter,
                                Description:      "The date and time after which to patch the cluster. Prefix the time value with the respective RFC. Ex: `RFC3339: 2006-01-02T15:04:05Z07:00`",
                        },
                        "cluster_timezone": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "",
                                ValidateFunc: validateTimezone,
                                Description:  "Defines the time zone used by this cluster to interpret scheduled operations. Maintenance tasks like upgrades will follow this time zone to ensure they run at the appropriate local time for the cluster. Must be in IANA timezone format (e.g., 'America/New_York', 'Asia/Kolkata', 'Europe/London').",
                        },
                        "kubeconfig": {
                                Type:        schema.TypeString,
                                Computed:    true,
                                Description: "Kubeconfig for the cluster. This can be used to connect to the cluster using `kubectl`.",
                        },
                        "admin_kube_config": {
                                Type:        schema.TypeString,
                                Computed:    true,
                                Description: "Admin Kube-config for the cluster. This can be used to connect to the cluster using `kubectl`, With admin privilege.",
                        },
                        "cloud_config": {
                                Type:     schema.TypeList,
                                Required: true,
                                MaxItems: 1,
                                Elem: &amp;schema.Resource{
                                        Schema: map[string]*schema.Schema{
                                                "domain": {
                                                        Type:        schema.TypeString,
                                                        Required:    true,
                                                        Description: "Domain name in which the cluster to be provisioned.",
                                                },
                                                "enable_lxd_vm": {
                                                        Type:        schema.TypeBool,
                                                        Optional:    true,
                                                        Default:     false,
                                                        Description: "Whether to enable LXD VM. Default is `false`.",
                                                },
                                                "ntp_servers": {
                                                        Type:     schema.TypeSet,
                                                        Optional: true,
                                                        Set:      schema.HashString,
                                                        Elem: &amp;schema.Schema{
                                                                Type: schema.TypeString,
                                                        },
                                                        Description: "A list of NTP servers to use instead of the machine image's default NTP server list.",
                                                },
                                        },
                                },
                        },
                        "machine_pool": {
                                Type:     schema.TypeSet,
                                Required: true,
                                Set:      resourceMachinePoolMaasHash,
                                Elem: &amp;schema.Resource{
                                        Schema: map[string]*schema.Schema{
                                                "additional_labels": {
                                                        Type:     schema.TypeMap,
                                                        Optional: true,
                                                        Elem: &amp;schema.Schema{
                                                                Type: schema.TypeString,
                                                        },
                                                        Description: "Additional labels to be applied to the machine pool. Labels must be in the form of `key:value`.",
                                                },
                                                "additional_annotations": {
                                                        Type:     schema.TypeMap,
                                                        Optional: true,
                                                        Elem: &amp;schema.Schema{
                                                                Type: schema.TypeString,
                                                        },
                                                        Description: "Additional annotations to be applied to the machine pool. Annotations must be in the form of `key:value`.",
                                                },
                                                "node":   schemas.NodeSchema(),
                                                "taints": schemas.ClusterTaintsSchema(),
                                                "control_plane": {
                                                        Type:     schema.TypeBool,
                                                        Optional: true,
                                                        Default:  false,
                                                        //ForceNew: true,
                                                        Description: "Whether this machine pool is a control plane. Defaults to `false`.",
                                                },
                                                "control_plane_as_worker": {
                                                        Type:     schema.TypeBool,
                                                        Optional: true,
                                                        Default:  false,
                                                        //ForceNew: true,
                                                        Description: "Whether this machine pool is a control plane and a worker. Defaults to `false`.",
                                                },
                                                "name": {
                                                        Type:     schema.TypeString,
                                                        Required: true,
                                                        //ForceNew: true,
                                                        Description: "Name of the machine pool.",
                                                },
                                                "count": {
                                                        Type:        schema.TypeInt,
                                                        Required:    true,
                                                        Description: "Number of nodes in the machine pool.",
                                                },
                                                "node_repave_interval": {
                                                        Type:        schema.TypeInt,
                                                        Optional:    true,
                                                        Default:     0,
                                                        Description: "Minimum number of seconds node should be Ready, before the next node is selected for repave. Default value is `0`, Applicable only for worker pools.",
                                                },
                                                "min": {
                                                        Type:        schema.TypeInt,
                                                        Optional:    true,
                                                        Default:     0,
                                                        Description: "Minimum number of nodes in the machine pool. This is used for autoscaling the machine pool.",
                                                },
                                                "max": {
                                                        Type:        schema.TypeInt,
                                                        Optional:    true,
                                                        Default:     0,
                                                        Description: "Maximum number of nodes in the machine pool. This is used for autoscaling the machine pool.",
                                                },
                                                "instance_type": {
                                                        Type:     schema.TypeList,
                                                        Required: true,
                                                        MaxItems: 1,
                                                        Elem: &amp;schema.Resource{
                                                                Schema: map[string]*schema.Schema{
                                                                        "min_memory_mb": {
                                                                                Type:        schema.TypeInt,
                                                                                Required:    true,
                                                                                Description: "Minimum memory in MB required for the machine pool node.",
                                                                        },
                                                                        "min_cpu": {
                                                                                Type:        schema.TypeInt,
                                                                                Required:    true,
                                                                                Description: "Minimum number of CPU required for the machine pool node.",
                                                                        },
                                                                },
                                                        },
                                                },
                                                "update_strategy": {
                                                        Type:         schema.TypeString,
                                                        Optional:     true,
                                                        Default:      "RollingUpdateScaleOut",
                                                        Description:  "Update strategy for the machine pool. Valid values are `RollingUpdateScaleOut`, `RollingUpdateScaleIn` and `OverrideScaling`. If `OverrideScaling` is used, `override_scaling` must be specified with both `max_surge` and `max_unavailable`.",
                                                        ValidateFunc: validation.StringInSlice([]string{"RollingUpdateScaleOut", "RollingUpdateScaleIn", "OverrideScaling"}, false),
                                                },
                                                "override_scaling": schemas.OverrideScalingSchema(),
                                                "override_kubeadm_configuration": {
                                                        Type:        schema.TypeString,
                                                        Optional:    true,
                                                        Description: "YAML config for kubeletExtraArgs, preKubeadmCommands, postKubeadmCommands. Overrides pack-level settings. Worker pools only.",
                                                },
                                                "azs": {
                                                        Type:     schema.TypeSet,
                                                        Required: true,
                                                        Set:      schema.HashString,
                                                        Elem: &amp;schema.Schema{
                                                                Type: schema.TypeString,
                                                        },
                                                        Description: "Availability zones in which the machine pool nodes to be provisioned.",
                                                },
                                                "node_tags": {
                                                        Type:     schema.TypeSet,
                                                        Optional: true,
                                                        Set:      schema.HashString,
                                                        Elem: &amp;schema.Schema{
                                                                Type: schema.TypeString,
                                                        },
                                                        Description: "Node tags to dynamically place nodes in a pool by using MAAS automatic tags. Specify the tag values that you want to apply to all nodes in the node pool.",
                                                },
                                                "placement": {
                                                        Type:     schema.TypeList,
                                                        Required: true,
                                                        MaxItems: 1,
                                                        Elem: &amp;schema.Resource{
                                                                Schema: map[string]*schema.Schema{
                                                                        "id": {
                                                                                Type:        schema.TypeString,
                                                                                Computed:    true,
                                                                                Description: "This is a computed(read-only) ID of the placement that is used to connect to the Maas cloud.",
                                                                        },
                                                                        "resource_pool": {
                                                                                Type:        schema.TypeString,
                                                                                Required:    true,
                                                                                Description: "The name of the resource pool in the Maas cloud.",
                                                                        },
                                                                },
                                                        },
                                                },
                                                "use_lxd_vm": {
                                                        Type:        schema.TypeBool,
                                                        Optional:    true,
                                                        Default:     false,
                                                        Description: "Whether to use LXD VM. Default is `false`. Available once **Palette with LXD support** is released.",
                                                },
                                                "network": {
                                                        Type:        schema.TypeList,
                                                        Optional:    true,
                                                        MaxItems:    1,
                                                        Description: "Network configuration for the machine pool. Available once **Palette with LXD support** is released.",
                                                        Elem: &amp;schema.Resource{
                                                                Schema: map[string]*schema.Schema{
                                                                        "network_name": {
                                                                                Type:        schema.TypeString,
                                                                                Required:    true,
                                                                                Description: "The name of the network in which VMs are created/located.",
                                                                        },
                                                                        "parent_pool_uid": {
                                                                                Type:        schema.TypeString,
                                                                                Optional:    true,
                                                                                Description: "The UID of the parent pool which allocates IPs for this IPPool.",
                                                                        },
                                                                        "static_ip": {
                                                                                Type:        schema.TypeBool,
                                                                                Optional:    true,
                                                                                Default:     false,
                                                                                Description: "Whether to use static IP. Default is `false`.",
                                                                        },
                                                                },
                                                        },
                                                },
                                        },
                                },
                        },
                        "backup_policy":        schemas.BackupPolicySchema(),
                        "scan_policy":          schemas.ScanPolicySchema(),
                        "cluster_rbac_binding": schemas.ClusterRbacBindingSchema(),
                        "namespaces":           schemas.ClusterNamespacesSchema(),
                        "host_config":          schemas.ClusterHostConfigSchema(),
                        "location_config":      schemas.ClusterLocationSchema(),
                        "skip_completion": {
                                Type:        schema.TypeBool,
                                Optional:    true,
                                Default:     false,
                                Description: "If `true`, the cluster will be created asynchronously. Default value is `false`.",
                        },
                        "force_delete": {
                                Type:        schema.TypeBool,
                                Optional:    true,
                                Default:     false,
                                Description: "If set to `true`, the cluster will be force deleted and user has to manually clean up the provisioned cloud resources.",
                        },
                        "force_delete_delay": {
                                Type:             schema.TypeInt,
                                Optional:         true,
                                Default:          20,
                                Description:      "Delay duration in minutes to before invoking cluster force delete. Default and minimum is 20.",
                                ValidateDiagFunc: validation.ToDiagFunc(validation.IntAtLeast(20)),
                        },
                },
        }
}</span>

func resourceClusterMaasCreate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        resourceContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, resourceContext)

        // Warning or errors can be collected in a slice type
        var diags diag.Diagnostics

        // Validate override_Scaling configuration
        if err := validateOverrideScaling(d, "machine_pool"); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">cluster, err := toMaasCluster(c, d)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">uid, err := c.CreateClusterMaas(cluster)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">diagnostics, isError := waitForClusterCreation(ctx, d, uid, diags, c, true)
        if len(diagnostics) &gt; 0 </span><span class="cov0" title="0">{
                diags = append(diags, diagnostics...)
        }</span>
        <span class="cov0" title="0">if isError </span><span class="cov0" title="0">{
                return diagnostics
        }</span>
        <span class="cov0" title="0">resourceClusterMaasRead(ctx, d, m)

        return diags</span>
}

func resourceClusterMaasRead(_ context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        resourceContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, resourceContext)

        var diags diag.Diagnostics

        cluster, err := resourceClusterRead(d, c, diags)
        if err != nil </span><span class="cov0" title="0">{
                return handleReadError(d, err, diags)
        }</span> else<span class="cov0" title="0"> if cluster == nil </span><span class="cov0" title="0">{
                // Deleted - Terraform will recreate it
                d.SetId("")
                return diags
        }</span>

        // verify cluster type
        <span class="cov0" title="0">err = ValidateCloudType("spectrocloud_cluster_maas", cluster)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">diagnostics, done := readCommonFields(c, d, cluster)
        if done </span><span class="cov0" title="0">{
                return diagnostics
        }</span>

        // Flatten cluster_template variables using variables API
        <span class="cov0" title="0">if err := flattenClusterTemplateVariables(c, d, d.Id()); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">return flattenCloudConfigMaas(cluster.Spec.CloudConfigRef.UID, d, c)</span>
}

func flattenCloudConfigMaas(configUID string, d *schema.ResourceData, c *client.V1Client) diag.Diagnostics <span class="cov0" title="0">{
        var diags diag.Diagnostics
        err := d.Set("cloud_config_id", configUID)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">if err := ReadCommonAttributes(d); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">if config, err := c.GetCloudConfigMaas(configUID); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span> else<span class="cov0" title="0"> {
                if config.Spec != nil &amp;&amp; config.Spec.CloudAccountRef != nil </span><span class="cov0" title="0">{
                        if err := d.Set("cloud_account_id", config.Spec.CloudAccountRef.UID); err != nil </span><span class="cov0" title="0">{
                                return diag.FromErr(err)
                        }</span>
                }
                <span class="cov0" title="0">if err := d.Set("cloud_config", flattenClusterConfigsMaas(config)); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
                <span class="cov0" title="0">mp := flattenMachinePoolConfigsMaas(config.Spec.MachinePoolConfig, config.Spec.ClusterConfig)
                mp, err := flattenNodeMaintenanceStatus(c, d, c.GetNodeStatusMapMaas, mp, configUID)
                if err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
                <span class="cov0" title="0">if err := d.Set("machine_pool", mp); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
        }

        <span class="cov0" title="0">generalWarningForRepave(&amp;diags)
        return diags</span>
}

func flattenClusterConfigsMaas(config *models.V1MaasCloudConfig) []interface{} <span class="cov0" title="0">{
        if config == nil || config.Spec == nil || config.Spec.ClusterConfig == nil </span><span class="cov0" title="0">{
                return make([]interface{}, 0)
        }</span>

        <span class="cov0" title="0">m := make(map[string]interface{})

        if config.Spec.ClusterConfig.Domain != nil </span><span class="cov0" title="0">{
                m["domain"] = *config.Spec.ClusterConfig.Domain
        }</span>
        <span class="cov0" title="0">if config.Spec.ClusterConfig.EnableLxdVM </span><span class="cov0" title="0">{
                m["enable_lxd_vm"] = true
        }</span>
        <span class="cov0" title="0">if config.Spec.ClusterConfig.NtpServers != nil </span><span class="cov0" title="0">{
                m["ntp_servers"] = config.Spec.ClusterConfig.NtpServers
        }</span>

        <span class="cov0" title="0">return []interface{}{m}</span>
}

func flattenMachinePoolConfigsMaas(machinePools []*models.V1MaasMachinePoolConfig, config *models.V1MaasClusterConfig) []interface{} <span class="cov0" title="0">{
        if machinePools == nil </span><span class="cov0" title="0">{
                return make([]interface{}, 0)
        }</span>

        <span class="cov0" title="0">ois := make([]interface{}, len(machinePools))

        for i, machinePool := range machinePools </span><span class="cov0" title="0">{
                oi := make(map[string]interface{})

                FlattenAdditionalLabelsAnnotationsAndTaints(machinePool.AdditionalLabels, machinePool.AdditionalAnnotations, machinePool.Taints, oi)
                FlattenControlPlaneAndRepaveInterval(&amp;machinePool.IsControlPlane, oi, machinePool.NodeRepaveInterval)

                oi["control_plane_as_worker"] = machinePool.UseControlPlaneAsWorker
                oi["name"] = machinePool.Name
                oi["count"] = int(machinePool.Size)
                if machinePool.UpdateStrategy != nil </span><span class="cov0" title="0">{
                        oi["update_strategy"] = machinePool.UpdateStrategy.Type
                        // Flatten override_Scaling if using OverrideScaling strategy
                        flattenOverrideScaling(machinePool.UpdateStrategy, oi)
                }</span>

                // Flatten override_kubeadm_configuration (worker pools only)
                <span class="cov0" title="0">if !machinePool.IsControlPlane &amp;&amp; machinePool.OverrideKubeadmConfiguration != "" </span><span class="cov0" title="0">{
                        oi["override_kubeadm_configuration"] = machinePool.OverrideKubeadmConfiguration
                }</span>

                <span class="cov0" title="0">oi["min"] = int(machinePool.MinSize)
                oi["max"] = int(machinePool.MaxSize)
                oi["instance_type"] = machinePool.InstanceType

                if machinePool.InstanceType != nil </span><span class="cov0" title="0">{
                        s := make(map[string]interface{})
                        s["min_memory_mb"] = int(machinePool.InstanceType.MinMemInMB)
                        s["min_cpu"] = int(machinePool.InstanceType.MinCPU)
                        oi["instance_type"] = []interface{}{s}
                }</span>

                <span class="cov0" title="0">oi["azs"] = machinePool.Azs
                if config != nil </span><span class="cov0" title="0">{
                        placement := make(map[string]interface{})
                        if machinePool.ResourcePool != "" </span><span class="cov0" title="0">{
                                placement["resource_pool"] = machinePool.ResourcePool
                                oi["placement"] = []interface{}{placement}
                        }</span>
                }
                <span class="cov0" title="0">oi["node_tags"] = machinePool.Tags
                oi["use_lxd_vm"] = machinePool.UseLxdVM

                if machinePool.Network != nil </span><span class="cov0" title="0">{
                        network := make(map[string]interface{})
                        network["network_name"] = *machinePool.Network.NetworkName
                        network["parent_pool_uid"] = machinePool.Network.ParentPoolRef.UID
                        network["static_ip"] = machinePool.Network.StaticIP
                        oi["network"] = []interface{}{network}
                }</span>

                <span class="cov0" title="0">ois[i] = oi</span>
        }

        <span class="cov0" title="0">return ois</span>
}

func resourceClusterMaasUpdate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        resourceContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, resourceContext)

        // Warning or errors can be collected in a slice type
        var diags diag.Diagnostics

        // Validate that cluster_type is not being modified (it's a create-only field)
        if err := ValidateClusterTypeUpdate(d); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">err := validateSystemRepaveApproval(d, c)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">cloudConfigId := d.Get("cloud_config_id").(string)

        // Handle cloud_config updates (Day 2 operations for NTP servers, etc.)
        if d.HasChange("cloud_config") </span><span class="cov0" title="0">{
                cloudConfig := d.Get("cloud_config").([]interface{})[0].(map[string]interface{})
                cloudConfigEntity := toMaasCloudConfigUpdate(cloudConfig)
                if err := c.UpdateCloudConfigMaas(cloudConfigId, cloudConfigEntity); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
        }

        <span class="cov0" title="0">CloudConfig, err := c.GetCloudConfigMaas(cloudConfigId)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">if d.HasChange("machine_pool") </span><span class="cov0" title="0">{
                // Validate override_Scaling configuration
                if err := validateOverrideScaling(d, "machine_pool"); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>

                <span class="cov0" title="0">oraw, nraw := d.GetChange("machine_pool")
                if oraw == nil </span><span class="cov0" title="0">{
                        oraw = new(schema.Set)
                }</span>
                <span class="cov0" title="0">if nraw == nil </span><span class="cov0" title="0">{
                        nraw = new(schema.Set)
                }</span>

                <span class="cov0" title="0">os := oraw.(*schema.Set)
                ns := nraw.(*schema.Set)

                osMap := make(map[string]interface{})
                for _, mp := range os.List() </span><span class="cov0" title="0">{
                        machinePool := mp.(map[string]interface{})
                        osMap[machinePool["name"].(string)] = machinePool
                }</span>

                <span class="cov0" title="0">nsMap := make(map[string]interface{})

                for _, mp := range ns.List() </span><span class="cov0" title="0">{
                        machinePoolResource := mp.(map[string]interface{})
                        nsMap[machinePoolResource["name"].(string)] = machinePoolResource
                        // since known issue in TF SDK: https://github.com/hashicorp/terraform-plugin-sdk/issues/588
                        if machinePoolResource["name"].(string) != "" </span><span class="cov0" title="0">{
                                name := machinePoolResource["name"].(string)
                                hash := resourceMachinePoolMaasHash(machinePoolResource)

                                var err error
                                machinePool, err := toMachinePoolMaas(machinePoolResource)
                                if err != nil </span><span class="cov0" title="0">{
                                        return diag.FromErr(err)
                                }</span>

                                <span class="cov0" title="0">if oldMachinePool, ok := osMap[name]; !ok </span><span class="cov0" title="0">{
                                        log.Printf("Create machine pool %s", name)
                                        err = c.CreateMachinePoolMaas(cloudConfigId, machinePool)
                                }</span> else<span class="cov0" title="0"> if hash != resourceMachinePoolMaasHash(oldMachinePool) </span><span class="cov0" title="0">{
                                        log.Printf("Change in machine pool %s", name)
                                        err = c.UpdateMachinePoolMaas(cloudConfigId, machinePool)
                                        // Node Maintenance Actions
                                        err := resourceNodeAction(c, ctx, nsMap[name], c.GetNodeMaintenanceStatusMaas, CloudConfig.Kind, cloudConfigId, name)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return diag.FromErr(err)
                                        }</span>
                                }

                                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                                        return diag.FromErr(err)
                                }</span>

                                // Processed (if exists)
                                <span class="cov0" title="0">delete(osMap, name)</span>
                        }
                }

                // Deleted old machine pools
                <span class="cov0" title="0">for _, mp := range osMap </span><span class="cov0" title="0">{
                        machinePool := mp.(map[string]interface{})
                        name := machinePool["name"].(string)
                        log.Printf("Deleted machine pool %s", name)
                        if err := c.DeleteMachinePoolMaas(cloudConfigId, name); err != nil </span><span class="cov0" title="0">{
                                return diag.FromErr(err)
                        }</span>
                }
        }

        <span class="cov0" title="0">diagnostics, done := updateCommonFields(d, c)
        if done </span><span class="cov0" title="0">{
                return diagnostics
        }</span>

        <span class="cov0" title="0">resourceClusterMaasRead(ctx, d, m)

        return diags</span>
}

func toMaasCloudConfigUpdate(cloudConfig map[string]interface{}) *models.V1MaasCloudClusterConfigEntity <span class="cov0" title="0">{
        DomainVal := cloudConfig["domain"].(string)
        return &amp;models.V1MaasCloudClusterConfigEntity{
                ClusterConfig: &amp;models.V1MaasClusterConfig{
                        Domain:      &amp;DomainVal,
                        EnableLxdVM: cloudConfig["enable_lxd_vm"].(bool),
                        NtpServers:  toNtpServers(cloudConfig),
                },
        }
}</span>

func toMaasCluster(c *client.V1Client, d *schema.ResourceData) (*models.V1SpectroMaasClusterEntity, error) <span class="cov0" title="0">{
        // gnarly, I know! =/
        cloudConfig := d.Get("cloud_config").([]interface{})[0].(map[string]interface{})
        DomainVal := cloudConfig["domain"].(string)

        clusterContext := d.Get("context").(string)
        profiles, err := toProfiles(c, d, clusterContext)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">cluster := &amp;models.V1SpectroMaasClusterEntity{
                Metadata: getClusterMetadata(d),
                Spec: &amp;models.V1SpectroMaasClusterEntitySpec{
                        CloudAccountUID: types.Ptr(d.Get("cloud_account_id").(string)),
                        Profiles:        profiles,
                        ClusterTemplate: toClusterTemplateReference(d),
                        ClusterType:     toClusterType(d),
                        Policies:        toPolicies(d),
                        CloudConfig: &amp;models.V1MaasClusterConfig{
                                Domain:      &amp;DomainVal,
                                EnableLxdVM: cloudConfig["enable_lxd_vm"].(bool),
                                NtpServers:  toNtpServers(cloudConfig),
                        },
                },
        }

        //for _, machinePool := range d.Get("machine_pool").([]interface{}) {
        machinePoolConfigs := make([]*models.V1MaasMachinePoolConfigEntity, 0)
        for _, machinePool := range d.Get("machine_pool").(*schema.Set).List() </span><span class="cov0" title="0">{
                mp, err := toMachinePoolMaas(machinePool)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">machinePoolConfigs = append(machinePoolConfigs, mp)</span>
        }

        <span class="cov0" title="0">cluster.Spec.Machinepoolconfig = machinePoolConfigs
        cluster.Spec.ClusterConfig = toClusterConfig(d)

        return cluster, nil</span>
}

func toMachinePoolMaas(machinePool interface{}) (*models.V1MaasMachinePoolConfigEntity, error) <span class="cov0" title="0">{
        m := machinePool.(map[string]interface{})

        labels := make([]string, 0)
        controlPlane := m["control_plane"].(bool)
        controlPlaneAsWorker := m["control_plane_as_worker"].(bool)
        if controlPlane </span><span class="cov0" title="0">{
                labels = append(labels, "control-plane")
        }</span> else<span class="cov0" title="0"> {
                labels = append(labels, "worker")
        }</span>

        <span class="cov0" title="0">azs := make([]string, 0)
        for _, az := range m["azs"].(*schema.Set).List() </span><span class="cov0" title="0">{
                azs = append(azs, az.(string))
        }</span>

        <span class="cov0" title="0">InstanceType := m["instance_type"].([]interface{})[0].(map[string]interface{})
        log.Printf("Create machine pool %s", InstanceType)

        min := SafeInt32(m["count"].(int))
        max := SafeInt32(m["count"].(int))

        if m["min"] != nil </span><span class="cov0" title="0">{
                min = SafeInt32(m["min"].(int))
        }</span>

        <span class="cov0" title="0">if m["max"] != nil </span><span class="cov0" title="0">{
                max = SafeInt32(m["max"].(int))
        }</span>
        <span class="cov0" title="0">var nodePoolTags []string
        for _, nt := range m["node_tags"].(*schema.Set).List() </span><span class="cov0" title="0">{
                nodePoolTags = append(nodePoolTags, nt.(string))
        }</span>

        <span class="cov0" title="0">mp := &amp;models.V1MaasMachinePoolConfigEntity{
                CloudConfig: &amp;models.V1MaasMachinePoolCloudConfigEntity{
                        Azs: azs,
                        InstanceType: &amp;models.V1MaasInstanceType{
                                MinCPU:     SafeInt32(InstanceType["min_cpu"].(int)),
                                MinMemInMB: SafeInt32(InstanceType["min_memory_mb"].(int)),
                        },
                        Tags:     nodePoolTags,
                        UseLxdVM: m["use_lxd_vm"].(bool),
                },
                PoolConfig: &amp;models.V1MachinePoolConfigEntity{
                        AdditionalLabels:        toAdditionalNodePoolLabels(m),
                        AdditionalAnnotations:   toAdditionalNodePoolAnnotations(m),
                        Taints:                  toClusterTaints(m),
                        IsControlPlane:          controlPlane,
                        Labels:                  labels,
                        Name:                    types.Ptr(m["name"].(string)),
                        Size:                    types.Ptr(SafeInt32(m["count"].(int))),
                        UpdateStrategy:          toUpdateStrategy(m),
                        UseControlPlaneAsWorker: controlPlaneAsWorker,
                        MinSize:                 min,
                        MaxSize:                 max,
                },
        }

        // Handle override_kubeadm_configuration (worker pools only)
        if !controlPlane </span><span class="cov0" title="0">{
                if overrideKubeadm, ok := m["override_kubeadm_configuration"].(string); ok &amp;&amp; overrideKubeadm != "" </span><span class="cov0" title="0">{
                        mp.PoolConfig.OverrideKubeadmConfiguration = overrideKubeadm
                }</span>
        }

        <span class="cov0" title="0">if len(m["network"].([]interface{})) &gt; 0 </span><span class="cov0" title="0">{
                network := m["network"].([]interface{})[0].(map[string]interface{})
                net := &amp;models.V1MaasNetworkConfigEntity{
                        NetworkName:   types.Ptr(network["network_name"].(string)),
                        StaticIP:      network["static_ip"].(bool),
                        ParentPoolUID: network["parent_pool_uid"].(string),
                }
                mp.CloudConfig.Network = net
        }</span>

        <span class="cov0" title="0">if len(m["placement"].([]interface{})) &gt; 0 </span><span class="cov0" title="0">{
                Placement := m["placement"].([]interface{})[0].(map[string]interface{})
                mp.CloudConfig.ResourcePool = types.Ptr(Placement["resource_pool"].(string))
        }</span> else<span class="cov0" title="0"> {
                rp := ""
                mp.CloudConfig.ResourcePool = &amp;rp // backend is not accepting nil, rather pointer to empty string.
        }</span>

        <span class="cov0" title="0">if !controlPlane </span><span class="cov0" title="0">{
                nodeRepaveInterval := 0
                if m["node_repave_interval"] != nil </span><span class="cov0" title="0">{
                        nodeRepaveInterval = m["node_repave_interval"].(int)
                }</span>
                <span class="cov0" title="0">mp.PoolConfig.NodeRepaveInterval = SafeInt32(nodeRepaveInterval)</span>
        } else<span class="cov0" title="0"> {
                err := ValidationNodeRepaveIntervalForControlPlane(m["node_repave_interval"].(int))
                if err != nil </span><span class="cov0" title="0">{
                        return mp, err
                }</span>
        }

        <span class="cov0" title="0">return mp, nil</span>
}
</pre>
		
		<pre class="file" id="file150" style="display: none">package spectrocloud

import (
        "context"
        "fmt"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
)

func resourceClusterMaasImport(ctx context.Context, d *schema.ResourceData, m interface{}) ([]*schema.ResourceData, error) <span class="cov0" title="0">{
        // m is the client, which can be used to make API requests to the infrastructure
        c, err := GetCommonCluster(d, m)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">diags := resourceClusterMaasRead(ctx, d, m)
        if diags.HasError() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("could not read cluster for import: %v", diags)
        }</span>

        // cluster profile and common default cluster attribute is get set here
        <span class="cov0" title="0">err = flattenCommonAttributeForClusterImport(c, d)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Return the resource data. In most cases, this method is only used to
        // import one resource at a time, so you should return the resource data
        // in a slice with a single element.
        <span class="cov0" title="0">return []*schema.ResourceData{d}, nil</span>
}
</pre>
		
		<pre class="file" id="file151" style="display: none">package spectrocloud

import (
        "context"
        "log"
        "sort"
        "time"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"

        "github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/schemas"
        "github.com/spectrocloud/terraform-provider-spectrocloud/types"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/spectrocloud/palette-sdk-go/api/models"
        "github.com/spectrocloud/palette-sdk-go/client"
)

func resourceClusterOpenStack() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                CreateContext: resourceClusterOpenStackCreate,
                ReadContext:   resourceClusterOpenStackRead,
                UpdateContext: resourceClusterOpenStackUpdate,
                DeleteContext: resourceClusterDelete,
                Importer: &amp;schema.ResourceImporter{
                        StateContext: resourceClusterOpenstackImport,
                },
                Description: "Resource for managing Openstack clusters in Spectro Cloud through Palette.",

                Timeouts: &amp;schema.ResourceTimeout{
                        Create: schema.DefaultTimeout(180 * time.Minute),
                        Update: schema.DefaultTimeout(180 * time.Minute),
                        Delete: schema.DefaultTimeout(180 * time.Minute),
                },
                SchemaVersion: 1,
                StateUpgraders: []schema.StateUpgrader{
                        {
                                Type:    resourceClusterOpenStackResourceV1().CoreConfigSchema().ImpliedType(),
                                Upgrade: resourceClusterOpenStackStateUpgradeV1,
                                Version: 0,
                        },
                },

                Schema: map[string]*schema.Schema{
                        "name": {
                                Type:     schema.TypeString,
                                Required: true,
                                ForceNew: true,
                        },
                        "context": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "project",
                                ValidateFunc: validation.StringInSlice([]string{"", "project", "tenant"}, false),
                                Description: "The context of the OpenStack cluster. Allowed values are `project` or `tenant`. " +
                                        "Default is `project`. " + PROJECT_NAME_NUANCE,
                        },
                        "tags": {
                                Type:     schema.TypeSet,
                                Optional: true,
                                Set:      schema.HashString,
                                Elem: &amp;schema.Schema{
                                        Type: schema.TypeString,
                                },
                                Description: "A list of tags to be applied to the cluster. Tags must be in the form of `key:value`.",
                        },
                        "description": {
                                Type:        schema.TypeString,
                                Optional:    true,
                                Default:     "",
                                Description: "The description of the cluster. Default value is empty string.",
                        },
                        "cluster_meta_attribute": {
                                Type:        schema.TypeString,
                                Optional:    true,
                                Description: "`cluster_meta_attribute` can be used to set additional cluster metadata information, eg `{'nic_name': 'test', 'env': 'stage'}`",
                        },
                        "cluster_profile":  schemas.ClusterProfileSchema(),
                        "cluster_template": schemas.ClusterTemplateSchema(),
                        "apply_setting": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "DownloadAndInstall",
                                ValidateFunc: validation.StringInSlice([]string{"DownloadAndInstall", "DownloadAndInstallLater"}, false),
                                Description: "The setting to apply the cluster profile. `DownloadAndInstall` will download and install packs in one action. " +
                                        "`DownloadAndInstallLater` will only download artifact and postpone install for later. " +
                                        "Default value is `DownloadAndInstall`.",
                        },
                        "cloud_account_id": {
                                Type:     schema.TypeString,
                                Required: true,
                                ForceNew: true,
                        },
                        "cloud_config_id": {
                                Type:        schema.TypeString,
                                Computed:    true,
                                Description: "ID of the cloud config used for the cluster. This cloud config must be of type `azure`.",
                                Deprecated:  "This field is deprecated and will be removed in the future. Use `cloud_config` instead.",
                        },
                        "review_repave_state": {
                                Type:         schema.TypeString,
                                Default:      "",
                                Optional:     true,
                                ValidateFunc: validateReviewRepaveValue,
                                Description:  "To authorize the cluster repave, set the value to `Approved` for approval and `\"\"` to decline. Default value is `\"\"`.",
                        },
                        "pause_agent_upgrades": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "unlock",
                                ValidateFunc: validation.StringInSlice([]string{"lock", "unlock"}, false),
                                Description:  "The pause agent upgrades setting allows to control the automatic upgrade of the Palette component and agent for an individual cluster. The default value is `unlock`, meaning upgrades occur automatically. Setting it to `lock` pauses automatic agent upgrades for the cluster.",
                        },
                        "os_patch_on_boot": {
                                Type:        schema.TypeBool,
                                Optional:    true,
                                Default:     false,
                                Description: "Whether to apply OS patch on boot. Default is `false`.",
                        },
                        "os_patch_schedule": {
                                Type:             schema.TypeString,
                                Optional:         true,
                                ValidateDiagFunc: validateOsPatchSchedule,
                                Description:      "Cron schedule for OS patching. This must be in the form of `0 0 * * *`.",
                        },
                        "os_patch_after": {
                                Type:             schema.TypeString,
                                Optional:         true,
                                ValidateDiagFunc: validateOsPatchOnDemandAfter,
                                Description:      "The date and time after which to patch the cluster. Prefix the time value with the respective RFC. Ex: `RFC3339: 2006-01-02T15:04:05Z07:00`",
                        },
                        "cluster_timezone": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "",
                                ValidateFunc: validateTimezone,
                                Description:  "Defines the time zone used by this cluster to interpret scheduled operations. Maintenance tasks like upgrades will follow this time zone to ensure they run at the appropriate local time for the cluster. Must be in IANA timezone format (e.g., 'America/New_York', 'Asia/Kolkata', 'Europe/London').",
                        },
                        "kubeconfig": {
                                Type:        schema.TypeString,
                                Computed:    true,
                                Description: "Kubeconfig for the cluster. This can be used to connect to the cluster using `kubectl`.",
                        },
                        "admin_kube_config": {
                                Type:        schema.TypeString,
                                Computed:    true,
                                Description: "Admin Kube-config for the cluster. This can be used to connect to the cluster using `kubectl`, With admin privilege.",
                        },
                        "cloud_config": {
                                Type:     schema.TypeList,
                                ForceNew: true,
                                Required: true,
                                MaxItems: 1,
                                Elem: &amp;schema.Resource{
                                        Schema: map[string]*schema.Schema{
                                                "domain": {
                                                        Type:     schema.TypeString,
                                                        Required: true,
                                                },
                                                "region": {
                                                        Type:     schema.TypeString,
                                                        Required: true,
                                                },
                                                "project": {
                                                        Type:     schema.TypeString,
                                                        Required: true,
                                                },
                                                "ssh_key": {
                                                        Type:        schema.TypeString,
                                                        Required:    true,
                                                        Description: "Public SSH key to be used for the cluster nodes.",
                                                },
                                                "network_id": {
                                                        Type:     schema.TypeString,
                                                        Optional: true,
                                                },
                                                "subnet_id": {
                                                        Type:     schema.TypeString,
                                                        Optional: true,
                                                },
                                                "dns_servers": {
                                                        Type:     schema.TypeSet,
                                                        Required: true,
                                                        ForceNew: true,
                                                        Set:      schema.HashString,
                                                        Elem: &amp;schema.Schema{
                                                                Type: schema.TypeString,
                                                        },
                                                },
                                                "subnet_cidr": {
                                                        Type:     schema.TypeString,
                                                        Required: true,
                                                },
                                        },
                                },
                        },
                        "machine_pool": {
                                Type:     schema.TypeSet,
                                Required: true,
                                Set:      resourceMachinePoolOpenStackHash,
                                Elem: &amp;schema.Resource{
                                        Schema: map[string]*schema.Schema{
                                                "additional_labels": {
                                                        Type:     schema.TypeMap,
                                                        Optional: true,
                                                        Elem: &amp;schema.Schema{
                                                                Type: schema.TypeString,
                                                        },
                                                        Description: "Additional labels to be applied to the machine pool. Labels must be in the form of `key:value`.",
                                                },
                                                "additional_annotations": {
                                                        Type:     schema.TypeMap,
                                                        Optional: true,
                                                        Elem: &amp;schema.Schema{
                                                                Type: schema.TypeString,
                                                        },
                                                        Description: "Additional annotations to be applied to the machine pool. Annotations must be in the form of `key:value`.",
                                                },
                                                "taints": schemas.ClusterTaintsSchema(),
                                                "node":   schemas.NodeSchema(),
                                                "control_plane": {
                                                        Type:        schema.TypeBool,
                                                        Optional:    true,
                                                        Default:     false,
                                                        Description: "Whether this machine pool is a control plane. Defaults to `false`.",
                                                },
                                                "control_plane_as_worker": {
                                                        Type:     schema.TypeBool,
                                                        Optional: true,
                                                        Default:  false,
                                                        //ForceNew: true,
                                                        Description: "Whether this machine pool is a control plane and a worker. Defaults to `false`.",
                                                },
                                                "name": {
                                                        Type:     schema.TypeString,
                                                        Required: true,
                                                },
                                                "count": {
                                                        Type:        schema.TypeInt,
                                                        Required:    true,
                                                        Description: "Number of nodes in the machine pool.",
                                                },
                                                "node_repave_interval": {
                                                        Type:        schema.TypeInt,
                                                        Optional:    true,
                                                        Default:     0,
                                                        Description: "Minimum number of seconds node should be Ready, before the next node is selected for repave. Default value is `0`, Applicable only for worker pools.",
                                                },
                                                "update_strategy": {
                                                        Type:         schema.TypeString,
                                                        Optional:     true,
                                                        Default:      "RollingUpdateScaleOut",
                                                        Description:  "Update strategy for the machine pool. Valid values are `RollingUpdateScaleOut`, `RollingUpdateScaleIn` and `OverrideScaling`. If `OverrideScaling` is used, `override_scaling` must be specified with both `max_surge` and `max_unavailable`.",
                                                        ValidateFunc: validation.StringInSlice([]string{"RollingUpdateScaleOut", "RollingUpdateScaleIn", "OverrideScaling"}, false),
                                                },
                                                "override_scaling": schemas.OverrideScalingSchema(),
                                                "override_kubeadm_configuration": {
                                                        Type:        schema.TypeString,
                                                        Optional:    true,
                                                        Description: "YAML config for kubeletExtraArgs, preKubeadmCommands, postKubeadmCommands. Overrides pack-level settings. Worker pools only.",
                                                },
                                                "instance_type": {
                                                        Type:     schema.TypeString,
                                                        Required: true,
                                                },
                                                "azs": {
                                                        Type:     schema.TypeSet,
                                                        Optional: true,
                                                        Elem: &amp;schema.Schema{
                                                                Type: schema.TypeString,
                                                        },
                                                },
                                                "subnet_id": {
                                                        Type:     schema.TypeString,
                                                        Optional: true,
                                                },
                                        },
                                },
                        },
                        "backup_policy":        schemas.BackupPolicySchema(),
                        "scan_policy":          schemas.ScanPolicySchema(),
                        "cluster_rbac_binding": schemas.ClusterRbacBindingSchema(),
                        "namespaces":           schemas.ClusterNamespacesSchema(),
                        "host_config":          schemas.ClusterHostConfigSchema(),
                        "location_config":      schemas.ClusterLocationSchema(),
                        "skip_completion": {
                                Type:        schema.TypeBool,
                                Optional:    true,
                                Default:     false,
                                Description: "If `true`, the cluster will be created asynchronously. Default value is `false`.",
                        },
                        "force_delete": {
                                Type:        schema.TypeBool,
                                Optional:    true,
                                Default:     false,
                                Description: "If set to `true`, the cluster will be force deleted and user has to manually clean up the provisioned cloud resources.",
                        },
                        "force_delete_delay": {
                                Type:             schema.TypeInt,
                                Optional:         true,
                                Default:          20,
                                Description:      "Delay duration in minutes to before invoking cluster force delete. Default and minimum is 20.",
                                ValidateDiagFunc: validation.ToDiagFunc(validation.IntAtLeast(20)),
                        },
                },
        }
}</span>

func resourceClusterOpenStackCreate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        resourceContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, resourceContext)

        // Warning or errors can be collected in a slice type
        var diags diag.Diagnostics

        // Validate override_Scaling configuration
        if err := validateOverrideScaling(d, "machine_pool"); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">cluster, err := toOpenStackCluster(c, d)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">uid, err := c.CreateClusterOpenStack(cluster)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">diagnostics, isError := waitForClusterCreation(ctx, d, uid, diags, c, true)
        if len(diagnostics) &gt; 0 </span><span class="cov0" title="0">{
                diags = append(diags, diagnostics...)
        }</span>
        <span class="cov0" title="0">if isError </span><span class="cov0" title="0">{
                return diagnostics
        }</span>
        <span class="cov0" title="0">resourceClusterOpenStackRead(ctx, d, m)

        return diags</span>
}

func toOpenStackCluster(c *client.V1Client, d *schema.ResourceData) (*models.V1SpectroOpenStackClusterEntity, error) <span class="cov0" title="0">{
        cloudConfig := d.Get("cloud_config").([]interface{})[0].(map[string]interface{})

        clusterContext := d.Get("context").(string)
        profiles, err := toProfiles(c, d, clusterContext)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">cluster := &amp;models.V1SpectroOpenStackClusterEntity{
                Metadata: getClusterMetadata(d),
                Spec: &amp;models.V1SpectroOpenStackClusterEntitySpec{
                        CloudAccountUID: types.Ptr(d.Get("cloud_account_id").(string)),
                        Profiles:        profiles,
                        ClusterTemplate: toClusterTemplateReference(d),
                        Policies:        toPolicies(d),
                        CloudConfig: &amp;models.V1OpenStackClusterConfig{
                                Region:     cloudConfig["region"].(string),
                                SSHKeyName: cloudConfig["ssh_key"].(string),
                                Domain: &amp;models.V1OpenStackResource{
                                        ID:   cloudConfig["domain"].(string),
                                        Name: cloudConfig["domain"].(string),
                                },
                                Network: &amp;models.V1OpenStackResource{
                                        ID: cloudConfig["network_id"].(string),
                                },
                                Project: &amp;models.V1OpenStackResource{
                                        Name: cloudConfig["project"].(string),
                                },
                                Subnet: &amp;models.V1OpenStackResource{
                                        ID: cloudConfig["subnet_id"].(string),
                                },
                                NodeCidr: cloudConfig["subnet_cidr"].(string),
                        },
                },
        }

        if cloudConfig["dns_servers"] != nil </span><span class="cov0" title="0">{
                dnsServers := make([]string, 0)
                for _, dns := range cloudConfig["dns_servers"].(*schema.Set).List() </span><span class="cov0" title="0">{
                        dnsServers = append(dnsServers, dns.(string))
                }</span>

                <span class="cov0" title="0">cluster.Spec.CloudConfig.DNSNameservers = dnsServers</span>
        }

        <span class="cov0" title="0">machinePoolConfigs := make([]*models.V1OpenStackMachinePoolConfigEntity, 0)

        for _, machinePool := range d.Get("machine_pool").(*schema.Set).List() </span><span class="cov0" title="0">{
                mp, err := toMachinePoolOpenStack(machinePool)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">machinePoolConfigs = append(machinePoolConfigs, mp)</span>
        }

        // sort
        <span class="cov0" title="0">sort.SliceStable(machinePoolConfigs, func(i, j int) bool </span><span class="cov0" title="0">{
                return machinePoolConfigs[i].PoolConfig.IsControlPlane
        }</span>)

        <span class="cov0" title="0">cluster.Spec.Machinepoolconfig = machinePoolConfigs
        cluster.Spec.ClusterConfig = toClusterConfig(d)

        return cluster, nil</span>
}

//goland:noinspection GoUnhandledErrorResult
func resourceClusterOpenStackRead(_ context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        resourceContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, resourceContext)

        var diags diag.Diagnostics

        cluster, err := resourceClusterRead(d, c, diags)
        if err != nil </span><span class="cov0" title="0">{
                return handleReadError(d, err, diags)
        }</span> else<span class="cov0" title="0"> if cluster == nil </span><span class="cov0" title="0">{
                // Deleted - Terraform will recreate it
                d.SetId("")
                return diags
        }</span>

        <span class="cov0" title="0">err = ValidateCloudType("spectrocloud_cluster_openstack", cluster)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">configUID := cluster.Spec.CloudConfigRef.UID
        if err := d.Set("cloud_config_id", configUID); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">if config, err := c.GetCloudConfigOpenStack(configUID); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span> else<span class="cov0" title="0"> {
                if config.Spec != nil &amp;&amp; config.Spec.CloudAccountRef != nil </span><span class="cov0" title="0">{
                        if err := d.Set("cloud_account_id", config.Spec.CloudAccountRef.UID); err != nil </span><span class="cov0" title="0">{
                                return diag.FromErr(err)
                        }</span>
                }
                <span class="cov0" title="0">if err := d.Set("cloud_config", flattenClusterConfigsOpenstack(config)); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>

                <span class="cov0" title="0">mp := flattenMachinePoolConfigsOpenStack(config.Spec.MachinePoolConfig)
                mp, err := flattenNodeMaintenanceStatus(c, d, c.GetNodeStatusMapOpenStack, mp, configUID)
                if err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
                <span class="cov0" title="0">if err := d.Set("machine_pool", mp); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
        }

        <span class="cov0" title="0">diagnostics, done := readCommonFields(c, d, cluster)
        if done </span><span class="cov0" title="0">{
                return diagnostics
        }</span>

        // Flatten cluster_template variables using variables API
        <span class="cov0" title="0">if err := flattenClusterTemplateVariables(c, d, d.Id()); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">generalWarningForRepave(&amp;diags)
        return diags</span>
}

func flattenClusterConfigsOpenstack(config *models.V1OpenStackCloudConfig) []interface{} <span class="cov0" title="0">{
        if config == nil || config.Spec == nil || config.Spec.ClusterConfig == nil </span><span class="cov0" title="0">{
                return make([]interface{}, 0)
        }</span>

        <span class="cov0" title="0">cloudConfig := make(map[string]interface{})

        if config.Spec.ClusterConfig.Domain != nil </span><span class="cov0" title="0">{
                cloudConfig["domain"] = config.Spec.ClusterConfig.Domain.Name
        }</span>
        <span class="cov0" title="0">if config.Spec.ClusterConfig.Region != "" </span><span class="cov0" title="0">{
                cloudConfig["region"] = config.Spec.ClusterConfig.Region
        }</span>
        <span class="cov0" title="0">if config.Spec.ClusterConfig.Project != nil </span><span class="cov0" title="0">{
                cloudConfig["project"] = config.Spec.ClusterConfig.Project.Name
        }</span>
        <span class="cov0" title="0">if config.Spec.ClusterConfig.SSHKeyName != "" </span><span class="cov0" title="0">{
                cloudConfig["ssh_key"] = config.Spec.ClusterConfig.SSHKeyName
        }</span>
        <span class="cov0" title="0">if config.Spec.ClusterConfig.Network != nil </span><span class="cov0" title="0">{
                cloudConfig["network_id"] = config.Spec.ClusterConfig.Network.ID
        }</span>
        <span class="cov0" title="0">if config.Spec.ClusterConfig.Subnet != nil </span><span class="cov0" title="0">{
                cloudConfig["subnet_id"] = config.Spec.ClusterConfig.Subnet.ID
        }</span>
        <span class="cov0" title="0">if config.Spec.ClusterConfig.DNSNameservers != nil </span><span class="cov0" title="0">{
                cloudConfig["dns_servers"] = config.Spec.ClusterConfig.DNSNameservers
        }</span>
        <span class="cov0" title="0">if config.Spec.ClusterConfig.NodeCidr != "" </span><span class="cov0" title="0">{
                cloudConfig["subnet_cidr"] = config.Spec.ClusterConfig.NodeCidr
        }</span>

        <span class="cov0" title="0">return []interface{}{cloudConfig}</span>
}

func flattenMachinePoolConfigsOpenStack(machinePools []*models.V1OpenStackMachinePoolConfig) []interface{} <span class="cov0" title="0">{
        if machinePools == nil </span><span class="cov0" title="0">{
                return make([]interface{}, 0)
        }</span>

        <span class="cov0" title="0">ois := make([]interface{}, 0)

        for _, machinePool := range machinePools </span><span class="cov0" title="0">{
                oi := make(map[string]interface{})

                FlattenAdditionalLabelsAnnotationsAndTaints(machinePool.AdditionalLabels, machinePool.AdditionalAnnotations, machinePool.Taints, oi)
                FlattenControlPlaneAndRepaveInterval(&amp;machinePool.IsControlPlane, oi, machinePool.NodeRepaveInterval)

                oi["control_plane_as_worker"] = machinePool.UseControlPlaneAsWorker
                oi["name"] = machinePool.Name
                oi["count"] = int(machinePool.Size)
                if machinePool.UpdateStrategy != nil &amp;&amp; machinePool.UpdateStrategy.Type != "" </span><span class="cov0" title="0">{
                        oi["update_strategy"] = machinePool.UpdateStrategy.Type
                        // Flatten override_Scaling if using OverrideScaling strategy
                        flattenOverrideScaling(machinePool.UpdateStrategy, oi)
                }</span> else<span class="cov0" title="0"> {
                        oi["update_strategy"] = "RollingUpdateScaleOut"
                }</span>

                // Flatten override_kubeadm_configuration (worker pools only)
                <span class="cov0" title="0">if !machinePool.IsControlPlane &amp;&amp; machinePool.OverrideKubeadmConfiguration != "" </span><span class="cov0" title="0">{
                        oi["override_kubeadm_configuration"] = machinePool.OverrideKubeadmConfiguration
                }</span>

                <span class="cov0" title="0">oi["subnet_id"] = machinePool.Subnet.ID
                oi["azs"] = machinePool.Azs
                oi["instance_type"] = machinePool.FlavorConfig.Name

                ois = append(ois, oi)</span>
        }

        <span class="cov0" title="0">return ois</span>
}

func resourceClusterOpenStackUpdate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        resourceContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, resourceContext)

        // Warning or errors can be collected in a slice type
        var diags diag.Diagnostics
        err := validateSystemRepaveApproval(d, c)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">cloudConfigId := d.Get("cloud_config_id").(string)
        CloudConfig, err := c.GetCloudConfigOpenStack(cloudConfigId)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">if d.HasChange("machine_pool") </span><span class="cov0" title="0">{
                // Validate override_Scaling configuration
                if err := validateOverrideScaling(d, "machine_pool"); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>

                <span class="cov0" title="0">log.Printf("[DEBUG] === MACHINE POOL CHANGE DETECTED ===")
                oraw, nraw := d.GetChange("machine_pool")
                if oraw == nil </span><span class="cov0" title="0">{
                        oraw = new(schema.Set)
                }</span>
                <span class="cov0" title="0">if nraw == nil </span><span class="cov0" title="0">{
                        nraw = new(schema.Set)
                }</span>

                <span class="cov0" title="0">os := oraw.(*schema.Set)
                ns := nraw.(*schema.Set)

                osMap := make(map[string]interface{})
                for _, mp := range os.List() </span><span class="cov0" title="0">{
                        machinePoolResource := mp.(map[string]interface{})
                        name := machinePoolResource["name"].(string)
                        if name != "" </span><span class="cov0" title="0">{
                                osMap[name] = machinePoolResource
                        }</span>
                }
                <span class="cov0" title="0">nsMap := make(map[string]interface{})
                for _, mp := range ns.List() </span><span class="cov0" title="0">{
                        machinePoolResource := mp.(map[string]interface{})
                        name := machinePoolResource["name"].(string)
                        if name != "" </span><span class="cov0" title="0">{
                                nsMap[name] = machinePoolResource
                                if oldMachinePool, exists := osMap[name]; !exists </span><span class="cov0" title="0">{
                                        log.Printf("[DEBUG] Create machine pool %s", name)
                                        machinePool, err := toMachinePoolOpenStack(machinePoolResource)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return diag.FromErr(err)
                                        }</span>
                                        <span class="cov0" title="0">if err := c.CreateMachinePoolOpenStack(cloudConfigId, machinePool); err != nil </span><span class="cov0" title="0">{
                                                return diag.FromErr(err)
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        oldHash := resourceMachinePoolOpenStackHash(oldMachinePool)
                                        newHash := resourceMachinePoolOpenStackHash(machinePoolResource)

                                        if oldHash != newHash </span><span class="cov0" title="0">{
                                                log.Printf("[DEBUG] Updating machine pool %s (hash changed: %d -&gt; %d)", name, oldHash, newHash)
                                                machinePool, err := toMachinePoolOpenStack(machinePoolResource)
                                                if err != nil </span><span class="cov0" title="0">{
                                                        return diag.FromErr(err)
                                                }</span>
                                                <span class="cov0" title="0">if err := c.UpdateMachinePoolOpenStack(cloudConfigId, machinePool); err != nil </span><span class="cov0" title="0">{
                                                        return diag.FromErr(err)
                                                }</span>
                                                <span class="cov0" title="0">err = resourceNodeAction(c, ctx, machinePoolResource, c.GetNodeMaintenanceStatusOpenStack, CloudConfig.Kind, cloudConfigId, name)
                                                if err != nil </span><span class="cov0" title="0">{
                                                        return diag.FromErr(err)
                                                }</span>
                                        } else<span class="cov0" title="0"> {
                                                log.Printf("[DEBUG] Machine pool %s unchanged (hash: %d)", name, oldHash)
                                        }</span>
                                }
                                <span class="cov0" title="0">delete(osMap, name)</span>
                        }
                }

                // REMOVED machine pools - DELETE
                <span class="cov0" title="0">for name := range osMap </span><span class="cov0" title="0">{
                        log.Printf("[DEBUG] Deleting removed machine pool %s", name)
                        if err := c.DeleteMachinePoolOpenStack(cloudConfigId, name); err != nil </span><span class="cov0" title="0">{
                                return diag.FromErr(err)
                        }</span>
                }
        }

        <span class="cov0" title="0">diagnostics, done := updateCommonFields(d, c)
        if done </span><span class="cov0" title="0">{
                return diagnostics
        }</span>

        <span class="cov0" title="0">resourceClusterOpenStackRead(ctx, d, m)

        return diags</span>
}

func toMachinePoolOpenStack(machinePool interface{}) (*models.V1OpenStackMachinePoolConfigEntity, error) <span class="cov0" title="0">{
        m := machinePool.(map[string]interface{})

        labels := make([]string, 0)
        controlPlane := m["control_plane"].(bool)
        controlPlaneAsWorker := m["control_plane_as_worker"].(bool)
        if controlPlane </span><span class="cov0" title="0">{
                labels = append(labels, "control-plane")
        }</span> else<span class="cov0" title="0"> {
                labels = append(labels, "worker")
        }</span>

        <span class="cov0" title="0">azs := make([]string, 0)
        if _, ok := m["azs"]; ok &amp;&amp; m["azs"] != nil </span><span class="cov0" title="0">{
                azsSet := m["azs"].(*schema.Set)
                for _, val := range azsSet.List() </span><span class="cov0" title="0">{
                        azs = append(azs, val.(string))
                }</span>
        }

        <span class="cov0" title="0">mp := &amp;models.V1OpenStackMachinePoolConfigEntity{
                CloudConfig: &amp;models.V1OpenStackMachinePoolCloudConfigEntity{
                        Azs: azs,
                        Subnet: &amp;models.V1OpenStackResource{
                                ID: m["subnet_id"].(string),
                        },
                        FlavorConfig: &amp;models.V1OpenstackFlavorConfig{
                                Name: types.Ptr(m["instance_type"].(string)),
                        },
                },
                PoolConfig: &amp;models.V1MachinePoolConfigEntity{
                        AdditionalLabels:        toAdditionalNodePoolLabels(m),
                        AdditionalAnnotations:   toAdditionalNodePoolAnnotations(m),
                        Taints:                  toClusterTaints(m),
                        IsControlPlane:          controlPlane,
                        Labels:                  labels,
                        Name:                    types.Ptr(m["name"].(string)),
                        Size:                    types.Ptr(SafeInt32(m["count"].(int))),
                        UpdateStrategy:          toUpdateStrategy(m),
                        UseControlPlaneAsWorker: controlPlaneAsWorker,
                },
        }

        // Handle override_kubeadm_configuration (worker pools only)
        if !controlPlane </span><span class="cov0" title="0">{
                if overrideKubeadm, ok := m["override_kubeadm_configuration"].(string); ok &amp;&amp; overrideKubeadm != "" </span><span class="cov0" title="0">{
                        mp.PoolConfig.OverrideKubeadmConfiguration = overrideKubeadm
                }</span>
        }

        <span class="cov0" title="0">if !controlPlane </span><span class="cov0" title="0">{
                nodeRepaveInterval := 0
                if m["node_repave_interval"] != nil </span><span class="cov0" title="0">{
                        nodeRepaveInterval = m["node_repave_interval"].(int)
                }</span>
                <span class="cov0" title="0">mp.PoolConfig.NodeRepaveInterval = SafeInt32(nodeRepaveInterval)</span>
        } else<span class="cov0" title="0"> {
                err := ValidationNodeRepaveIntervalForControlPlane(m["node_repave_interval"].(int))
                if err != nil </span><span class="cov0" title="0">{
                        return mp, err
                }</span>
        }

        <span class="cov0" title="0">return mp, nil</span>
}

func resourceClusterOpenStackStateUpgradeV1(ctx context.Context, rawState map[string]interface{}, meta interface{}) (map[string]interface{}, error) <span class="cov0" title="0">{
        log.Printf("[DEBUG] Upgrading cluster OpenStack state from version 2 to 3")

        // Convert machine_pool from TypeList to TypeSet
        // Note: We keep the data as a list in rawState and let Terraform's schema processing
        // convert it to TypeSet when loading the resource using the schema. This avoids JSON serialization
        // issues with schema.Set objects that contain hash functions.
        if machinePoolRaw, exists := rawState["machine_pool"]; exists </span><span class="cov0" title="0">{
                if machinePoolList, ok := machinePoolRaw.([]interface{}); ok </span><span class="cov0" title="0">{
                        log.Printf("[DEBUG] Keeping machine_pool as list during state upgrade with %d items", len(machinePoolList))

                        // Keep the machine pool data as-is (as a list)
                        // Terraform will convert it to TypeSet when loading the resource using the schema
                        rawState["machine_pool"] = machinePoolList

                        log.Printf("[DEBUG] Successfully prepared machine_pool for TypeSet conversion")
                }</span> else<span class="cov0" title="0"> {
                        log.Printf("[DEBUG] machine_pool is not a list, skipping conversion")
                }</span>
        } else<span class="cov0" title="0"> {
                log.Printf("[DEBUG] No machine_pool found in state, skipping conversion")
        }</span>

        <span class="cov0" title="0">return rawState, nil</span>
}
</pre>
		
		<pre class="file" id="file152" style="display: none">package spectrocloud

import (
        "context"
        "fmt"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
)

func resourceClusterOpenstackImport(ctx context.Context, d *schema.ResourceData, m interface{}) ([]*schema.ResourceData, error) <span class="cov0" title="0">{
        // m is the client, which can be used to make API requests to the infrastructure
        c, err := GetCommonCluster(d, m)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">diags := resourceClusterOpenStackRead(ctx, d, m)
        if diags.HasError() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("could not read cluster for import: %v", diags)
        }</span>

        // cluster profile and common default cluster attribute is get set here
        <span class="cov0" title="0">err = flattenCommonAttributeForClusterImport(c, d)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Return the resource data. In most cases, this method is only used to
        // import one resource at a time, so you should return the resource data
        // in a slice with a single element.
        <span class="cov0" title="0">return []*schema.ResourceData{d}, nil</span>
}
</pre>
		
		<pre class="file" id="file153" style="display: none">package spectrocloud

import (
        "context"
        "fmt"

        "github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/schemas"
        "github.com/spectrocloud/terraform-provider-spectrocloud/types"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"

        "log"
        "strings"
        "time"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/spectrocloud/palette-sdk-go/api/models"
        "github.com/spectrocloud/palette-sdk-go/client"
)

func resourceClusterProfile() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                CreateContext: resourceClusterProfileCreate,
                ReadContext:   resourceClusterProfileRead,
                UpdateContext: resourceClusterProfileUpdate,
                DeleteContext: resourceClusterProfileDelete,
                Importer: &amp;schema.ResourceImporter{
                        StateContext: resourceClusterProfileImport,
                },
                Description: "The Cluster Profile resource allows you to create and manage cluster profiles.",

                Timeouts: &amp;schema.ResourceTimeout{
                        Create: schema.DefaultTimeout(20 * time.Second),
                        Update: schema.DefaultTimeout(20 * time.Second),
                        Delete: schema.DefaultTimeout(20 * time.Second),
                },

                Schema: map[string]*schema.Schema{
                        "name": {
                                Type:     schema.TypeString,
                                Required: true,
                        },
                        "version": {
                                Type:     schema.TypeString,
                                Optional: true,
                                Default:  "1.0.0", // default as in UI
                                Description: "Version of the cluster profile. Defaults to '1.0.0'. " +
                                        "**Important**: Modifying this value will only update the version number of the existing cluster profile. " +
                                        "It will NOT create a new version in Palette. " +
                                        "To create a new version of a cluster profile, refer to the example at: " +
                                        "https://github.com/spectrocloud/spectro-samples/tree/main/terraform/cluster-profiles",
                        },
                        "context": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "project",
                                ValidateFunc: validation.StringInSlice([]string{"", "project", "tenant", "system"}, false),
                                Description: "The context of the cluster profile. Allowed values are `project` or `tenant`. " +
                                        "Default value is `project`. " + PROJECT_NAME_NUANCE,
                        },
                        "tags": {
                                Type:     schema.TypeSet,
                                Optional: true,
                                Set:      schema.HashString,
                                Elem: &amp;schema.Schema{
                                        Type: schema.TypeString,
                                },
                                Description: "A list of tags to be applied to the cluster. Tags must be in the form of `key:value`.",
                        },
                        "description": {
                                Type:     schema.TypeString,
                                Optional: true,
                        },
                        "cloud": {
                                Type:     schema.TypeString,
                                Default:  "all",
                                Optional: true,
                                // Removing validation to support custom clouds
                                // ValidateFunc: validation.StringInSlice([]string{"all", "aws", "azure", "gcp", "vsphere", "openstack", "maas", "virtual", "baremetal", "eks", "aks", "edge", "edge-native", "generic", "gke"}, false),
                                ForceNew: true,
                                Description: "Specify the infrastructure provider the cluster profile is for. Only Palette supported infrastructure providers can be used. The supported cloud types are - `all, aws, azure, gcp, vsphere, openstack, maas, virtual, baremetal, eks, aks, edge-native, generic, and gke` or any custom cloud provider registered in Palette, e.g., `nutanix`." +
                                        "If the value is set to `all`, then the type must be set to `add-on`. Otherwise, the cluster profile may be incompatible with other providers. Default value is `all`.",
                        },
                        "type": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "add-on",
                                ValidateFunc: validation.StringInSlice([]string{"add-on", "cluster", "infra", "system"}, false),
                                Description:  "Specify the cluster profile type to use. Allowed values are `cluster`, `infra`, `add-on`, and `system`. These values map to the following User Interface (UI) labels. Use the value ' cluster ' for a **Full** cluster profile." + "For an Infrastructure cluster profile, use the value `infra`; for an Add-on cluster profile, use the value `add-on`." + "System cluster profiles can be specified using the value `system`. To learn more about cluster profiles, refer to the [Cluster Profile](https://docs.spectrocloud.com/cluster-profiles) documentation. Default value is `add-on`.",
                                ForceNew:     true,
                        },
                        "profile_variables": schemas.ProfileVariables(),
                        "pack":              schemas.PackSchema(),
                },
        }
}</span>

func resourceClusterProfileCreate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        ProfileContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, ProfileContext)

        // Warning or errors can be collected in a slice type
        var diags diag.Diagnostics

        clusterProfile, err := toClusterProfileCreateWithResolution(d, c)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        // Create
        <span class="cov0" title="0">uid, err := c.CreateClusterProfile(clusterProfile)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        // And then publish
        <span class="cov0" title="0">if err = c.PublishClusterProfile(uid); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">d.SetId(uid)
        resourceClusterProfileRead(ctx, d, m)
        return diags</span>
}

func resourceClusterProfileRead(_ context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        ProfileContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, ProfileContext)

        var diags diag.Diagnostics

        cp, err := c.GetClusterProfile(d.Id())
        if err != nil </span><span class="cov0" title="0">{
                return handleReadError(d, err, diags)
        }</span> else<span class="cov0" title="0"> if cp == nil </span><span class="cov0" title="0">{
                // Deleted - Terraform will recreate it
                d.SetId("")
                return diags
        }</span>

        <span class="cov0" title="0">err = flattenClusterProfileCommon(d, cp)
        if err != nil </span><span class="cov0" title="0">{
                diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">tags := flattenTags(cp.Metadata.Labels)
        if tags != nil </span><span class="cov0" title="0">{
                if err := d.Set("tags", tags); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
        }

        <span class="cov0" title="0">packManifests, d2, done2 := getPacksContent(cp.Spec.Published.Packs, c, d)
        if done2 </span><span class="cov0" title="0">{
                return d2
        }</span>

        <span class="cov0" title="0">err = d.Set("name", cp.Metadata.Name)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        // Profile variables
        <span class="cov0" title="0">profileVariables, err := c.GetProfileVariables(d.Id())
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">pv, err := flattenProfileVariables(d, profileVariables)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">err = d.Set("profile_variables", pv)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">diagPacks, diagnostics, done := GetDiagPacks(d, err)
        if done </span><span class="cov0" title="0">{
                return diagnostics
        }</span>
        // Build registry maps to track which packs use registry_name or registry_uid
        <span class="cov0" title="0">registryNameMap := buildPackRegistryNameMap(d)
        registryUIDMap := buildPackRegistryUIDMap(d)
        packs, err := flattenPacksWithRegistryMaps(c, diagPacks, cp.Spec.Published.Packs, packManifests, registryNameMap, registryUIDMap)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">if err := d.Set("pack", packs); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">return diags</span>
}

func flattenClusterProfileCommon(d *schema.ResourceData, cp *models.V1ClusterProfile) error <span class="cov0" title="0">{
        // set cloud
        if err := d.Set("cloud", cp.Spec.Published.CloudType); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // set type
        <span class="cov0" title="0">if err := d.Set("type", cp.Spec.Published.Type); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // set version
        <span class="cov0" title="0">if err := d.Set("version", cp.Spec.Published.ProfileVersion); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func resourceClusterProfileUpdate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        ProfileContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, ProfileContext)

        // Warning or errors can be collected in a slice type
        var diags diag.Diagnostics

        if d.HasChanges("profile_variables") </span><span class="cov0" title="0">{
                pvs, err := toClusterProfileVariables(d)
                if err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
                <span class="cov0" title="0">mVars := &amp;models.V1Variables{
                        Variables: pvs,
                }
                err = c.UpdateProfileVariables(mVars, d.Id())
                if err != nil </span><span class="cov0" title="0">{
                        oldVariables, _ := d.GetChange("profile_variables")
                        _ = d.Set("profile_variables", oldVariables)
                        return diag.FromErr(err)
                }</span>
        }

        <span class="cov0" title="0">if d.HasChanges("name") || d.HasChanges("tags") || d.HasChanges("pack") || d.HasChanges("description") || d.HasChanges("version") </span><span class="cov0" title="0">{
                log.Printf("Updating packs")
                cp, err := c.GetClusterProfile(d.Id())
                if err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
                <span class="cov0" title="0">cluster, err := toClusterProfileUpdateWithResolution(d, cp, c)
                if err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
                <span class="cov0" title="0">metadata, err := toClusterProfilePatch(d)
                if err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>

                //ProfileContext := d.Get("context").(string)
                <span class="cov0" title="0">if err := c.UpdateClusterProfile(cluster); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
                <span class="cov0" title="0">if err := c.PatchClusterProfile(cluster, metadata); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
                <span class="cov0" title="0">if err := c.PublishClusterProfile(cluster.Metadata.UID); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
        }

        <span class="cov0" title="0">resourceClusterProfileRead(ctx, d, m)

        return diags</span>
}

func resourceClusterProfileDelete(_ context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        ProfileContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, ProfileContext)

        var diags diag.Diagnostics

        if err := c.DeleteClusterProfile(d.Id()); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">return diags</span>
}

func toClusterProfileCreateWithResolution(d *schema.ResourceData, c *client.V1Client) (*models.V1ClusterProfileEntity, error) <span class="cov0" title="0">{
        cp := toClusterProfileBasic(d)

        packs := make([]*models.V1PackManifestEntity, 0)
        for _, pack := range d.Get("pack").([]interface{}) </span><span class="cov0" title="0">{
                if p, e := toClusterProfilePackCreateWithResolution(pack, c); e != nil </span><span class="cov0" title="0">{
                        return nil, e
                }</span> else<span class="cov0" title="0"> {
                        packs = append(packs, p)
                }</span>
        }
        <span class="cov0" title="0">cp.Spec.Template.Packs = packs
        if profileVariable, err := toClusterProfileVariables(d); err == nil </span><span class="cov0" title="0">{
                cp.Spec.Variables = profileVariable
        }</span> else<span class="cov0" title="0"> {
                return cp, err
        }</span>
        <span class="cov0" title="0">return cp, nil</span>
}

func toClusterProfileBasic(d *schema.ResourceData) *models.V1ClusterProfileEntity <span class="cov0" title="0">{
        description := ""
        if d.Get("description") != nil </span><span class="cov0" title="0">{
                description = d.Get("description").(string)
        }</span>
        <span class="cov0" title="0">cp := &amp;models.V1ClusterProfileEntity{
                Metadata: &amp;models.V1ObjectMeta{
                        Name: d.Get("name").(string),
                        UID:  d.Id(),
                        Annotations: map[string]string{
                                "description": description,
                        },
                        Labels: toTags(d),
                },
                Spec: &amp;models.V1ClusterProfileEntitySpec{
                        Template: &amp;models.V1ClusterProfileTemplateDraft{
                                CloudType: d.Get("cloud").(string),
                                Type:      types.Ptr(models.V1ProfileType(d.Get("type").(string))),
                        },
                        Version: d.Get("version").(string),
                },
        }
        return cp</span>
}

func toClusterProfilePackCreate(pSrc interface{}) (*models.V1PackManifestEntity, error) <span class="cov0" title="0">{
        p := pSrc.(map[string]interface{})

        pName := p["name"].(string)
        pTag := p["tag"].(string)
        pUID := p["uid"].(string)
        pRegistryUID := ""
        if p["registry_uid"] != nil </span><span class="cov0" title="0">{
                pRegistryUID = p["registry_uid"].(string)
        }</span>
        <span class="cov0" title="0">pRegistryName := ""
        if p["registry_name"] != nil </span><span class="cov0" title="0">{
                pRegistryName = p["registry_name"].(string)
        }</span>
        <span class="cov0" title="0">pType := models.V1PackType(p["type"].(string))

        // Validate pack UID or resolution fields
        if err := schemas.ValidatePackUIDOrResolutionFields(p); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Note: registry_name is stored but not resolved here since we don't have client
        // Actual resolution will happen in toClusterProfilePackCreateWithResolution

        <span class="cov0" title="0">switch pType </span>{
        case models.V1PackTypeSpectro:<span class="cov0" title="0">
                if pUID == "" </span><span class="cov0" title="0">{
                        // UID not provided, validation already passed, so we have all resolution fields
                        // This path should not be reached if validation is working correctly
                        if pTag == "" || (pRegistryUID == "" &amp;&amp; pRegistryName == "") </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("pack %s: internal error - validation should have caught missing resolution fields", pName)
                        }</span>
                }
        case models.V1PackTypeManifest:<span class="cov0" title="0">
                if pUID == "" </span><span class="cov0" title="0">{
                        pUID = "spectro-manifest-pack"
                }</span>
        }

        <span class="cov0" title="0">pack := &amp;models.V1PackManifestEntity{
                Name:        types.Ptr(pName),
                Tag:         p["tag"].(string),
                RegistryUID: pRegistryUID,
                UID:         pUID,
                Type:        &amp;pType,
                // UI strips a single newline, so we should do the same
                Values: strings.TrimSpace(p["values"].(string)),
        }

        manifests := make([]*models.V1ManifestInputEntity, 0)
        if len(p["manifest"].([]interface{})) &gt; 0 </span><span class="cov0" title="0">{
                for _, manifest := range p["manifest"].([]interface{}) </span><span class="cov0" title="0">{
                        m := manifest.(map[string]interface{})
                        manifests = append(manifests, &amp;models.V1ManifestInputEntity{
                                Content: strings.TrimSpace(m["content"].(string)),
                                Name:    m["name"].(string),
                        })
                }</span>
        }
        <span class="cov0" title="0">pack.Manifests = manifests

        return pack, nil</span>
}

func toClusterProfilePackCreateWithResolution(pSrc interface{}, c *client.V1Client) (*models.V1PackManifestEntity, error) <span class="cov0" title="0">{
        p := pSrc.(map[string]interface{})

        pName := p["name"].(string)
        pTag := p["tag"].(string)
        pUID := p["uid"].(string)
        pRegistryUID := ""
        if p["registry_uid"] != nil </span><span class="cov0" title="0">{
                pRegistryUID = p["registry_uid"].(string)
        }</span>
        <span class="cov0" title="0">pRegistryName := ""
        if p["registry_name"] != nil </span><span class="cov0" title="0">{
                pRegistryName = p["registry_name"].(string)
        }</span>
        <span class="cov0" title="0">pType := models.V1PackType(p["type"].(string))

        // Validate pack UID or resolution fields
        if err := schemas.ValidatePackUIDOrResolutionFields(p); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // If registry_name is provided, resolve it to registry_uid
        <span class="cov0" title="0">if pRegistryName != "" &amp;&amp; pRegistryUID == "" </span><span class="cov0" title="0">{
                resolvedUID, err := resolveRegistryNameToUID(c, pRegistryName, p["type"].(string))
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("pack %s: %w", pName, err)
                }</span>
                <span class="cov0" title="0">pRegistryUID = resolvedUID</span>
        }

        <span class="cov0" title="0">switch pType </span>{
        case models.V1PackTypeSpectro:<span class="cov0" title="0">
                if pUID == "" </span><span class="cov0" title="0">{
                        // UID not provided, validation already passed, so we have all resolution fields
                        // Resolve the pack UID
                        resolvedUID, err := resolvePackUID(c, pName, pTag, pRegistryUID)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to resolve pack UID for pack %s: %w", pName, err)
                        }</span>
                        <span class="cov0" title="0">pUID = resolvedUID</span>
                }
        case models.V1PackTypeHelm:<span class="cov0" title="0">
                if pUID == "" </span><span class="cov0" title="0">{
                        // UID not provided, validation already passed, so we have all resolution fields
                        // Resolve the pack UID
                        resolvedUID, err := resolvePackUID(c, pName, pTag, pRegistryUID)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to resolve pack UID for pack %s: %w", pName, err)
                        }</span>
                        <span class="cov0" title="0">pUID = resolvedUID</span>
                }
        case models.V1PackTypeManifest:<span class="cov0" title="0">
                if pUID == "" </span><span class="cov0" title="0">{
                        pUID = "spectro-manifest-pack"
                }</span>
        }

        <span class="cov0" title="0">pack := &amp;models.V1PackManifestEntity{
                Name:        types.Ptr(pName),
                Tag:         p["tag"].(string),
                RegistryUID: pRegistryUID,
                UID:         pUID,
                Type:        &amp;pType,
                // UI strips a single newline, so we should do the same
                Values: strings.TrimSpace(p["values"].(string)),
        }

        manifests := make([]*models.V1ManifestInputEntity, 0)
        if len(p["manifest"].([]interface{})) &gt; 0 </span><span class="cov0" title="0">{
                for _, manifest := range p["manifest"].([]interface{}) </span><span class="cov0" title="0">{
                        m := manifest.(map[string]interface{})
                        manifests = append(manifests, &amp;models.V1ManifestInputEntity{
                                Content: strings.TrimSpace(m["content"].(string)),
                                Name:    m["name"].(string),
                        })
                }</span>
        }
        <span class="cov0" title="0">pack.Manifests = manifests

        return pack, nil</span>
}

func toClusterProfileUpdateWithResolution(d *schema.ResourceData, cluster *models.V1ClusterProfile, c *client.V1Client) (*models.V1ClusterProfileUpdateEntity, error) <span class="cov0" title="0">{
        cp := &amp;models.V1ClusterProfileUpdateEntity{
                Metadata: &amp;models.V1ObjectMeta{
                        Name: d.Get("name").(string),
                        UID:  d.Id(),
                },
                Spec: &amp;models.V1ClusterProfileUpdateEntitySpec{
                        Template: &amp;models.V1ClusterProfileTemplateUpdate{
                                Type: types.Ptr(models.V1ProfileType(d.Get("type").(string))),
                        },
                        Version: d.Get("version").(string),
                },
        }
        packs := make([]*models.V1PackManifestUpdateEntity, 0)
        for _, pack := range d.Get("pack").([]interface{}) </span><span class="cov0" title="0">{
                if p, e := toClusterProfilePackUpdateWithResolution(pack, cluster.Spec.Published.Packs, c); e != nil </span><span class="cov0" title="0">{
                        return nil, e
                }</span> else<span class="cov0" title="0"> {
                        packs = append(packs, p)
                }</span>
        }
        <span class="cov0" title="0">cp.Spec.Template.Packs = packs

        return cp, nil</span>
}

func toClusterProfilePatch(d *schema.ResourceData) (*models.V1ProfileMetaEntity, error) <span class="cov0" title="0">{
        description := ""
        if d.Get("description") != nil </span><span class="cov0" title="0">{
                description = d.Get("description").(string)
        }</span>
        <span class="cov0" title="0">metadata := &amp;models.V1ProfileMetaEntity{
                Metadata: &amp;models.V1ObjectMetaInputEntity{
                        Name: d.Get("name").(string),
                        Annotations: map[string]string{
                                "description": description,
                        },
                        Labels: toTags(d),
                },
                Spec: &amp;models.V1ClusterProfileSpecEntity{
                        Version: d.Get("version").(string),
                },
        }

        return metadata, nil</span>
}

func toClusterProfilePackUpdateWithResolution(pSrc interface{}, packs []*models.V1PackRef, c *client.V1Client) (*models.V1PackManifestUpdateEntity, error) <span class="cov0" title="0">{
        p := pSrc.(map[string]interface{})

        pName := p["name"].(string)
        pTag := p["tag"].(string)
        pUID := p["uid"].(string)

        pRegistryUID := ""
        if p["registry_uid"] != nil </span><span class="cov0" title="0">{
                pRegistryUID = p["registry_uid"].(string)
        }</span>
        <span class="cov0" title="0">pType := models.V1PackType(p["type"].(string))

        // Validate pack UID or resolution fields
        if err := schemas.ValidatePackUIDOrResolutionFields(p); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">switch pType </span>{
        case models.V1PackTypeSpectro:<span class="cov0" title="0">
                if pUID == "" </span><span class="cov0" title="0">{
                        // UID not provided, validation already passed, so we have all resolution fields
                        // Resolve the pack UID
                        resolvedUID, err := resolvePackUID(c, pName, pTag, pRegistryUID)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to resolve pack UID for pack %s: %w", pName, err)
                        }</span>
                        <span class="cov0" title="0">pUID = resolvedUID</span>
                }
        case models.V1PackTypeHelm:<span class="cov0" title="0">
                if pUID == "" </span><span class="cov0" title="0">{
                        // UID not provided, validation already passed, so we have all resolution fields
                        // Resolve the pack UID
                        resolvedUID, err := resolvePackUID(c, pName, pTag, pRegistryUID)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to resolve pack UID for pack %s: %w", pName, err)
                        }</span>
                        <span class="cov0" title="0">pUID = resolvedUID</span>
                }
        case models.V1PackTypeManifest:<span class="cov0" title="0">
                if pUID == "" </span><span class="cov0" title="0">{
                        pUID = "spectro-manifest-pack"
                }</span>
        }

        <span class="cov0" title="0">pack := &amp;models.V1PackManifestUpdateEntity{
                //Layer:  p["layer"].(string),
                Name:        types.Ptr(pName),
                Tag:         p["tag"].(string),
                RegistryUID: pRegistryUID,
                UID:         pUID,
                Type:        &amp;pType,
                // UI strips a single newline, so we should do the same
                Values: strings.TrimSpace(p["values"].(string)),
        }

        manifests := make([]*models.V1ManifestRefUpdateEntity, 0)
        for _, manifest := range p["manifest"].([]interface{}) </span><span class="cov0" title="0">{
                m := manifest.(map[string]interface{})
                manifests = append(manifests, &amp;models.V1ManifestRefUpdateEntity{
                        Content: strings.TrimSpace(m["content"].(string)),
                        Name:    types.Ptr(m["name"].(string)),
                        UID:     getManifestUID(m["name"].(string), packs),
                })
        }</span>
        <span class="cov0" title="0">pack.Manifests = manifests

        return pack, nil</span>
}

func getManifestUID(name string, packs []*models.V1PackRef) string <span class="cov0" title="0">{
        for _, pack := range packs </span><span class="cov0" title="0">{
                for _, manifest := range pack.Manifests </span><span class="cov0" title="0">{
                        if manifest.Name == name </span><span class="cov0" title="0">{
                                return manifest.UID
                        }</span>
                }
        }

        <span class="cov0" title="0">return ""</span>
}

func toClusterProfileVariables(d *schema.ResourceData) ([]*models.V1Variable, error) <span class="cov0" title="0">{
        var profileVariables []*models.V1Variable
        if pVariables, ok := d.GetOk("profile_variables"); ok </span><span class="cov0" title="0">{
                if pVariables.([]interface{})[0] != nil </span><span class="cov0" title="0">{
                        variables := pVariables.([]interface{})[0].(map[string]interface{})["variable"]
                        for _, v := range variables.([]interface{}) </span><span class="cov0" title="0">{
                                variable := v.(map[string]interface{})
                                pv := &amp;models.V1Variable{
                                        DefaultValue: variable["default_value"].(string),
                                        Description:  variable["description"].(string),
                                        DisplayName:  variable["display_name"].(string), // revisit
                                        Format:       types.Ptr(models.V1VariableFormat(variable["format"].(string))),
                                        Hidden:       variable["hidden"].(bool),
                                        Immutable:    variable["immutable"].(bool),
                                        Name:         StringPtr(variable["name"].(string)),
                                        Regex:        variable["regex"].(string),
                                        IsSensitive:  variable["is_sensitive"].(bool),
                                        Required:     variable["required"].(bool),
                                }
                                profileVariables = append(profileVariables, pv)
                        }</span>
                }
        }
        <span class="cov0" title="0">return profileVariables, nil</span>
}

func flattenProfileVariables(d *schema.ResourceData, pv []*models.V1Variable) ([]interface{}, error) <span class="cov0" title="0">{
        if len(pv) == 0 </span><span class="cov0" title="0">{
                return make([]interface{}, 0), nil
        }</span>
        <span class="cov0" title="0">var variables []interface{}
        for _, v := range pv </span><span class="cov0" title="0">{
                variable := make(map[string]interface{})
                variable["name"] = v.Name
                variable["display_name"] = v.DisplayName
                variable["description"] = v.Description
                variable["format"] = v.Format
                variable["default_value"] = v.DefaultValue
                variable["regex"] = v.Regex
                variable["required"] = v.Required
                variable["immutable"] = v.Immutable
                variable["hidden"] = v.Hidden
                variable["is_sensitive"] = v.IsSensitive
                variables = append(variables, variable)
        }</span>
        // Sorting ordering the list per configuration this reference if we need to change profile_variables to TypeList
        <span class="cov0" title="0">var sortedVariables []interface{}
        var configVariables []interface{}
        if v, ok := d.GetOk("profile_variables"); ok </span><span class="cov0" title="0">{
                configVariables = v.([]interface{})[0].(map[string]interface{})["variable"].([]interface{})
                for _, cv := range configVariables </span><span class="cov0" title="0">{
                        mapV := cv.(map[string]interface{})
                        for _, va := range variables </span><span class="cov0" title="0">{
                                vs := va.(map[string]interface{})
                                if mapV["name"].(string) == String(vs["name"].(*string)) </span><span class="cov0" title="0">{
                                        sortedVariables = append(sortedVariables, va)
                                }</span>
                        }
                }
        } else<span class="cov0" title="0"> {
                sortedVariables = variables
        }</span>

        <span class="cov0" title="0">flattenProVariables := make([]interface{}, 1)
        flattenProVariables[0] = map[string]interface{}{
                "variable": sortedVariables,
        }
        return flattenProVariables, nil</span>
}

// resolvePackUID resolves the pack UID based on name, tag, and registry_uid
func resolvePackUID(c *client.V1Client, name, tag, registryUID string) (string, error) <span class="cov0" title="0">{
        if name == "" || tag == "" || registryUID == "" </span><span class="cov0" title="0">{
                return "", fmt.Errorf("name, tag, and registry_uid are all required for pack resolution")
        }</span>

        // Get pack versions by name and registry
        <span class="cov0" title="0">packVersions, err := c.GetPacksByNameAndRegistry(name, registryUID)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get pack versions for name %s in registry %s: %w", name, registryUID, err)
        }</span>

        <span class="cov0" title="0">if packVersions == nil || len(packVersions.Tags) == 0 </span><span class="cov0" title="0">{
                return "", fmt.Errorf("no pack found with name %s in registry %s", name, registryUID)
        }</span>

        // Find the pack with matching tag/version
        <span class="cov0" title="0">for _, packTag := range packVersions.Tags </span><span class="cov0" title="0">{
                if packTag.Version == tag </span><span class="cov0" title="0">{
                        return packTag.PackUID, nil
                }</span>
        }

        <span class="cov0" title="0">return "", fmt.Errorf("no pack found with name %s, tag %s in registry %s", name, tag, registryUID)</span>
}
</pre>
		
		<pre class="file" id="file154" style="display: none">package spectrocloud

import (
        "context"
        "fmt"
        "github.com/spectrocloud/palette-sdk-go/client"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
)

func resourceClusterProfileImport(ctx context.Context, d *schema.ResourceData, m interface{}) ([]*schema.ResourceData, error) <span class="cov0" title="0">{
        _, err := GetCommonClusterProfile(d, m)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">diags := resourceClusterProfileRead(ctx, d, m)
        if diags.HasError() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("could not read cluster for import: %v", diags)
        }</span>

        // Return the resource data. In most cases, this method is only used to
        // import one resource at a time, so you should return the resource data
        // in a slice with a single element.
        <span class="cov0" title="0">return []*schema.ResourceData{d}, nil</span>
}

func GetCommonClusterProfile(d *schema.ResourceData, m interface{}) (*client.V1Client, error) <span class="cov0" title="0">{
        resourceContext, profileID, err := ParseResourceID(d)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">c := getV1ClientWithResourceContext(m, resourceContext)
        profile, err := c.GetClusterProfile(profileID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unable to retrieve cluster data: %s", err)
        }</span>
        <span class="cov0" title="0">if profile == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cluster profile id: %s not found", d.Id())
        }</span>

        <span class="cov0" title="0">err = d.Set("name", profile.Metadata.Name)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">err = d.Set("context", profile.Metadata.Annotations["scope"])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Set the ID of the resource in the state. This ID is used to track the
        // resource and must be set in the state during the import.
        <span class="cov0" title="0">d.SetId(profile.Metadata.UID)

        return c, nil</span>
}
</pre>
		
		<pre class="file" id="file155" style="display: none">package spectrocloud

import (
        "context"
        "fmt"
        "os"
        "path/filepath"
        "strings"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
)

func resourceClusterProfileImportFeature() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                CreateContext: resourceClusterProfileImportFeatureCreate,
                ReadContext:   resourceClusterProfileImportFeatureRead,
                UpdateContext: resourceClusterProfileImportFeatureUpdate,
                DeleteContext: resourceClusterProfileImportFeatureDelete,

                Schema: map[string]*schema.Schema{
                        "import_file": {
                                Type:     schema.TypeString,
                                Required: true,
                        },
                        "context": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "project",
                                ValidateFunc: validation.StringInSlice([]string{"", "project", "tenant", "system"}, false),
                                Description: "Allowed values are `project`, `tenant` or `system`. " +
                                        "Defaults to `project`. " + PROJECT_NAME_NUANCE,
                        },
                },
        }
}</span>

// implement the resource functions
func resourceClusterProfileImportFeatureCreate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        ProfileContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, ProfileContext)

        importFile, err := toClusterProfileImportCreate(d)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">uid, err := c.CreateClusterProfileImport(importFile)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">d.SetId(uid)
        return nil</span>
}

func toClusterProfileImportCreate(d *schema.ResourceData) (*os.File, error) <span class="cov0" title="0">{
        importFilePath := d.Get("import_file").(string)

        // Validate file path to prevent directory traversal attacks
        if !isValidFilePath(importFilePath) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid file path: %s", importFilePath)
        }</span>
        // #nosec G304
        <span class="cov0" title="0">importFile, err := os.Open(importFilePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error opening import file: %s", err)
        }</span>
        /*defer func(importFile *os.File) {
                err := importFile.Close()
                if err != nil {
                        fmt.Errorf("error closing import file: %s", err)
                }
        }(importFile)*/

        <span class="cov0" title="0">return importFile, nil</span>
}

// isValidFilePath checks if the file path is safe and doesn't contain directory traversal attempts
func isValidFilePath(filePath string) bool <span class="cov0" title="0">{
        // Check for directory traversal patterns
        if strings.Contains(filePath, "..") || strings.Contains(filePath, "//") </span><span class="cov0" title="0">{
                return false
        }</span>

        // Ensure the path is absolute or relative to current directory
        <span class="cov0" title="0">absPath, err := filepath.Abs(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // Check if the resolved path is within the current working directory
        <span class="cov0" title="0">cwd, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return strings.HasPrefix(absPath, cwd)</span>
}

func resourceClusterProfileImportFeatureRead(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        resourceContext := d.Get("context").(string)
        var diags diag.Diagnostics

        c := getV1ClientWithResourceContext(m, resourceContext)
        _, err := c.ClusterProfileExport(d.Id())
        if err != nil </span><span class="cov0" title="0">{
                return handleReadError(d, err, diags)
        }</span>
        //we don't want to set back the cluster profile, currently we're only supporting profile file name in schema not content.

        <span class="cov0" title="0">return nil</span>
}

func resourceClusterProfileImportFeatureUpdate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        resourceContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, resourceContext)

        importFile, err := toClusterProfileImportCreate(d)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        // Call the API endpoint to delete the cluster profile import resource
        <span class="cov0" title="0">err = c.DeleteClusterProfile(d.Id())
        if err != nil </span><span class="cov0" title="0">{
                // Return an error if the API call fails
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">uid, err := c.CreateClusterProfileImport(importFile)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">d.SetId(uid)

        return nil</span>
}

func resourceClusterProfileImportFeatureDelete(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        resourceContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, resourceContext)

        // Call the API endpoint to delete the cluster profile import resource
        if err := c.DeleteClusterProfile(d.Id()); err != nil </span><span class="cov0" title="0">{
                // Return an error if the API call fails
                return diag.FromErr(err)
        }</span>

        // Set the ID to an empty string to indicate that the resource has been deleted
        <span class="cov0" title="0">d.SetId("")

        return nil</span>
}
</pre>
		
		<pre class="file" id="file156" style="display: none">package spectrocloud

import (
        "context"
        "log"
        "time"

        "github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/schemas"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"

        "github.com/spectrocloud/palette-sdk-go/api/models"
        "github.com/spectrocloud/palette-sdk-go/client"
)

func resourceClusterVirtual() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                CreateContext: resourceClusterVirtualCreate,
                ReadContext:   resourceClusterVirtualRead,
                UpdateContext: resourceClusterVirtualUpdate,
                DeleteContext: resourceClusterDelete,
                Importer: &amp;schema.ResourceImporter{
                        StateContext: resourceClusterVirtualImport,
                },
                Description: "A resource to manage a Palette Virtual Cluster.",

                Timeouts: &amp;schema.ResourceTimeout{
                        Create: schema.DefaultTimeout(60 * time.Minute),
                        Update: schema.DefaultTimeout(60 * time.Minute),
                        Delete: schema.DefaultTimeout(60 * time.Minute),
                },

                SchemaVersion: 2,
                Schema: map[string]*schema.Schema{
                        "name": {
                                Type:     schema.TypeString,
                                Required: true,
                                ForceNew: true,
                        },
                        "context": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "project",
                                ValidateFunc: validation.StringInSlice([]string{"project", "cluster"}, false),
                                Description: "The context of the virtual cluster. Allowed values are `project` or `tenant`. " +
                                        "Default is `project`. " + PROJECT_NAME_NUANCE,
                        },
                        "tags": {
                                Type:     schema.TypeSet,
                                Optional: true,
                                Set:      schema.HashString,
                                Elem: &amp;schema.Schema{
                                        Type: schema.TypeString,
                                },
                                Description: "A list of tags to be applied to the cluster. Tags must be in the form of `key:value`.",
                        },
                        "description": {
                                Type:        schema.TypeString,
                                Optional:    true,
                                Default:     "",
                                Description: "The description of the cluster. Default value is empty string.",
                        },
                        "host_cluster_uid": {
                                Type:     schema.TypeString,
                                Optional: true,
                                // ExactlyOneOf: []string{"host_cluster_uid", "cluster_group_uid"},
                                ValidateFunc: validation.StringNotInSlice([]string{""}, false),
                        },
                        "cluster_group_uid": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                ValidateFunc: validation.StringNotInSlice([]string{""}, false),
                        },
                        "pause_cluster": {
                                Type:        schema.TypeBool,
                                Optional:    true,
                                Default:     false,
                                Description: "To pause and resume cluster state. Set to true to pause running cluster &amp; false to resume it.",
                        },
                        "resources": {
                                Type:     schema.TypeList,
                                Optional: true,
                                MaxItems: 1,
                                Elem: &amp;schema.Resource{
                                        Schema: map[string]*schema.Schema{
                                                "max_cpu": {
                                                        Type:     schema.TypeInt,
                                                        Optional: true,
                                                },
                                                "max_mem_in_mb": {
                                                        Type:     schema.TypeInt,
                                                        Optional: true,
                                                },
                                                "max_storage_in_gb": {
                                                        Type:     schema.TypeInt,
                                                        Optional: true,
                                                },
                                                "min_cpu": {
                                                        Type:     schema.TypeInt,
                                                        Optional: true,
                                                },
                                                "min_mem_in_mb": {
                                                        Type:     schema.TypeInt,
                                                        Optional: true,
                                                },
                                                "min_storage_in_gb": {
                                                        Type:     schema.TypeInt,
                                                        Optional: true,
                                                },
                                        },
                                },
                        },
                        "pause_agent_upgrades": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "unlock",
                                ValidateFunc: validation.StringInSlice([]string{"lock", "unlock"}, false),
                                Description:  "The pause agent upgrades setting allows to control the automatic upgrade of the Palette component and agent for an individual cluster. The default value is `unlock`, meaning upgrades occur automatically. Setting it to `lock` pauses automatic agent upgrades for the cluster.",
                        },
                        "cluster_profile": schemas.ClusterProfileSchema(),
                        "apply_setting": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "DownloadAndInstall",
                                ValidateFunc: validation.StringInSlice([]string{"DownloadAndInstall", "DownloadAndInstallLater"}, false),
                                Description: "The setting to apply the cluster profile. `DownloadAndInstall` will download and install packs in one action. " +
                                        "`DownloadAndInstallLater` will only download artifact and postpone install for later. " +
                                        "Default value is `DownloadAndInstall`.",
                        },
                        "cloud_config_id": {
                                Type:        schema.TypeString,
                                Computed:    true,
                                Description: "ID of the cloud config used for the cluster. This cloud config must be of type `azure`.",
                                Deprecated:  "This field is deprecated and will be removed in the future. Use `cloud_config` instead.",
                        },
                        "os_patch_on_boot": {
                                Type:        schema.TypeBool,
                                Optional:    true,
                                Default:     false,
                                Description: "Whether to apply OS patch on boot. Default is `false`.",
                        },
                        "os_patch_schedule": {
                                Type:             schema.TypeString,
                                Optional:         true,
                                ValidateDiagFunc: validateOsPatchSchedule,
                                Description:      "Cron schedule for OS patching. This must be in the form of `0 0 * * *`.",
                        },
                        "os_patch_after": {
                                Type:             schema.TypeString,
                                Optional:         true,
                                ValidateDiagFunc: validateOsPatchOnDemandAfter,
                                Description:      "The date and time after which to patch the cluster. Prefix the time value with the respective RFC. Ex: `RFC3339: 2006-01-02T15:04:05Z07:00`",
                        },
                        "kubeconfig": {
                                Type:        schema.TypeString,
                                Computed:    true,
                                Description: "Kubeconfig for the cluster. This can be used to connect to the cluster using `kubectl`.",
                        },
                        "admin_kube_config": {
                                Type:        schema.TypeString,
                                Computed:    true,
                                Description: "Admin Kube-config for the cluster. This can be used to connect to the cluster using `kubectl`, With admin privilege.",
                        },
                        "cloud_config": {
                                Type:     schema.TypeList,
                                ForceNew: true,
                                Optional: true,
                                MaxItems: 1,
                                Elem: &amp;schema.Resource{
                                        Schema: map[string]*schema.Schema{
                                                "chart_name": {
                                                        Type:     schema.TypeString,
                                                        Optional: true,
                                                },
                                                "chart_repo": {
                                                        Type:     schema.TypeString,
                                                        Optional: true,
                                                },
                                                "chart_version": {
                                                        Type:     schema.TypeString,
                                                        Optional: true,
                                                },
                                                "chart_values": {
                                                        Type:     schema.TypeString,
                                                        Optional: true,
                                                },
                                                "k8s_version": {
                                                        Type:     schema.TypeString,
                                                        Optional: true,
                                                },
                                        },
                                },
                        },
                        "backup_policy":        schemas.BackupPolicySchema(),
                        "scan_policy":          schemas.ScanPolicySchema(),
                        "cluster_rbac_binding": schemas.ClusterRbacBindingSchema(),
                        "namespaces":           schemas.ClusterNamespacesSchema(),
                        "location_config":      schemas.ClusterLocationSchemaComputed(),
                        "skip_completion": {
                                Type:        schema.TypeBool,
                                Optional:    true,
                                Default:     false,
                                Description: "If `true`, the cluster will be created asynchronously. Default value is `false`.",
                        },
                        "force_delete": {
                                Type:        schema.TypeBool,
                                Optional:    true,
                                Default:     false,
                                Description: "If set to `true`, the cluster will be force deleted and user has to manually clean up the provisioned cloud resources.",
                        },
                        "force_delete_delay": {
                                Type:             schema.TypeInt,
                                Optional:         true,
                                Default:          20,
                                Description:      "Delay duration in minutes to before invoking cluster force delete. Default and minimum is 20.",
                                ValidateDiagFunc: validation.ToDiagFunc(validation.IntAtLeast(20)),
                        },
                },
        }
}</span>

func resourceClusterVirtualCreate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        resourceContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, resourceContext)

        // Warning or errors can be collected in a slice type
        var diags diag.Diagnostics

        cluster, err := toVirtualCluster(c, d)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">uid, err := c.CreateClusterVirtual(cluster)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">diagnostics, isError := waitForClusterCreation(ctx, d, uid, diags, c, true)
        if len(diagnostics) &gt; 0 </span><span class="cov0" title="0">{
                diags = append(diags, diagnostics...)
        }</span>
        <span class="cov0" title="0">if isError </span><span class="cov0" title="0">{
                return diagnostics
        }</span>

        <span class="cov0" title="0">resourceClusterVirtualRead(ctx, d, m)

        return diags</span>
}

//goland:noinspection GoUnhandledErrorResult
func resourceClusterVirtualRead(_ context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        resourceContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, resourceContext)

        var diags diag.Diagnostics

        cluster, err := resourceClusterRead(d, c, diags)
        if err != nil </span><span class="cov0" title="0">{
                return handleReadError(d, err, diags)
        }</span> else<span class="cov0" title="0"> if cluster == nil </span><span class="cov0" title="0">{
                // Deleted - Terraform will recreate it
                d.SetId("")
                return diags
        }</span>

        <span class="cov0" title="0">diagnostics, done := readCommonFields(c, d, cluster)
        if done </span><span class="cov0" title="0">{
                return diagnostics
        }</span>

        <span class="cov0" title="0">return flattenCloudConfigVirtual(cluster.Spec.CloudConfigRef.UID, d, c)</span>
}

func flattenCloudConfigVirtual(configUID string, d *schema.ResourceData, c *client.V1Client) diag.Diagnostics <span class="cov0" title="0">{
        err := d.Set("cloud_config_id", configUID)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">return diag.Diagnostics{}</span>
}

func resourceClusterVirtualUpdate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        resourceContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, resourceContext)

        // Warning or errors can be collected in a slice type
        var diags diag.Diagnostics

        cloudConfigId := d.Get("cloud_config_id").(string)
        if d.HasChange("machine_pool") </span><span class="cov0" title="0">{
                oraw, nraw := d.GetChange("machine_pool")
                if oraw == nil </span><span class="cov0" title="0">{
                        oraw = new(schema.Set)
                }</span>
                <span class="cov0" title="0">if nraw == nil </span><span class="cov0" title="0">{
                        nraw = new(schema.Set)
                }</span>

                <span class="cov0" title="0">os := oraw.(*schema.Set)
                ns := nraw.(*schema.Set)

                osMap := make(map[string]interface{})
                for _, mp := range os.List() </span><span class="cov0" title="0">{
                        machinePool := mp.(map[string]interface{})
                        osMap[machinePool["name"].(string)] = machinePool
                }</span>

                <span class="cov0" title="0">for _, mp := range ns.List() </span><span class="cov0" title="0">{
                        machinePoolResource := mp.(map[string]interface{})
                        // since known issue in TF SDK: https://github.com/hashicorp/terraform-plugin-sdk/issues/588
                        if machinePoolResource["name"].(string) != "" </span><span class="cov0" title="0">{
                                name := machinePoolResource["name"].(string)
                                hash := resourceMachinePoolVirtualHash(machinePoolResource)

                                machinePool := toMachinePoolVirtual(machinePoolResource)

                                var err error
                                if oldMachinePool, ok := osMap[name]; !ok </span><span class="cov0" title="0">{
                                        log.Printf("Create machine pool %s", name)
                                        err = c.CreateMachinePoolVirtual(cloudConfigId, machinePool)
                                }</span> else<span class="cov0" title="0"> if hash != resourceMachinePoolVirtualHash(oldMachinePool) </span><span class="cov0" title="0">{
                                        log.Printf("Change in machine pool %s", name)
                                        err = c.UpdateMachinePoolVirtual(cloudConfigId, machinePool)
                                }</span>
                                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                                        return diag.FromErr(err)
                                }</span>

                                // Processed (if exists)
                                <span class="cov0" title="0">delete(osMap, name)</span>
                        }
                }

                // Deleted old machine pools
                <span class="cov0" title="0">for _, mp := range osMap </span><span class="cov0" title="0">{
                        machinePool := mp.(map[string]interface{})
                        name := machinePool["name"].(string)
                        log.Printf("Deleted machine pool %s", name)
                        if err := c.DeleteMachinePoolVirtual(cloudConfigId, name); err != nil </span><span class="cov0" title="0">{
                                return diag.FromErr(err)
                        }</span>
                }
        }

        <span class="cov0" title="0">diagnostics, done := updateCommonFields(d, c)
        if done </span><span class="cov0" title="0">{
                return diagnostics
        }</span>
        <span class="cov0" title="0">if d.HasChange("resources") </span><span class="cov0" title="0">{
                resourcesObj, ok := d.GetOk("resources")
                if ok </span><span class="cov0" title="0">{
                        resources := resourcesObj.([]interface{})[0].(map[string]interface{})
                        VCResizeConfig := toVirtualClusterResize(resources)
                        if err := c.ResizeClusterVirtual(cloudConfigId, VCResizeConfig); err != nil </span><span class="cov0" title="0">{
                                // If resize virtual cluster is errored we need to set old state back to resource
                                oldState, _ := d.GetChange("resources")
                                _ = d.Set("resources", oldState)
                                return diag.FromErr(err)
                        }</span>
                }
        }

        <span class="cov0" title="0">if d.HasChange("pause_cluster") </span><span class="cov0" title="0">{
                var body *models.V1LifecycleConfigEntity
                pause := new(bool)
                if d.Get("pause_cluster").(bool) </span><span class="cov0" title="0">{
                        *pause = true
                }</span> else<span class="cov0" title="0"> {
                        *pause = false
                }</span>
                <span class="cov0" title="0">body = &amp;models.V1LifecycleConfigEntity{
                        LifecycleConfig: &amp;models.V1LifecycleConfig{
                                Pause: pause,
                        },
                }
                _, err := c.VirtualClusterLifecycleConfigChange(d.Id(), body)
                if err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
                <span class="cov0" title="0">if *pause </span><span class="cov0" title="0">{
                        diagnostics, isError := waitForVirtualClusterLifecyclePause(ctx, d, d.Id(), diags, c)
                        if isError </span><span class="cov0" title="0">{
                                return diagnostics
                        }</span>
                } else<span class="cov0" title="0"> {
                        diagnostics, isError := waitForVirtualClusterLifecycleResume(ctx, d, d.Id(), diags, c)
                        if isError </span><span class="cov0" title="0">{
                                return diagnostics
                        }</span>
                }
        }
        <span class="cov0" title="0">resourceClusterVirtualRead(ctx, d, m)
        return diags</span>
}

func toVirtualCluster(c *client.V1Client, d *schema.ResourceData) (*models.V1SpectroVirtualClusterEntity, error) <span class="cov0" title="0">{
        // parse host cluster / cluster group uid
        hostClusterUid := d.Get("host_cluster_uid").(string)
        clusterGroupUid := d.Get("cluster_group_uid").(string)

        // parse CloudConfig
        var chartName, chartRepo, chartVersion, chartValues, kubernetesVersion string
        val, ok := d.GetOk("cloud_config")
        if ok </span><span class="cov0" title="0">{
                cloudConfig := val.([]interface{})[0].(map[string]interface{})
                chartName = cloudConfig["chart_name"].(string)
                chartRepo = cloudConfig["chart_repo"].(string)
                chartVersion = cloudConfig["chart_version"].(string)
                chartValues = cloudConfig["chart_values"].(string)
                kubernetesVersion = cloudConfig["k8s_version"].(string)
        }</span>

        <span class="cov0" title="0">clusterContext := d.Get("context").(string)
        profiles, err := toProfiles(c, d, clusterContext)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">cluster := &amp;models.V1SpectroVirtualClusterEntity{
                Metadata: getClusterMetadata(d),
                Spec: &amp;models.V1SpectroVirtualClusterEntitySpec{
                        CloudConfig: &amp;models.V1VirtualClusterConfig{
                                HelmRelease: &amp;models.V1VirtualClusterHelmRelease{
                                        Chart: &amp;models.V1VirtualClusterHelmChart{
                                                Name:    chartName,
                                                Repo:    chartRepo,
                                                Version: chartVersion,
                                        },
                                        Values: chartValues,
                                },
                                KubernetesVersion: kubernetesVersion,
                        },
                        ClusterConfig: &amp;models.V1ClusterConfigEntity{
                                HostClusterConfig: &amp;models.V1HostClusterConfig{
                                        ClusterGroup: &amp;models.V1ObjectReference{
                                                UID: clusterGroupUid,
                                        },
                                        HostCluster: &amp;models.V1ObjectReference{
                                                UID: hostClusterUid,
                                        },
                                },
                        },
                        Machinepoolconfig: nil,
                        Profiles:          profiles,
                        Policies:          toPolicies(d),
                },
        }

        // init cluster resources (machinepool)
        machinePoolConfigs := make([]*models.V1VirtualMachinePoolConfigEntity, 0)
        resourcesObj, ok := d.GetOk("resources")
        if ok </span><span class="cov0" title="0">{
                resources := resourcesObj.([]interface{})[0].(map[string]interface{})
                mp := toMachinePoolVirtual(resources)
                machinePoolConfigs = append(machinePoolConfigs, mp)
        }</span>
        <span class="cov0" title="0">cluster.Spec.Machinepoolconfig = machinePoolConfigs

        return cluster, nil</span>
}

func toMachinePoolVirtual(resources map[string]interface{}) *models.V1VirtualMachinePoolConfigEntity <span class="cov0" title="0">{
        maxCpu := resources["max_cpu"].(int)
        maxMemInMb := resources["max_mem_in_mb"].(int)
        maxStorageInGb := resources["max_storage_in_gb"].(int)
        minCpu := resources["min_cpu"].(int)
        minMemInMb := resources["min_mem_in_mb"].(int)
        minStorageInGb := resources["min_storage_in_gb"].(int)

        mp := &amp;models.V1VirtualMachinePoolConfigEntity{
                CloudConfig: &amp;models.V1VirtualMachinePoolCloudConfigEntity{
                        InstanceType: &amp;models.V1VirtualInstanceType{
                                MaxCPU:        SafeInt32(maxCpu),
                                MaxMemInMiB:   SafeInt32(maxMemInMb),
                                MaxStorageGiB: SafeInt32(maxStorageInGb),
                                MinCPU:        SafeInt32(minCpu),
                                MinMemInMiB:   SafeInt32(minMemInMb),
                                MinStorageGiB: SafeInt32(minStorageInGb),
                        },
                },
        }

        return mp
}</span>

func toVirtualClusterResize(resources map[string]interface{}) *models.V1VirtualClusterResize <span class="cov0" title="0">{
        maxCpu := resources["max_cpu"].(int)
        maxMemInMb := resources["max_mem_in_mb"].(int)
        maxStorageInGb := resources["max_storage_in_gb"].(int)
        minCpu := resources["min_cpu"].(int)
        minMemInMb := resources["min_mem_in_mb"].(int)
        minStorageInGb := resources["min_storage_in_gb"].(int)
        VCResize := &amp;models.V1VirtualClusterResize{
                InstanceType: &amp;models.V1VirtualInstanceType{
                        MaxCPU:        SafeInt32(maxCpu),
                        MaxMemInMiB:   SafeInt32(maxMemInMb),
                        MaxStorageGiB: SafeInt32(maxStorageInGb),
                        MinCPU:        SafeInt32(minCpu),
                        MinMemInMiB:   SafeInt32(minMemInMb),
                        MinStorageGiB: SafeInt32(minStorageInGb),
                },
        }
        return VCResize
}</span>
</pre>
		
		<pre class="file" id="file157" style="display: none">package spectrocloud

import (
        "context"
        "fmt"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
)

func resourceClusterVirtualImport(ctx context.Context, d *schema.ResourceData, m interface{}) ([]*schema.ResourceData, error) <span class="cov0" title="0">{
        // Virtual clusters have a context, default to "project"
        c := getV1ClientWithResourceContext(m, "project")

        // The import ID should be the cluster UID
        virtualClusterUID := d.Id()

        // Validate that the cluster exists and we can access it
        cluster, err := c.GetCluster(virtualClusterUID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("could not retrieve virtual cluster for import: %s", err)
        }</span>
        <span class="cov0" title="0">if cluster == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("virtual cluster with ID %s not found", virtualClusterUID)
        }</span>

        // Set the cluster name from the retrieved cluster
        <span class="cov0" title="0">if err := d.Set("name", cluster.Metadata.Name); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Set the context to project as default for import
        <span class="cov0" title="0">if err := d.Set("context", "project"); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := d.Set("cluster_group_uid", cluster.Spec.ClusterConfig.HostClusterConfig.ClusterGroup.UID); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // setting up default settings for import
        <span class="cov0" title="0">if err := d.Set("host_cluster_uid", cluster.Spec.ClusterConfig.HostClusterConfig.HostCluster.UID); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if err := d.Set("apply_setting", "DownloadAndInstall"); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if err := d.Set("force_delete", false); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if err := d.Set("force_delete_delay", 20); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if err := d.Set("skip_completion", false); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if err := d.Set("os_patch_on_boot", false); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if err := d.Set("pause_cluster", false); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Read all cluster data to populate the state
        <span class="cov0" title="0">diags := resourceClusterVirtualRead(ctx, d, m)
        if diags.HasError() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("could not read virtual cluster for import: %v", diags)
        }</span>

        <span class="cov0" title="0">return []*schema.ResourceData{d}, nil</span>
}
</pre>
		
		<pre class="file" id="file158" style="display: none">package spectrocloud

import (
        "context"
        "errors"
        "fmt"
        "log"
        "math"
        "sort"
        "strings"
        "time"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
        "github.com/spectrocloud/palette-sdk-go/api/models"
        "github.com/spectrocloud/palette-sdk-go/client"

        "github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/schemas"
        "github.com/spectrocloud/terraform-provider-spectrocloud/types"
)

func resourceClusterVsphere() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                CreateContext: resourceClusterVsphereCreate,
                ReadContext:   resourceClusterVsphereRead,
                UpdateContext: resourceClusterVsphereUpdate,
                DeleteContext: resourceClusterDelete,
                Importer: &amp;schema.ResourceImporter{
                        StateContext: resourceClusterVsphereImport,
                },
                Description: "A resource to manage a vSphere cluster in Palette.",

                Timeouts: &amp;schema.ResourceTimeout{
                        Create: schema.DefaultTimeout(180 * time.Minute),
                        Update: schema.DefaultTimeout(180 * time.Minute),
                        Delete: schema.DefaultTimeout(180 * time.Minute),
                },

                Schema: map[string]*schema.Schema{
                        "name": {
                                Type:        schema.TypeString,
                                Required:    true,
                                ForceNew:    true,
                                Description: "The name of the cluster.",
                        },
                        "context": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "project",
                                ValidateFunc: validation.StringInSlice([]string{"", "project", "tenant"}, false),
                                Description: "The context of the VMware cluster. Allowed values are `project` or `tenant`. " +
                                        "Default is `project`. " + PROJECT_NAME_NUANCE,
                        },
                        "tags": {
                                Type:     schema.TypeSet,
                                Optional: true,
                                Set:      schema.HashString,
                                Elem: &amp;schema.Schema{
                                        Type: schema.TypeString,
                                },
                                Description: "A list of tags to be applied to the cluster. Tags must be in the form of `key:value`.",
                        },
                        "description": {
                                Type:        schema.TypeString,
                                Optional:    true,
                                Default:     "",
                                Description: "The description of the cluster. Default value is empty string.",
                        },
                        "cluster_meta_attribute": {
                                Type:        schema.TypeString,
                                Optional:    true,
                                Description: "`cluster_meta_attribute` can be used to set additional cluster metadata information, eg `{'nic_name': 'test', 'env': 'stage'}`",
                        },
                        "cluster_profile":  schemas.ClusterProfileSchema(),
                        "cluster_template": schemas.ClusterTemplateSchema(),
                        "apply_setting": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "DownloadAndInstall",
                                ValidateFunc: validation.StringInSlice([]string{"DownloadAndInstall", "DownloadAndInstallLater"}, false),
                                Description: "The setting to apply the cluster profile. `DownloadAndInstall` will download and install packs in one action. " +
                                        "`DownloadAndInstallLater` will only download artifact and postpone install for later. " +
                                        "Default value is `DownloadAndInstall`.",
                        },
                        "cloud_account_id": {
                                Type:        schema.TypeString,
                                Required:    true,
                                ForceNew:    true,
                                Description: "ID of the cloud account to be used for the cluster. This cloud account must be of type `vsphere`.",
                        },
                        "cloud_config_id": {
                                Type:        schema.TypeString,
                                Computed:    true,
                                Description: "ID of the cloud config used for the cluster. This cloud config must be of type `azure`.",
                                Deprecated:  "This field is deprecated and will be removed in the future. Use `cloud_config` instead.",
                        },
                        "review_repave_state": {
                                Type:         schema.TypeString,
                                Default:      "",
                                Optional:     true,
                                ValidateFunc: validateReviewRepaveValue,
                                Description:  "To authorize the cluster repave, set the value to `Approved` for approval and `\"\"` to decline. Default value is `\"\"`.",
                        },
                        "pause_agent_upgrades": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "unlock",
                                ValidateFunc: validation.StringInSlice([]string{"lock", "unlock"}, false),
                                Description:  "The pause agent upgrades setting allows to control the automatic upgrade of the Palette component and agent for an individual cluster. The default value is `unlock`, meaning upgrades occur automatically. Setting it to `lock` pauses automatic agent upgrades for the cluster.",
                        },
                        "os_patch_on_boot": {
                                Type:        schema.TypeBool,
                                Optional:    true,
                                Default:     false,
                                Description: "Whether to apply OS patch on boot. Default is `false`.",
                        },
                        "os_patch_schedule": {
                                Type:             schema.TypeString,
                                Optional:         true,
                                ValidateDiagFunc: validateOsPatchSchedule,
                                Description:      "The cron schedule for OS patching. This must be in the form of cron syntax. Ex: `0 0 * * *`.",
                        },
                        "os_patch_after": {
                                Type:             schema.TypeString,
                                Optional:         true,
                                ValidateDiagFunc: validateOsPatchOnDemandAfter,
                                Description:      "The date and time after which to patch the cluster. Prefix the time value with the respective RFC. Ex: `RFC3339: 2006-01-02T15:04:05Z07:00`",
                        },
                        "cluster_timezone": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "",
                                ValidateFunc: validateTimezone,
                                Description:  "Defines the time zone used by this cluster to interpret scheduled operations. Maintenance tasks like upgrades will follow this time zone to ensure they run at the appropriate local time for the cluster. Must be in IANA timezone format (e.g., 'America/New_York', 'Asia/Kolkata', 'Europe/London').",
                        },
                        "kubeconfig": {
                                Type:        schema.TypeString,
                                Computed:    true,
                                Description: "Kubeconfig for the cluster. This can be used to connect to the cluster using `kubectl`.",
                        },
                        "admin_kube_config": {
                                Type:        schema.TypeString,
                                Computed:    true,
                                Description: "Admin Kube-config for the cluster. This can be used to connect to the cluster using `kubectl`, With admin privilege.",
                        },
                        "cloud_config": {
                                Type:     schema.TypeList,
                                ForceNew: true,
                                Required: true,
                                MaxItems: 1,
                                Elem: &amp;schema.Resource{
                                        Schema: map[string]*schema.Schema{
                                                "datacenter": {
                                                        Type:        schema.TypeString,
                                                        Required:    true,
                                                        Description: "The name of the datacenter in vSphere. This is the name of the datacenter as it appears in vSphere.",
                                                },
                                                "folder": {
                                                        Type:        schema.TypeString,
                                                        Required:    true,
                                                        Description: "The name of the folder in vSphere. This is the name of the folder as it appears in vSphere.",
                                                },
                                                "image_template_folder": {
                                                        Type:        schema.TypeString,
                                                        Optional:    true,
                                                        Description: "The name of the image template folder in vSphere. This is the name of the folder as it appears in vSphere.",
                                                },
                                                "ssh_key": {
                                                        Type:         schema.TypeString,
                                                        Optional:     true,
                                                        ExactlyOneOf: []string{"cloud_config.0.ssh_key", "cloud_config.0.ssh_keys"},
                                                        Description:  "The SSH key to be used for the cluster. This is the public key that will be used to access the cluster nodes. `ssh_key &amp; ssh_keys` are mutually exclusive.",
                                                        Deprecated:   "This field is deprecated and will be removed in the future. Use `ssh_keys` instead.",
                                                },
                                                "ssh_keys": {
                                                        Type:         schema.TypeSet,
                                                        Optional:     true,
                                                        Set:          schema.HashString,
                                                        ExactlyOneOf: []string{"cloud_config.0.ssh_key", "cloud_config.0.ssh_keys"},
                                                        Elem: &amp;schema.Schema{
                                                                Type: schema.TypeString,
                                                        },
                                                        Description: "List of public SSH (Secure Shell) keys to establish, administer, and communicate with remote clusters, `ssh_key &amp; ssh_keys` are mutually exclusive.",
                                                },
                                                "static_ip": {
                                                        Type:     schema.TypeBool,
                                                        Optional: true,
                                                        Default:  false,
                                                        Description: "Whether to use static IP addresses for the cluster. If `true`, the cluster will use static IP addresses. " +
                                                                "If `false`, the cluster will use DDNS. Default is `false`.",
                                                },

                                                // DHCP Properties
                                                "network_type": {
                                                        Type:        schema.TypeString,
                                                        Optional:    true,
                                                        Description: "The type of network to use for the cluster. This can be `VIP` or `DDNS`.",
                                                },
                                                "host_endpoint": {
                                                        Type:        schema.TypeString,
                                                        Optional:    true,
                                                        Description: "The host endpoint to use for the cluster. This can be `IP` or `FQDN(External/DDNS)`.",
                                                },
                                                "network_search_domain": {
                                                        Type:        schema.TypeString,
                                                        Optional:    true,
                                                        Description: "The search domain to use for the cluster in case of DHCP.",
                                                },
                                                "ntp_servers": {
                                                        Type:     schema.TypeSet,
                                                        Optional: true,
                                                        Set:      schema.HashString,
                                                        Elem: &amp;schema.Schema{
                                                                Type: schema.TypeString,
                                                        },
                                                        Description: "A list of NTP servers to be used by the cluster.",
                                                },
                                        },
                                },
                        },
                        "machine_pool": {
                                Type:     schema.TypeSet,
                                Required: true,
                                Set:      resourceMachinePoolVsphereHash,
                                Elem: &amp;schema.Resource{
                                        Schema: map[string]*schema.Schema{
                                                "name": {
                                                        Type:     schema.TypeString,
                                                        Required: true,
                                                        //ForceNew: true,
                                                        Description: "The name of the machine pool. This is used to identify the machine pool in the cluster.",
                                                },
                                                "additional_labels": {
                                                        Type:     schema.TypeMap,
                                                        Optional: true,
                                                        Elem: &amp;schema.Schema{
                                                                Type: schema.TypeString,
                                                        },
                                                        Description: "Additional labels to be applied to the machine pool. Labels must be in the form of `key:value`.",
                                                },
                                                "additional_annotations": {
                                                        Type:     schema.TypeMap,
                                                        Optional: true,
                                                        Elem: &amp;schema.Schema{
                                                                Type: schema.TypeString,
                                                        },
                                                        Description: "Additional annotations to be applied to the machine pool. Annotations must be in the form of `key:value`.",
                                                },
                                                "taints": schemas.ClusterTaintsSchema(),
                                                "node":   schemas.NodeSchema(),
                                                "control_plane": {
                                                        Type:     schema.TypeBool,
                                                        Optional: true,
                                                        Default:  false,
                                                        //ForceNew: true,
                                                        Description: "Whether this machine pool is a control plane. Defaults to `false`.",
                                                },
                                                "control_plane_as_worker": {
                                                        Type:     schema.TypeBool,
                                                        Optional: true,
                                                        Default:  false,
                                                        //ForceNew: true,
                                                        Description: "Whether this machine pool is a control plane and a worker. Defaults to `false`.",
                                                },
                                                "node_repave_interval": {
                                                        Type:        schema.TypeInt,
                                                        Optional:    true,
                                                        Default:     0,
                                                        Description: "Minimum number of seconds node should be Ready, before the next node is selected for repave. Default value is `0`, Applicable only for worker pools.",
                                                },
                                                "count": {
                                                        Type:        schema.TypeInt,
                                                        Required:    true,
                                                        Description: "Number of nodes in the machine pool.",
                                                },
                                                "min": {
                                                        Type:        schema.TypeInt,
                                                        Optional:    true,
                                                        Description: "Minimum number of nodes in the machine pool. This is used for autoscaling the machine pool.",
                                                },
                                                "max": {
                                                        Type:        schema.TypeInt,
                                                        Optional:    true,
                                                        Description: "Maximum number of nodes in the machine pool. This is used for autoscaling the machine pool.",
                                                },
                                                "update_strategy": {
                                                        Type:         schema.TypeString,
                                                        Optional:     true,
                                                        Default:      "RollingUpdateScaleOut",
                                                        Description:  "Update strategy for the machine pool. Valid values are `RollingUpdateScaleOut`, `RollingUpdateScaleIn` and `OverrideScaling`. If `OverrideScaling` is used, `override_scaling` must be specified with both `max_surge` and `max_unavailable`.",
                                                        ValidateFunc: validation.StringInSlice([]string{"RollingUpdateScaleOut", "RollingUpdateScaleIn", "OverrideScaling"}, false),
                                                },
                                                "override_scaling": schemas.OverrideScalingSchema(),
                                                "override_kubeadm_configuration": {
                                                        Type:        schema.TypeString,
                                                        Optional:    true,
                                                        Description: "YAML config for kubeletExtraArgs, preKubeadmCommands, postKubeadmCommands. Overrides pack-level settings. Worker pools only.",
                                                },
                                                "instance_type": {
                                                        Type:     schema.TypeList,
                                                        Required: true,
                                                        MaxItems: 1,
                                                        Elem: &amp;schema.Resource{
                                                                Schema: map[string]*schema.Schema{
                                                                        "disk_size_gb": {
                                                                                Type:        schema.TypeInt,
                                                                                Required:    true,
                                                                                Description: "The size of the disk in GB.",
                                                                        },
                                                                        "memory_mb": {
                                                                                Type:        schema.TypeInt,
                                                                                Required:    true,
                                                                                Description: "The amount of memory in MB.",
                                                                        },
                                                                        "cpu": {
                                                                                Type:        schema.TypeInt,
                                                                                Required:    true,
                                                                                Description: "The number of CPUs.",
                                                                        },
                                                                },
                                                        },
                                                },
                                                "placement": {
                                                        Type:     schema.TypeList,
                                                        MaxItems: 1,
                                                        Required: true,
                                                        Elem: &amp;schema.Resource{
                                                                Schema: map[string]*schema.Schema{
                                                                        "id": {
                                                                                Type:     schema.TypeString,
                                                                                Computed: true,
                                                                        },
                                                                        "cluster": {
                                                                                Type:        schema.TypeString,
                                                                                Required:    true,
                                                                                Description: "The name of the cluster to use for the machine pool. As it appears in the vSphere.",
                                                                        },
                                                                        "resource_pool": {
                                                                                Type:        schema.TypeString,
                                                                                Required:    true,
                                                                                Description: "The name of the resource pool to use for the machine pool. As it appears in the vSphere.",
                                                                        },
                                                                        "datastore": {
                                                                                Type:        schema.TypeString,
                                                                                Required:    true,
                                                                                Description: "The name of the datastore to use for the machine pool. As it appears in the vSphere.",
                                                                        },
                                                                        "network": {
                                                                                Type:        schema.TypeString,
                                                                                Required:    true,
                                                                                Description: "The name of the network to use for the machine pool. As it appears in the vSphere.",
                                                                        },
                                                                        "static_ip_pool_id": {
                                                                                Type:        schema.TypeString,
                                                                                Optional:    true,
                                                                                Description: "The ID of the static IP pool to use for the machine pool in case of static cluster placement.",
                                                                        },
                                                                },
                                                        },
                                                },
                                        },
                                },
                        },
                        "backup_policy":        schemas.BackupPolicySchema(),
                        "scan_policy":          schemas.ScanPolicySchema(),
                        "cluster_rbac_binding": schemas.ClusterRbacBindingSchema(),
                        "namespaces":           schemas.ClusterNamespacesSchema(),
                        "host_config":          schemas.ClusterHostConfigSchema(),
                        "location_config":      schemas.ClusterLocationSchema(),
                        "skip_completion": {
                                Type:        schema.TypeBool,
                                Optional:    true,
                                Default:     false,
                                Description: "If `true`, the cluster will be created asynchronously. Default value is `false`.",
                        },
                        "force_delete": {
                                Type:        schema.TypeBool,
                                Optional:    true,
                                Default:     false,
                                Description: "If set to `true`, the cluster will be force deleted and user has to manually clean up the provisioned cloud resources.",
                        },
                        "force_delete_delay": {
                                Type:             schema.TypeInt,
                                Optional:         true,
                                Default:          20,
                                Description:      "Delay duration in minutes to before invoking cluster force delete. Default and minimum is 20.",
                                ValidateDiagFunc: validation.ToDiagFunc(validation.IntAtLeast(20)),
                        },
                },
        }
}</span>

func resourceClusterVsphereCreate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        resourceContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, resourceContext)

        // Warning or errors can be collected in a slice type
        var diags diag.Diagnostics

        // Validate override_Scaling configuration
        if err := validateOverrideScaling(d, "machine_pool"); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">cluster, err := toVsphereCluster(c, d)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">uid, err := c.CreateClusterVsphere(cluster)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">diagnostics, isError := waitForClusterCreation(ctx, d, uid, diags, c, true)
        if len(diagnostics) &gt; 0 </span><span class="cov0" title="0">{
                diags = append(diags, diagnostics...)
        }</span>
        <span class="cov0" title="0">if isError </span><span class="cov0" title="0">{
                return diagnostics
        }</span>
        <span class="cov0" title="0">resourceClusterVsphereRead(ctx, d, m)

        return diags</span>
}

//goland:noinspection GoUnhandledErrorResult
func resourceClusterVsphereRead(_ context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        resourceContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, resourceContext)

        var diags diag.Diagnostics

        cluster, err := resourceClusterRead(d, c, diags)
        if err != nil </span><span class="cov0" title="0">{
                return handleReadError(d, err, diags)
        }</span> else<span class="cov0" title="0"> if cluster == nil </span><span class="cov0" title="0">{
                // Deleted - Terraform will recreate it
                d.SetId("")
                return diags
        }</span>

        // verify cluster type
        <span class="cov0" title="0">err = ValidateCloudType("spectrocloud_cluster_vsphere", cluster)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">configUID := cluster.Spec.CloudConfigRef.UID
        if err := d.Set("cloud_config_id", configUID); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">if config, err := c.GetCloudConfigVsphere(configUID); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span> else<span class="cov0" title="0"> {
                if err := d.Set("cloud_account_id", config.Spec.CloudAccountRef.UID); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
                <span class="cov0" title="0">cloudConfigFlatten := flattenClusterConfigsVsphere(d, config)
                if err := d.Set("cloud_config", cloudConfigFlatten); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
                <span class="cov0" title="0">mp := flattenMachinePoolConfigsVsphere(config.Spec.MachinePoolConfig)
                mp, err := flattenNodeMaintenanceStatus(c, d, c.GetNodeStatusMapVsphere, mp, configUID)
                if err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
                <span class="cov0" title="0">if err := d.Set("machine_pool", mp); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
        }

        <span class="cov0" title="0">diagnostics, done := readCommonFields(c, d, cluster)
        if done </span><span class="cov0" title="0">{
                return diagnostics
        }</span>

        // Flatten cluster_template variables using variables API
        <span class="cov0" title="0">if err := flattenClusterTemplateVariables(c, d, d.Id()); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">generalWarningForRepave(&amp;diags)
        return diags</span>
}

func flattenClusterConfigsVsphere(d *schema.ResourceData, cloudConfig *models.V1VsphereCloudConfig) interface{} <span class="cov0" title="0">{
        cloudConfigFlatten := make([]interface{}, 0)
        if cloudConfig == nil </span><span class="cov0" title="0">{
                return cloudConfigFlatten
        }</span>

        <span class="cov0" title="0">ret := make(map[string]interface{})
        if cloudConfig.Spec.ClusterConfig == nil </span><span class="cov0" title="0">{
                return cloudConfigFlatten
        }</span>

        <span class="cov0" title="0">if cloudConfig.Spec.ClusterConfig.ControlPlaneEndpoint != nil </span><span class="cov0" title="0">{
                cpEndpoint := cloudConfig.Spec.ClusterConfig.ControlPlaneEndpoint
                if cpEndpoint.Type != "" </span><span class="cov0" title="0">{
                        ret["network_type"] = cpEndpoint.Type
                }</span>

                <span class="cov0" title="0">if cpEndpoint.DdnsSearchDomain != "" </span><span class="cov0" title="0">{
                        ret["network_search_domain"] = cpEndpoint.DdnsSearchDomain
                }</span>
                <span class="cov0" title="0">if cpEndpoint.Host != "" </span><span class="cov0" title="0">{
                        ret["host_endpoint"] = cpEndpoint.Host
                }</span>
        }
        //Setting up placement attributes if its defined
        <span class="cov0" title="0">if cloudConfig.Spec.ClusterConfig.Placement != nil </span><span class="cov0" title="0">{
                placement := cloudConfig.Spec.ClusterConfig.Placement
                ret["datacenter"] = placement.Datacenter
                ret["folder"] = placement.Folder
                ret["image_template_folder"] = placement.ImageTemplateFolder
        }</span>
        //Currently we do support ssh_key and ssh_keys in vsphere cluster.
        //Handling flatten for if ssh_key is set
        <span class="cov0" title="0">if _, ok := d.GetOk("cloud_config.0.ssh_key"); ok </span><span class="cov0" title="0">{
                ret["ssh_key"] = strings.TrimSpace(cloudConfig.Spec.ClusterConfig.SSHKeys[0])
        }</span>
        //Handling flatten for if ssh_keys is set
        <span class="cov0" title="0">if _, ok := d.GetOk("cloud_config.0.ssh_keys"); ok </span><span class="cov0" title="0">{
                ret["ssh_keys"] = cloudConfig.Spec.ClusterConfig.SSHKeys
        }</span>
        //During cluster import by default we are setting up ssh_keys, above 2 conditions will not be true for import case.
        <span class="cov0" title="0">if len(cloudConfig.Spec.ClusterConfig.SSHKeys) != 0 </span><span class="cov0" title="0">{
                ret["ssh_keys"] = cloudConfig.Spec.ClusterConfig.SSHKeys
        }</span>

        <span class="cov0" title="0">ret["static_ip"] = cloudConfig.Spec.ClusterConfig.StaticIP

        if cloudConfig.Spec.ClusterConfig.NtpServers != nil </span><span class="cov0" title="0">{
                ret["ntp_servers"] = cloudConfig.Spec.ClusterConfig.NtpServers
        }</span>

        <span class="cov0" title="0">cloudConfigFlatten = append(cloudConfigFlatten, ret)

        return cloudConfigFlatten</span>
}

func flattenMachinePoolConfigsVsphere(machinePools []*models.V1VsphereMachinePoolConfig) []interface{} <span class="cov0" title="0">{
        if machinePools == nil </span><span class="cov0" title="0">{
                return make([]interface{}, 0)
        }</span>

        <span class="cov0" title="0">ois := make([]interface{}, len(machinePools))

        for i, machinePool := range machinePools </span><span class="cov0" title="0">{
                oi := make(map[string]interface{})

                FlattenAdditionalLabelsAnnotationsAndTaints(machinePool.AdditionalLabels, machinePool.AdditionalAnnotations, machinePool.Taints, oi)
                FlattenControlPlaneAndRepaveInterval(machinePool.IsControlPlane, oi, machinePool.NodeRepaveInterval)

                oi["control_plane_as_worker"] = machinePool.UseControlPlaneAsWorker
                oi["name"] = machinePool.Name
                oi["count"] = machinePool.Size
                oi["min"] = int(machinePool.MinSize)
                oi["max"] = int(machinePool.MaxSize)
                if machinePool.UpdateStrategy != nil </span><span class="cov0" title="0">{
                        oi["update_strategy"] = machinePool.UpdateStrategy.Type
                        // Flatten override_Scaling if using OverrideScaling strategy
                        flattenOverrideScaling(machinePool.UpdateStrategy, oi)
                }</span>

                // Flatten override_kubeadm_configuration (worker pools only)
                <span class="cov0" title="0">if machinePool.IsControlPlane != nil &amp;&amp; !*machinePool.IsControlPlane &amp;&amp; machinePool.OverrideKubeadmConfiguration != "" </span><span class="cov0" title="0">{
                        oi["override_kubeadm_configuration"] = machinePool.OverrideKubeadmConfiguration
                }</span>

                <span class="cov0" title="0">if machinePool.InstanceType != nil </span><span class="cov0" title="0">{
                        s := make(map[string]interface{})
                        s["disk_size_gb"] = int(*machinePool.InstanceType.DiskGiB)
                        s["memory_mb"] = int(*machinePool.InstanceType.MemoryMiB)
                        s["cpu"] = int(*machinePool.InstanceType.NumCPUs)

                        oi["instance_type"] = []interface{}{s}
                }</span>

                <span class="cov0" title="0">placements := make([]interface{}, len(machinePool.Placements))
                for j, p := range machinePool.Placements </span><span class="cov0" title="0">{
                        pj := make(map[string]interface{})
                        pj["id"] = p.UID
                        pj["cluster"] = p.Cluster
                        pj["resource_pool"] = p.ResourcePool
                        pj["datastore"] = p.Datastore
                        pj["network"] = p.Network.NetworkName

                        poolID := ""
                        if p.Network.ParentPoolRef != nil </span><span class="cov0" title="0">{
                                poolID = p.Network.ParentPoolRef.UID
                        }</span>
                        <span class="cov0" title="0">pj["static_ip_pool_id"] = poolID

                        placements[j] = pj</span>
                }
                <span class="cov0" title="0">oi["placement"] = placements

                ois[i] = oi</span>
        }

        <span class="cov0" title="0">return ois</span>
}

func sortPlacementStructs(structs []interface{}) <span class="cov0" title="0">{
        sort.Slice(structs, func(i, j int) bool </span><span class="cov0" title="0">{
                clusterI := structs[i].(map[string]interface{})["cluster"]
                clusterJ := structs[j].(map[string]interface{})["cluster"]
                if clusterI != clusterJ </span><span class="cov0" title="0">{
                        return clusterI.(string) &lt; clusterJ.(string)
                }</span>
                <span class="cov0" title="0">datastoreI := structs[i].(map[string]interface{})["datastore"]
                datastoreJ := structs[j].(map[string]interface{})["datastore"]
                if datastoreI != datastoreJ </span><span class="cov0" title="0">{
                        return datastoreI.(string) &lt; datastoreJ.(string)
                }</span>
                <span class="cov0" title="0">resourcePoolI := structs[i].(map[string]interface{})["resource_pool"]
                resourcePoolJ := structs[j].(map[string]interface{})["resource_pool"]
                if resourcePoolI != resourcePoolJ </span><span class="cov0" title="0">{
                        return resourcePoolI.(string) &lt; resourcePoolJ.(string)
                }</span>
                <span class="cov0" title="0">networkI := structs[i].(map[string]interface{})["network"]
                networkJ := structs[j].(map[string]interface{})["network"]
                return networkI.(string) &lt; networkJ.(string)</span>
        })
}

func ValidateMachinePoolChange(oMPool interface{}, nMPool interface{}) (bool, error) <span class="cov0" title="0">{
        var oPlacements []interface{}
        var nPlacements []interface{}
        // Identifying control plane placements from machine pool interface before change
        for i, oMachinePool := range oMPool.(*schema.Set).List() </span><span class="cov0" title="0">{
                if oMachinePool.(map[string]interface{})["control_plane"] == true </span><span class="cov0" title="0">{
                        oPlacements = oMPool.(*schema.Set).List()[i].(map[string]interface{})["placement"].([]interface{})
                }</span>
        }
        // Identifying control plane placements from machine pool interface after change
        <span class="cov0" title="0">for _, nMachinePool := range nMPool.(*schema.Set).List() </span><span class="cov0" title="0">{
                if nMachinePool.(map[string]interface{})["control_plane"] == true </span><span class="cov0" title="0">{
                        nPlacements = nMachinePool.(map[string]interface{})["placement"].([]interface{})
                }</span>
        }
        // Validating any New or old placements got added/removed.
        <span class="cov0" title="0">if len(nPlacements) != len(oPlacements) </span><span class="cov0" title="0">{
                errMsg := `placement validation error - adding/removing placement component in control plane is not allowed; to update the placement configuration in the control plane, kindly recreate the cluster`
                return true, errors.New(errMsg)
        }</span>

        // Need to add sort with all fields
        // oPlacements and nPlacements for correct comparison in case order was changed
        <span class="cov0" title="0">sortPlacementStructs(oPlacements)
        sortPlacementStructs(nPlacements)

        // Validating any New or old placements got changed.
        for pIndex, nP := range nPlacements </span><span class="cov0" title="0">{
                oPlacement := oPlacements[pIndex].(map[string]interface{})
                nPlacement := nP.(map[string]interface{})
                if oPlacement["cluster"] != nPlacement["cluster"] </span><span class="cov0" title="0">{
                        errMsg := fmt.Sprintf("Placement attributes for control_plane cannot be updated, validation error: Trying to update `ComputeCluster` value. Old value - %s, New value - %s ", oPlacement["cluster"], nPlacement["cluster"])
                        return true, errors.New(errMsg)
                }</span>
                <span class="cov0" title="0">if oPlacement["datastore"] != nPlacement["datastore"] </span><span class="cov0" title="0">{
                        errMsg := fmt.Sprintf("Placement attributes for control_plane cannot be updated, validation error: Trying to update `DataStore` value. Old value - %s, New value - %s ", oPlacement["datastore"], nPlacement["datastore"])
                        return true, errors.New(errMsg)
                }</span>
                <span class="cov0" title="0">if oPlacement["resource_pool"] != nPlacement["resource_pool"] </span><span class="cov0" title="0">{
                        errMsg := fmt.Sprintf("Placement attributes for control_plane cannot be updated, validation error: Trying to update `resource_pool` value. Old value - %s, New value - %s ", oPlacement["resource_pool"], nPlacement["resource_pool"])
                        return true, errors.New(errMsg)
                }</span>
                <span class="cov0" title="0">if oPlacement["network"] != nPlacement["network"] </span><span class="cov0" title="0">{
                        errMsg := fmt.Sprintf("Placement attributes for control_plane cannot be updated, validation error: Trying to update `Network` value. Old value - %s, New value - %s ", oPlacement["network"], nPlacement["network"])
                        return true, errors.New(errMsg)
                }</span>
        }
        <span class="cov0" title="0">return false, nil</span>
}

func resourceClusterVsphereUpdate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        resourceContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, resourceContext)

        // Warning or errors can be collected in a slice type
        var diags diag.Diagnostics
        err := validateSystemRepaveApproval(d, c)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">cloudConfigId := d.Get("cloud_config_id").(string)
        CloudConfig, err := c.GetCloudConfigVsphere(cloudConfigId)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">if d.HasChange("cloud_config") </span><span class="cov0" title="0">{
                occ, ncc := d.GetChange("cloud_config")
                if occ.([]interface{})[0].(map[string]interface{})["datacenter"] != ncc.([]interface{})[0].(map[string]interface{})["datacenter"] </span><span class="cov0" title="0">{
                        return diag.Errorf("Validation error: %s", "Datacenter value cannot be updated after cluster provisioning. Kindly destroy and recreate with updated Datacenter attribute.")
                }</span>
                <span class="cov0" title="0">cloudConfig := toCloudConfigUpdate(d.Get("cloud_config").([]interface{})[0].(map[string]interface{}))
                if err := c.UpdateCloudConfigVsphere(cloudConfigId, cloudConfig); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
        }

        <span class="cov0" title="0">if d.HasChange("machine_pool") </span><span class="cov0" title="0">{
                // Validate override_Scaling configuration
                if err := validateOverrideScaling(d, "machine_pool"); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>

                <span class="cov0" title="0">oraw, nraw := d.GetChange("machine_pool")
                if oraw != nil &amp;&amp; nraw != nil </span><span class="cov0" title="0">{
                        if ok, err := ValidateMachinePoolChange(oraw, nraw); ok </span><span class="cov0" title="0">{
                                return diag.Errorf("%s", err.Error())
                        }</span>
                }
                <span class="cov0" title="0">if oraw == nil </span><span class="cov0" title="0">{
                        oraw = new(schema.Set)
                }</span>
                <span class="cov0" title="0">if nraw == nil </span><span class="cov0" title="0">{
                        nraw = new(schema.Set)
                }</span>

                <span class="cov0" title="0">os := oraw.(*schema.Set)
                ns := nraw.(*schema.Set)

                osMap := make(map[string]interface{})
                for _, mp := range os.List() </span><span class="cov0" title="0">{
                        machinePool := mp.(map[string]interface{})
                        osMap[machinePool["name"].(string)] = machinePool
                }</span>

                <span class="cov0" title="0">nsMap := make(map[string]interface{})

                for _, mp := range ns.List() </span><span class="cov0" title="0">{
                        machinePoolResource := mp.(map[string]interface{})
                        nsMap[machinePoolResource["name"].(string)] = machinePoolResource
                        if machinePoolResource["name"].(string) != "" </span><span class="cov0" title="0">{
                                name := machinePoolResource["name"].(string)
                                hash := resourceMachinePoolVsphereHash(machinePoolResource)

                                var err error
                                machinePool, err := toMachinePoolVsphere(machinePoolResource)
                                if err != nil </span><span class="cov0" title="0">{
                                        return diag.FromErr(err)
                                }</span>

                                <span class="cov0" title="0">if oldMachinePool, ok := osMap[name]; !ok </span><span class="cov0" title="0">{
                                        log.Printf("Create machine pool %s", name)
                                        err = c.CreateMachinePoolVsphere(cloudConfigId, machinePool)
                                }</span> else<span class="cov0" title="0"> if hash != resourceMachinePoolVsphereHash(oldMachinePool) </span><span class="cov0" title="0">{
                                        log.Printf("Change in machine pool %s", name)
                                        oldMachinePool, _ := toMachinePoolVsphere(oldMachinePool)
                                        oldPlacements := oldMachinePool.CloudConfig.Placements

                                        // set the placement ids
                                        for i, p := range machinePool.CloudConfig.Placements </span><span class="cov0" title="0">{
                                                if len(oldPlacements) &gt; i </span><span class="cov0" title="0">{
                                                        p.UID = oldPlacements[i].UID
                                                }</span>
                                        }
                                        // PEM-5013 For day 2 operation hubble is expecting datacenter and folder in machine pool even though TF maintain in cloud config
                                        <span class="cov0" title="0">if machinePool.PoolConfig.IsControlPlane </span><span class="cov0" title="0">{
                                                cConfig := d.Get("cloud_config").([]interface{})[0].(map[string]interface{})
                                                machinePool.CloudConfig.Placements[0].Datacenter = cConfig["datacenter"].(string)
                                                machinePool.CloudConfig.Placements[0].Folder = cConfig["folder"].(string)
                                        }</span>
                                        <span class="cov0" title="0">err = c.UpdateMachinePoolVsphere(cloudConfigId, machinePool)
                                        // Node Maintenance Actions
                                        err := resourceNodeAction(c, ctx, nsMap[name], c.GetNodeMaintenanceStatusVsphere, CloudConfig.Kind, cloudConfigId, name)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return diag.FromErr(err)
                                        }</span>
                                }

                                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                                        return diag.FromErr(err)
                                }</span>

                                // Processed (if exists)
                                <span class="cov0" title="0">delete(osMap, name)</span>
                        }
                }

                // Deleted old machine pools
                <span class="cov0" title="0">for _, mp := range osMap </span><span class="cov0" title="0">{
                        machinePool := mp.(map[string]interface{})
                        name := machinePool["name"].(string)
                        log.Printf("Deleted machine pool %s", name)
                        if err := c.DeleteMachinePoolVsphere(cloudConfigId, name); err != nil </span><span class="cov0" title="0">{
                                return diag.FromErr(err)
                        }</span>
                }
        }

        <span class="cov0" title="0">diagnostics, done := updateCommonFields(d, c)
        if done </span><span class="cov0" title="0">{
                return diagnostics
        }</span>

        <span class="cov0" title="0">resourceClusterVsphereRead(ctx, d, m)

        return diags</span>
}

func toVsphereCluster(c *client.V1Client, d *schema.ResourceData) (*models.V1SpectroVsphereClusterEntity, error) <span class="cov0" title="0">{
        cloudConfig := d.Get("cloud_config").([]interface{})[0].(map[string]interface{})
        //clientSecret := strfmt.Password(d.Get("azure_client_secret").(string))

        clusterContext := d.Get("context").(string)
        profiles, err := toProfiles(c, d, clusterContext)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">cluster := &amp;models.V1SpectroVsphereClusterEntity{
                Metadata: getClusterMetadata(d),
                Spec: &amp;models.V1SpectroVsphereClusterEntitySpec{
                        CloudAccountUID: d.Get("cloud_account_id").(string),
                        Profiles:        profiles,
                        ClusterTemplate: toClusterTemplateReference(d),
                        Policies:        toPolicies(d),
                        CloudConfig:     toCloudConfigCreate(cloudConfig),
                },
        }

        machinePoolConfigs := make([]*models.V1VsphereMachinePoolConfigEntity, 0)
        for _, machinePool := range d.Get("machine_pool").(*schema.Set).List() </span><span class="cov0" title="0">{
                mp, err := toMachinePoolVsphere(machinePool)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">machinePoolConfigs = append(machinePoolConfigs, mp)</span>
        }

        <span class="cov0" title="0">sort.SliceStable(machinePoolConfigs, func(i, j int) bool </span><span class="cov0" title="0">{
                return machinePoolConfigs[i].PoolConfig.IsControlPlane
        }</span>)

        <span class="cov0" title="0">cluster.Spec.Machinepoolconfig = machinePoolConfigs
        cluster.Spec.ClusterConfig = toClusterConfig(d)

        return cluster, nil</span>
}

func toCloudConfigCreate(cloudConfig map[string]interface{}) *models.V1VsphereClusterConfigEntity <span class="cov0" title="0">{
        V1VsphereClusterConfigEntity := getClusterConfigEntity(cloudConfig)
        V1VsphereClusterConfigEntity.ControlPlaneEndpoint = &amp;models.V1ControlPlaneEndPoint{
                DdnsSearchDomain: cloudConfig["network_search_domain"].(string),
                Type:             cloudConfig["network_type"].(string),
                Host:             cloudConfig["host_endpoint"].(string),
        }

        return V1VsphereClusterConfigEntity
}</span>

func toCloudConfigUpdate(cloudConfig map[string]interface{}) *models.V1VsphereCloudClusterConfigEntity <span class="cov0" title="0">{
        return &amp;models.V1VsphereCloudClusterConfigEntity{
                ClusterConfig: toCloudConfigCreate(cloudConfig),
        }
}</span>

func toMachinePoolVsphere(machinePool interface{}) (*models.V1VsphereMachinePoolConfigEntity, error) <span class="cov0" title="0">{
        m := machinePool.(map[string]interface{})

        labels := make([]string, 0)
        controlPlane := m["control_plane"].(bool)
        controlPlaneAsWorker := m["control_plane_as_worker"].(bool)
        if controlPlane </span><span class="cov0" title="0">{
                labels = append(labels, "control-plane")
        }</span> else<span class="cov0" title="0"> {
                labels = append(labels, "worker")
        }</span>

        <span class="cov0" title="0">placements := make([]*models.V1VspherePlacementConfigEntity, 0)
        for _, pos := range m["placement"].([]interface{}) </span><span class="cov0" title="0">{
                p := pos.(map[string]interface{})
                poolID := p["static_ip_pool_id"].(string)
                staticIP := false
                if len(poolID) &gt; 0 </span><span class="cov0" title="0">{
                        staticIP = true
                }</span>

                <span class="cov0" title="0">placements = append(placements, &amp;models.V1VspherePlacementConfigEntity{
                        UID:          p["id"].(string),
                        Cluster:      p["cluster"].(string),
                        ResourcePool: p["resource_pool"].(string),
                        Datastore:    p["datastore"].(string),
                        Network: &amp;models.V1VsphereNetworkConfigEntity{
                                NetworkName:   types.Ptr(p["network"].(string)),
                                ParentPoolUID: poolID,
                                StaticIP:      staticIP,
                        },
                })</span>
        }

        <span class="cov0" title="0">ins := m["instance_type"].([]interface{})[0].(map[string]interface{})

        // Check bounds before conversion
        diskSizeInt := ins["disk_size_gb"].(int)
        memoryInt := ins["memory_mb"].(int)
        cpuInt := ins["cpu"].(int)

        if diskSizeInt &lt; 0 || memoryInt &lt; 0 || cpuInt &lt; 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("instance type values cannot be negative: disk_size_gb=%d, memory_mb=%d, cpu=%d", diskSizeInt, memoryInt, cpuInt)
        }</span>
        <span class="cov0" title="0">if diskSizeInt &gt; math.MaxInt32 || cpuInt &gt; math.MaxInt32 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("instance type values out of range: disk_size_gb=%d, memory_mb=%d, cpu=%d", diskSizeInt, memoryInt, cpuInt)
        }</span>

        <span class="cov0" title="0">instanceType := models.V1VsphereInstanceType{
                DiskGiB:   types.Ptr(SafeInt32(diskSizeInt)),
                MemoryMiB: types.Ptr(SafeInt64(memoryInt)),
                NumCPUs:   types.Ptr(SafeInt32(cpuInt)),
        }

        countInt := m["count"].(int)
        if countInt &lt; 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("count value %d cannot be negative", countInt)
        }</span>
        <span class="cov0" title="0">if countInt &gt; math.MaxInt32 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("count value %d is out of range for int32", countInt)
        }</span>

        <span class="cov0" title="0">min := SafeInt32(countInt)
        max := SafeInt32(countInt)

        if m["min"] != nil </span><span class="cov0" title="0">{
                minInt := m["min"].(int)
                if minInt &lt; 0 </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("min value %d cannot be negative", minInt)
                }</span>
                <span class="cov0" title="0">if minInt &gt; math.MaxInt32 </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("min value %d is out of range for int32", minInt)
                }</span>
                <span class="cov0" title="0">min = SafeInt32(minInt)</span>
        }

        <span class="cov0" title="0">if m["max"] != nil </span><span class="cov0" title="0">{
                maxInt := m["max"].(int)
                if maxInt &lt; 0 </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("max value %d cannot be negative", maxInt)
                }</span>
                <span class="cov0" title="0">if maxInt &gt; math.MaxInt32 </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("max value %d is out of range for int32", maxInt)
                }</span>
                <span class="cov0" title="0">max = SafeInt32(maxInt)</span>
        }

        <span class="cov0" title="0">mp := &amp;models.V1VsphereMachinePoolConfigEntity{
                CloudConfig: &amp;models.V1VsphereMachinePoolCloudConfigEntity{
                        Placements:   placements,
                        InstanceType: &amp;instanceType,
                },
                PoolConfig: &amp;models.V1MachinePoolConfigEntity{
                        AdditionalLabels:        toAdditionalNodePoolLabels(m),
                        AdditionalAnnotations:   toAdditionalNodePoolAnnotations(m),
                        Taints:                  toClusterTaints(m),
                        IsControlPlane:          controlPlane,
                        Labels:                  labels,
                        Name:                    types.Ptr(m["name"].(string)),
                        Size:                    types.Ptr(SafeInt32(m["count"].(int))),
                        UpdateStrategy:          toUpdateStrategy(m),
                        UseControlPlaneAsWorker: controlPlaneAsWorker,
                        MinSize:                 min,
                        MaxSize:                 max,
                },
        }

        // Handle override_kubeadm_configuration (worker pools only)
        if !controlPlane </span><span class="cov0" title="0">{
                if overrideKubeadm, ok := m["override_kubeadm_configuration"].(string); ok &amp;&amp; overrideKubeadm != "" </span><span class="cov0" title="0">{
                        mp.PoolConfig.OverrideKubeadmConfiguration = overrideKubeadm
                }</span>
        }

        <span class="cov0" title="0">if !controlPlane </span><span class="cov0" title="0">{
                nodeRepaveInterval := 0
                if m["node_repave_interval"] != nil </span><span class="cov0" title="0">{
                        nodeRepaveInterval = m["node_repave_interval"].(int)
                }</span>
                <span class="cov0" title="0">if nodeRepaveInterval &lt; 0 </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("node_repave_interval value %d cannot be negative", nodeRepaveInterval)
                }</span>
                <span class="cov0" title="0">if nodeRepaveInterval &gt; math.MaxInt32 </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("node_repave_interval value %d is out of range for int32", nodeRepaveInterval)
                }</span>
                <span class="cov0" title="0">mp.PoolConfig.NodeRepaveInterval = SafeInt32(nodeRepaveInterval)</span>
        } else<span class="cov0" title="0"> {
                nodeRepaveInterval := m["node_repave_interval"].(int)
                if nodeRepaveInterval &lt; 0 </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("node_repave_interval value %d cannot be negative", nodeRepaveInterval)
                }</span>
                <span class="cov0" title="0">if nodeRepaveInterval &gt; math.MaxInt32 </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("node_repave_interval value %d is out of range for int32", nodeRepaveInterval)
                }</span>
                <span class="cov0" title="0">err := ValidationNodeRepaveIntervalForControlPlane(nodeRepaveInterval)
                if err != nil </span><span class="cov0" title="0">{
                        return mp, err
                }</span>
        }

        <span class="cov0" title="0">return mp, nil</span>
}

func getSSHKey(cloudConfig map[string]interface{}) []string <span class="cov0" title="0">{
        sshKeys, _ := toSSHKeys(cloudConfig)
        return sshKeys
}</span>

func getStaticIP(cloudConfig map[string]interface{}) bool <span class="cov0" title="0">{
        staticIP := cloudConfig["static_ip"].(bool)
        return staticIP
}</span>

func getClusterConfigEntity(cloudConfig map[string]interface{}) *models.V1VsphereClusterConfigEntity <span class="cov0" title="0">{
        clusterConfigEntity := &amp;models.V1VsphereClusterConfigEntity{
                NtpServers: toNtpServers(cloudConfig),
                Placement: &amp;models.V1VspherePlacementConfigEntity{
                        Datacenter:          cloudConfig["datacenter"].(string),
                        Folder:              cloudConfig["folder"].(string),
                        ImageTemplateFolder: getImageTemplateFolder(cloudConfig),
                },
                SSHKeys:  getSSHKey(cloudConfig),
                StaticIP: getStaticIP(cloudConfig),
        }
        return clusterConfigEntity
}</span>
</pre>
		
		<pre class="file" id="file159" style="display: none">package spectrocloud

import (
        "context"
        "fmt"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
)

func resourceClusterVsphereImport(ctx context.Context, d *schema.ResourceData, m interface{}) ([]*schema.ResourceData, error) <span class="cov0" title="0">{
        c, err := GetCommonCluster(d, m)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">diags := resourceClusterVsphereRead(ctx, d, m)
        if diags.HasError() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("could not read cluster for import: %v", diags)
        }</span>

        // cluster profile and common default cluster attribute is get set here
        <span class="cov0" title="0">err = flattenCommonAttributeForClusterImport(c, d)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return []*schema.ResourceData{d}, nil</span>
}
</pre>
		
		<pre class="file" id="file160" style="display: none">package spectrocloud

import (
        "context"
        "fmt"
        "time"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
        "github.com/spectrocloud/palette-sdk-go/api/models"
        "github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/constants"
)

func resourceDeveloperSetting() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                CreateContext: resourceDeveloperSettingCreate,
                ReadContext:   resourceDeveloperSettingRead,
                UpdateContext: resourceDeveloperSettingUpdate,
                DeleteContext: resourceDeveloperSettingDelete,
                Importer: &amp;schema.ResourceImporter{
                        StateContext: resourceDeveloperSettingImport,
                },
                Timeouts: &amp;schema.ResourceTimeout{
                        Create: schema.DefaultTimeout(10 * time.Minute),
                        Update: schema.DefaultTimeout(10 * time.Minute),
                        Delete: schema.DefaultTimeout(10 * time.Minute),
                },
                SchemaVersion: 2,

                Schema: map[string]*schema.Schema{
                        "virtual_clusters_limit": {
                                Type:         schema.TypeInt,
                                Optional:     true,
                                Default:      2,
                                ValidateFunc: validation.IntBetween(1, 1000),
                                Description:  "Specifies the number of virtual clusters to be created.",
                        },
                        "cpu": {
                                Type:         schema.TypeInt,
                                Optional:     true,
                                Default:      12,
                                ValidateFunc: validation.IntBetween(4, 1000),
                                Description:  "Defines the number of CPU cores allocated to the cluster.",
                        },
                        "memory": {
                                Type:         schema.TypeInt,
                                Optional:     true,
                                Default:      16,
                                ValidateFunc: validation.IntBetween(4, 1000),
                                Description:  "Specifies the amount of memory (in GiB) allocated to the cluster.",
                        },
                        "storage": {
                                Type:         schema.TypeInt,
                                Optional:     true,
                                Default:      20,
                                ValidateFunc: validation.IntBetween(2, 100000),
                                Description:  "Defines the storage capacity (in GiB) allocated to the cluster.",
                        },
                        "hide_system_cluster_group": {
                                Type:        schema.TypeBool,
                                Optional:    true,
                                Default:     false,
                                Description: "If set to `true`, hides the system cluster.",
                        },
                },
        }
}</span>

func toDeveloperSetting(d *schema.ResourceData) (*models.V1DeveloperCredit, *models.V1TenantEnableClusterGroup) <span class="cov0" title="0">{
        cpuInt := d.Get("cpu").(int)
        memoryInt := d.Get("memory").(int)
        storageInt := d.Get("storage").(int)
        virtualClustersLimitInt := d.Get("virtual_clusters_limit").(int)

        // Check bounds for int32 conversion
        if cpuInt &gt; constants.Int32MaxValue || memoryInt &gt; constants.Int32MaxValue || storageInt &gt; constants.Int32MaxValue || virtualClustersLimitInt &gt; constants.Int32MaxValue </span><span class="cov0" title="0">{
                // Return default values if any value is out of range
                return &amp;models.V1DeveloperCredit{
                                CPU:                  12,
                                MemoryGiB:            16,
                                StorageGiB:           20,
                                VirtualClustersLimit: 2,
                        }, &amp;models.V1TenantEnableClusterGroup{
                                HideSystemClusterGroups: false,
                        }
        }</span>

        <span class="cov0" title="0">devCredit := &amp;models.V1DeveloperCredit{
                CPU:                  SafeInt32(cpuInt),
                MemoryGiB:            SafeInt32(memoryInt),
                StorageGiB:           SafeInt32(storageInt),
                VirtualClustersLimit: SafeInt32(virtualClustersLimitInt),
        }
        sysClusterGroupPref := &amp;models.V1TenantEnableClusterGroup{
                HideSystemClusterGroups: d.Get("hide_system_cluster_group").(bool),
        }
        return devCredit, sysClusterGroupPref</span>
}

func toDeveloperSettingDefault(d *schema.ResourceData) (*models.V1DeveloperCredit, *models.V1TenantEnableClusterGroup) <span class="cov0" title="0">{
        return &amp;models.V1DeveloperCredit{
                        CPU:                  12,
                        MemoryGiB:            16,
                        StorageGiB:           20,
                        VirtualClustersLimit: 2,
                }, &amp;models.V1TenantEnableClusterGroup{
                        HideSystemClusterGroups: false,
                }
}</span>

func flattenDeveloperSetting(devSetting *models.V1DeveloperCredit, sysClusterGroupPref *models.V1TenantEnableClusterGroup, d *schema.ResourceData) error <span class="cov0" title="0">{
        if err := d.Set("virtual_clusters_limit", devSetting.VirtualClustersLimit); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := d.Set("cpu", devSetting.CPU); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := d.Set("memory", devSetting.MemoryGiB); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := d.Set("storage", devSetting.StorageGiB); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := d.Set("hide_system_cluster_group", sysClusterGroupPref.HideSystemClusterGroups); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func resourceDeveloperSettingCreate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        c := getV1ClientWithResourceContext(m, tenantString)
        var diags diag.Diagnostics
        devSettings, sysClusterGroupPref := toDeveloperSetting(d)
        tenantUID, err := c.GetTenantUID()
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        // For developer setting we don't have support for creation it's always an update
        <span class="cov0" title="0">err = c.UpdateDeveloperSetting(tenantUID, devSettings)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">err = c.UpdateSystemClusterGroupPreference(tenantUID, sysClusterGroupPref)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">d.SetId("default-dev-setting-id")
        return diags</span>
}

func resourceDeveloperSettingRead(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        c := getV1ClientWithResourceContext(m, tenantString)
        var diags diag.Diagnostics
        tenantUID, err := c.GetTenantUID()
        if err != nil </span><span class="cov0" title="0">{
                return handleReadError(d, err, diags)
        }</span>
        <span class="cov0" title="0">respDevSettings, err := c.GetDeveloperSetting(tenantUID)
        if err != nil </span><span class="cov0" title="0">{
                return handleReadError(d, err, diags)
        }</span>
        <span class="cov0" title="0">respSysClusterGroupPref, err := c.GetSystemClusterGroupPreference(tenantUID)
        if err != nil </span><span class="cov0" title="0">{
                return handleReadError(d, err, diags)
        }</span>
        // handling case for cross-plane for singleton resource
        <span class="cov0" title="0">if d.Id() != "default-dev-setting-id" </span><span class="cov0" title="0">{
                d.SetId("")
                return diags
        }</span>
        <span class="cov0" title="0">err = flattenDeveloperSetting(respDevSettings, respSysClusterGroupPref, d)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">return diags</span>
}

func resourceDeveloperSettingUpdate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        c := getV1ClientWithResourceContext(m, tenantString)
        var diags diag.Diagnostics
        devSettings, sysClusterGroupPref := toDeveloperSetting(d)
        tenantUID, err := c.GetTenantUID()
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        // For developer setting we don't have support for creation it's always an update
        <span class="cov0" title="0">err = c.UpdateDeveloperSetting(tenantUID, devSettings)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">err = c.UpdateSystemClusterGroupPreference(tenantUID, sysClusterGroupPref)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">return diags</span>
}

func resourceDeveloperSettingDelete(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        c := getV1ClientWithResourceContext(m, tenantString)
        var diags diag.Diagnostics
        // We can't delete the base developer setting, instead we are setting it to default
        devSettings, sysClusterGroupPref := toDeveloperSettingDefault(d)
        tenantUID, err := c.GetTenantUID()
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        // For developer setting we don't have support for creation it's always an update
        <span class="cov0" title="0">err = c.UpdateDeveloperSetting(tenantUID, devSettings)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">err = c.UpdateSystemClusterGroupPreference(tenantUID, sysClusterGroupPref)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">d.SetId("")
        return diags</span>
}

func resourceDeveloperSettingImport(ctx context.Context, d *schema.ResourceData, m interface{}) ([]*schema.ResourceData, error) <span class="cov0" title="0">{
        c := getV1ClientWithResourceContext(m, "tenant")
        var diags diag.Diagnostics
        givenTenantId := d.Id()
        actualTenantId, err := c.GetTenantUID()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if givenTenantId != actualTenantId </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("tenant id is not valid with current user: %v", diags)
        }</span>
        <span class="cov0" title="0">diags = resourceDeveloperSettingRead(ctx, d, m)
        if diags.HasError() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("could not read developer settings for import: %v", diags)
        }</span>
        <span class="cov0" title="0">return []*schema.ResourceData{d}, nil</span>
}
</pre>
		
		<pre class="file" id="file161" style="display: none">package spectrocloud

import (
        "bytes"
        "context"
        "fmt"
        "log"
        "sort"
        "strings"
        "time"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
        "github.com/spectrocloud/palette-sdk-go/api/models"
)

func resourceFilter() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                CreateContext: resourceFilterCreate,
                ReadContext:   resourceFilterRead,
                UpdateContext: resourceFilterUpdate,
                DeleteContext: resourceFilterDelete,
                Importer: &amp;schema.ResourceImporter{
                        StateContext: resourceFilterImport,
                },
                Description: "A resource for creating and managing filters.",

                Timeouts: &amp;schema.ResourceTimeout{
                        Create: schema.DefaultTimeout(10 * time.Minute),
                        Update: schema.DefaultTimeout(10 * time.Minute),
                        Delete: schema.DefaultTimeout(10 * time.Minute),
                },

                SchemaVersion: 3,
                StateUpgraders: []schema.StateUpgrader{
                        {
                                Type:    resourceFilterResourceV2().CoreConfigSchema().ImpliedType(),
                                Upgrade: resourceFilterStateUpgradeV2,
                                Version: 2,
                        },
                },
                Schema: map[string]*schema.Schema{
                        "metadata": {
                                Type:        schema.TypeList,
                                Required:    true,
                                MaxItems:    1,
                                Description: "Metadata of the filter.",
                                Elem: &amp;schema.Resource{
                                        Schema: map[string]*schema.Schema{
                                                "name": {
                                                        Type:        schema.TypeString,
                                                        Required:    true,
                                                        Description: "The name of the filter.",
                                                },
                                        },
                                },
                        },
                        "spec": {
                                Type:        schema.TypeList,
                                Required:    true,
                                MaxItems:    1,
                                Description: "Specification of the filter.",
                                Elem: &amp;schema.Resource{
                                        Schema: map[string]*schema.Schema{
                                                "filter_group": {
                                                        Type:        schema.TypeList,
                                                        Required:    true,
                                                        MaxItems:    1,
                                                        Description: "Filter group of the filter.",
                                                        Elem: &amp;schema.Resource{
                                                                Schema: map[string]*schema.Schema{
                                                                        "conjunction": {
                                                                                Type:         schema.TypeString,
                                                                                Required:     true,
                                                                                ValidateFunc: validation.StringInSlice([]string{"and", "or"}, false),
                                                                                Description:  "Conjunction operation of the filter group. Valid values are 'and' and 'or'.",
                                                                        },
                                                                        "filters": {
                                                                                Type:        schema.TypeSet,
                                                                                Required:    true,
                                                                                Set:         resourceFilterItemHash,
                                                                                Description: "List of filters in the filter group.",
                                                                                Elem: &amp;schema.Resource{
                                                                                        Schema: map[string]*schema.Schema{
                                                                                                "key": {
                                                                                                        Type:        schema.TypeString,
                                                                                                        Required:    true,
                                                                                                        Description: "Key of the filter.",
                                                                                                },
                                                                                                "negation": {
                                                                                                        Type:        schema.TypeBool,
                                                                                                        Optional:    true,
                                                                                                        Default:     false,
                                                                                                        Description: "Negation flag of the filter condition.",
                                                                                                },
                                                                                                "operator": {
                                                                                                        Type:         schema.TypeString,
                                                                                                        Required:     true,
                                                                                                        ValidateFunc: validation.StringInSlice([]string{"eq"}, false),
                                                                                                        Description:  "Operator of the filter. Valid values are 'eq'.",
                                                                                                },
                                                                                                "values": {
                                                                                                        Type:        schema.TypeList,
                                                                                                        Required:    true,
                                                                                                        Elem:        &amp;schema.Schema{Type: schema.TypeString},
                                                                                                        Description: "Values of the filter.",
                                                                                                },
                                                                                        },
                                                                                },
                                                                        },
                                                                },
                                                        },
                                                },
                                        },
                                },
                        },
                },
        }
}</span>

func resourceFilterCreate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        c := getV1ClientWithResourceContext(m, "")

        metadata := d.Get("metadata").([]interface{})
        spec := d.Get("spec").([]interface{})

        tagFilter := &amp;models.V1TagFilter{
                Metadata: expandMetadata(metadata),
                Spec:     expandSpec(spec),
        }

        uid, err := c.CreateTagFilter(tagFilter)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">d.SetId(*uid.UID)
        return resourceFilterRead(ctx, d, m)</span>
}

func resourceFilterRead(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        c := getV1ClientWithResourceContext(m, "")
        var diags diag.Diagnostics
        uid := d.Id()

        tagFilterSummary, err := c.GetTagFilter(uid)
        if err != nil </span><span class="cov0" title="0">{
                return handleReadError(d, err, diags)
        }</span>

        <span class="cov0" title="0">if err := d.Set("metadata", flattenMetadata(tagFilterSummary.Metadata)); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">if err := d.Set("spec", flattenSpec(tagFilterSummary.Spec)); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func resourceFilterUpdate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        c := getV1ClientWithResourceContext(m, "")

        tagFilter := &amp;models.V1TagFilter{
                Metadata: expandMetadata(d.Get("metadata").([]interface{})),
                Spec:     expandSpec(d.Get("spec").([]interface{})),
        }

        err := c.UpdateTagFilter(d.Id(), tagFilter)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">return resourceFilterRead(ctx, d, m)</span>
}

func resourceFilterDelete(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        c := getV1ClientWithResourceContext(m, "")

        err := c.DeleteTagFilter(d.Id())
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">d.SetId("")

        return nil</span>
}

// resourceFilterResourceV2 returns the schema for version 2 of the resource
// where filters was TypeList instead of TypeSet
func resourceFilterResourceV2() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                Schema: map[string]*schema.Schema{
                        "metadata": {
                                Type:        schema.TypeList,
                                Required:    true,
                                MaxItems:    1,
                                Description: "Metadata of the filter.",
                                Elem: &amp;schema.Resource{
                                        Schema: map[string]*schema.Schema{
                                                "name": {
                                                        Type:        schema.TypeString,
                                                        Required:    true,
                                                        Description: "The name of the filter.",
                                                },
                                        },
                                },
                        },
                        "spec": {
                                Type:        schema.TypeList,
                                Required:    true,
                                MaxItems:    1,
                                Description: "Specification of the filter.",
                                Elem: &amp;schema.Resource{
                                        Schema: map[string]*schema.Schema{
                                                "filter_group": {
                                                        Type:        schema.TypeList,
                                                        Required:    true,
                                                        MaxItems:    1,
                                                        Description: "Filter group of the filter.",
                                                        Elem: &amp;schema.Resource{
                                                                Schema: map[string]*schema.Schema{
                                                                        "conjunction": {
                                                                                Type:         schema.TypeString,
                                                                                Required:     true,
                                                                                ValidateFunc: validation.StringInSlice([]string{"and", "or"}, false),
                                                                                Description:  "Conjunction operation of the filter group. Valid values are 'and' and 'or'.",
                                                                        },
                                                                        "filters": {
                                                                                Type:        schema.TypeList, // V2: TypeList
                                                                                Required:    true,
                                                                                Description: "List of filters in the filter group.",
                                                                                Elem: &amp;schema.Resource{
                                                                                        Schema: map[string]*schema.Schema{
                                                                                                "key": {
                                                                                                        Type:        schema.TypeString,
                                                                                                        Required:    true,
                                                                                                        Description: "Key of the filter.",
                                                                                                },
                                                                                                "negation": {
                                                                                                        Type:        schema.TypeBool,
                                                                                                        Optional:    true,
                                                                                                        Default:     false,
                                                                                                        Description: "Negation flag of the filter condition.",
                                                                                                },
                                                                                                "operator": {
                                                                                                        Type:         schema.TypeString,
                                                                                                        Required:     true,
                                                                                                        ValidateFunc: validation.StringInSlice([]string{"eq"}, false),
                                                                                                        Description:  "Operator of the filter. Valid values are 'eq'.",
                                                                                                },
                                                                                                "values": {
                                                                                                        Type:        schema.TypeList,
                                                                                                        Required:    true,
                                                                                                        Elem:        &amp;schema.Schema{Type: schema.TypeString},
                                                                                                        Description: "Values of the filter.",
                                                                                                },
                                                                                        },
                                                                                },
                                                                        },
                                                                },
                                                        },
                                                },
                                        },
                                },
                        },
                },
        }
}</span>

// resourceFilterStateUpgradeV2 migrates state from version 2 to version 3
// Converts filters from TypeList to TypeSet
func resourceFilterStateUpgradeV2(ctx context.Context, rawState map[string]interface{}, meta interface{}) (map[string]interface{}, error) <span class="cov0" title="0">{
        log.Printf("[DEBUG] Upgrading filter state from version 2 to 3")

        // Navigate to spec -&gt; filter_group -&gt; filters
        if specRaw, exists := rawState["spec"]; exists </span><span class="cov0" title="0">{
                if specList, ok := specRaw.([]interface{}); ok &amp;&amp; len(specList) &gt; 0 </span><span class="cov0" title="0">{
                        if specMap, ok := specList[0].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                if filterGroupRaw, exists := specMap["filter_group"]; exists </span><span class="cov0" title="0">{
                                        if filterGroupList, ok := filterGroupRaw.([]interface{}); ok &amp;&amp; len(filterGroupList) &gt; 0 </span><span class="cov0" title="0">{
                                                if filterGroupMap, ok := filterGroupList[0].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                                        if filtersRaw, exists := filterGroupMap["filters"]; exists </span><span class="cov0" title="0">{
                                                                if filtersList, ok := filtersRaw.([]interface{}); ok </span><span class="cov0" title="0">{
                                                                        log.Printf("[DEBUG] Converting filters from TypeList to TypeSet with %d items", len(filtersList))
                                                                        // Keep the data as a list in rawState and let Terraform's schema processing
                                                                        // convert it to TypeSet during normal resource loading. This avoids JSON serialization
                                                                        // issues with schema.Set objects that contain hash functions.
                                                                        filterGroupMap["filters"] = filtersList
                                                                        log.Printf("[DEBUG] Successfully prepared filters for TypeSet conversion")
                                                                }</span> else<span class="cov0" title="0"> {
                                                                        log.Printf("[DEBUG] filters is not a list, skipping conversion")
                                                                }</span>
                                                        } else<span class="cov0" title="0"> {
                                                                log.Printf("[DEBUG] No filters found in filter_group, skipping conversion")
                                                        }</span>
                                                }
                                        }
                                }
                        }
                }
        } else<span class="cov0" title="0"> {
                log.Printf("[DEBUG] No spec found in state, skipping conversion")
        }</span>

        <span class="cov0" title="0">return rawState, nil</span>
}

// resourceFilterItemHash creates a hash for filter items in the TypeSet
func resourceFilterItemHash(v interface{}) int <span class="cov0" title="0">{
        var buf bytes.Buffer
        filter := v.(map[string]interface{})

        // Required fields - always include
        if key, ok := filter["key"].(string); ok </span><span class="cov0" title="0">{
                buf.WriteString(fmt.Sprintf("key:%s-", key))
        }</span>

        <span class="cov0" title="0">if operator, ok := filter["operator"].(string); ok </span><span class="cov0" title="0">{
                buf.WriteString(fmt.Sprintf("operator:%s-", operator))
        }</span>

        // Optional field with default
        <span class="cov0" title="0">if negation, ok := filter["negation"].(bool); ok </span><span class="cov0" title="0">{
                buf.WriteString(fmt.Sprintf("negation:%t-", negation))
        }</span>

        // Handle values list - sort for deterministic hash
        <span class="cov0" title="0">if valuesRaw, ok := filter["values"]; ok &amp;&amp; valuesRaw != nil </span><span class="cov0" title="0">{
                if valuesList, ok := valuesRaw.([]interface{}); ok </span><span class="cov0" title="0">{
                        valuesStr := make([]string, len(valuesList))
                        for i, v := range valuesList </span><span class="cov0" title="0">{
                                if str, ok := v.(string); ok </span><span class="cov0" title="0">{
                                        valuesStr[i] = str
                                }</span>
                        }
                        <span class="cov0" title="0">sort.Strings(valuesStr)
                        buf.WriteString(fmt.Sprintf("values:%s-", strings.Join(valuesStr, ",")))</span>
                }
        }

        <span class="cov0" title="0">return int(hash(buf.String()))</span>
}
</pre>
		
		<pre class="file" id="file162" style="display: none">package spectrocloud

import (
        "context"
        "fmt"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
)

func resourceFilterImport(ctx context.Context, d *schema.ResourceData, m interface{}) ([]*schema.ResourceData, error) <span class="cov0" title="0">{
        c := getV1ClientWithResourceContext(m, "")

        // The import ID should be the filter UID
        filterUID := d.Id()

        // Validate that the filter exists and we can access it
        tagFilter, err := c.GetTagFilter(filterUID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("could not retrieve filter for import: %s", err)
        }</span>
        <span class="cov0" title="0">if tagFilter == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("filter with ID %s not found", filterUID)
        }</span>

        // Set the filter name from the retrieved filter metadata
        <span class="cov0" title="0">if tagFilter.Metadata != nil &amp;&amp; tagFilter.Metadata.Name != "" </span><span class="cov0" title="0">{
                metadata := []interface{}{
                        map[string]interface{}{
                                "name": tagFilter.Metadata.Name,
                        },
                }
                if err := d.Set("metadata", metadata); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        // Read all filter data to populate the state
        <span class="cov0" title="0">diags := resourceFilterRead(ctx, d, m)
        if diags.HasError() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("could not read filter for import: %v", diags)
        }</span>

        <span class="cov0" title="0">return []*schema.ResourceData{d}, nil</span>
}
</pre>
		
		<pre class="file" id="file163" style="display: none">package spectrocloud

import (
        "context"
        "errors"
        "fmt"
        "log"
        "time"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/spectrocloud/palette-sdk-go/api/models"
        "github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/convert"
        "github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/kubevirt/schema/datavolume"
        "github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/kubevirt/utils"
        "github.com/spectrocloud/terraform-provider-spectrocloud/types"
)

func resourceKubevirtDataVolume() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                CreateContext: resourceKubevirtDataVolumeCreate,
                ReadContext:   resourceKubevirtDataVolumeRead,
                UpdateContext: resourceKubevirtDataVolumeUpdate,
                DeleteContext: resourceKubevirtDataVolumeDelete,
                Importer: &amp;schema.ResourceImporter{
                        StateContext: schema.ImportStatePassthroughContext,
                },
                Timeouts: &amp;schema.ResourceTimeout{
                        Create: schema.DefaultTimeout(40 * time.Minute),
                        Delete: schema.DefaultTimeout(5 * time.Minute),
                },
                Schema: datavolume.DataVolumeFields(),
        }
}</span>

func resourceKubevirtDataVolumeCreate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        ClusterContext := d.Get("cluster_context").(string)
        c := getV1ClientWithResourceContext(m, ClusterContext)

        var diags diag.Diagnostics
        dv, err := datavolume.FromResourceData(d)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        // Extract "add_volume_options" from the Terraform schema
        <span class="cov0" title="0">addVolumeOptionsData := d.Get("add_volume_options").([]interface{})
        AddVolumeOptions := ExpandAddVolumeOptions(addVolumeOptionsData)

        hapiVolume, err := convert.ToHapiVolume(dv, AddVolumeOptions)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">log.Printf("[INFO] Creating new data volume: %#v", dv)
        // Warning or errors can be collected in a slice type
        clusterUid := d.Get("cluster_uid").(string)

        _, err = c.GetCluster(clusterUid)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">if d.Get("vm_name") == nil </span><span class="cov0" title="0">{
                return diag.FromErr(errors.New("vm_name is required"))
        }</span>
        <span class="cov0" title="0">vmName := d.Get("vm_name").(string)

        if d.Get("vm_namespace") == nil </span><span class="cov0" title="0">{
                return diag.FromErr(errors.New("vm_namespace is required"))
        }</span>
        <span class="cov0" title="0">vmNamespace := d.Get("vm_namespace").(string)

        if _, err := c.CreateDataVolume(clusterUid, vmName, hapiVolume); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">log.Printf("[INFO] Submitted new data volume: %#v", dv)
        if err := datavolume.ToResourceData(*dv, d); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">d.SetId(utils.BuildIdDV(ClusterContext, clusterUid, vmNamespace, vmName, hapiVolume.DataVolumeTemplate.Metadata))

        return diags</span>
}

func resourceKubevirtDataVolumeRead(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        ClusterContext := d.Get("cluster_context").(string)
        var diags diag.Diagnostics

        c := getV1ClientWithResourceContext(m, ClusterContext)

        _, clusterUid, namespace, vm_name, _, err := utils.IdPartsDV(d.Id())
        if err != nil </span><span class="cov0" title="0">{
                return handleReadError(d, err, diags)
        }</span>

        <span class="cov0" title="0">log.Printf("[INFO] Reading virtual machine %s", vm_name)

        hapiVM, err := c.GetVirtualMachine(clusterUid, namespace, vm_name)
        if err != nil </span><span class="cov0" title="0">{
                return handleReadError(d, err, diags)
        }</span>
        <span class="cov0" title="0">if hapiVM == nil </span><span class="cov0" title="0">{
                return diag.FromErr(fmt.Errorf("virtual machine not found %s, %s, %s to read data volume", clusterUid, namespace, vm_name))
        }</span>

        <span class="cov0" title="0">metadataSlice := d.Get("metadata").([]interface{})
        rd_metadata := metadataSlice[0].(map[string]interface{})
        rd_metadataName := rd_metadata["name"].(string)
        rd_metadataNamespace := rd_metadata["namespace"].(string)
        // Read data volume templates from vm.Spec.DataVolumeTemplates and filter by name
        for _, dv := range hapiVM.Spec.DataVolumeTemplates </span><span class="cov0" title="0">{
                name := dv.Metadata.Name
                namespace := dv.Metadata.Namespace

                if name == rd_metadataName &amp;&amp; namespace == rd_metadataNamespace </span><span class="cov0" title="0">{
                        kvVolume, err := convert.FromHapiVolume(&amp;models.V1VMAddVolumeEntity{
                                DataVolumeTemplate: dv,
                        })
                        if err != nil </span><span class="cov0" title="0">{
                                return diag.FromErr(err)
                        }</span>
                        <span class="cov0" title="0">err = datavolume.ToResourceData(*kvVolume, d)
                        if err != nil </span><span class="cov0" title="0">{
                                return diag.FromErr(err)
                        }</span>
                        <span class="cov0" title="0">break</span>
                }
        }
        <span class="cov0" title="0">return diag.Diagnostics{}</span>
}

func resourceKubevirtDataVolumeUpdate(ctx context.Context, resourceData *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        // implement update as delete followed by create
        if err := resourceKubevirtDataVolumeDelete(ctx, resourceData, m); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return resourceKubevirtDataVolumeCreate(ctx, resourceData, m)</span>
}

func resourceKubevirtDataVolumeDelete(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        ClusterContext := d.Get("cluster_context").(string)
        c := getV1ClientWithResourceContext(m, ClusterContext)

        var diags diag.Diagnostics
        _, clusterUid, namespace, vm_name, vol_name, err := utils.IdPartsDV(d.Id())
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">_, err = c.GetCluster(clusterUid)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">log.Printf("[INFO] Deleting data volume: %#v", vm_name)
        if err := c.DeleteDataVolume(clusterUid, namespace, vm_name, &amp;models.V1VMRemoveVolumeEntity{
                Persist: true,
                RemoveVolumeOptions: &amp;models.V1VMRemoveVolumeOptions{
                        Name: types.Ptr(vol_name),
                },
        }); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">log.Printf("[INFO] data volume %s deleted", vm_name)

        d.SetId("")
        return diags</span>
}

func ExpandAddVolumeOptions(addVolumeOptions []interface{}) *models.V1VMAddVolumeOptions <span class="cov0" title="0">{
        if len(addVolumeOptions) == 0 || addVolumeOptions[0] == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">m := addVolumeOptions[0].(map[string]interface{})

        result := &amp;models.V1VMAddVolumeOptions{
                Name: types.Ptr(m["name"].(string)),
        }

        if diskList, ok := m["disk"].([]interface{}); ok &amp;&amp; len(diskList) &gt; 0 </span><span class="cov0" title="0">{
                if diskMap, ok := diskList[0].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                        result.Disk = &amp;models.V1VMDisk{
                                Name: types.Ptr(diskMap["name"].(string)),
                                Disk: &amp;models.V1VMDiskTarget{
                                        Bus: diskMap["bus"].(string),
                                },
                        }
                }</span>
        }

        <span class="cov0" title="0">if volumeSourceList, ok := m["volume_source"].([]interface{}); ok &amp;&amp; len(volumeSourceList) &gt; 0 </span><span class="cov0" title="0">{
                if volumeSourceMap, ok := volumeSourceList[0].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                        if dataVolumeList, ok := volumeSourceMap["data_volume"].([]interface{}); ok &amp;&amp; len(dataVolumeList) &gt; 0 </span><span class="cov0" title="0">{
                                if dataVolumeMap, ok := dataVolumeList[0].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                        result.VolumeSource = &amp;models.V1VMHotplugVolumeSource{
                                                DataVolume: &amp;models.V1VMCoreDataVolumeSource{
                                                        Name:         types.Ptr(dataVolumeMap["name"].(string)),
                                                        Hotpluggable: dataVolumeMap["hotpluggable"].(bool),
                                                },
                                        }
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">return result</span>
}
</pre>
		
		<pre class="file" id="file164" style="display: none">package spectrocloud

import (
        "context"
        "fmt"
        "log"
        "strings"
        "time"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/spectrocloud/palette-sdk-go/client"
        "github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/convert"

        "github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/kubevirt/schema/virtualmachine"

        "github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/kubevirt/utils"
)

func resourceKubevirtVirtualMachine() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                CreateContext: resourceKubevirtVirtualMachineCreate,
                ReadContext:   resourceKubevirtVirtualMachineRead,
                UpdateContext: resourceVirtualMachineUpdate,
                DeleteContext: resourceKubevirtVirtualMachineDelete,
                Importer: &amp;schema.ResourceImporter{
                        StateContext: schema.ImportStatePassthroughContext,
                },
                Timeouts: &amp;schema.ResourceTimeout{
                        Create: schema.DefaultTimeout(40 * time.Minute),
                        Delete: schema.DefaultTimeout(5 * time.Minute),
                },
                Schema: virtualmachine.VirtualMachineFields(),
        }
}</span>
func resourceKubevirtVirtualMachineCreate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        ClusterContext := d.Get("cluster_context").(string)
        c := getV1ClientWithResourceContext(m, ClusterContext)
        // Warning or errors can be collected in a slice type
        var diags diag.Diagnostics
        clusterUid := d.Get("cluster_uid").(string)
        cluster, err := c.GetCluster(clusterUid)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        // if cluster is nil(deleted or not found), return error
        <span class="cov0" title="0">if cluster == nil </span><span class="cov0" title="0">{
                return diag.FromErr(fmt.Errorf("cluster not found for uid %s", clusterUid))
        }</span>
        <span class="cov0" title="0">virtualMachineToCreate, err := virtualmachine.FromResourceData(d)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">hapiVM, err := convert.ToHapiVm(virtualMachineToCreate)
        if _, ok := d.GetOk("run_on_launch"); ok </span><span class="cov0" title="0">{
                if !d.Get("run_on_launch").(bool) </span><span class="cov0" title="0">{
                        hapiVM.Spec.RunStrategy = "Manual"
                }</span> else<span class="cov0" title="0"> {
                        hapiVM.Spec.Running = d.Get("run_on_launch").(bool)
                }</span>
        }

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">if cloneFromVM, ok := d.GetOk("base_vm_name"); ok &amp;&amp; cloneFromVM != "" </span><span class="cov0" title="0">{
                // Handling clone case
                err = c.CloneVirtualMachine(clusterUid, cloneFromVM.(string), hapiVM.Metadata.Name, hapiVM.Metadata.Namespace)
                if err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
                <span class="cov0" title="0">vm, err := c.GetVirtualMachine(clusterUid, hapiVM.Metadata.Namespace, hapiVM.Metadata.Name)
                if err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
                <span class="cov0" title="0">if vm == nil </span><span class="cov0" title="0">{
                        return diag.FromErr(fmt.Errorf("virtual machine not found after clone operation %s, %s, %s", clusterUid, hapiVM.Metadata.Namespace, hapiVM.Metadata.Name))
                }</span>
                <span class="cov0" title="0">d.SetId(utils.BuildId(ClusterContext, clusterUid, vm.Metadata))
                // apply the rest of configuration after clone to override it.
                hapiVM.Metadata.ResourceVersion = vm.Metadata.ResourceVersion // set resource version to avoid conflict
                /*                //        // TODO: There is issue in Ally side, team asked as to explicitly make deletion-time to nil before put operation, after fix will remove.
                                hapiVM.Spec.Template.Metadata.DeletionTimestamp = nil
                                hapiVM.Metadata.DeletionTimestamp = nil
                                hapiVM.Spec.Template.Metadata.CreationTimestamp = ""
                                hapiVM.Metadata.CreationTimestamp = ""*/
                _, err = c.UpdateVirtualMachine(cluster, hapiVM.Metadata.Name, hapiVM)
                if err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
        } else<span class="cov0" title="0"> {
                vm, err := c.CreateVirtualMachine(cluster.Metadata.UID, hapiVM)
                if err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
                <span class="cov0" title="0">d.SetId(utils.BuildId(ClusterContext, clusterUid, vm.Metadata))</span>
        }
        <span class="cov0" title="0">if d.Get("run_on_launch").(bool) </span><span class="cov0" title="0">{
                diags, _ = waitForVirtualMachineToTargetState(ctx, d, cluster.Metadata.UID, hapiVM.Metadata.Name, hapiVM.Metadata.Namespace, diags, c, "create", "Running")
                if diags.HasError() </span><span class="cov0" title="0">{
                        return diags
                }</span>
        }

        <span class="cov0" title="0">resourceKubevirtVirtualMachineRead(ctx, d, m)
        return diags</span>
}

func resourceKubevirtVirtualMachineRead(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        ClusterContext := d.Get("cluster_context").(string)
        var diags diag.Diagnostics
        c := getV1ClientWithResourceContext(m, ClusterContext)

        _, clusterUid, namespace, name, err := utils.IdParts(d.Id())
        if err != nil </span><span class="cov0" title="0">{
                return handleReadError(d, err, diags)
        }</span>

        <span class="cov0" title="0">log.Printf("[INFO] Reading virtual machine %s", name)

        hapiVM, err := c.GetVirtualMachine(clusterUid, namespace, name)
        if err != nil </span><span class="cov0" title="0">{
                return handleReadError(d, err, diags)
        }</span>
        <span class="cov0" title="0">vm, err := convert.ToKubevirtVM(hapiVM)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">if vm == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">log.Printf("[INFO] Received virtual machine: %#v", vm)

        err = virtualmachine.ToResourceData(*vm, d)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func resourceVirtualMachineUpdate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        ClusterContext := d.Get("cluster_context").(string)
        c := getV1ClientWithResourceContext(m, ClusterContext)
        _, clusterUid, vmNamespace, vmName, err := utils.IdParts(d.Id())
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">hapiVM, err := c.GetVirtualMachine(clusterUid, vmNamespace, vmName)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">if hapiVM == nil </span><span class="cov0" title="0">{
                return diag.FromErr(fmt.Errorf("cannot read virtual machine %s, %s, %s", clusterUid, vmNamespace, vmName))
        }</span>

        // prepare new vm data
        <span class="cov0" title="0">vm, err := virtualmachine.FromResourceData(d)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">hapiVM, err = convert.ToHapiVm(vm)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        // needed to get context for the cluster
        <span class="cov0" title="0">cluster, err := c.GetCluster(clusterUid)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">if _, ok := d.GetOk("run_on_launch"); ok </span><span class="cov0" title="0">{
                if !d.Get("run_on_launch").(bool) </span><span class="cov0" title="0">{
                        hapiVM.Spec.RunStrategy = "Manual"
                }</span> else<span class="cov0" title="0"> {
                        hapiVM.Spec.Running = d.Get("run_on_launch").(bool)
                }</span>
        }
        <span class="cov0" title="0">_, err = c.UpdateVirtualMachine(cluster, vmName, hapiVM)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">if _, ok := d.GetOk("vm_action"); ok &amp;&amp; d.HasChange("vm_action") </span><span class="cov0" title="0">{
                stateToChange := d.Get("vm_action").(string)
                resourceVirtualMachineActions(c, ctx, d, stateToChange, clusterUid, vmName, vmNamespace)
        }</span>

        <span class="cov0" title="0">return resourceKubevirtVirtualMachineRead(ctx, d, m)</span>
}

func resourceVirtualMachineActions(c *client.V1Client, ctx context.Context, d *schema.ResourceData, stateToChange, clusterUid, vmName, vmNamespace string) diag.Diagnostics <span class="cov0" title="0">{
        var diags diag.Diagnostics
        //ClusterContext := d.Get("cluster_context").(string)
        // need to add validation status and allowed actions
        // Stopped  - start
        // Paused - restart, resume
        // Running - stop ,restart,pause, migrate
        switch strings.ToLower(stateToChange) </span>{
        //"start", "stop", "restart", "pause", "resume", "migrate"
        case "start":<span class="cov0" title="0">
                err := c.StartVirtualMachine(clusterUid, vmName, vmNamespace)
                if err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
                <span class="cov0" title="0">diags, _ = waitForVirtualMachineToTargetState(ctx, d, clusterUid, vmName, vmNamespace, diags, c, "update", "Running")
                if diags.HasError() </span><span class="cov0" title="0">{
                        return diags
                }</span>
        case "stop":<span class="cov0" title="0">
                err := c.StopVirtualMachine(clusterUid, vmName, vmNamespace)
                if err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
                <span class="cov0" title="0">diags, _ = waitForVirtualMachineToTargetState(ctx, d, clusterUid, vmName, vmNamespace, diags, c, "update", "Stopped")
                if diags.HasError() </span><span class="cov0" title="0">{
                        return diags
                }</span>
        case "restart":<span class="cov0" title="0">
                err := c.RestartVirtualMachine(clusterUid, vmName, vmNamespace)
                if err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
                <span class="cov0" title="0">diags, _ = waitForVirtualMachineToTargetState(ctx, d, clusterUid, vmName, vmNamespace, diags, c, "update", "Running")
                if diags.HasError() </span><span class="cov0" title="0">{
                        return diags
                }</span>
        case "pause":<span class="cov0" title="0">
                err := c.PauseVirtualMachine(clusterUid, vmName, vmNamespace)
                if err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
                <span class="cov0" title="0">diags, _ = waitForVirtualMachineToTargetState(ctx, d, clusterUid, vmName, vmNamespace, diags, c, "update", "Paused")
                if diags.HasError() </span><span class="cov0" title="0">{
                        return diags
                }</span>
        case "resume":<span class="cov0" title="0">
                err := c.ResumeVirtualMachine(clusterUid, vmName, vmNamespace)
                if err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
                <span class="cov0" title="0">diags, _ = waitForVirtualMachineToTargetState(ctx, d, clusterUid, vmName, vmNamespace, diags, c, "update", "Running")
                if diags.HasError() </span><span class="cov0" title="0">{
                        return diags
                }</span>
        case "migrate":<span class="cov0" title="0">
                _ = c.MigrateVirtualMachineNodeToNode(clusterUid, vmName, vmNamespace)
                diags, _ = waitForVirtualMachineToTargetState(ctx, d, clusterUid, vmName, vmNamespace, diags, c, "update", "Running")
                if diags.HasError() </span><span class="cov0" title="0">{
                        return diags
                }</span>
        }
        <span class="cov0" title="0">hapiVM, err := c.GetVirtualMachine(clusterUid, vmNamespace, vmName)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">if hapiVM == nil </span><span class="cov0" title="0">{
                return diag.FromErr(fmt.Errorf("cannot read virtual machine after update %s, %s, %s", clusterUid, vmNamespace, vmName))
        }</span>
        <span class="cov0" title="0">return diags</span>
}

func resourceKubevirtVirtualMachineDelete(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        var diags diag.Diagnostics
        _, clusterUid, namespace, name, err := utils.IdParts(d.Id())
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">ClusterContext := d.Get("cluster_context").(string)
        c := getV1ClientWithResourceContext(m, ClusterContext)

        log.Printf("[INFO] Deleting virtual machine: %#v", name)
        if err := c.DeleteVirtualMachine(clusterUid, namespace, name); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">diags, _ = waitForVirtualMachineToTargetState(ctx, d, clusterUid, name, namespace, diags, c, "delete", "Deleted")
        if diags.HasError() </span><span class="cov0" title="0">{
                return diags
        }</span>
        <span class="cov0" title="0">log.Printf("[INFO] virtual machine %s deleted", name)

        d.SetId("")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file165" style="display: none">package spectrocloud

import (
        "context"
        "errors"
        "fmt"
        "strings"
        "time"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
        "github.com/spectrocloud/palette-sdk-go/api/apiutil/transport"
        "github.com/spectrocloud/palette-sdk-go/api/models"
        "github.com/spectrocloud/palette-sdk-go/client"
)

func resourceMacros() *schema.Resource <span class="cov10" title="9">{
        return &amp;schema.Resource{
                CreateContext: resourceMacrosCreate,
                ReadContext:   resourceMacrosRead,
                UpdateContext: resourceMacrosUpdate,
                DeleteContext: resourceMacrosDelete,
                Importer: &amp;schema.ResourceImporter{
                        StateContext: resourceMacrosImport,
                },
                Description: "A resource for creating and managing service output variables and macros.",

                Timeouts: &amp;schema.ResourceTimeout{
                        Create: schema.DefaultTimeout(10 * time.Minute),
                        Update: schema.DefaultTimeout(10 * time.Minute),
                        Delete: schema.DefaultTimeout(10 * time.Minute),
                },
                SchemaVersion: 1,
                Schema: map[string]*schema.Schema{
                        "macros": {
                                Type:     schema.TypeMap,
                                Required: true,
                                Elem: &amp;schema.Schema{
                                        Type: schema.TypeString,
                                },
                                Description: "The key-value mapping includes the macro name and its corresponding value, representing either a macro or a service variable output.",
                        },
                        "context": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "tenant",
                                ValidateFunc: validation.StringInSlice([]string{"project", "tenant"}, false),
                                Description: "The context of the cluster profile. Allowed values are `project` or `tenant`. " +
                                        "Default value is `project`. " + PROJECT_NAME_NUANCE,
                        },
                },
        }
}</span>

func resourceMacrosCreate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov3" title="2">{
        macrosContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, "")
        var diags diag.Diagnostics
        contextUid := ""
        var err error
        if macrosContext == "project" </span><span class="cov3" title="2">{
                contextUid = ProviderInitProjectUid
        }</span>
        <span class="cov3" title="2">macroUID, err := c.CreateMacros(contextUid, toMacros(d))
        if err != nil </span><span class="cov1" title="1">{
                return diag.FromErr(err)
        }</span>
        <span class="cov1" title="1">d.SetId(macroUID)
        return diags</span>
}

func resourceMacrosRead(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov3" title="2">{
        macrosContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, "")
        var diags diag.Diagnostics
        var macros []*models.V1Macro
        var err error
        contextUid := ""
        if macrosContext == "project" </span><span class="cov3" title="2">{
                contextUid = ProviderInitProjectUid
        }</span>
        <span class="cov3" title="2">macros, err = c.GetTFMacrosV2(d.Get("macros").(map[string]interface{}), contextUid)
        if err != nil </span><span class="cov1" title="1">{
                return handleReadError(d, err, diags)
        }</span> else<span class="cov1" title="1"> if len(macros) == 0 </span><span class="cov0" title="0">{
                // Deleted - Terraform will recreate it
                d.SetId("")
                return diags
        }</span>
        <span class="cov1" title="1">macrosId, err := GetMacrosId(c, contextUid)
        if err != nil </span><span class="cov0" title="0">{
                return handleReadError(d, err, diags)
        }</span>
        <span class="cov1" title="1">d.SetId(macrosId)

        retMacros := map[string]interface{}{}

        for _, v := range macros </span><span class="cov3" title="2">{
                retMacros[v.Name] = v.Value
        }</span>

        <span class="cov1" title="1">if err := d.Set("macros", retMacros); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov1" title="1">return diags</span>
}

func resourceMacrosUpdate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov3" title="2">{
        macrosContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, "")
        var diags diag.Diagnostics
        var err error
        contextUid := ""
        if macrosContext == "project" </span><span class="cov3" title="2">{
                contextUid = ProviderInitProjectUid
        }</span>
        <span class="cov3" title="2">if d.HasChange("macros") </span><span class="cov0" title="0">{
                oldMacros, _ := d.GetChange("macros")
                existMacros, _ := c.GetExistMacros(oldMacros.(map[string]interface{}), contextUid)
                err = c.UpdateMacros(contextUid, mergeExistingMacros(d, existMacros))
                if err != nil </span><span class="cov0" title="0">{
                        var e *transport.TransportError
                        if errors.As(err, &amp;e) &amp;&amp; e.HttpCode == 422 </span><span class="cov0" title="0">{
                                if err := d.Set("macros", oldMacros); err != nil </span><span class="cov0" title="0">{
                                        return diag.FromErr(err)
                                }</span>
                                <span class="cov0" title="0">e.Payload.Message = e.Payload.Message + "\n Kindly verify if any of the specified macro names already exist in the system."
                                return diag.FromErr(e)</span>
                        }
                        <span class="cov0" title="0">_ = d.Set("macros", oldMacros)
                        return diag.FromErr(err)</span>
                }
        }
        <span class="cov3" title="2">return diags</span>
}

func resourceMacrosDelete(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov3" title="2">{
        macrosContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, "")
        var diags diag.Diagnostics
        var err error
        contextUid := ""
        if macrosContext == "project" </span><span class="cov3" title="2">{
                contextUid = ProviderInitProjectUid
        }</span>
        <span class="cov3" title="2">err = c.DeleteMacros(contextUid, toMacros(d))
        if err != nil </span><span class="cov1" title="1">{
                return diag.FromErr(err)
        }</span>
        <span class="cov1" title="1">return diags</span>
}

func toMacros(d *schema.ResourceData) *models.V1Macros <span class="cov6" title="4">{
        var macro []*models.V1Macro
        dMacros := d.Get("macros").(map[string]interface{})
        for k, v := range dMacros </span><span class="cov9" title="8">{
                macro = append(macro, &amp;models.V1Macro{
                        Name:  k,
                        Value: v.(string),
                })
        }</span>
        <span class="cov6" title="4">retMacros := &amp;models.V1Macros{
                Macros: macro,
        }
        return retMacros</span>
}

func mergeExistingMacros(d *schema.ResourceData, existMacros []*models.V1Macro) *models.V1Macros <span class="cov0" title="0">{
        var macro []*models.V1Macro
        dMacros := d.Get("macros").(map[string]interface{})
        for k, v := range dMacros </span><span class="cov0" title="0">{
                macro = append(macro, &amp;models.V1Macro{
                        Name:  k,
                        Value: v.(string),
                })
        }</span>
        <span class="cov0" title="0">for _, em := range existMacros </span><span class="cov0" title="0">{
                macro = append(macro, &amp;models.V1Macro{
                        Name:  em.Name,
                        Value: em.Value,
                })
        }</span>
        <span class="cov0" title="0">retMacros := &amp;models.V1Macros{
                Macros: macro,
        }
        return retMacros</span>
}

func GetMacrosId(c *client.V1Client, uid string) (string, error) <span class="cov1" title="1">{
        hashId := ""
        if uid != "" </span><span class="cov1" title="1">{
                hashId = fmt.Sprintf("%s-%s-%s", "project", "macros", uid)
        }</span> else<span class="cov0" title="0"> {
                tenantID, err := c.GetTenantUID()
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov0" title="0">hashId = fmt.Sprintf("%s-%s-%s", "tenant", "macros", tenantID)</span>
        }
        <span class="cov1" title="1">return hashId, nil</span>
}

func resourceMacrosImport(ctx context.Context, d *schema.ResourceData, m interface{}) ([]*schema.ResourceData, error) <span class="cov0" title="0">{
        var diags diag.Diagnostics

        rawIDContext := d.Id()
        parts := strings.Split(rawIDContext, ":")
        if len(parts) != 2 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("import ID must be in the format '{projectUID/tenanatUID}:{project/tenant}'")
        }</span>

        <span class="cov0" title="0">contextID := parts[0]
        macrosContext := parts[1]
        err := ValidateContext(macrosContext)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">err = d.Set("context", macrosContext)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">c := getV1ClientWithResourceContext(m, macrosContext)
        var macros []*models.V1Macro

        if macrosContext == "project" </span><span class="cov0" title="0">{
                if contextID != ProviderInitProjectUid </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid import: given project UID {%s} and provider project UID {%s} are different  cross-project resource imports are not allowed; project UID must match the provider configuration", contextID, ProviderInitProjectUid)
                }</span>
                <span class="cov0" title="0">macros, err = c.GetMacros(ProviderInitProjectUid)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        } else<span class="cov0" title="0"> {
                actualTenantId, _ := c.GetTenantUID()
                if contextID != actualTenantId </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid import: tenant UID {%s} does not match your authorized tenant UID {%s}", contextID, actualTenantId)
                }</span>
                <span class="cov0" title="0">macros, err = c.GetMacros("")
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">existingMacros := map[string]interface{}{}
        for _, v := range macros </span><span class="cov0" title="0">{
                existingMacros[v.Name] = v.Value
        }</span>
        <span class="cov0" title="0">err = d.Set("macros", existingMacros)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">macrosId, err := GetMacrosId(c, contextID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">d.SetId(macrosId)

        if diags.HasError() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("could not read password policy for import: %v", diags)
        }</span>
        <span class="cov0" title="0">return []*schema.ResourceData{d}, nil</span>
}
</pre>
		
		<pre class="file" id="file166" style="display: none">package spectrocloud

import (
        "context"
        "fmt"
        "time"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
        "github.com/spectrocloud/palette-sdk-go/api/models"
)

func resourcePasswordPolicy() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                CreateContext: resourcePasswordPolicyCreate,
                ReadContext:   resourcePasswordPolicyRead,
                UpdateContext: resourcePasswordPolicyUpdate,
                DeleteContext: resourcePasswordPolicyDelete,
                Importer: &amp;schema.ResourceImporter{
                        StateContext: resourcePasswordPolicyImport,
                },
                CustomizeDiff: resourcePasswordPolicyCustomizeDiff,

                Timeouts: &amp;schema.ResourceTimeout{
                        Create: schema.DefaultTimeout(10 * time.Minute),
                        Update: schema.DefaultTimeout(10 * time.Minute),
                        Delete: schema.DefaultTimeout(10 * time.Minute),
                },
                SchemaVersion: 2,
                Schema: map[string]*schema.Schema{
                        "password_regex": {
                                Type:        schema.TypeString,
                                Optional:    true,
                                Default:     "",
                                Description: "A regular expression (regex) to define custom password patterns, such as enforcing specific characters or sequences in the password.",
                        },
                        "password_expiry_days": {
                                Type:         schema.TypeInt,
                                Optional:     true,
                                Default:      999,
                                ValidateFunc: validation.IntBetween(1, 1000),
                                Description:  "The number of days before the password expires. Must be between 1 and 1000 days. Defines how often passwords must be changed.  Default is `999` days for expiry. Conflicts with `min_password_length`, `min_uppercase_letters`, `min_digits`, `min_lowercase_letters`, `min_special_characters`",
                        },
                        "first_reminder_days": {
                                Type:        schema.TypeInt,
                                Optional:    true,
                                Default:     5,
                                Description: "The number of days before the password expiry to send the first reminder to the user. Default is `5` days before expiry.",
                        },
                        "min_password_length": {
                                Type:        schema.TypeInt,
                                Optional:    true,
                                Description: "The minimum length required for the password. Enforces a stronger password policy by ensuring a minimum number of characters.  Default minimum length is `6`.",
                        },
                        "min_uppercase_letters": {
                                Type:        schema.TypeInt,
                                Optional:    true,
                                Description: "The minimum number of uppercase letters (A-Z) required in the password. Helps ensure password complexity with a mix of case-sensitive characters. Minimum length of upper case should be `1`.",
                        },
                        "min_digits": {
                                Type:        schema.TypeInt,
                                Optional:    true,
                                Description: "The minimum number of numeric digits (0-9) required in the password. Ensures that passwords contain numerical characters. Minimum length of digit should be `1`.",
                        },
                        "min_lowercase_letters": {
                                Type:        schema.TypeInt,
                                Optional:    true,
                                Description: "The minimum number of lowercase letters (a-z) required in the password. Ensures that lowercase characters are included for password complexity. Minimum length of lower case should be `1`.",
                        },
                        "min_special_characters": {
                                Type:        schema.TypeInt,
                                Optional:    true,
                                Description: "The minimum number of special characters (e.g., !, @, #, $, %) required in the password. This increases the password's security level by including symbols. Minimum special characters should be `1`.",
                        },
                },
        }
}</span>

func resourcePasswordPolicyCustomizeDiff(ctx context.Context, diff *schema.ResourceDiff, v interface{}) error <span class="cov0" title="0">{
        passwordRegex := diff.Get("password_regex").(string)

        // If password_regex is set, check that the individual password requirements are not set
        if passwordRegex != "" </span><span class="cov0" title="0">{
                conflictingFields := []string{
                        "min_password_length",
                        "min_uppercase_letters",
                        "min_digits",
                        "min_lowercase_letters",
                        "min_special_characters",
                }

                for _, field := range conflictingFields </span><span class="cov0" title="0">{
                        if val := diff.Get(field); val != nil &amp;&amp; val != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("password_regex cannot be used together with %s. Use either password_regex for custom patterns or the individual minimum requirements", field)
                        }</span>
                }

                // When using password_regex, password_expiry_days and first_reminder_days are required
                <span class="cov0" title="0">if diff.Get("password_expiry_days").(int) == 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("password_expiry_days is required when using password_regex")
                }</span>
                <span class="cov0" title="0">if diff.Get("first_reminder_days").(int) == 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("first_reminder_days is required when using password_regex")
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func toPasswordPolicy(d *schema.ResourceData) (*models.V1TenantPasswordPolicyEntity, error) <span class="cov0" title="0">{
        if d.Get("password_regex").(string) != "" </span><span class="cov0" title="0">{
                return &amp;models.V1TenantPasswordPolicyEntity{
                        IsRegex:              true,
                        Regex:                d.Get("password_regex").(string),
                        ExpiryDurationInDays: int64(d.Get("password_expiry_days").(int)),
                        FirstReminderInDays:  int64(d.Get("first_reminder_days").(int)),
                }, nil
        }</span>
        <span class="cov0" title="0">return &amp;models.V1TenantPasswordPolicyEntity{
                ExpiryDurationInDays:      int64(d.Get("password_expiry_days").(int)),
                FirstReminderInDays:       int64(d.Get("first_reminder_days").(int)),
                IsRegex:                   false,
                MinLength:                 int64(d.Get("min_password_length").(int)),
                MinNumOfBlockLetters:      int64(d.Get("min_uppercase_letters").(int)),
                MinNumOfDigits:            int64(d.Get("min_digits").(int)),
                MinNumOfSmallLetters:      int64(d.Get("min_lowercase_letters").(int)),
                MinNumOfSpecialCharacters: int64(d.Get("min_special_characters").(int)),
                Regex:                     "",
        }, nil</span>
}

func toPasswordPolicyDefault(d *schema.ResourceData) (*models.V1TenantPasswordPolicyEntity, error) <span class="cov0" title="0">{
        return &amp;models.V1TenantPasswordPolicyEntity{
                ExpiryDurationInDays:      999,
                FirstReminderInDays:       5,
                IsRegex:                   false,
                MinLength:                 6,
                MinNumOfBlockLetters:      1,
                MinNumOfDigits:            1,
                MinNumOfSmallLetters:      1,
                MinNumOfSpecialCharacters: 1,
                Regex:                     "",
        }, nil
}</span>

func flattenPasswordPolicy(passwordPolicy *models.V1TenantPasswordPolicyEntity, d *schema.ResourceData) error <span class="cov0" title="0">{
        var err error
        if passwordPolicy.Regex != "" </span><span class="cov0" title="0">{
                err = d.Set("password_regex", passwordPolicy.Regex)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        } else<span class="cov0" title="0"> {
                err = d.Set("min_password_length", passwordPolicy.MinLength)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">err = d.Set("min_uppercase_letters", passwordPolicy.MinNumOfBlockLetters)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">err = d.Set("min_digits", passwordPolicy.MinNumOfDigits)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">err = d.Set("min_lowercase_letters", passwordPolicy.MinNumOfSmallLetters)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">err = d.Set("min_special_characters", passwordPolicy.MinNumOfSpecialCharacters)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">err = d.Set("password_expiry_days", passwordPolicy.ExpiryDurationInDays)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">err = d.Set("first_reminder_days", passwordPolicy.FirstReminderInDays)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func resourcePasswordPolicyCreate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        c := getV1ClientWithResourceContext(m, tenantString)
        var diags diag.Diagnostics
        passwordPolicy, err := toPasswordPolicy(d)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">tenantUID, err := c.GetTenantUID()
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        // For Password Policy we don't have support for creation it's always an update
        <span class="cov0" title="0">err = c.UpdatePasswordPolicy(tenantUID, passwordPolicy)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">d.SetId("default-password-policy-id")
        return diags</span>
}

func resourcePasswordPolicyRead(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        c := getV1ClientWithResourceContext(m, tenantString)
        var diags diag.Diagnostics
        tenantUID, err := c.GetTenantUID()
        if err != nil </span><span class="cov0" title="0">{
                return handleReadError(d, err, diags)
        }</span>
        <span class="cov0" title="0">resp, err := c.GetPasswordPolicy(tenantUID)
        if err != nil </span><span class="cov0" title="0">{
                return handleReadError(d, err, diags)
        }</span>
        // handling case for cross-plane for singleton resource
        <span class="cov0" title="0">if d.Id() != "default-password-policy-id" </span><span class="cov0" title="0">{
                // If we are not reading the default password policy, we should not set the ID
                d.SetId("")
                return diags
        }</span>
        <span class="cov0" title="0">err = flattenPasswordPolicy(resp, d)
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return diags</span>
}

func resourcePasswordPolicyUpdate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        c := getV1ClientWithResourceContext(m, tenantString)
        var diags diag.Diagnostics
        passwordPolicy, err := toPasswordPolicy(d)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">tenantUID, err := c.GetTenantUID()
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        // For Password Policy we don't have support for creation it's always an update
        <span class="cov0" title="0">err = c.UpdatePasswordPolicy(tenantUID, passwordPolicy)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">return diags</span>
}

func resourcePasswordPolicyDelete(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        c := getV1ClientWithResourceContext(m, tenantString)
        var diags diag.Diagnostics
        // We can't delete the base password policy, instead
        passwordPolicy, err := toPasswordPolicyDefault(d)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">tenantUID, err := c.GetTenantUID()
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        // For Password Policy we don't have support for creation it's always an update
        <span class="cov0" title="0">err = c.UpdatePasswordPolicy(tenantUID, passwordPolicy)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">d.SetId("")
        return diags</span>
}

func resourcePasswordPolicyImport(ctx context.Context, d *schema.ResourceData, m interface{}) ([]*schema.ResourceData, error) <span class="cov0" title="0">{
        c := getV1ClientWithResourceContext(m, "tenant")
        var diags diag.Diagnostics
        givenTenantId := d.Id()
        actualTenantId, err := c.GetTenantUID()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if givenTenantId != actualTenantId </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("tenant id is not valid with current user: %v", diags)
        }</span>
        <span class="cov0" title="0">diags = resourcePasswordPolicyRead(ctx, d, m)
        if diags.HasError() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("could not read password policy for import: %v", diags)
        }</span>
        <span class="cov0" title="0">return []*schema.ResourceData{d}, nil</span>
}
</pre>
		
		<pre class="file" id="file167" style="display: none">package spectrocloud

import (
        "context"
        "regexp"
        "time"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
        "github.com/spectrocloud/palette-sdk-go/api/models"
)

func resourcePrivateCloudGatewayDNSMap() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                CreateContext: resourcePCGDNSMapCreate,
                ReadContext:   resourcePCGDNSMapRead,
                UpdateContext: resourcePCGDNSMapUpdate,
                DeleteContext: resourcePCGDNSMapDelete,
                Importer: &amp;schema.ResourceImporter{
                        StateContext: resourcePrivateCloudGatewayDNSMapImport,
                },
                Description: "This resource allows for the management of DNS mappings for private cloud gateways. This helps ensure proper DNS resolution for resources within the private cloud environment.",

                Timeouts: &amp;schema.ResourceTimeout{
                        Create: schema.DefaultTimeout(10 * time.Minute),
                        Update: schema.DefaultTimeout(10 * time.Minute),
                        Delete: schema.DefaultTimeout(10 * time.Minute),
                },
                SchemaVersion: 2,
                Schema: map[string]*schema.Schema{
                        "private_cloud_gateway_id": {
                                Type:        schema.TypeString,
                                ForceNew:    true,
                                Required:    true,
                                Description: "The ID of the Private Cloud Gateway.",
                        },
                        "search_domain_name": {
                                Type:        schema.TypeString,
                                Required:    true,
                                Description: "The domain name used for DNS search queries within the private cloud.",
                                ValidateFunc: validation.StringMatch(
                                        regexp.MustCompile(`^([a-zA-Z0-9-]+\.)+[a-zA-Z]{2,}$`),
                                        "must be a valid domain name",
                                ),
                        },
                        "data_center": {
                                Type:        schema.TypeString,
                                Required:    true,
                                ForceNew:    true,
                                Description: "The data center in which the private cloud resides.",
                        },
                        "network": {
                                Type:        schema.TypeString,
                                Required:    true,
                                ForceNew:    true,
                                Description: "The network to which the private cloud gateway is mapped.",
                        },
                },
        }
}</span>

func toDNSMap(d *schema.ResourceData) *models.V1VsphereDNSMapping <span class="cov0" title="0">{
        return &amp;models.V1VsphereDNSMapping{
                Metadata: &amp;models.V1ObjectMeta{
                        Name: d.Get("search_domain_name").(string),
                },
                Spec: &amp;models.V1VsphereDNSMappingSpec{
                        Datacenter:        StringPtr(d.Get("data_center").(string)),
                        DNSName:           StringPtr(d.Get("search_domain_name").(string)),
                        Network:           StringPtr(d.Get("network").(string)),
                        PrivateGatewayUID: StringPtr(d.Get("private_cloud_gateway_id").(string)),
                        // UI doesn't send network_url may need to enable in the future.
                        // NetworkURL:        "",
                },
        }
}</span>

func flattenDNSMap(dnsMap *models.V1VsphereDNSMapping, d *schema.ResourceData) error <span class="cov0" title="0">{
        if dnsMap != nil </span><span class="cov0" title="0">{
                if *dnsMap.Spec.DNSName != "" </span><span class="cov0" title="0">{
                        err := d.Set("search_domain_name", *dnsMap.Spec.DNSName)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
                <span class="cov0" title="0">if *dnsMap.Spec.Datacenter != "" </span><span class="cov0" title="0">{
                        err := d.Set("data_center", *dnsMap.Spec.Datacenter)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
                <span class="cov0" title="0">if *dnsMap.Spec.Network != "" </span><span class="cov0" title="0">{
                        err := d.Set("network", *dnsMap.Spec.Network)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
                <span class="cov0" title="0">if *dnsMap.Spec.PrivateGatewayUID != "" </span><span class="cov0" title="0">{
                        err := d.Set("private_cloud_gateway_id", *dnsMap.Spec.PrivateGatewayUID)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

func resourcePCGDNSMapCreate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        c := getV1ClientWithResourceContext(m, "tenant")
        var diags diag.Diagnostics

        dnsMap := toDNSMap(d)
        uid, err := c.CreateVsphereDNSMap(dnsMap)

        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">d.SetId(uid)

        return diags</span>
}

func resourcePCGDNSMapUpdate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        c := getV1ClientWithResourceContext(m, "tenant")
        var diags diag.Diagnostics

        dnsMap := toDNSMap(d)
        err := c.UpdateVsphereDNSMap(d.Id(), dnsMap)

        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">return diags</span>
}

func resourcePCGDNSMapRead(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        c := getV1ClientWithResourceContext(m, "tenant")
        var diags diag.Diagnostics
        dnsMap, err := c.GetVsphereDNSMap(d.Id())
        if err != nil </span><span class="cov0" title="0">{
                return handleReadError(d, err, diags)
        }</span>
        <span class="cov0" title="0">err = flattenDNSMap(dnsMap, d)
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return diags</span>
}

func resourcePCGDNSMapDelete(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        c := getV1ClientWithResourceContext(m, "tenant")
        var diags diag.Diagnostics
        err := c.DeleteVsphereDNSMap(d.Id())
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">d.SetId("")
        return diags</span>
}
</pre>
		
		<pre class="file" id="file168" style="display: none">package spectrocloud

import (
        "context"
        "fmt"
        "strings"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/spectrocloud/palette-sdk-go/client"
)

func resourcePrivateCloudGatewayDNSMapImport(ctx context.Context, d *schema.ResourceData, m interface{}) ([]*schema.ResourceData, error) <span class="cov0" title="0">{
        _, err := GetCommonPrivateCloudGatewayDNSMap(d, m)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Read all DNS map data to populate the state
        <span class="cov0" title="0">diags := resourcePCGDNSMapRead(ctx, d, m)
        if diags.HasError() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("could not read PCG DNS map for import: %v", diags)
        }</span>

        <span class="cov0" title="0">return []*schema.ResourceData{d}, nil</span>
}

func GetCommonPrivateCloudGatewayDNSMap(d *schema.ResourceData, m interface{}) (*client.V1Client, error) <span class="cov0" title="0">{
        // DNS maps are tenant-level resources, so use tenant context
        c := getV1ClientWithResourceContext(m, "tenant")

        // Parse the import ID to extract PCG ID and DNS map ID
        // Expected format: pcg_id:dns_map_id
        importID := d.Id()
        if importID == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("DNS map import ID is required")
        }</span>

        <span class="cov0" title="0">parts := strings.Split(importID, ":")
        if len(parts) != 2 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid import ID format. Expected format: pcg_id:dns_map_id, got: %s", importID)
        }</span>

        <span class="cov0" title="0">pcgID := parts[0]
        dnsMapID := parts[1]

        // Validate that the PCG exists
        pcg, err := c.GetPCGByID(pcgID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unable to retrieve private cloud gateway: %s", err)
        }</span>
        <span class="cov0" title="0">if pcg == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("private cloud gateway with ID %s not found", pcgID)
        }</span>

        // Validate that the DNS map exists
        <span class="cov0" title="0">dnsMap, err := c.GetVsphereDNSMap(dnsMapID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unable to retrieve DNS map: %s", err)
        }</span>
        <span class="cov0" title="0">if dnsMap == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("DNS map with ID %s not found", dnsMapID)
        }</span>

        // Set the required fields for the resource from the retrieved DNS map
        <span class="cov0" title="0">if err := d.Set("private_cloud_gateway_id", pcgID); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if dnsMap.Spec != nil </span><span class="cov0" title="0">{
                if dnsMap.Spec.DNSName != nil &amp;&amp; *dnsMap.Spec.DNSName != "" </span><span class="cov0" title="0">{
                        if err := d.Set("search_domain_name", *dnsMap.Spec.DNSName); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                }

                <span class="cov0" title="0">if dnsMap.Spec.Datacenter != nil &amp;&amp; *dnsMap.Spec.Datacenter != "" </span><span class="cov0" title="0">{
                        if err := d.Set("data_center", *dnsMap.Spec.Datacenter); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                }

                <span class="cov0" title="0">if dnsMap.Spec.Network != nil &amp;&amp; *dnsMap.Spec.Network != "" </span><span class="cov0" title="0">{
                        if err := d.Set("network", *dnsMap.Spec.Network); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                }
        }

        // Set the ID to just the DNS map ID (the read function will use private_cloud_gateway_id)
        <span class="cov0" title="0">d.SetId(dnsMapID)

        return c, nil</span>
}
</pre>
		
		<pre class="file" id="file169" style="display: none">package spectrocloud

import (
        "context"
        "fmt"
        "time"

        "github.com/hashicorp/go-cty/cty"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

        "github.com/spectrocloud/palette-sdk-go/api/models"
        "github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/constants"
)

func resourcePrivateCloudGatewayIpPool() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                CreateContext: resourceIpPoolCreate,
                ReadContext:   resourceIpPoolRead,
                UpdateContext: resourceIpPoolUpdate,
                DeleteContext: resourceIpPoolDelete,
                Importer: &amp;schema.ResourceImporter{
                        StateContext: resourcePrivateCloudGatewayIpPoolImport,
                },
                Description: "A Resource to manage IP pools for Private Cloud Gateway.",

                Timeouts: &amp;schema.ResourceTimeout{
                        Create: schema.DefaultTimeout(10 * time.Minute),
                        Update: schema.DefaultTimeout(10 * time.Minute),
                        Delete: schema.DefaultTimeout(10 * time.Minute),
                },

                SchemaVersion: 2,
                Schema: map[string]*schema.Schema{
                        "name": {
                                Type:        schema.TypeString,
                                Required:    true,
                                ForceNew:    true,
                                Description: "The name of the IP pool.",
                        },
                        "private_cloud_gateway_id": {
                                Type:        schema.TypeString,
                                ForceNew:    true,
                                Required:    true,
                                Description: "The ID of the Private Cloud Gateway.",
                        },
                        "network_type": {
                                Type:             schema.TypeString,
                                Required:         true,
                                ValidateDiagFunc: validateNetworkType,
                                Description:      "The type of network for the IP pool. Allowed values are: `range` and `subnet`.",
                        },
                        "ip_start_range": {
                                Type:        schema.TypeString,
                                Optional:    true,
                                Description: "The start IP address of the IP pool. Required if `network_type` is `range`.",
                        },
                        "ip_end_range": {
                                Type:        schema.TypeString,
                                Optional:    true,
                                Description: "The end IP address of the IP pool. Required if `network_type` is `range`.",
                        },
                        "subnet_cidr": {
                                Type:        schema.TypeString,
                                Optional:    true,
                                Description: "The subnet CIDR of the IP pool. Required if `network_type` is `subnet`.",
                        },
                        "prefix": {
                                Type:        schema.TypeInt,
                                Required:    true,
                                Description: "The prefix of the IP pool provided network range or subnet. For example `24` for a `/24` subnet or a range that falls inside a `24` subnet.",
                        },
                        "gateway": {
                                Type:        schema.TypeString,
                                Required:    true,
                                Description: "The network gateway IP address for the IP pool. Typically, this is the default network gateway for the subnet.",
                        },
                        "nameserver_addresses": {
                                Type:     schema.TypeSet,
                                Optional: true,
                                Set:      schema.HashString,
                                Elem: &amp;schema.Schema{
                                        Type: schema.TypeString,
                                },
                                Description: "The list of nameserver IP addresses for the IP pool.",
                        },
                        "nameserver_search_suffix": {
                                Type:     schema.TypeSet,
                                Optional: true,
                                Set:      schema.HashString,
                                Elem: &amp;schema.Schema{
                                        Type: schema.TypeString,
                                },
                                Description: "The list of nameserver search suffixes for the IP pool. For example, `example.org`.",
                        },
                        "restrict_to_single_cluster": {
                                Type:        schema.TypeBool,
                                Optional:    true,
                                Default:     false,
                                Description: "Restrict the IP pool to a single cluster. If set to `true`, the IP pool is restricted to a single cluster. We recommend setting this to `true` for production environments and creating separate IP pools for each cluster.",
                        },
                },
        }
}</span>

func resourceIpPoolCreate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        c := getV1ClientWithResourceContext(m, "tenant")
        var diags diag.Diagnostics
        pcgUID := d.Get("private_cloud_gateway_id").(string)

        pool := toIpPool(d)

        uid, err := c.CreateIPPool(pcgUID, pool)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">d.SetId(uid)

        return diags</span>
}

func resourceIpPoolRead(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        c := getV1ClientWithResourceContext(m, "tenant")
        var diags diag.Diagnostics

        pcgUID := d.Get("private_cloud_gateway_id").(string)

        pool, err := c.GetIPPool(pcgUID, d.Id())
        if err != nil </span><span class="cov0" title="0">{
                return handleReadError(d, err, diags)
        }</span> else<span class="cov0" title="0"> if pool == nil </span><span class="cov0" title="0">{
                // Deleted - Terraform will recreate it
                d.SetId("")
                return diags
        }</span>

        <span class="cov0" title="0">if err := d.Set("name", pool.Metadata.Name); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">if err := d.Set("gateway", pool.Spec.Pool.Gateway); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">if err := d.Set("prefix", pool.Spec.Pool.Prefix); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">if err := d.Set("restrict_to_single_cluster", pool.Spec.RestrictToSingleCluster); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">if len(pool.Spec.Pool.Subnet) &gt; 0 </span><span class="cov0" title="0">{
                if err := d.Set("subnet_cidr", pool.Spec.Pool.Subnet); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
        } else<span class="cov0" title="0"> {
                if err := d.Set("ip_start_range", pool.Spec.Pool.Start); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
                <span class="cov0" title="0">if err := d.Set("ip_end_range", pool.Spec.Pool.End); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
        }

        <span class="cov0" title="0">if pool.Spec.Pool.Nameserver != nil &amp;&amp; len(pool.Spec.Pool.Nameserver.Addresses) &gt; 0 </span><span class="cov0" title="0">{
                if err := d.Set("nameserver_addresses", pool.Spec.Pool.Nameserver.Addresses); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
        } else<span class="cov0" title="0"> if pool.Spec.Pool.Nameserver != nil &amp;&amp; len(pool.Spec.Pool.Nameserver.Search) &gt; 0 </span><span class="cov0" title="0">{
                if err := d.Set("nameserver_search_suffix", pool.Spec.Pool.Nameserver.Search); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
        }

        <span class="cov0" title="0">return diags</span>
}

func resourceIpPoolUpdate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        c := getV1ClientWithResourceContext(m, "tenant")
        var diags diag.Diagnostics

        pcgUID := d.Get("private_cloud_gateway_id").(string)

        pool := toIpPool(d)

        err := c.UpdateIPPool(pcgUID, d.Id(), pool)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">return diags</span>
}

func resourceIpPoolDelete(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        c := getV1ClientWithResourceContext(m, "tenant")
        var diags diag.Diagnostics

        pcgUID := d.Get("private_cloud_gateway_id").(string)

        err := c.DeleteIPPool(pcgUID, d.Id())
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">return diags</span>
}

func toIpPool(d *schema.ResourceData) *models.V1IPPoolInputEntity <span class="cov0" title="0">{
        prefixInt := d.Get("prefix").(int)
        if prefixInt &gt; constants.Int32MaxValue </span><span class="cov0" title="0">{
                // This should not happen in practice as prefix is typically 0-32 for CIDR notation
                prefixInt = 24 // Default to /24 if out of range
        }</span>

        <span class="cov0" title="0">pool := &amp;models.V1Pool{
                Gateway:    d.Get("gateway").(string),
                Nameserver: &amp;models.V1Nameserver{},
                Prefix:     SafeInt32(prefixInt),
        }

        if d.Get("network_type").(string) == "range" </span><span class="cov0" title="0">{
                pool.Start = d.Get("ip_start_range").(string)
                pool.End = d.Get("ip_end_range").(string)
        }</span> else<span class="cov0" title="0"> {
                pool.Subnet = d.Get("subnet_cidr").(string)
        }</span>

        <span class="cov0" title="0">if d.Get("nameserver_addresses") != nil </span><span class="cov0" title="0">{
                addresses := make([]string, 0)
                for _, az := range d.Get("nameserver_addresses").(*schema.Set).List() </span><span class="cov0" title="0">{
                        addresses = append(addresses, az.(string))
                }</span>
                <span class="cov0" title="0">pool.Nameserver.Addresses = addresses</span>
        }

        <span class="cov0" title="0">if d.Get("nameserver_search_suffix") != nil </span><span class="cov0" title="0">{
                searchArr := make([]string, 0)
                for _, az := range d.Get("nameserver_search_suffix").(*schema.Set).List() </span><span class="cov0" title="0">{
                        searchArr = append(searchArr, az.(string))
                }</span>
                <span class="cov0" title="0">pool.Nameserver.Search = searchArr</span>
        }

        <span class="cov0" title="0">return &amp;models.V1IPPoolInputEntity{
                Metadata: &amp;models.V1ObjectMeta{
                        Name: d.Get("name").(string),
                        UID:  d.Id(),
                },
                Spec: &amp;models.V1IPPoolInputEntitySpec{
                        Pool:                    pool,
                        RestrictToSingleCluster: d.Get("restrict_to_single_cluster").(bool),
                },
        }</span>
}

func validateNetworkType(data interface{}, path cty.Path) diag.Diagnostics <span class="cov0" title="0">{
        var diags diag.Diagnostics
        networkType := data.(string)
        for _, nwType := range []string{"range", "subnet"} </span><span class="cov0" title="0">{
                if nwType == networkType </span><span class="cov0" title="0">{
                        return diags
                }</span>
        }
        <span class="cov0" title="0">return diag.FromErr(fmt.Errorf("network type '%s' is invalid. valid network types are 'range' and 'subnet'", networkType))</span>
}
</pre>
		
		<pre class="file" id="file170" style="display: none">package spectrocloud

import (
        "context"
        "fmt"
        "strings"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/spectrocloud/palette-sdk-go/client"
)

func resourcePrivateCloudGatewayIpPoolImport(ctx context.Context, d *schema.ResourceData, m interface{}) ([]*schema.ResourceData, error) <span class="cov0" title="0">{
        _, err := GetCommonPrivateCloudGatewayIpPool(d, m)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Read all IP pool data to populate the state
        <span class="cov0" title="0">diags := resourceIpPoolRead(ctx, d, m)
        if diags.HasError() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("could not read IP pool for import: %v", diags)
        }</span>

        <span class="cov0" title="0">return []*schema.ResourceData{d}, nil</span>
}

func GetCommonPrivateCloudGatewayIpPool(d *schema.ResourceData, m interface{}) (*client.V1Client, error) <span class="cov0" title="0">{
        // IP pools are tenant-level resources, so use tenant context
        c := getV1ClientWithResourceContext(m, "tenant")

        // Parse the import ID to extract PCG ID and IP pool ID
        // Expected format: pcg_id:ippool_id
        importID := d.Id()
        if importID == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("IP pool import ID is required")
        }</span>

        <span class="cov0" title="0">parts := strings.Split(importID, ":")
        if len(parts) != 2 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid import ID format. Expected format: pcg_id:ippool_id, got: %s", importID)
        }</span>

        <span class="cov0" title="0">pcgID := parts[0]
        ipPoolID := parts[1]

        // Validate that the PCG exists
        pcg, err := c.GetPCGByID(pcgID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unable to retrieve private cloud gateway: %s", err)
        }</span>
        <span class="cov0" title="0">if pcg == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("private cloud gateway with ID %s not found", pcgID)
        }</span>

        // Validate that the IP pool exists within the PCG
        <span class="cov0" title="0">ipPool, err := c.GetIPPool(pcgID, ipPoolID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unable to retrieve IP pool: %s", err)
        }</span>
        <span class="cov0" title="0">if ipPool == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("IP pool with ID %s not found in PCG %s", ipPoolID, pcgID)
        }</span>

        // Set the required fields for the resource
        <span class="cov0" title="0">if err := d.Set("private_cloud_gateway_id", pcgID); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := d.Set("name", ipPool.Metadata.Name); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Set the network type based on the pool configuration
        <span class="cov0" title="0">networkType := "range" // default
        if ipPool.Spec != nil &amp;&amp; ipPool.Spec.Pool != nil &amp;&amp; len(ipPool.Spec.Pool.Subnet) &gt; 0 </span><span class="cov0" title="0">{
                networkType = "subnet"
        }</span>
        <span class="cov0" title="0">if err := d.Set("network_type", networkType); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Set the ID to just the IP pool ID (the read function will use private_cloud_gateway_id)
        <span class="cov0" title="0">d.SetId(ipPoolID)

        return c, nil</span>
}
</pre>
		
		<pre class="file" id="file171" style="display: none">package spectrocloud

import (
        "context"
        "fmt"
        "strings"
        "time"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
        "github.com/spectrocloud/palette-sdk-go/api/models"
        "github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/constants"
)

func resourcePlatformSetting() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                CreateContext: resourcePlatformSettingCreate,
                ReadContext:   resourcePlatformSettingRead,
                UpdateContext: resourcePlatformSettingUpdate,
                DeleteContext: resourcePlatformSettingDelete,
                Importer: &amp;schema.ResourceImporter{
                        StateContext: resourcePlatformSettingImport,
                },
                Timeouts: &amp;schema.ResourceTimeout{
                        Create: schema.DefaultTimeout(10 * time.Minute),
                        Update: schema.DefaultTimeout(10 * time.Minute),
                        Delete: schema.DefaultTimeout(10 * time.Minute),
                },
                SchemaVersion: 2,
                Schema: map[string]*schema.Schema{
                        "context": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "tenant",
                                ForceNew:     true,
                                ValidateFunc: validation.StringInSlice([]string{"project", "tenant"}, false),
                                Description: "Defines the scope of the platform setting. Valid values are `project` or `tenant`. " +
                                        "By default, it is set to `tenant`. " + PROJECT_NAME_NUANCE,
                        },
                        "session_timeout": {
                                Type:        schema.TypeInt,
                                Optional:    true,
                                Description: "Specifies the duration (in minutes) of inactivity before a user is automatically logged out. The default is 240 minutes allowed in Palette. Allowed only for `tenant` context",
                        },
                        "pause_agent_upgrades": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "unlock",
                                ValidateFunc: validation.StringInSlice([]string{"lock", "unlock"}, false),
                                Description: "Controls automatic upgrades for Palette components and agents in clusters deployed under a tenant or project. " +
                                        "Setting it to `lock` disables automatic upgrades, while `unlock` (default) allows automatic upgrades.",
                        },
                        "enable_auto_remediation": {
                                Type:        schema.TypeBool,
                                Optional:    true,
                                Default:     true,
                                Description: "Enables automatic remediation. set only with `project' context",
                        },
                        "cluster_auto_remediation": {
                                Type:     schema.TypeBool,
                                Optional: true,
                                Default:  true,
                                Description: "Enables automatic remediation for unhealthy nodes in Palette-provisioned clusters by replacing them with new nodes. " +
                                        "Disabling this feature prevents auto-remediation. Not applicable to `EKS`, `AKS`, or `TKE` clusters.",
                        },
                        "automatic_cluster_role_binding": {
                                Type:        schema.TypeBool,
                                Optional:    true,
                                Default:     false,
                                Description: "Enables automatic cluster role binding for clusters deployed under a tenant or project. Setting it to `false` disables automatic cluster role binding.",
                        },
                        "non_fips_addon_pack": {
                                Type:        schema.TypeBool,
                                Optional:    true,
                                Description: "Allows users in this tenant to use non-FIPS-compliant addon packs when creating cluster profiles. The `non_fips_addon_pack` only supported in palette vertex environment. Allowed only for `tenant` context",
                        },
                        "non_fips_features": {
                                Type:        schema.TypeBool,
                                Optional:    true,
                                Description: "Allows users in this tenant to access non-FIPS-compliant features such as backup, restore, and scans. The `non_fips_features` only supported in palette vertex environment. Allowed only for `tenant` context",
                        },
                        "non_fips_cluster_import": {
                                Type:        schema.TypeBool,
                                Optional:    true,
                                Description: "Allows users in this tenant to import clusters, but the imported clusters may not be FIPS-compliant.  The `non_fips_cluster_import` only supported in palette vertex environment. Allowed only for `tenant` context",
                        },
                        "login_banner": {
                                Type:        schema.TypeList,
                                MaxItems:    1,
                                Optional:    true,
                                Description: "Configure a login banner that users must acknowledge before signing in. Allowed only for `tenant` context",
                                Elem: &amp;schema.Resource{
                                        Schema: map[string]*schema.Schema{
                                                "title": {
                                                        Type:        schema.TypeString,
                                                        Required:    true,
                                                        Description: "Specify the title of the login banner.",
                                                },
                                                "message": {
                                                        Type:        schema.TypeString,
                                                        Required:    true,
                                                        Description: "Specify the message displayed in the login banner.",
                                                },
                                        },
                                },
                        },
                },
                CustomizeDiff: validateContextDependencies,
        }
}</span>

func validateContextDependencies(ctx context.Context, d *schema.ResourceDiff, meta interface{}) error <span class="cov0" title="0">{
        contextVal := d.Get("context").(string)

        if contextVal == "project" </span><span class="cov0" title="0">{
                disallowedFields := []string{"session_timeout", "login_banner", "non_fips_addon_pack", "non_fips_features", "non_fips_cluster_import"}

                for _, field := range disallowedFields </span><span class="cov0" title="0">{
                        if _, exists := d.GetOk(field); exists </span><span class="cov0" title="0">{
                                return fmt.Errorf("attribute %q is not allowed when context is set to 'project'", field)
                        }</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

func updatePlatformSettings(d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        platformSettingContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, platformSettingContext)
        tenantUID, err := c.GetTenantUID()
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">var diags diag.Diagnostics

        remediationSettings := &amp;models.V1NodesAutoRemediationSettings{
                DisableNodesAutoRemediation: d.Get("cluster_auto_remediation").(bool),
                IsEnabled:                   d.Get("enable_auto_remediation").(bool), // when ever we are setting `cluster_auto_remediation` we need enable it hence set same attribute
        }
        if platformSettingContext == tenantString </span><span class="cov0" title="0">{
                // session timeout
                if sessionTime, ok := d.GetOk("session_timeout"); ok </span><span class="cov0" title="0">{
                        sessionTimeInt := sessionTime.(int)
                        if sessionTimeInt &gt; constants.Int32MaxValue </span><span class="cov0" title="0">{
                                return diag.FromErr(fmt.Errorf("session_timeout value %d is out of range for int32", sessionTimeInt))
                        }</span>
                        <span class="cov0" title="0">err = c.UpdateSessionTimeout(tenantUID,
                                &amp;models.V1AuthTokenSettings{ExpiryTimeMinutes: SafeInt32(sessionTimeInt)})
                        if err != nil </span><span class="cov0" title="0">{
                                return diag.FromErr(err)
                        }</span>
                }

                <span class="cov0" title="0">if automaticClusterRoleBinding, ok := d.GetOk("automatic_cluster_role_binding"); ok </span><span class="cov0" title="0">{
                        var bindingMode string
                        if automaticClusterRoleBinding.(bool) </span><span class="cov0" title="0">{
                                bindingMode = "enabled"
                        }</span> else<span class="cov0" title="0"> {
                                bindingMode = "disabled"
                        }</span>
                        <span class="cov0" title="0">err = c.UpdateAutomaticClusterRoleBinding(tenantUID,
                                &amp;models.V1TenantClusterRbacSettings{AutomaticClusterRoleBinding: &amp;bindingMode})
                        if err != nil </span><span class="cov0" title="0">{
                                return diag.FromErr(err)
                        }</span>
                }

                <span class="cov0" title="0">loginBanner := d.Get("login_banner").([]interface{})
                // login banner
                if len(loginBanner) == 1 </span><span class="cov0" title="0">{
                        bannerData := loginBanner[0].(map[string]interface{})
                        bannerSetting := &amp;models.V1LoginBannerSettings{
                                Message:   bannerData["message"].(string),
                                IsEnabled: true,
                                Title:     bannerData["title"].(string),
                        }
                        err = c.UpdateLoginBanner(tenantUID, bannerSetting)
                        if err != nil </span><span class="cov0" title="0">{
                                return diag.FromErr(err)
                        }</span>
                } else<span class="cov0" title="0"> {
                        bannerSetting := &amp;models.V1LoginBannerSettings{
                                Message:   "",
                                IsEnabled: false,
                                Title:     "",
                        }
                        err = c.UpdateLoginBanner(tenantUID, bannerSetting)
                        if err != nil </span><span class="cov0" title="0">{
                                return diag.FromErr(err)
                        }</span>
                }
                // cluster node remediation for tenant
                <span class="cov0" title="0">err = c.UpdateClusterAutoRemediationForTenant(tenantUID, remediationSettings)
                if err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>

                // non fip related setting
                <span class="cov0" title="0">fipsAddonPack := "nonFipsDisabled"
                fipsFeatures := "nonFipsDisabled"
                fipsClusterImport := "nonFipsDisabled"

                fp, fpOk := d.GetOk("non_fips_addon_pack")
                ff, ffOk := d.GetOk("non_fips_features")
                fi, fiOk := d.GetOk("non_fips_cluster_import")

                if fpOk </span><span class="cov0" title="0">{
                        fipsAddonPack = convertFIPSBool(fp.(bool))
                }</span>
                <span class="cov0" title="0">if ffOk </span><span class="cov0" title="0">{
                        fipsFeatures = convertFIPSBool(ff.(bool))
                }</span>
                <span class="cov0" title="0">if fiOk </span><span class="cov0" title="0">{
                        fipsClusterImport = convertFIPSBool(fi.(bool))
                }</span>

                <span class="cov0" title="0">if fiOk || ffOk || fpOk </span><span class="cov0" title="0">{
                        err = c.UpdateFIPSPreference(tenantUID, &amp;models.V1FipsSettings{
                                FipsClusterFeatureConfig: &amp;models.V1NonFipsConfig{Mode: &amp;fipsFeatures},
                                FipsClusterImportConfig:  &amp;models.V1NonFipsConfig{Mode: &amp;fipsClusterImport},
                                FipsPackConfig:           &amp;models.V1NonFipsConfig{Mode: &amp;fipsAddonPack},
                        })
                        if err != nil </span><span class="cov0" title="0">{
                                return diag.FromErr(err)
                        }</span>
                }
                <span class="cov0" title="0">d.SetId(fmt.Sprintf("platformsetting-%s", tenantUID))</span>
        } else<span class="cov0" title="0"> {
                // cluster node remediation for project
                err = c.UpdateClusterAutoRemediationForProject(ProviderInitProjectUid, remediationSettings)
                if err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
                <span class="cov0" title="0">d.SetId(fmt.Sprintf("platformsetting-%s", ProviderInitProjectUid))</span>
        }
        // pause agent upgrade setting according to context
        <span class="cov0" title="0">err = c.UpdatePlatformClusterUpgradeSetting(&amp;models.V1ClusterUpgradeSettingsEntity{
                SpectroComponents: d.Get("pause_agent_upgrades").(string)})
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">return diags</span>
}

func convertFIPSBool(flag bool) string <span class="cov0" title="0">{
        if flag </span><span class="cov0" title="0">{
                return "nonFipsEnabled"
        }</span>
        <span class="cov0" title="0">return "nonFipsDisabled"</span>
}

func convertFIPSString(flag string) bool <span class="cov0" title="0">{
        return flag == "nonFipsEnabled"
}</span>

func resourcePlatformSettingCreate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        diags := updatePlatformSettings(d, m)
        return diags
}</span>

func resourcePlatformSettingRead(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        platformSettingContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, platformSettingContext)
        var diags diag.Diagnostics
        tenantUID, err := c.GetTenantUID()
        if err != nil </span><span class="cov0" title="0">{
                return handleReadError(d, err, diags)
        }</span>
        // handling case for cross-plane for singleton resource
        <span class="cov0" title="0">if d.Id() == "" </span><span class="cov0" title="0">{
                d.SetId("")
                return diags
        }</span>

        <span class="cov0" title="0">if platformSettingContext == tenantString </span><span class="cov0" title="0">{
                // read session timeout
                var respSessionTimeout *models.V1AuthTokenSettings
                respSessionTimeout, err = c.GetSessionTimeout(tenantUID)
                if err != nil </span><span class="cov0" title="0">{
                        return handleReadError(d, err, diags)
                }</span>
                <span class="cov0" title="0">if err = d.Set("session_timeout", respSessionTimeout.ExpiryTimeMinutes); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>

                // read automatic cluster role binding
                <span class="cov0" title="0">var respAutomaticClusterRoleBinding *models.V1TenantClusterRbacSettings
                respAutomaticClusterRoleBinding, err = c.GetAutomaticClusterRoleBinding(tenantUID)
                if err != nil </span><span class="cov0" title="0">{
                        return handleReadError(d, err, diags)
                }</span>
                <span class="cov0" title="0">if err = d.Set("automatic_cluster_role_binding", respAutomaticClusterRoleBinding.AutomaticClusterRoleBinding != nil &amp;&amp; *respAutomaticClusterRoleBinding.AutomaticClusterRoleBinding == "enabled"); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>

                // read login banner
                <span class="cov0" title="0">var respLoginBanner *models.V1LoginBannerSettings
                respLoginBanner, err = c.GetLoginBanner(tenantUID)
                if err != nil </span><span class="cov0" title="0">{
                        return handleReadError(d, err, diags)
                }</span>
                <span class="cov0" title="0">if respLoginBanner.Title != "" &amp;&amp; respLoginBanner.Message != "" </span><span class="cov0" title="0">{
                        bannerDetails := make([]interface{}, 0)
                        bd := map[string]string{
                                "title":   respLoginBanner.Title,
                                "message": respLoginBanner.Message,
                        }
                        bannerDetails = append(bannerDetails, bd)
                        if err = d.Set("login_banner", bannerDetails); err != nil </span><span class="cov0" title="0">{
                                return diag.FromErr(err)
                        }</span>
                }
                // get cluster_auto_remediation tenant
                <span class="cov0" title="0">var respRemediation *models.V1TenantClusterSettings
                respRemediation, err = c.GetClusterAutoRemediationForTenant(tenantUID)
                if err != nil </span><span class="cov0" title="0">{
                        return handleReadError(d, err, diags)
                }</span>
                <span class="cov0" title="0">if err = d.Set("cluster_auto_remediation", respRemediation.NodesAutoRemediationSetting.DisableNodesAutoRemediation); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
                // get fips settings
                <span class="cov0" title="0">var fipsPreference *models.V1FipsSettings

                _, fpOk := d.GetOk("non_fips_addon_pack")
                _, ffOk := d.GetOk("non_fips_features")
                _, fiOk := d.GetOk("non_fips_cluster_import")

                if fiOk || ffOk || fpOk </span><span class="cov0" title="0">{
                        fipsPreference, err = c.GetFIPSPreference(tenantUID)
                        if err != nil </span><span class="cov0" title="0">{
                                return handleReadError(d, err, diags)
                        }</span>
                        <span class="cov0" title="0">if _, ok := d.GetOk("non_fips_addon_pack"); ok </span><span class="cov0" title="0">{
                                err := d.Set("non_fips_addon_pack", convertFIPSString(*fipsPreference.FipsPackConfig.Mode))
                                if err != nil </span><span class="cov0" title="0">{
                                        return diag.FromErr(err)
                                }</span>
                        }
                        <span class="cov0" title="0">if _, ok := d.GetOk("non_fips_features"); ok </span><span class="cov0" title="0">{
                                err := d.Set("non_fips_features", convertFIPSString(*fipsPreference.FipsClusterFeatureConfig.Mode))
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil
                                }</span>
                        }
                        <span class="cov0" title="0">if _, ok := d.GetOk("non_fips_cluster_import"); ok </span><span class="cov0" title="0">{
                                err := d.Set("non_fips_cluster_import", convertFIPSString(*fipsPreference.FipsClusterImportConfig.Mode))
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil
                                }</span>
                        }
                }
        } else<span class="cov0" title="0"> {
                // get cluster_auto_remediation project
                var respProjectRemediation *models.V1ProjectClusterSettings
                respProjectRemediation, err = c.GetClusterAutoRemediationForProject(ProviderInitProjectUid)
                if err != nil </span><span class="cov0" title="0">{
                        return handleReadError(d, err, diags)
                }</span>
                <span class="cov0" title="0">if err = d.Set("cluster_auto_remediation", respProjectRemediation.NodesAutoRemediationSetting.DisableNodesAutoRemediation); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
                <span class="cov0" title="0">if err = d.Set("enable_auto_remediation", respProjectRemediation.NodesAutoRemediationSetting.IsEnabled); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
        }
        // pause agent upgrade setting according to context
        <span class="cov0" title="0">var upgradeSetting *models.V1ClusterUpgradeSettingsEntity
        upgradeSetting, err = c.GetPlatformClustersUpgradeSetting()
        if err != nil </span><span class="cov0" title="0">{
                return handleReadError(d, err, diags)
        }</span>
        <span class="cov0" title="0">if err = d.Set("pause_agent_upgrades", upgradeSetting.SpectroComponents); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">return diags</span>
}

func resourcePlatformSettingUpdate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        platformSettingContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, platformSettingContext)
        tenantUID, err := c.GetTenantUID()
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">var diags diag.Diagnostics

        remediationSettings := &amp;models.V1NodesAutoRemediationSettings{
                DisableNodesAutoRemediation: d.Get("cluster_auto_remediation").(bool),
                IsEnabled:                   d.Get("enable_auto_remediation").(bool), // when ever we are setting `cluster_auto_remediation` we need enable it hence set same attribute
        }
        if platformSettingContext == tenantString </span><span class="cov0" title="0">{
                // session timeout
                if d.HasChange("session_timeout") </span><span class="cov0" title="0">{
                        if sessionTime, ok := d.GetOk("session_timeout"); ok </span><span class="cov0" title="0">{
                                sessionTimeInt := sessionTime.(int)
                                if sessionTimeInt &gt; constants.Int32MaxValue </span><span class="cov0" title="0">{
                                        return diag.FromErr(fmt.Errorf("session_timeout value %d is out of range for int32", sessionTimeInt))
                                }</span>
                                <span class="cov0" title="0">err = c.UpdateSessionTimeout(tenantUID,
                                        &amp;models.V1AuthTokenSettings{ExpiryTimeMinutes: SafeInt32(sessionTimeInt)})
                                if err != nil </span><span class="cov0" title="0">{
                                        return diag.FromErr(err)
                                }</span>
                        }
                }

                <span class="cov0" title="0">if ok := d.HasChange("automatic_cluster_role_binding"); ok </span><span class="cov0" title="0">{
                        automaticClusterRoleBinding := d.Get("automatic_cluster_role_binding")
                        var bindingMode string
                        if automaticClusterRoleBinding.(bool) </span><span class="cov0" title="0">{
                                bindingMode = "enabled"
                        }</span> else<span class="cov0" title="0"> {
                                bindingMode = "disabled"
                        }</span>
                        <span class="cov0" title="0">err = c.UpdateAutomaticClusterRoleBinding(tenantUID,
                                &amp;models.V1TenantClusterRbacSettings{AutomaticClusterRoleBinding: &amp;bindingMode})
                        if err != nil </span><span class="cov0" title="0">{
                                return diag.FromErr(err)
                        }</span>
                }

                <span class="cov0" title="0">if d.HasChange("login_banner") </span><span class="cov0" title="0">{
                        loginBanner := d.Get("login_banner").([]interface{})
                        // login banner
                        if len(loginBanner) == 1 </span><span class="cov0" title="0">{
                                bannerData := loginBanner[0].(map[string]interface{})
                                bannerSetting := &amp;models.V1LoginBannerSettings{
                                        Message:   bannerData["message"].(string),
                                        IsEnabled: true,
                                        Title:     bannerData["title"].(string),
                                }
                                err = c.UpdateLoginBanner(tenantUID, bannerSetting)
                                if err != nil </span><span class="cov0" title="0">{
                                        return diag.FromErr(err)
                                }</span>
                        } else<span class="cov0" title="0"> {
                                bannerSetting := &amp;models.V1LoginBannerSettings{
                                        Message:   "",
                                        IsEnabled: false,
                                        Title:     "",
                                }
                                err = c.UpdateLoginBanner(tenantUID, bannerSetting)
                                if err != nil </span><span class="cov0" title="0">{
                                        return diag.FromErr(err)
                                }</span>
                        }
                }
                <span class="cov0" title="0">if d.HasChanges("cluster_auto_remediation", "enable_auto_remediation") </span><span class="cov0" title="0">{
                        // cluster node remediation for tenant
                        err = c.UpdateClusterAutoRemediationForTenant(tenantUID, remediationSettings)
                        if err != nil </span><span class="cov0" title="0">{
                                return diag.FromErr(err)
                        }</span>
                }

                // non fip related setting
                <span class="cov0" title="0">fipsAddonPack := "nonFipsDisabled"
                fipsFeatures := "nonFipsDisabled"
                fipsClusterImport := "nonFipsDisabled"
                if d.HasChanges("non_fips_addon_pack", "non_fips_features", "non_fips_cluster_import") </span><span class="cov0" title="0">{
                        if v, ok := d.GetOk("non_fips_addon_pack"); ok </span><span class="cov0" title="0">{
                                fipsAddonPack = convertFIPSBool(v.(bool))
                        }</span>
                        <span class="cov0" title="0">if v, ok := d.GetOk("non_fips_features"); ok </span><span class="cov0" title="0">{
                                fipsFeatures = convertFIPSBool(v.(bool))
                        }</span>
                        <span class="cov0" title="0">if v, ok := d.GetOk("non_fips_cluster_import"); ok </span><span class="cov0" title="0">{
                                fipsClusterImport = convertFIPSBool(v.(bool))
                        }</span>
                        <span class="cov0" title="0">err = c.UpdateFIPSPreference(tenantUID, &amp;models.V1FipsSettings{
                                FipsClusterFeatureConfig: &amp;models.V1NonFipsConfig{Mode: &amp;fipsFeatures},
                                FipsClusterImportConfig:  &amp;models.V1NonFipsConfig{Mode: &amp;fipsClusterImport},
                                FipsPackConfig:           &amp;models.V1NonFipsConfig{Mode: &amp;fipsAddonPack},
                        })
                        if err != nil </span><span class="cov0" title="0">{
                                return diag.FromErr(err)
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                // cluster node remediation for project
                if d.HasChanges("cluster_auto_remediation", "enable_auto_remediation") </span><span class="cov0" title="0">{
                        err = c.UpdateClusterAutoRemediationForProject(ProviderInitProjectUid, remediationSettings)
                        if err != nil </span><span class="cov0" title="0">{
                                return diag.FromErr(err)
                        }</span>
                }
        }
        // pause agent upgrade setting according to context
        <span class="cov0" title="0">if d.HasChange("pause_agent_upgrades") </span><span class="cov0" title="0">{
                err = c.UpdatePlatformClusterUpgradeSetting(&amp;models.V1ClusterUpgradeSettingsEntity{
                        SpectroComponents: d.Get("pause_agent_upgrades").(string)})
                if err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
        }

        <span class="cov0" title="0">return diags</span>
}

func updatePlatformSettingsDefault(d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        platformSettingContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, platformSettingContext)
        tenantUID, err := c.GetTenantUID()
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">var diags diag.Diagnostics
        remediationSettings := &amp;models.V1NodesAutoRemediationSettings{
                DisableNodesAutoRemediation: true,
                IsEnabled:                   true,
        }
        if platformSettingContext == tenantString </span><span class="cov0" title="0">{
                // session timeout
                err = c.UpdateSessionTimeout(tenantUID,
                        &amp;models.V1AuthTokenSettings{ExpiryTimeMinutes: SafeInt32(240)})
                if err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>

                <span class="cov0" title="0">bindingMode := "disabled"
                err = c.UpdateAutomaticClusterRoleBinding(tenantUID,
                        &amp;models.V1TenantClusterRbacSettings{AutomaticClusterRoleBinding: &amp;bindingMode})
                if err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>

                <span class="cov0" title="0">bannerSetting := &amp;models.V1LoginBannerSettings{
                        Message:   "",
                        IsEnabled: false,
                        Title:     "",
                }
                err = c.UpdateLoginBanner(tenantUID, bannerSetting)
                if err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
                // cluster node remediation for tenant
                <span class="cov0" title="0">err = c.UpdateClusterAutoRemediationForTenant(tenantUID, remediationSettings)
                if err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
                // fips setting to default
                <span class="cov0" title="0">_, fpOk := d.GetOk("non_fips_addon_pack")
                _, ffOk := d.GetOk("non_fips_features")
                _, fiOk := d.GetOk("non_fips_cluster_import")

                fipsAddonPack := "nonFipsDisabled"
                fipsFeatures := "nonFipsDisabled"
                fipsClusterImport := "nonFipsDisabled"
                if fiOk || ffOk || fpOk </span><span class="cov0" title="0">{
                        err = c.UpdateFIPSPreference(tenantUID, &amp;models.V1FipsSettings{
                                FipsClusterFeatureConfig: &amp;models.V1NonFipsConfig{Mode: &amp;fipsFeatures},
                                FipsClusterImportConfig:  &amp;models.V1NonFipsConfig{Mode: &amp;fipsClusterImport},
                                FipsPackConfig:           &amp;models.V1NonFipsConfig{Mode: &amp;fipsAddonPack},
                        })
                        if err != nil </span><span class="cov0" title="0">{
                                return diag.FromErr(err)
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                // cluster node remediation for project
                err = c.UpdateClusterAutoRemediationForProject(ProviderInitProjectUid, remediationSettings)
                if err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
        }
        // pause agent upgrade setting according to context
        <span class="cov0" title="0">err = c.UpdatePlatformClusterUpgradeSetting(&amp;models.V1ClusterUpgradeSettingsEntity{
                SpectroComponents: "unlock"})
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">return diags</span>
}

func resourcePlatformSettingDelete(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        return updatePlatformSettingsDefault(d, m)
}</span>

func resourcePlatformSettingImport(ctx context.Context, d *schema.ResourceData, m interface{}) ([]*schema.ResourceData, error) <span class="cov0" title="0">{
        platformContext, uid, err := ParseResourceID(d)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">err = ValidateContext(platformContext)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">c := getV1ClientWithResourceContext(m, platformContext)
        var diags diag.Diagnostics

        if platformContext == tenantString </span><span class="cov0" title="0">{
                givenTenantId := strings.TrimPrefix(uid, "platformsetting-")
                actualTenantId, err := c.GetTenantUID()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">if givenTenantId != actualTenantId </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("tenant id is not valid with current user or invalid tenant uid provided: %v", diags)
                }</span>
                <span class="cov0" title="0">if err = d.Set("context", tenantString); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">d.SetId(fmt.Sprintf("platformsetting-%s", actualTenantId))</span>
        } else<span class="cov0" title="0"> {
                givenProjectId := strings.TrimPrefix(uid, "platformsetting-")
                actualProjectId := ProviderInitProjectUid
                if givenProjectId != actualProjectId </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("project id is not valid with provider initialization: %v", diags)
                }</span>
                <span class="cov0" title="0">if err = d.Set("context", tenantString); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">d.SetId(fmt.Sprintf("platformsetting-%s", actualProjectId))</span>
        }
        <span class="cov0" title="0">diags = resourcePlatformSettingRead(ctx, d, m)
        if diags.HasError() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("could not read developer settings for import: %v", diags)
        }</span>
        <span class="cov0" title="0">return []*schema.ResourceData{d}, nil</span>
}
</pre>
		
		<pre class="file" id="file172" style="display: none">package spectrocloud

import (
        "context"
        "time"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/spectrocloud/palette-sdk-go/api/models"
)

func resourceProject() *schema.Resource <span class="cov10" title="32">{
        return &amp;schema.Resource{
                CreateContext: resourceProjectCreate,
                ReadContext:   resourceProjectRead,
                UpdateContext: resourceProjectUpdate,
                DeleteContext: resourceProjectDelete,
                Importer: &amp;schema.ResourceImporter{
                        StateContext: resourceProjectImport,
                },
                Description: "Create and manage projects in Palette.",

                Timeouts: &amp;schema.ResourceTimeout{
                        Create: schema.DefaultTimeout(10 * time.Minute),
                        Update: schema.DefaultTimeout(10 * time.Minute),
                        Delete: schema.DefaultTimeout(10 * time.Minute),
                },

                SchemaVersion: 2,
                Schema: map[string]*schema.Schema{
                        "name": {
                                Type:        schema.TypeString,
                                Required:    true,
                                Description: "The name of the project.",
                        },
                        "tags": {
                                Type:     schema.TypeSet,
                                Optional: true,
                                Set:      schema.HashString,
                                Elem: &amp;schema.Schema{
                                        Type: schema.TypeString,
                                },
                                Description: "Assign tags to the project.",
                        },
                        "description": {
                                Type:        schema.TypeString,
                                Optional:    true,
                                Description: "The description of the project.",
                        },
                },
        }
}</span>

func resourceProjectCreate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov2" title="2">{
        c := getV1ClientWithResourceContext(m, "")
        var diags diag.Diagnostics

        uid, err := c.CreateProject(toProject(d))
        if err != nil </span><span class="cov1" title="1">{
                return diag.FromErr(err)
        }</span>
        <span class="cov1" title="1">d.SetId(uid)

        return diags</span>
}

func resourceProjectRead(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov4" title="4">{
        c := getV1ClientWithResourceContext(m, "")
        var diags diag.Diagnostics

        project, err := c.GetProject(d.Id())
        if err != nil </span><span class="cov1" title="1">{
                return handleReadError(d, err, diags)
        }</span> else<span class="cov3" title="3"> if project == nil </span><span class="cov0" title="0">{
                // Deleted - Terraform will recreate it
                d.SetId("")
                return diags
        }</span>

        <span class="cov3" title="3">if err := d.Set("name", project.Metadata.Name); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov3" title="3">if v, found := project.Metadata.Annotations["description"]; found </span><span class="cov1" title="1">{
                if err := d.Set("description", v); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
        }

        <span class="cov3" title="3">if err := d.Set("tags", flattenTags(project.Metadata.Labels)); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov3" title="3">return diags</span>
}

func resourceProjectUpdate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov2" title="2">{
        c := getV1ClientWithResourceContext(m, "")
        var diags diag.Diagnostics

        err := c.UpdateProject(d.Id(), toProject(d))
        if err != nil </span><span class="cov1" title="1">{
                return diag.FromErr(err)
        }</span>
        <span class="cov1" title="1">return diags</span>
}

func resourceProjectDelete(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov2" title="2">{
        c := getV1ClientWithResourceContext(m, "")
        var diags diag.Diagnostics

        err := c.DeleteProject(d.Id())
        if err != nil </span><span class="cov1" title="1">{
                return diag.FromErr(err)
        }</span>

        <span class="cov1" title="1">return diags</span>
}

func toProject(d *schema.ResourceData) *models.V1ProjectEntity <span class="cov7" title="12">{
        annotations := make(map[string]string)
        if len(d.Get("description").(string)) &gt; 0 </span><span class="cov2" title="2">{
                annotations["description"] = d.Get("description").(string)
        }</span>
        <span class="cov7" title="12">return &amp;models.V1ProjectEntity{
                Metadata: &amp;models.V1ObjectMeta{
                        Name:        d.Get("name").(string),
                        UID:         d.Id(),
                        Labels:      toTags(d),
                        Annotations: annotations,
                },
        }</span>
}
</pre>
		
		<pre class="file" id="file173" style="display: none">package spectrocloud

import (
        "context"
        "fmt"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
)

func resourceProjectImport(ctx context.Context, d *schema.ResourceData, m interface{}) ([]*schema.ResourceData, error) <span class="cov0" title="0">{
        c := getV1ClientWithResourceContext(m, "")

        // The import ID should be the project UID
        projectUID := d.Id()

        // Validate that the project exists and we can access it
        project, err := c.GetProject(projectUID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("could not retrieve project for import: %s", err)
        }</span>
        <span class="cov0" title="0">if project == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("project with ID %s not found", projectUID)
        }</span>

        // Set the project name from the retrieved project
        <span class="cov0" title="0">if err := d.Set("name", project.Metadata.Name); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Read all project data to populate the state
        <span class="cov0" title="0">diags := resourceProjectRead(ctx, d, m)
        if diags.HasError() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("could not read project for import: %v", diags)
        }</span>

        <span class="cov0" title="0">return []*schema.ResourceData{d}, nil</span>
}
</pre>
		
		<pre class="file" id="file174" style="display: none">package spectrocloud

import (
        "context"
        "fmt"
        "github.com/go-openapi/strfmt"
        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
        "github.com/spectrocloud/palette-sdk-go/api/models"
        "regexp"
        "time"
)

func resourceRegistrationToken() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                CreateContext: resourceRegistrationTokenCreate,
                ReadContext:   resourceRegistrationTokenRead,
                UpdateContext: resourceRegistrationTokenUpdate,
                DeleteContext: resourceRegistrationTokenDelete,
                Importer: &amp;schema.ResourceImporter{
                        StateContext: resourceRegistrationTokenImport,
                },
                Timeouts: &amp;schema.ResourceTimeout{
                        Create: schema.DefaultTimeout(10 * time.Minute),
                        Update: schema.DefaultTimeout(10 * time.Minute),
                        Delete: schema.DefaultTimeout(10 * time.Minute),
                },
                SchemaVersion: 2,
                Schema: map[string]*schema.Schema{
                        "name": {
                                Type:        schema.TypeString,
                                Required:    true,
                                Description: "The name of the registration token.",
                        },
                        "description": {
                                Type:        schema.TypeString,
                                Optional:    true,
                                Default:     "",
                                Description: "A brief description of the registration token.",
                        },
                        "project_uid": {
                                Type:        schema.TypeString,
                                Optional:    true,
                                Default:     "",
                                Description: "The unique identifier of the project associated with the registration token.",
                        },
                        "expiry_date": {
                                Type:     schema.TypeString,
                                Required: true,
                                ValidateFunc: validation.StringMatch(
                                        regexp.MustCompile(`^\d{4}-\d{2}-\d{2}$`),
                                        "expiry_date must be in YYYY-MM-DD format",
                                ),
                                Description: "The expiration date of the registration token in `YYYY-MM-DD` format.",
                        },
                        "status": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "active",
                                ValidateFunc: validation.StringInSlice([]string{"active", "inactive"}, false),
                                Description:  "The status of the registration token. Allowed values are `active` or `inactive`. Default is `active`.",
                        },
                        "token": {
                                Type:     schema.TypeString,
                                Computed: true,
                        },
                },
        }
}</span>

func flattenRegistrationToken(d *schema.ResourceData, tokenEntity *models.V1EdgeToken) error <span class="cov0" title="0">{
        if err := d.Set("name", tokenEntity.Metadata.Name); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if desc, exists := tokenEntity.Metadata.Annotations["description"]; exists </span><span class="cov0" title="0">{
                if err := d.Set("description", desc); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">if tokenEntity.Spec.DefaultProject != nil </span><span class="cov0" title="0">{
                if err := d.Set("project_uid", tokenEntity.Spec.DefaultProject.UID); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">dt := strfmt.DateTime(tokenEntity.Spec.Expiry)
        expDate := time.Time(dt).Format("2006-01-02")
        if err := d.Set("expiry_date", expDate); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := d.Set("token", tokenEntity.Spec.Token); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := d.Set("status", StateConvertBool(tokenEntity.Status.IsActive)); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func StateConvertBool(isActive bool) string <span class="cov0" title="0">{
        if isActive </span><span class="cov0" title="0">{
                return "active"
        }</span>
        <span class="cov0" title="0">return "inactive"</span>
}

func stateConvertString(state string) bool <span class="cov0" title="0">{
        return state == "active"
}</span>

func toRegistrationTokenCreate(d *schema.ResourceData) (*models.V1EdgeTokenEntity, error) <span class="cov0" title="0">{
        name := d.Get("name").(string)
        description := d.Get("description").(string)
        defaultProjectUID := d.Get("project_uid").(string)
        //expiry := d.Get("expiry_date").(string)

        //Parse string to time.Time
        parsedTime, err := time.Parse("2006-01-02", d.Get("expiry_date").(string))
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("Error parsing date:", err)
                return nil, err
        }</span>
        // Convert to strfmt.DateTime
        <span class="cov0" title="0">expiry := strfmt.DateTime(parsedTime)

        return &amp;models.V1EdgeTokenEntity{
                Metadata: &amp;models.V1ObjectMeta{
                        Name: name,
                        Annotations: map[string]string{
                                "description": description,
                        },
                },
                Spec: &amp;models.V1EdgeTokenSpecEntity{
                        DefaultProjectUID: defaultProjectUID,
                        Expiry:            models.V1Time(expiry),
                },
        }, nil</span>
}

func toRegistrationTokenUpdate(d *schema.ResourceData) (*models.V1EdgeTokenUpdate, error) <span class="cov0" title="0">{
        name := d.Get("name").(string)
        description := d.Get("description").(string)
        defaultProjectUID := d.Get("project_uid").(string)
        //expiry := d.Get("expiry_date").(string)

        //Parse string to time.Time
        parsedTime, err := time.Parse("2006-01-02", d.Get("expiry_date").(string))
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("Error parsing date:", err)
                return nil, err
        }</span>
        // Convert to strfmt.DateTime
        <span class="cov0" title="0">expiry := strfmt.DateTime(parsedTime)

        return &amp;models.V1EdgeTokenUpdate{
                Metadata: &amp;models.V1ObjectMeta{
                        Name: name,
                        Annotations: map[string]string{
                                "description": description,
                        },
                        UID: d.Id(),
                },
                Spec: &amp;models.V1EdgeTokenSpecUpdate{
                        DefaultProjectUID: defaultProjectUID,
                        Expiry:            models.V1Time(expiry),
                },
        }, nil</span>
}

func resourceRegistrationTokenCreate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        c := getV1ClientWithResourceContext(m, tenantString)
        var diags diag.Diagnostics
        tokenEntity, err := toRegistrationTokenCreate(d)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">uid, token, err := c.CreateRegistrationToken(tokenEntity.Metadata.Name, tokenEntity)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">d.SetId(uid)
        err = d.Set("token", token)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">state := stateConvertString(d.Get("status").(string))
        err = c.UpdateRegistrationTokenState(d.Id(), &amp;models.V1EdgeTokenActiveState{IsActive: state})
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">return diags</span>
}

func resourceRegistrationTokenRead(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        c := getV1ClientWithResourceContext(m, tenantString)
        var diags diag.Diagnostics
        regToken, err := c.GetRegistrationTokenByUID(d.Id())
        if err != nil </span><span class="cov0" title="0">{
                return handleReadError(d, err, diags)
        }</span>
        <span class="cov0" title="0">err = flattenRegistrationToken(d, regToken)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">return diags</span>
}

func resourceRegistrationTokenUpdate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        c := getV1ClientWithResourceContext(m, tenantString)
        var diags diag.Diagnostics
        if d.HasChange("status") </span><span class="cov0" title="0">{
                state := stateConvertString(d.Get("status").(string))
                err := c.UpdateRegistrationTokenState(d.Id(), &amp;models.V1EdgeTokenActiveState{IsActive: state})
                if err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
        }
        <span class="cov0" title="0">if d.HasChanges("name", "description", "expiry_date", "project_uid") </span><span class="cov0" title="0">{
                regUpdateEntity, err := toRegistrationTokenUpdate(d)
                if err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
                <span class="cov0" title="0">err = c.UpdateRegistrationTokenByUID(d.Id(), regUpdateEntity)
                if err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
        }

        <span class="cov0" title="0">return diags</span>
}

func resourceRegistrationTokenDelete(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        c := getV1ClientWithResourceContext(m, tenantString)
        var diags diag.Diagnostics
        err := c.DeleteRegistrationToken(d.Id())
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">return diags</span>
}

func resourceRegistrationTokenImport(ctx context.Context, d *schema.ResourceData, m interface{}) ([]*schema.ResourceData, error) <span class="cov0" title="0">{
        diags := resourceRegistrationTokenRead(ctx, d, m)
        if diags.HasError() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("could not read regiatration token for import: %v", diags)
        }</span>
        <span class="cov0" title="0">return []*schema.ResourceData{d}, nil</span>
}
</pre>
		
		<pre class="file" id="file175" style="display: none">package spectrocloud

import (
        "context"
        "errors"
        "fmt"
        "log"
        "time"

        "github.com/go-openapi/strfmt"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/spectrocloud/palette-sdk-go/api/models"
        "github.com/spectrocloud/palette-sdk-go/client"
)

func resourceRegistryHelm() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                CreateContext: resourceRegistryHelmCreate,
                ReadContext:   resourceRegistryHelmRead,
                UpdateContext: resourceRegistryHelmUpdate,
                DeleteContext: resourceRegistryHelmDelete,
                Importer: &amp;schema.ResourceImporter{
                        StateContext: resourceRegistryHelmImport,
                },

                Timeouts: &amp;schema.ResourceTimeout{
                        Create: schema.DefaultTimeout(10 * time.Minute),
                        Update: schema.DefaultTimeout(10 * time.Minute),
                        Delete: schema.DefaultTimeout(10 * time.Minute),
                },

                SchemaVersion: 2,
                Schema: map[string]*schema.Schema{
                        "name": {
                                Type:        schema.TypeString,
                                Required:    true,
                                ForceNew:    true,
                                Description: "The name of the Helm registry. This must be unique",
                        },
                        "is_private": {
                                Type:        schema.TypeBool,
                                Required:    true,
                                Description: "Specifies whether the Helm registry is private or public.",
                        },
                        "endpoint": {
                                Type:        schema.TypeString,
                                Required:    true,
                                Description: "The URL endpoint of the Helm registry where the charts are hosted.",
                        },
                        "credentials": {
                                Type:        schema.TypeList,
                                Required:    true,
                                MaxItems:    1,
                                Description: "Authentication credentials for accessing the Helm registry.",
                                Elem: &amp;schema.Resource{
                                        Schema: map[string]*schema.Schema{
                                                "credential_type": {
                                                        Type:         schema.TypeString,
                                                        Required:     true,
                                                        Description:  "The type of authentication used for the Helm registry. Supported values are 'noAuth' for no authentication, 'basic' for username/password, and 'token' for token-based authentication.",
                                                        ValidateFunc: validation.StringInSlice([]string{"noAuth", "basic", "token"}, false),
                                                },
                                                "username": {
                                                        Type:        schema.TypeString,
                                                        Optional:    true,
                                                        Description: "The username for basic authentication. Required if 'credential_type' is set to 'basic'.",
                                                },
                                                "password": {
                                                        Type:        schema.TypeString,
                                                        Optional:    true,
                                                        Description: "The password for basic authentication. Required if 'credential_type' is set to 'basic'.",
                                                },
                                                "token": {
                                                        Type:        schema.TypeString,
                                                        Optional:    true,
                                                        Description: "The authentication token. Required if 'credential_type' is set to 'token'.",
                                                },
                                        },
                                },
                        },
                        "wait_for_sync": {
                                Type:        schema.TypeBool,
                                Optional:    true,
                                Default:     false,
                                Description: "If `true`, Terraform will wait for the Helm registry to complete its initial synchronization before marking the resource as created or updated. Default value is `false`.",
                        },
                },
        }
}</span>

func resourceRegistryHelmCreate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        c := getV1ClientWithResourceContext(m, "tenant")
        var diags diag.Diagnostics

        registry := toRegistryEntityHelm(d)
        uid, err := c.CreateHelmRegistry(registry)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">d.SetId(uid)

        // Wait for sync if requested
        if d.Get("wait_for_sync") != nil &amp;&amp; d.Get("wait_for_sync").(bool) </span><span class="cov0" title="0">{
                diagnostics, isError := waitForRegistrySync(ctx, d, uid, diags, c, schema.TimeoutCreate)
                if len(diagnostics) &gt; 0 </span><span class="cov0" title="0">{
                        diags = append(diags, diagnostics...)
                }</span>
                <span class="cov0" title="0">if isError </span><span class="cov0" title="0">{
                        return diagnostics
                }</span>
        }

        <span class="cov0" title="0">return diags</span>
}

func resourceRegistryHelmRead(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        c := getV1ClientWithResourceContext(m, "tenant")
        var diags diag.Diagnostics

        registry, err := c.GetHelmRegistry(d.Id())
        if err != nil </span><span class="cov0" title="0">{
                return handleReadError(d, err, diags)
        }</span> else<span class="cov0" title="0"> if registry == nil </span><span class="cov0" title="0">{
                // Deleted - Terraform will recreate it
                d.SetId("")
                return diags
        }</span>

        <span class="cov0" title="0">if err := d.Set("name", registry.Metadata.Name); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">if err := d.Set("is_private", registry.Spec.IsPrivate); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">if err := d.Set("endpoint", registry.Spec.Endpoint); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">switch registry.Spec.Auth.Type </span>{
        case "noAuth":<span class="cov0" title="0">
                credentials := make([]interface{}, 0, 1)
                acc := make(map[string]interface{})
                acc["credential_type"] = "noAuth"
                credentials = append(credentials, acc)
                if err := d.Set("credentials", credentials); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
        case "basic":<span class="cov0" title="0">
                credentials := make([]interface{}, 0, 1)
                acc := make(map[string]interface{})
                acc["credential_type"] = "basic"
                acc["username"] = registry.Spec.Auth.Username
                acc["password"] = registry.Spec.Auth.Password.String()
                credentials = append(credentials, acc)
                if err := d.Set("credentials", credentials); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
        case "token":<span class="cov0" title="0">
                credentials := make([]interface{}, 0, 1)
                acc := make(map[string]interface{})
                acc["credential_type"] = "token"
                acc["username"] = registry.Spec.Auth.Username
                acc["token"] = registry.Spec.Auth.Token.String()
                credentials = append(credentials, acc)
                if err := d.Set("credentials", credentials); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
        }

        <span class="cov0" title="0">return diags</span>
}

func resourceRegistryHelmUpdate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        c := getV1ClientWithResourceContext(m, "tenant")
        var diags diag.Diagnostics

        registry := toRegistryHelm(d)
        err := c.UpdateHelmRegistry(d.Id(), registry)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        // Wait for sync if requested
        <span class="cov0" title="0">if d.Get("wait_for_sync") != nil &amp;&amp; d.Get("wait_for_sync").(bool) </span><span class="cov0" title="0">{
                diagnostics, isError := waitForRegistrySync(ctx, d, d.Id(), diags, c, schema.TimeoutUpdate)
                if len(diagnostics) &gt; 0 </span><span class="cov0" title="0">{
                        diags = append(diags, diagnostics...)
                }</span>
                <span class="cov0" title="0">if isError </span><span class="cov0" title="0">{
                        return diagnostics
                }</span>
        }

        <span class="cov0" title="0">return diags</span>
}

func resourceRegistryHelmDelete(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        c := getV1ClientWithResourceContext(m, "tenant")
        var diags diag.Diagnostics
        err := c.DeleteHelmRegistry(d.Id())
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">return diags</span>
}

func toRegistryEntityHelm(d *schema.ResourceData) *models.V1HelmRegistryEntity <span class="cov0" title="0">{
        endpoint := d.Get("endpoint").(string)
        isPrivate := d.Get("is_private").(bool)
        config := d.Get("credentials").([]interface{})[0].(map[string]interface{})
        return &amp;models.V1HelmRegistryEntity{
                Metadata: &amp;models.V1ObjectMeta{
                        Name: d.Get("name").(string),
                },
                Spec: &amp;models.V1HelmRegistrySpecEntity{
                        Name:      d.Get("name").(string),
                        Auth:      toRegistryHelmCredential(config),
                        Endpoint:  &amp;endpoint,
                        IsPrivate: isPrivate,
                },
        }
}</span>

func toRegistryHelm(d *schema.ResourceData) *models.V1HelmRegistry <span class="cov0" title="0">{
        endpoint := d.Get("endpoint").(string)
        isPrivate := d.Get("is_private").(bool)
        config := d.Get("credentials").([]interface{})[0].(map[string]interface{})
        return &amp;models.V1HelmRegistry{
                Metadata: &amp;models.V1ObjectMeta{
                        Name: d.Get("name").(string),
                },
                Spec: &amp;models.V1HelmRegistrySpec{
                        Name:      d.Get("name").(string),
                        Auth:      toRegistryHelmCredential(config),
                        Endpoint:  &amp;endpoint,
                        IsPrivate: isPrivate,
                },
        }
}</span>

func toRegistryHelmCredential(regCred map[string]interface{}) *models.V1RegistryAuth <span class="cov0" title="0">{
        auth := &amp;models.V1RegistryAuth{
                Type: "noAuth",
        }

        switch regCred["credential_type"].(string) </span>{
        case "basic":<span class="cov0" title="0">
                auth.Type = "basic"
                auth.Username = regCred["username"].(string)
                auth.Password = strfmt.Password(regCred["password"].(string))</span>
        case "token":<span class="cov0" title="0">
                auth.Type = "token"
                auth.Username = regCred["username"].(string)
                auth.Token = strfmt.Password(regCred["token"].(string))</span>
        }
        <span class="cov0" title="0">return auth</span>
}

// waitForRegistrySync waits for a Helm registry to complete its synchronization
func waitForRegistrySync(ctx context.Context, d *schema.ResourceData, uid string, diags diag.Diagnostics, c *client.V1Client, timeoutType string) (diag.Diagnostics, bool) <span class="cov0" title="0">{
        stateConf := &amp;retry.StateChangeConf{
                Pending: []string{
                        "InProgress",
                        "Pending",
                        "Unknown",
                        "", // Handle empty status as pending
                },
                Target: []string{
                        "Success",
                        "Completed",
                },
                Refresh:    resourceRegistrySyncRefreshFunc(c, uid),
                Timeout:    d.Timeout(timeoutType) - 1*time.Minute,
                MinTimeout: 10 * time.Second,
                Delay:      30 * time.Second,
        }

        // Wait, catching any errors
        _, err := stateConf.WaitForStateContext(ctx)
        if err != nil </span><span class="cov0" title="0">{
                // Handle timeout errors gracefully
                var timeoutErr *retry.TimeoutError
                if errors.As(err, &amp;timeoutErr) </span><span class="cov0" title="0">{
                        log.Printf("waitForRegistrySync: timeout occurred, returning warning instead of error")

                        // Get current sync status for warning message
                        syncStatus, statusErr := c.GetHelmRegistrySyncStatus(uid)
                        currentStatus := timeoutErr.LastState
                        statusMessage := ""

                        if statusErr == nil &amp;&amp; syncStatus != nil </span><span class="cov0" title="0">{
                                if syncStatus.Status != "" </span><span class="cov0" title="0">{
                                        currentStatus = syncStatus.Status
                                }</span>
                                <span class="cov0" title="0">if syncStatus.Message != "" </span><span class="cov0" title="0">{
                                        statusMessage = fmt.Sprintf(" Message: %s", syncStatus.Message)
                                }</span>
                        }

                        <span class="cov0" title="0">if currentStatus == "" </span><span class="cov0" title="0">{
                                currentStatus = "Unknown"
                        }</span>

                        // Return warning instead of error for timeout
                        <span class="cov0" title="0">diags = append(diags, diag.Diagnostic{
                                Severity: diag.Warning,
                                Summary:  "Helm registry sync timeout",
                                Detail: fmt.Sprintf(
                                        "Helm registry synchronization timed out after waiting for %v. Current sync status is '%s'.%s "+
                                                "The registry sync may still be in progress and could eventually complete successfully. "+
                                                "You may need to increase the timeout or wait for the sync to complete manually.",
                                        d.Timeout(timeoutType)-1*time.Minute, currentStatus, statusMessage),
                        })
                        return diags, false</span>
                }

                // Check if this is a sync failure (not a timeout or API error)
                // Get current sync status to provide detailed error information
                <span class="cov0" title="0">syncStatus, statusErr := c.GetHelmRegistrySyncStatus(uid)
                if statusErr == nil &amp;&amp; syncStatus != nil </span><span class="cov0" title="0">{
                        status := syncStatus.Status
                        // Check if the sync explicitly failed
                        if status == "Failed" || status == "Error" || status == "failed" || status == "error" </span><span class="cov0" title="0">{
                                log.Printf("waitForRegistrySync: registry sync failed with status: %s", status)
                                errorDetail := fmt.Sprintf("Helm registry synchronization failed with status '%s'.", status)
                                if syncStatus.Message != "" </span><span class="cov0" title="0">{
                                        errorDetail += fmt.Sprintf("\n\nError details: %s", syncStatus.Message)
                                }</span>
                                <span class="cov0" title="0">errorDetail += "\n\nPlease check the registry configuration (endpoint, credentials) and try again."

                                diags = append(diags, diag.Diagnostic{
                                        Severity: diag.Error,
                                        Summary:  "Helm registry sync failed",
                                        Detail:   errorDetail,
                                })
                                return diags, true</span>
                        }
                }

                // For other non-timeout errors (API errors, network issues, etc.), return the original error
                <span class="cov0" title="0">log.Printf("waitForRegistrySync: unexpected error: %v", err)
                return diag.FromErr(err), true</span>
        }
        <span class="cov0" title="0">return nil, false</span>
}

// resourceRegistrySyncRefreshFunc returns a retry.StateRefreshFunc that checks the sync status of a Helm registry
func resourceRegistrySyncRefreshFunc(c *client.V1Client, uid string) retry.StateRefreshFunc <span class="cov0" title="0">{
        return func() (interface{}, string, error) </span><span class="cov0" title="0">{
                syncStatus, err := c.GetHelmRegistrySyncStatus(uid)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, "", err
                }</span>

                // If sync is not supported, consider it as successful
                <span class="cov0" title="0">if syncStatus != nil &amp;&amp; !syncStatus.IsSyncSupported </span><span class="cov0" title="0">{
                        log.Printf("[DEBUG] Registry sync is not supported, considering as completed")
                        return syncStatus, "Success", nil
                }</span>

                <span class="cov0" title="0">if syncStatus == nil || syncStatus.Status == "" </span><span class="cov0" title="0">{
                        log.Printf("[DEBUG] Registry sync status is empty, treating as pending")
                        return syncStatus, "", nil
                }</span>

                <span class="cov0" title="0">status := syncStatus.Status
                log.Printf("[DEBUG] Registry sync status: %s", status)

                // Map various status values to our state machine
                switch status </span>{
                case "Success", "Completed", "success", "completed":<span class="cov0" title="0">
                        return syncStatus, "Success", nil</span>
                case "Failed", "Error", "failed", "error":<span class="cov0" title="0">
                        if syncStatus.Message != "" </span><span class="cov0" title="0">{
                                return syncStatus, status, fmt.Errorf("registry sync failed: %s", syncStatus.Message)
                        }</span>
                        <span class="cov0" title="0">return syncStatus, status, fmt.Errorf("registry sync failed")</span>
                case "InProgress", "Running", "Syncing", "inprogress", "running", "syncing":<span class="cov0" title="0">
                        return syncStatus, "InProgress", nil</span>
                default:<span class="cov0" title="0">
                        // Unknown status, treat as pending
                        log.Printf("[DEBUG] Unknown registry sync status '%s', treating as pending", status)
                        return syncStatus, status, nil</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file176" style="display: none">package spectrocloud

import (
        "context"
        "fmt"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/spectrocloud/palette-sdk-go/client"
)

func resourceRegistryHelmImport(ctx context.Context, d *schema.ResourceData, m interface{}) ([]*schema.ResourceData, error) <span class="cov0" title="0">{
        _, err := GetCommonRegistryHelm(d, m)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Read all registry data to populate the state
        <span class="cov0" title="0">diags := resourceRegistryHelmRead(ctx, d, m)
        if diags.HasError() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("could not read Helm registry for import: %v", diags)
        }</span>

        <span class="cov0" title="0">return []*schema.ResourceData{d}, nil</span>
}

func GetCommonRegistryHelm(d *schema.ResourceData, m interface{}) (*client.V1Client, error) <span class="cov0" title="0">{
        // Helm registries are tenant-level resources only
        c := getV1ClientWithResourceContext(m, "tenant")

        // The import ID should be the registry UID
        registryUID := d.Id()
        if registryUID == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("helm registry import ID is required")
        }</span>

        // Validate that the registry exists and we can access it
        <span class="cov0" title="0">registry, err := c.GetHelmRegistry(registryUID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unable to retrieve Helm registry: %s", err)
        }</span>
        <span class="cov0" title="0">if registry == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("helm registry with ID %s not found", registryUID)
        }</span>

        // Set the required fields for the resource
        <span class="cov0" title="0">if err := d.Set("name", registry.Metadata.Name); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Set the endpoint URL
        <span class="cov0" title="0">if registry.Spec != nil &amp;&amp; registry.Spec.Endpoint != nil &amp;&amp; *registry.Spec.Endpoint != "" </span><span class="cov0" title="0">{
                if err := d.Set("endpoint", *registry.Spec.Endpoint); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        // Set the is_private field from the registry specification
        <span class="cov0" title="0">if registry.Spec != nil </span><span class="cov0" title="0">{
                if err := d.Set("is_private", registry.Spec.IsPrivate); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        // Set the ID to the registry ID
        <span class="cov0" title="0">d.SetId(registryUID)

        return c, nil</span>
}
</pre>
		
		<pre class="file" id="file177" style="display: none">package spectrocloud

import (
        "context"
        "errors"
        "fmt"
        "time"

        "github.com/spectrocloud/palette-sdk-go/client"

        "github.com/go-openapi/strfmt"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/spectrocloud/palette-sdk-go/api/models"
)

func resourceRegistryOciEcr() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                CreateContext: resourceRegistryEcrCreate,
                ReadContext:   resourceRegistryEcrRead,
                UpdateContext: resourceRegistryEcrUpdate,
                DeleteContext: resourceRegistryEcrDelete,
                Importer: &amp;schema.ResourceImporter{
                        StateContext: resourceRegistryOciImport,
                },

                Timeouts: &amp;schema.ResourceTimeout{
                        Create: schema.DefaultTimeout(10 * time.Minute),
                        Update: schema.DefaultTimeout(10 * time.Minute),
                        Delete: schema.DefaultTimeout(10 * time.Minute),
                },

                SchemaVersion: 2,
                Schema: map[string]*schema.Schema{
                        "name": {
                                Type:        schema.TypeString,
                                Required:    true,
                                ForceNew:    true,
                                Description: "The name of the OCI registry.",
                        },
                        "type": {
                                Type:         schema.TypeString,
                                Required:     true,
                                ForceNew:     true,
                                ValidateFunc: validation.StringInSlice([]string{"ecr", "basic"}, false),
                                Description:  "The type of the registry. Possible values are 'ecr' (Amazon Elastic Container Registry) or 'basic' (for other types of OCI registries).",
                        },
                        "is_private": {
                                Type:        schema.TypeBool,
                                Required:    true,
                                Description: "Specifies whether the registry is private or public. Private registries require authentication to access.",
                        },
                        "is_synchronization": {
                                Type:        schema.TypeBool,
                                Default:     false,
                                Optional:    true,
                                Description: "Specifies whether the registry is synchronized.",
                        },
                        "endpoint": {
                                Type:        schema.TypeString,
                                Required:    true,
                                Description: "The URL endpoint of the OCI registry. This is where the container images are hosted and accessed.",
                        },
                        "endpoint_suffix": {
                                Type:        schema.TypeString,
                                Optional:    true,
                                Default:     "",
                                Description: "Specifies a suffix to append to the endpoint. This field is optional, but some registries (e.g., JFrog) may require it. The final registry URL is constructed by appending this suffix to the endpoint.",
                        },
                        "base_content_path": {
                                Type:        schema.TypeString,
                                Optional:    true,
                                Default:     "",
                                Description: "The relative path to the endpoint specified.",
                        },
                        "provider_type": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "helm",
                                ValidateFunc: validation.StringInSlice([]string{"helm", "zarf", "pack"}, false),
                                Description:  "The type of provider used for interacting with the registry. Supported value's are `helm`, `zarf` and `pack`, The default is 'helm'. `zarf` is allowed with `type=\"basic\"`  ",
                        },
                        "wait_for_sync": {
                                Type:        schema.TypeBool,
                                Optional:    true,
                                Default:     false,
                                Description: "If `true`, Terraform will wait for the OCI registry to complete its initial synchronization before marking the resource as created or updated. This option is applicable when `provider_type` is set to `zarf` or `helm`. Default value is `false`.",
                        },
                        "wait_for_status_message": {
                                Type:        schema.TypeString,
                                Optional:    true,
                                Computed:    true,
                                Description: "The status message from the last sync operation. This is a computed field that is populated after sync completes.",
                        },
                        "credentials": {
                                Type:        schema.TypeList,
                                Required:    true,
                                MaxItems:    1,
                                Description: "Authentication credentials to access the private OCI registry. Required if `is_private` is set to `true`",
                                Elem: &amp;schema.Resource{
                                        Schema: map[string]*schema.Schema{
                                                "credential_type": {
                                                        Type:         schema.TypeString,
                                                        Required:     true,
                                                        ValidateFunc: validation.StringInSlice([]string{"secret", "sts", "basic", "noAuth"}, false),
                                                        Description:  "The type of authentication used for accessing the registry. Supported values are 'secret', 'sts', 'basic', and 'noAuth'.",
                                                },
                                                "access_key": {
                                                        Type:        schema.TypeString,
                                                        Optional:    true,
                                                        Description: "The access key for accessing the registry. Required if 'credential_type' is set to 'secret'.",
                                                },
                                                "secret_key": {
                                                        Type:        schema.TypeString,
                                                        Optional:    true,
                                                        Sensitive:   true,
                                                        Description: "The secret key for accessing the registry. Required if 'credential_type' is set to 'secret'.",
                                                },
                                                "arn": {
                                                        Type:        schema.TypeString,
                                                        Optional:    true,
                                                        Description: "The Amazon Resource Name (ARN) used for AWS-based authentication. Required if 'credential_type' is 'sts'.",
                                                },
                                                "external_id": {
                                                        Type:        schema.TypeString,
                                                        Optional:    true,
                                                        Description: "The external ID used for AWS STS (Security Token Service) authentication. Required if 'credential_type' is 'sts'.",
                                                },
                                                "username": {
                                                        Type:        schema.TypeString,
                                                        Optional:    true,
                                                        Description: "The username for basic authentication. Required if 'credential_type' is 'basic'.",
                                                },
                                                "password": {
                                                        Type:        schema.TypeString,
                                                        Optional:    true,
                                                        Sensitive:   true,
                                                        Description: "The password for basic authentication. Required if 'credential_type' is 'basic'.",
                                                },
                                                "tls_config": {
                                                        Type:        schema.TypeList,
                                                        Optional:    true,
                                                        MaxItems:    1,
                                                        Description: "TLS configuration for the registry.",
                                                        Elem: &amp;schema.Resource{
                                                                Schema: map[string]*schema.Schema{
                                                                        "certificate": {
                                                                                Type:        schema.TypeString,
                                                                                Optional:    true,
                                                                                Default:     "",
                                                                                Description: "Specifies the TLS certificate used for secure communication. Required for enabling SSL/TLS encryption.",
                                                                        },
                                                                        "insecure_skip_verify": {
                                                                                Type:        schema.TypeBool,
                                                                                Optional:    true,
                                                                                Default:     false,
                                                                                Description: "Disables TLS certificate verification when set to true.  WARNING: Setting this to true disables SSL certificate verification and makes connections vulnerable to man-in-the-middle attacks. Only use this when connecting to registries with self-signed certificates in trusted networks.",
                                                                        },
                                                                },
                                                        },
                                                },
                                        },
                                },
                        },
                },
                CustomizeDiff: func(ctx context.Context, d *schema.ResourceDiff, meta interface{}) error </span><span class="cov0" title="0">{
                        providerType := d.Get("provider_type").(string)
                        registryType := d.Get("type").(string)
                        isSync := d.Get("is_synchronization").(bool)
                        // Validate that `provider_type` is "zarf" only if `type` is "basic"
                        if providerType == "zarf" &amp;&amp; registryType != "basic" </span><span class="cov0" title="0">{
                                return fmt.Errorf("`provider_type` set to `zarf` is only allowed when `type` is `basic`")
                        }</span>

                        <span class="cov0" title="0">if providerType == "pack" &amp;&amp; !isSync </span><span class="cov0" title="0">{
                                return fmt.Errorf("`provider_type` set to `pack` is only allowed when `is_synchronization` is set to `true`")
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                },
        }
}

func validateRegistryCred(c *client.V1Client, registryType string, providerType string, isSync bool, basicSpec *models.V1BasicOciRegistrySpec, ecrSpec *models.V1EcrRegistrySpec) error <span class="cov0" title="0">{
        if isSync &amp;&amp; (providerType == "pack" || providerType == "helm" || providerType == "zarf") </span><span class="cov0" title="0">{
                switch registryType </span>{
                case "basic":<span class="cov0" title="0">
                        if basicSpec != nil </span><span class="cov0" title="0">{
                                if err := c.ValidateOciBasicRegistry(basicSpec); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                case "ecr":<span class="cov0" title="0">
                        if ecrSpec != nil </span><span class="cov0" title="0">{
                                if err := c.ValidateOciEcrRegistry(ecrSpec); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                }
        }
        <span class="cov0" title="0">return nil</span>
}

func resourceRegistryEcrCreate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        c := getV1ClientWithResourceContext(m, "tenant")
        var diags diag.Diagnostics

        registryType := d.Get("type").(string)
        providerType := d.Get("provider_type").(string)
        isSync := d.Get("is_synchronization").(bool)
        switch registryType </span>{
        case "ecr":<span class="cov0" title="0">
                registry := toRegistryEcr(d)
                if err := validateRegistryCred(c, registryType, providerType, isSync, nil, registry.Spec); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
                <span class="cov0" title="0">uid, err := c.CreateOciEcrRegistry(registry)
                if err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
                <span class="cov0" title="0">d.SetId(uid)</span>
        case "basic":<span class="cov0" title="0">
                registry := toRegistryBasic(d)
                if err := validateRegistryCred(c, registryType, providerType, isSync, registry.Spec, nil); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
                <span class="cov0" title="0">uid, err := c.CreateOciBasicRegistry(registry)
                if err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>

                <span class="cov0" title="0">d.SetId(uid)

                // Wait for sync if requested and provider_type is zarf or helm
                if (providerType == "zarf" || providerType == "helm") &amp;&amp; d.Get("wait_for_sync") != nil &amp;&amp; d.Get("wait_for_sync").(bool) </span><span class="cov0" title="0">{
                        diagnostics, isError := waitForOciRegistrySync(ctx, d, uid, diags, c, schema.TimeoutCreate)
                        if len(diagnostics) &gt; 0 </span><span class="cov0" title="0">{
                                diags = append(diags, diagnostics...)
                        }</span>
                        // Fetch final sync status and set wait_for_status_message
                        <span class="cov0" title="0">syncStatus, statusErr := c.GetOciBasicRegistrySyncStatus(uid)
                        if statusErr == nil &amp;&amp; syncStatus != nil </span><span class="cov0" title="0">{
                                statusMessage := ""
                                if syncStatus.Message != "" </span><span class="cov0" title="0">{
                                        statusMessage = syncStatus.Message
                                }</span> else<span class="cov0" title="0"> if syncStatus.Status != "" </span><span class="cov0" title="0">{
                                        statusMessage = fmt.Sprintf("Status: %s", syncStatus.Status)
                                }</span>
                                <span class="cov0" title="0">if err := d.Set("wait_for_status_message", statusMessage); err != nil </span><span class="cov0" title="0">{
                                        diags = append(diags, diag.FromErr(err)...)
                                }</span>
                        }
                        <span class="cov0" title="0">if isError </span><span class="cov0" title="0">{
                                return diagnostics
                        }</span>
                }
        }

        <span class="cov0" title="0">return diags</span>
}

func resourceRegistryEcrRead(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        c := getV1ClientWithResourceContext(m, "tenant")
        var diags diag.Diagnostics

        registryType := d.Get("type").(string)

        switch registryType </span>{
        case "ecr":<span class="cov0" title="0">
                registry, err := c.GetOciEcrRegistry(d.Id())
                if err != nil </span><span class="cov0" title="0">{
                        return handleReadError(d, err, diags)
                }</span> else<span class="cov0" title="0"> if registry == nil </span><span class="cov0" title="0">{
                        // Deleted - Terraform will recreate it
                        d.SetId("")
                        return diags
                }</span>

                <span class="cov0" title="0">if err := d.Set("name", registry.Metadata.Name); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
                <span class="cov0" title="0">if err := d.Set("is_private", registry.Spec.IsPrivate); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
                <span class="cov0" title="0">if err := d.Set("endpoint", registry.Spec.Endpoint); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
                <span class="cov0" title="0">if err := d.Set("base_content_path", registry.Spec.BaseContentPath); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
                <span class="cov0" title="0">if err := d.Set("is_synchronization", registry.Spec.IsSyncSupported); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
                <span class="cov0" title="0">if err := d.Set("provider_type", registry.Spec.ProviderType); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
                <span class="cov0" title="0">if err := d.Set("wait_for_sync", false); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
                <span class="cov0" title="0">credentials := make([]interface{}, 0, 1)
                acc := make(map[string]interface{})
                switch *registry.Spec.Credentials.CredentialType </span>{
                case models.V1AwsCloudAccountCredentialTypeSts:<span class="cov0" title="0">
                        acc["arn"] = registry.Spec.Credentials.Sts.Arn
                        acc["external_id"] = registry.Spec.Credentials.Sts.ExternalID
                        acc["credential_type"] = models.V1AwsCloudAccountCredentialTypeSts</span>
                case models.V1AwsCloudAccountCredentialTypeSecret:<span class="cov0" title="0">
                        acc["access_key"] = registry.Spec.Credentials.AccessKey
                        acc["credential_type"] = models.V1AwsCloudAccountCredentialTypeSecret</span>
                default:<span class="cov0" title="0">
                        errMsg := fmt.Sprintf("Registry type %s not implemented.", *registry.Spec.Credentials.CredentialType)
                        err = errors.New(errMsg)
                        return diag.FromErr(err)</span>
                }
                // tls configuration handling
                <span class="cov0" title="0">tlsConfig := make([]interface{}, 0, 1)
                tls := make(map[string]interface{})
                tls["certificate"] = registry.Spec.TLS.Certificate
                tls["insecure_skip_verify"] = registry.Spec.TLS.InsecureSkipVerify
                tlsConfig = append(tlsConfig, tls)
                acc["tls_config"] = tlsConfig
                credentials = append(credentials, acc)

                if err := d.Set("credentials", credentials); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
                <span class="cov0" title="0">return diags</span>

        case "basic":<span class="cov0" title="0">
                registry, err := c.GetOciBasicRegistry(d.Id())
                if err != nil </span><span class="cov0" title="0">{
                        return handleReadError(d, err, diags)
                }</span> else<span class="cov0" title="0"> if registry == nil </span><span class="cov0" title="0">{
                        // Deleted - Terraform will recreate it
                        d.SetId("")
                        return diags
                }</span>

                <span class="cov0" title="0">if err := d.Set("name", registry.Metadata.Name); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>

                <span class="cov0" title="0">if err := d.Set("endpoint", registry.Spec.Endpoint); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>

                <span class="cov0" title="0">isPrivate := registry.Spec.Auth.Type != "noAuth"
                if err := d.Set("is_private", isPrivate); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>

                <span class="cov0" title="0">if err := d.Set("provider_type", registry.Spec.ProviderType); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
                <span class="cov0" title="0">if err := d.Set("base_content_path", registry.Spec.BaseContentPath); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
                <span class="cov0" title="0">if err := d.Set("endpoint_suffix", registry.Spec.BasePath); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>

                <span class="cov0" title="0">if err := d.Set("is_synchronization", registry.Spec.IsSyncSupported); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
                <span class="cov0" title="0">if err := d.Set("wait_for_sync", false); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
                <span class="cov0" title="0">credentials := make([]interface{}, 0, 1)
                acc := make(map[string]interface{})
                // Read the actual auth type from the API response
                switch registry.Spec.Auth.Type </span>{
                case "noAuth":<span class="cov0" title="0">
                        acc["credential_type"] = "noAuth"
                        acc["username"] = ""
                        acc["password"] = ""</span>
                case "basic":<span class="cov0" title="0">
                        acc["credential_type"] = "basic"
                        acc["username"] = registry.Spec.Auth.Username
                        // FIX: Preserve password from state to avoid drift detection when API returns masked/different format
                        // This applies to ALL provider types: helm, zarf, and pack
                        if currentCredsRaw := d.Get("credentials"); currentCredsRaw != nil </span><span class="cov0" title="0">{
                                if currentCredsList, ok := currentCredsRaw.([]interface{}); ok &amp;&amp; len(currentCredsList) &gt; 0 </span><span class="cov0" title="0">{
                                        if currentCredMap, ok := currentCredsList[0].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                                if password, exists := currentCredMap["password"]; exists &amp;&amp; password != nil </span><span class="cov0" title="0">{
                                                        // Preserve password from state to avoid drift
                                                        acc["password"] = password
                                                }</span> else<span class="cov0" title="0"> {
                                                        acc["password"] = registry.Spec.Auth.Password.String()
                                                }</span>
                                        }
                                }
                        } else<span class="cov0" title="0"> {
                                // No existing credentials in state, use API value
                                acc["password"] = registry.Spec.Auth.Password.String()
                        }</span>
                }
                <span class="cov0" title="0">tlsConfig := make([]interface{}, 0, 1)
                tls := make(map[string]interface{})
                tls["certificate"] = registry.Spec.Auth.TLS.Certificate
                tls["insecure_skip_verify"] = registry.Spec.Auth.TLS.InsecureSkipVerify
                tlsConfig = append(tlsConfig, tls)
                acc["tls_config"] = tlsConfig
                credentials = append(credentials, acc)
                if err := d.Set("credentials", credentials); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
                <span class="cov0" title="0">return diags</span>
        }

        <span class="cov0" title="0">return diags</span>
}

func resourceRegistryEcrUpdate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        c := getV1ClientWithResourceContext(m, "tenant")
        var diags diag.Diagnostics
        // VALIDATION: Prevent changing is_synchronization from true to false
        // Once synchronization is enabled, it cannot be disabled
        if d.HasChange("is_synchronization") </span><span class="cov0" title="0">{
                oldSync, newSync := d.GetChange("is_synchronization")
                oldSyncBool := oldSync.(bool)
                newSyncBool := newSync.(bool)

                // If old value was true and new value is false, reject the change
                if oldSyncBool &amp;&amp; !newSyncBool </span><span class="cov0" title="0">{
                        return diag.FromErr(fmt.Errorf(
                                "cannot disable synchronization: `is_synchronization` cannot be modified during Day-2 Operations"))
                }</span>
        }

        <span class="cov0" title="0">registryType := d.Get("type").(string)
        providerType := d.Get("provider_type").(string)
        isSync := d.Get("is_synchronization").(bool)
        switch registryType </span>{
        case "ecr":<span class="cov0" title="0">
                registry := toRegistryEcr(d)
                if err := validateRegistryCred(c, registryType, providerType, isSync, nil, registry.Spec); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
                <span class="cov0" title="0">err := c.UpdateOciEcrRegistry(d.Id(), registry)
                if err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
        case "basic":<span class="cov0" title="0">
                registry := toRegistryBasic(d)
                if err := validateRegistryCred(c, registryType, providerType, isSync, registry.Spec, nil); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
                <span class="cov0" title="0">err := c.UpdateOciBasicRegistry(d.Id(), registry)
                if err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>

                // Wait for sync if requested and provider_type is zarf or helm
                <span class="cov0" title="0">if (providerType == "zarf" || providerType == "helm") &amp;&amp; d.Get("wait_for_sync") != nil &amp;&amp; d.Get("wait_for_sync").(bool) </span><span class="cov0" title="0">{
                        diagnostics, isError := waitForOciRegistrySync(ctx, d, d.Id(), diags, c, schema.TimeoutUpdate)
                        if len(diagnostics) &gt; 0 </span><span class="cov0" title="0">{
                                diags = append(diags, diagnostics...)
                        }</span>
                        // Fetch final sync status and set wait_for_status_message
                        <span class="cov0" title="0">syncStatus, statusErr := c.GetOciBasicRegistrySyncStatus(d.Id())
                        if statusErr == nil &amp;&amp; syncStatus != nil </span><span class="cov0" title="0">{
                                statusMessage := ""
                                if syncStatus.Message != "" </span><span class="cov0" title="0">{
                                        statusMessage = syncStatus.Message
                                }</span> else<span class="cov0" title="0"> if syncStatus.Status != "" </span><span class="cov0" title="0">{
                                        statusMessage = fmt.Sprintf("Status: %s", syncStatus.Status)
                                }</span>
                                <span class="cov0" title="0">if err := d.Set("wait_for_status_message", statusMessage); err != nil </span><span class="cov0" title="0">{
                                        diags = append(diags, diag.FromErr(err)...)
                                }</span>
                        }
                        <span class="cov0" title="0">if isError </span><span class="cov0" title="0">{
                                return diagnostics
                        }</span>
                }
        }

        <span class="cov0" title="0">return diags</span>
}

func resourceRegistryEcrDelete(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        c := getV1ClientWithResourceContext(m, "tenant")
        var diags diag.Diagnostics

        registryType := d.Get("type").(string)
        switch registryType </span>{
        case "ecr":<span class="cov0" title="0">
                err := c.DeleteOciEcrRegistry(d.Id())
                if err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
        case "basic":<span class="cov0" title="0">
                err := c.DeleteOciBasicRegistry(d.Id())
                if err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
        }

        <span class="cov0" title="0">return diags</span>
}

func toRegistryEcr(d *schema.ResourceData) *models.V1EcrRegistry <span class="cov0" title="0">{
        endpoint := d.Get("endpoint").(string)
        isPrivate := d.Get("is_private").(bool)
        isSynchronization := d.Get("is_synchronization").(bool)
        providerType := d.Get("provider_type").(string)
        baseContentPath := d.Get("base_content_path").(string)
        s3config := d.Get("credentials").([]interface{})[0].(map[string]interface{})
        var tlsCertificate string
        var tlsSkipVerify bool
        if len(s3config["tls_config"].([]interface{})) &gt; 0 </span><span class="cov0" title="0">{
                tlsCertificate = s3config["tls_config"].([]interface{})[0].(map[string]interface{})["certificate"].(string)
                tlsSkipVerify = s3config["tls_config"].([]interface{})[0].(map[string]interface{})["insecure_skip_verify"].(bool)
        }</span>

        <span class="cov0" title="0">return &amp;models.V1EcrRegistry{
                Metadata: &amp;models.V1ObjectMeta{
                        Name: d.Get("name").(string),
                },
                Spec: &amp;models.V1EcrRegistrySpec{
                        Credentials:     toRegistryAwsAccountCredential(s3config),
                        Endpoint:        &amp;endpoint,
                        IsPrivate:       &amp;isPrivate,
                        ProviderType:    &amp;providerType,
                        IsSyncSupported: isSynchronization,
                        BaseContentPath: baseContentPath,
                        TLS: &amp;models.V1TLSConfiguration{
                                Certificate:        tlsCertificate,
                                Enabled:            true,
                                InsecureSkipVerify: tlsSkipVerify,
                        },
                },
        }</span>
}

func toRegistryBasic(d *schema.ResourceData) *models.V1BasicOciRegistry <span class="cov0" title="0">{
        endpoint := d.Get("endpoint").(string)
        provider := d.Get("provider_type").(string)
        isSynchronization := d.Get("is_synchronization").(bool)
        endpointSuffix := d.Get("endpoint_suffix").(string)
        baseContentPath := d.Get("base_content_path").(string)
        authConfig := d.Get("credentials").([]interface{})[0].(map[string]interface{})
        var tlsCertificate string
        var tlsSkipVerify bool
        if len(authConfig["tls_config"].([]interface{})) &gt; 0 </span><span class="cov0" title="0">{
                tlsCertificate = authConfig["tls_config"].([]interface{})[0].(map[string]interface{})["certificate"].(string)
                tlsSkipVerify = authConfig["tls_config"].([]interface{})[0].(map[string]interface{})["insecure_skip_verify"].(bool)
        }</span>
        // Initialize auth with noAuth as default
        <span class="cov0" title="0">credentialType := authConfig["credential_type"].(string)
        authType := "noAuth"
        var username, password string

        // Only set username/password if credential_type is "basic"
        if credentialType == "basic" </span><span class="cov0" title="0">{
                authType = "basic"
                if val, ok := authConfig["username"]; ok &amp;&amp; val != nil </span><span class="cov0" title="0">{
                        username = val.(string)
                }</span>
                <span class="cov0" title="0">if val, ok := authConfig["password"]; ok &amp;&amp; val != nil </span><span class="cov0" title="0">{
                        password = val.(string)
                }</span>
        }

        <span class="cov0" title="0">return &amp;models.V1BasicOciRegistry{
                Metadata: &amp;models.V1ObjectMeta{
                        Name: d.Get("name").(string),
                },
                Spec: &amp;models.V1BasicOciRegistrySpec{
                        Endpoint:        &amp;endpoint,
                        BasePath:        endpointSuffix,
                        ProviderType:    &amp;provider,
                        BaseContentPath: baseContentPath,
                        Auth: &amp;models.V1RegistryAuth{
                                Username: username,
                                Password: strfmt.Password(password),
                                Type:     authType,
                                TLS: &amp;models.V1TLSConfiguration{
                                        Certificate:        tlsCertificate,
                                        Enabled:            true,
                                        InsecureSkipVerify: tlsSkipVerify,
                                },
                        },
                        IsSyncSupported: isSynchronization,
                },
        }</span>
}

func toRegistryAwsAccountCredential(regCred map[string]interface{}) *models.V1AwsCloudAccount <span class="cov0" title="0">{
        account := &amp;models.V1AwsCloudAccount{}
        if len(regCred["credential_type"].(string)) == 0 || regCred["credential_type"].(string) == "secret" </span><span class="cov0" title="0">{
                account.CredentialType = models.V1AwsCloudAccountCredentialTypeSecret.Pointer()
                account.AccessKey = regCred["access_key"].(string)
                account.SecretKey = regCred["secret_key"].(string)
        }</span> else<span class="cov0" title="0"> if regCred["credential_type"].(string) == "sts" </span><span class="cov0" title="0">{
                account.CredentialType = models.V1AwsCloudAccountCredentialTypeSts.Pointer()
                account.Sts = &amp;models.V1AwsStsCredentials{
                        Arn:        regCred["arn"].(string),
                        ExternalID: regCred["external_id"].(string),
                }
        }</span>
        <span class="cov0" title="0">return account</span>
}

// waitForOciRegistrySync waits for an OCI registry to complete its synchronization
func waitForOciRegistrySync(ctx context.Context, d *schema.ResourceData, uid string, diags diag.Diagnostics, c *client.V1Client, timeoutType string) (diag.Diagnostics, bool) <span class="cov0" title="0">{
        stateConf := &amp;retry.StateChangeConf{
                Pending: []string{
                        "InProgress",
                        "Pending",
                        "Unknown",
                        "", // Handle empty status as pending
                },
                Target: []string{
                        "Success",
                        "Completed",
                },
                Refresh:    resourceOciRegistrySyncRefreshFunc(c, uid),
                Timeout:    d.Timeout(timeoutType) - 1*time.Minute,
                MinTimeout: 10 * time.Second,
                Delay:      30 * time.Second,
        }

        // Wait, catching any errors
        _, err := stateConf.WaitForStateContext(ctx)
        if err != nil </span><span class="cov0" title="0">{
                // Handle timeout errors gracefully
                var timeoutErr *retry.TimeoutError
                if errors.As(err, &amp;timeoutErr) </span><span class="cov0" title="0">{
                        // Get current sync status for warning message
                        syncStatus, statusErr := c.GetOciBasicRegistrySyncStatus(uid)
                        currentStatus := timeoutErr.LastState
                        statusMessage := ""

                        if statusErr == nil &amp;&amp; syncStatus != nil </span><span class="cov0" title="0">{
                                if syncStatus.Status != "" </span><span class="cov0" title="0">{
                                        currentStatus = syncStatus.Status
                                }</span>
                                <span class="cov0" title="0">if syncStatus.Message != "" </span><span class="cov0" title="0">{
                                        statusMessage = fmt.Sprintf(" Message: %s", syncStatus.Message)
                                }</span>
                        }

                        <span class="cov0" title="0">if currentStatus == "" </span><span class="cov0" title="0">{
                                currentStatus = "Unknown"
                        }</span>

                        // Return warning instead of error for timeout
                        <span class="cov0" title="0">diags = append(diags, diag.Diagnostic{
                                Severity: diag.Warning,
                                Summary:  "OCI registry sync timeout",
                                Detail: fmt.Sprintf(
                                        "OCI registry synchronization timed out after waiting for %v. Current sync status is '%s'.%s "+
                                                "The registry sync may still be in progress and could eventually complete successfully. "+
                                                "You may need to increase the timeout or wait for the sync to complete manually.",
                                        d.Timeout(timeoutType)-1*time.Minute, currentStatus, statusMessage),
                        })
                        return diags, false</span>
                }

                // Check if this is a sync failure (not a timeout or API error)
                // Get current sync status to provide detailed error information
                <span class="cov0" title="0">syncStatus, statusErr := c.GetOciBasicRegistrySyncStatus(uid)
                if statusErr == nil &amp;&amp; syncStatus != nil </span><span class="cov0" title="0">{
                        status := syncStatus.Status
                        // Check if the sync explicitly failed
                        if status == "Failed" || status == "Error" || status == "failed" || status == "error" </span><span class="cov0" title="0">{
                                errorDetail := fmt.Sprintf("OCI registry synchronization failed with status '%s'.", status)
                                if syncStatus.Message != "" </span><span class="cov0" title="0">{
                                        errorDetail += fmt.Sprintf("\n\nError details: %s", syncStatus.Message)
                                }</span>
                                <span class="cov0" title="0">errorDetail += "\n\nPlease check the registry configuration (endpoint, credentials) and try again."

                                diags = append(diags, diag.Diagnostic{
                                        Severity: diag.Warning,
                                        Summary:  "OCI registry sync failed",
                                        Detail:   errorDetail,
                                })
                                return diags, false</span>
                        }
                }

                // For other non-timeout errors (API errors, network issues, etc.), return the original error
                <span class="cov0" title="0">return diag.FromErr(err), true</span>
        }
        <span class="cov0" title="0">return nil, false</span>
}

// resourceOciRegistrySyncRefreshFunc returns a retry.StateRefreshFunc that checks the sync status of an OCI registry
func resourceOciRegistrySyncRefreshFunc(c *client.V1Client, uid string) retry.StateRefreshFunc <span class="cov0" title="0">{
        return func() (interface{}, string, error) </span><span class="cov0" title="0">{
                syncStatus, err := c.GetOciBasicRegistrySyncStatus(uid)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, "", err
                }</span>

                // If sync is not supported, consider it as successful
                <span class="cov0" title="0">if syncStatus != nil &amp;&amp; !syncStatus.IsSyncSupported </span><span class="cov0" title="0">{
                        return syncStatus, "Success", nil
                }</span>

                <span class="cov0" title="0">if syncStatus == nil || syncStatus.Status == "" </span><span class="cov0" title="0">{
                        return syncStatus, "", nil
                }</span>

                <span class="cov0" title="0">status := syncStatus.Status

                // Map various status values to our state machine
                switch status </span>{
                case "Success", "Completed", "success", "completed":<span class="cov0" title="0">
                        return syncStatus, "Success", nil</span>
                case "Failed", "Error", "failed", "error":<span class="cov0" title="0">
                        if syncStatus.Message != "" </span><span class="cov0" title="0">{
                                return syncStatus, status, fmt.Errorf("registry sync failed: %s", syncStatus.Message)
                        }</span>
                        <span class="cov0" title="0">return syncStatus, status, fmt.Errorf("registry sync failed")</span>
                case "InProgress", "Running", "Syncing", "inprogress", "running", "syncing":<span class="cov0" title="0">
                        return syncStatus, "InProgress", nil</span>
                default:<span class="cov0" title="0">
                        // Unknown status, treat as pending
                        return syncStatus, status, nil</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file178" style="display: none">package spectrocloud

import (
        "context"
        "fmt"
        "strings"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/spectrocloud/palette-sdk-go/api/models"
        "github.com/spectrocloud/palette-sdk-go/client"
        "github.com/spectrocloud/palette-sdk-go/client/herr"
)

func resourceRegistryOciImport(ctx context.Context, d *schema.ResourceData, m interface{}) ([]*schema.ResourceData, error) <span class="cov0" title="0">{
        _, err := GetCommonRegistryOci(d, m)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Read all registry data to populate the state
        <span class="cov0" title="0">diags := resourceRegistryEcrRead(ctx, d, m)
        if diags.HasError() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("could not read OCI registry for import: %v", diags)
        }</span>

        <span class="cov0" title="0">return []*schema.ResourceData{d}, nil</span>
}

func GetCommonRegistryOci(d *schema.ResourceData, m interface{}) (*client.V1Client, error) <span class="cov0" title="0">{
        // OCI registries are tenant-level resources only
        c := getV1ClientWithResourceContext(m, "tenant")

        // The import ID can be either a registry UID or a registry name
        importID := d.Id()
        if importID == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("OCI registry import ID or Import Name is required")
        }</span>

        <span class="cov0" title="0">var registryUID string
        var registryName string
        var registryType string

        var ecrErr error
        var basicErr error
        var ecrRegistry *models.V1EcrRegistry
        var basicRegistry *models.V1BasicOciRegistry

        // Determine if importID looks like a UID or a name
        // Try ECR first (most common)
        ecrRegistry, ecrErr = c.GetOciEcrRegistry(importID)
        if ecrErr != nil </span><span class="cov0" title="0">{
                // Check if error is 404/ResourceNotFound - if so, continue to try Basic registry or name lookup
                if herr.IsNotFound(ecrErr) </span><span class="cov0" title="0">{
                        ecrErr = nil
                }</span> else<span class="cov0" title="0"> {
                        // For non-404 errors, return immediately
                        return nil, fmt.Errorf("failed to retrieve ECR registry '%s': %s", importID, ecrErr)
                }</span>
        }
        <span class="cov0" title="0">if ecrErr == nil &amp;&amp; ecrRegistry != nil </span><span class="cov0" title="0">{
                // Found by UID as ECR registry
                registryUID = importID
                registryName = ecrRegistry.Metadata.Name
                registryType = "ecr"
                // Set required fields immediately
                if err := d.Set("name", registryName); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">if err := d.Set("type", registryType); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">d.SetId(registryUID)
                return c, nil</span>
        }

        // Try Basic registry
        <span class="cov0" title="0">basicRegistry, basicErr = c.GetOciBasicRegistry(importID)
        if basicErr != nil </span><span class="cov0" title="0">{
                // Check if error is 404/ResourceNotFound - if so, continue to try name lookup
                if herr.IsNotFound(basicErr) </span><span class="cov0" title="0">{
                        basicErr = nil
                }</span> else<span class="cov0" title="0"> {
                        return nil, fmt.Errorf("failed to retrieve basic registry '%s': %s", importID, basicErr)
                }</span>
        }
        <span class="cov0" title="0">if basicErr == nil &amp;&amp; basicRegistry != nil </span><span class="cov0" title="0">{
                // Found by UID as Basic registry
                registryUID = importID
                registryName = basicRegistry.Metadata.Name
                registryType = "basic"
                // Set required fields immediately
                if err := d.Set("name", registryName); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">if err := d.Set("type", registryType); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">d.SetId(registryUID)
                return c, nil</span>
        }
        //}

        // Step 2: Try to get by name (either UID lookup failed, or importID contains spaces/is a name)
        <span class="cov0" title="0">registrySummary, nameErr := c.GetOciRegistryByName(importID)
        if nameErr != nil </span><span class="cov0" title="0">{
                // If we tried UID lookup first, include those errors in the message
                return nil, fmt.Errorf("unable to retrieve OCI registry by name or id '%s': %s", importID, nameErr)
        }</span>
        <span class="cov0" title="0">if registrySummary == nil || registrySummary.Metadata == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("OCI registry '%s' not found", importID)
        }</span>

        // Extract UID and type from the summary
        <span class="cov0" title="0">registryUID = registrySummary.Metadata.UID
        if registryUID == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("OCI registry with name '%s' found but has no UID", importID)
        }</span>

        <span class="cov0" title="0">registryName = registrySummary.Metadata.Name
        if registrySummary.Spec == nil || registrySummary.Spec.RegistryType == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("registry summary for '%s' does not contain registry type", importID)
        }</span>
        // Determine registry type from the summary
        // if registrySummary.Spec != nil &amp;&amp; registrySummary.Spec.RegistryType != "" {
        <span class="cov0" title="0">registryType = strings.ToLower(registrySummary.Spec.RegistryType)
        if registryType != "basic" &amp;&amp; registryType != "ecr" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unsupported registry type '%s' for registry '%s'. API returned type '%s', but only 'basic' and 'ecr' are supported", registryType, importID, registrySummary.Spec.RegistryType)
        }</span>
        // Set required fields after determining type from summary
        <span class="cov0" title="0">if err := d.Set("name", registryName); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if err := d.Set("type", registryType); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">d.SetId(registryUID)
        return c, nil</span>
}
</pre>
		
		<pre class="file" id="file179" style="display: none">package spectrocloud

import (
        "context"
        "fmt"
        "time"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
        "github.com/spectrocloud/palette-sdk-go/api/models"
)

func resourceResourceLimit() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                CreateContext: resourceResourceLimitsCreate,
                ReadContext:   resourceResourceLimitsRead,
                UpdateContext: resourceResourceLimitsUpdate,
                DeleteContext: resourceResourceLimitsDelete,
                Importer: &amp;schema.ResourceImporter{
                        StateContext: resourceResourceLimitsImport,
                },

                Timeouts: &amp;schema.ResourceTimeout{
                        Create: schema.DefaultTimeout(10 * time.Minute),
                        Update: schema.DefaultTimeout(10 * time.Minute),
                        Delete: schema.DefaultTimeout(10 * time.Minute),
                },
                Description:   "",
                SchemaVersion: 2,
                Schema: map[string]*schema.Schema{
                        "alert": {
                                Type:         schema.TypeInt,
                                Optional:     true,
                                Default:      100,
                                ValidateFunc: validation.IntBetween(1, 10000),
                                Description:  "The maximum number of alerts that can be created. Must be between 1 and 10,000.",
                        },
                        "api_keys": {
                                Type:         schema.TypeInt,
                                Optional:     true,
                                Default:      20,
                                ValidateFunc: validation.IntBetween(1, 10000),
                                Description:  "The maximum number of API keys that can be generated. Must be between 1 and 10,000.",
                        },
                        "application_deployment": {
                                Type:         schema.TypeInt,
                                Optional:     true,
                                Default:      100,
                                ValidateFunc: validation.IntBetween(1, 10000),
                                Description:  "The maximum number of application deployments allowed. Must be between 1 and 10,000.",
                        },
                        "application_profile": {
                                Type:         schema.TypeInt,
                                Optional:     true,
                                Default:      100,
                                ValidateFunc: validation.IntBetween(1, 10000),
                                Description:  "The maximum number of application profiles that can be configured. Must be between 1 and 10,000.",
                        },
                        "certificate": {
                                Type:         schema.TypeInt,
                                Optional:     true,
                                Default:      20,
                                ValidateFunc: validation.IntBetween(1, 10000),
                                Description:  "The maximum number of certificates that can be managed. Must be between 1 and 10,000.",
                        },
                        "cloud_account": {
                                Type:         schema.TypeInt,
                                Optional:     true,
                                Default:      200,
                                ValidateFunc: validation.IntBetween(1, 10000),
                                Description:  "The maximum number of cloud accounts that can be added. Must be between 1 and 10,000.",
                        },
                        "cluster_group": {
                                Type:         schema.TypeInt,
                                Optional:     true,
                                Default:      100,
                                ValidateFunc: validation.IntBetween(1, 10000),
                                Description:  "The maximum number of cluster groups that can be created. Must be between 1 and 10,000.",
                        },
                        "cluster_profile": {
                                Type:         schema.TypeInt,
                                Optional:     true,
                                Default:      200,
                                ValidateFunc: validation.IntBetween(1, 10000),
                                Description:  "The maximum number of cluster profiles that can be configured. Must be between 1 and 10,000.",
                        },
                        "appliance": {
                                Type:         schema.TypeInt,
                                Optional:     true,
                                Default:      200,
                                ValidateFunc: validation.IntBetween(1, 50000),
                                Description:  "The maximum number of appliances that can be managed. Must be between 1 and 50,000.",
                        },
                        "appliance_token": {
                                Type:         schema.TypeInt,
                                Optional:     true,
                                Default:      200,
                                ValidateFunc: validation.IntBetween(1, 10000),
                                Description:  "The maximum number of appliance tokens that can be issued. Must be between 1 and 10,000.",
                        },
                        "filter": {
                                Type:         schema.TypeInt,
                                Optional:     true,
                                Default:      100,
                                ValidateFunc: validation.IntBetween(1, 10000),
                                Description:  "The maximum number of filters that can be defined. Must be between 1 and 10,000.",
                        },
                        "location": {
                                Type:         schema.TypeInt,
                                Optional:     true,
                                Default:      100,
                                ValidateFunc: validation.IntBetween(1, 10000),
                                Description:  "The maximum number of locations that can be configured. Must be between 1 and 10,000.",
                        },
                        "macro": {
                                Type:         schema.TypeInt,
                                Optional:     true,
                                Default:      200,
                                ValidateFunc: validation.IntBetween(1, 10000),
                                Description:  "The maximum number of macros that can be created. Must be between 1 and 10,000.",
                        },
                        "private_gateway": {
                                Type:         schema.TypeInt,
                                Optional:     true,
                                Default:      50,
                                ValidateFunc: validation.IntBetween(1, 10000),
                                Description:  "The maximum number of private gateways that can be managed. Must be between 1 and 10,000.",
                        },
                        "project": {
                                Type:         schema.TypeInt,
                                Optional:     true,
                                Default:      50,
                                ValidateFunc: validation.IntBetween(1, 10000),
                                Description:  "The maximum number of projects that can be created. Must be between 1 and 10,000.",
                        },
                        "registry": {
                                Type:         schema.TypeInt,
                                Optional:     true,
                                Default:      50,
                                ValidateFunc: validation.IntBetween(1, 10000),
                                Description:  "The maximum number of registries that can be configured. Must be between 1 and 10,000.",
                        },
                        "role": {
                                Type:         schema.TypeInt,
                                Optional:     true,
                                Default:      100,
                                ValidateFunc: validation.IntBetween(1, 10000),
                                Description:  "The maximum number of roles that can be assigned. Must be between 1 and 10,000.",
                        },
                        "cluster": {
                                Type:         schema.TypeInt,
                                Optional:     true,
                                Default:      10000,
                                ValidateFunc: validation.IntBetween(1, 50000),
                                Description:  "The maximum number of clusters that can be created. Must be between 1 and 50,000.",
                        },
                        "ssh_key": {
                                Type:         schema.TypeInt,
                                Optional:     true,
                                Default:      300,
                                ValidateFunc: validation.IntBetween(1, 10000),
                                Description:  "The maximum number of SSH keys that can be managed. Must be between 1 and 10,000.",
                        },
                        "team": {
                                Type:         schema.TypeInt,
                                Optional:     true,
                                Default:      100,
                                ValidateFunc: validation.IntBetween(1, 10000),
                                Description:  "The maximum number of teams that can be created. Must be between 1 and 10,000.",
                        },
                        "user": {
                                Type:         schema.TypeInt,
                                Optional:     true,
                                Default:      300,
                                ValidateFunc: validation.IntBetween(1, 10000),
                                Description:  "The maximum number of users that can be added. Must be between 1 and 10,000.",
                        },
                        "workspace": {
                                Type:         schema.TypeInt,
                                Optional:     true,
                                Default:      50,
                                ValidateFunc: validation.IntBetween(1, 10000),
                                Description:  "The maximum number of workspaces that can be created. Must be between 1 and 10,000.",
                        },
                },
        }
}</span>

var KindToFieldMapping = []struct {
        Kind    models.V1ResourceLimitType
        Field   string
        Default int64
}{
        {models.V1ResourceLimitTypeAlert, "alert", 100},
        {models.V1ResourceLimitTypeAPIKey, "api_keys", 20},
        {models.V1ResourceLimitTypeAppdeployment, "application_deployment", 100},
        {models.V1ResourceLimitTypeAppprofile, "application_profile", 100},
        {models.V1ResourceLimitTypeCertificate, "certificate", 20},
        {models.V1ResourceLimitTypeCloudaccount, "cloud_account", 200},
        {models.V1ResourceLimitTypeClustergroup, "cluster_group", 100},
        {models.V1ResourceLimitTypeClusterprofile, "cluster_profile", 200},
        {models.V1ResourceLimitTypeEdgehost, "appliance", 200},
        {models.V1ResourceLimitTypeEdgetoken, "appliance_token", 200},
        {models.V1ResourceLimitTypeFilter, "filter", 100},
        {models.V1ResourceLimitTypeLocation, "location", 100},
        {models.V1ResourceLimitTypeMacro, "macro", 200},
        {models.V1ResourceLimitTypePrivategateway, "private_gateway", 50},
        {models.V1ResourceLimitTypeProject, "project", 50},
        {models.V1ResourceLimitTypeRegistry, "registry", 50},
        {models.V1ResourceLimitTypeRole, "role", 400},
        {models.V1ResourceLimitTypeSpectrocluster, "cluster", 1000},
        {models.V1ResourceLimitTypeSshkey, "ssh_key", 300},
        {models.V1ResourceLimitTypeTeam, "team", 100},
        {models.V1ResourceLimitTypeUser, "user", 300},
        {models.V1ResourceLimitTypeWorkspace, "workspace", 50},
}

func toResourceLimits(d *schema.ResourceData) (*models.V1TenantResourceLimitsEntity, error) <span class="cov0" title="0">{
        resourceLimit := make([]*models.V1TenantResourceLimitEntity, len(KindToFieldMapping))
        for i, mapping := range KindToFieldMapping </span><span class="cov0" title="0">{
                resourceLimit[i] = &amp;models.V1TenantResourceLimitEntity{
                        Kind:  mapping.Kind,
                        Limit: int64(d.Get(mapping.Field).(int)),
                }
        }</span>

        <span class="cov0" title="0">return &amp;models.V1TenantResourceLimitsEntity{Resources: resourceLimit}, nil</span>
}

func toResourceDefaultLimits(d *schema.ResourceData) (*models.V1TenantResourceLimitsEntity, error) <span class="cov0" title="0">{
        resourceLimit := make([]*models.V1TenantResourceLimitEntity, len(KindToFieldMapping))
        for i, limit := range KindToFieldMapping </span><span class="cov0" title="0">{
                resourceLimit[i] = &amp;models.V1TenantResourceLimitEntity{
                        Kind:  limit.Kind,
                        Limit: limit.Default,
                }
        }</span>

        <span class="cov0" title="0">return &amp;models.V1TenantResourceLimitsEntity{Resources: resourceLimit}, nil</span>
}

func flattenResourceLimits(resourceLimits *models.V1TenantResourceLimits, d *schema.ResourceData) error <span class="cov0" title="0">{
        kindToField := make(map[models.V1ResourceLimitType]string, len(KindToFieldMapping))
        for _, mapping := range KindToFieldMapping </span><span class="cov0" title="0">{
                kindToField[mapping.Kind] = mapping.Field
        }</span>

        <span class="cov0" title="0">for _, resource := range resourceLimits.Resources </span><span class="cov0" title="0">{
                if field, exists := kindToField[resource.Kind]; exists </span><span class="cov0" title="0">{
                        if err := d.Set(field, resource.Limit); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

func resourceResourceLimitsCreate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        c := getV1ClientWithResourceContext(m, tenantString)
        var diags diag.Diagnostics
        resourceLimits, err := toResourceLimits(d)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">tenantUID, err := c.GetTenantUID()
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">err = c.UpdateResourceLimits(tenantUID, resourceLimits)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">d.SetId("default-resource-limit-id")
        return diags</span>
}

func resourceResourceLimitsRead(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        c := getV1ClientWithResourceContext(m, tenantString)
        var diags diag.Diagnostics
        tenantUID, err := c.GetTenantUID()
        if err != nil </span><span class="cov0" title="0">{
                return handleReadError(d, err, diags)
        }</span>
        <span class="cov0" title="0">resp, err := c.GetResourceLimits(tenantUID)
        if err != nil </span><span class="cov0" title="0">{
                return handleReadError(d, err, diags)
        }</span>
        // handling case for cross-plane for singleton resource
        <span class="cov0" title="0">if d.Id() != "default-resource-limit-id" </span><span class="cov0" title="0">{
                d.SetId("")
                return diags
        }</span>
        <span class="cov0" title="0">err = flattenResourceLimits(resp, d)
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return diags</span>
}

func resourceResourceLimitsUpdate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        c := getV1ClientWithResourceContext(m, tenantString)
        var diags diag.Diagnostics
        resourceLimits, err := toResourceLimits(d)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">tenantUID, err := c.GetTenantUID()
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">err = c.UpdateResourceLimits(tenantUID, resourceLimits)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">return diags</span>
}

func resourceResourceLimitsDelete(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        c := getV1ClientWithResourceContext(m, tenantString)
        var diags diag.Diagnostics
        // We can't delete the base resource limit, instead
        resourceLimits, err := toResourceDefaultLimits(d)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">tenantUID, err := c.GetTenantUID()
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">err = c.UpdateResourceLimits(tenantUID, resourceLimits)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">d.SetId("")
        return diags</span>
}

func resourceResourceLimitsImport(ctx context.Context, d *schema.ResourceData, m interface{}) ([]*schema.ResourceData, error) <span class="cov0" title="0">{
        c := getV1ClientWithResourceContext(m, "tenant")
        var diags diag.Diagnostics
        givenTenantId := d.Id()
        actualTenantId, err := c.GetTenantUID()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if givenTenantId != actualTenantId </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("tenant id is not valid with current user: %v", diags)
        }</span>
        <span class="cov0" title="0">diags = resourceResourceLimitsRead(ctx, d, m)
        if diags.HasError() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("could not read resource limits for import: %v", diags)
        }</span>
        <span class="cov0" title="0">return []*schema.ResourceData{d}, nil</span>
}
</pre>
		
		<pre class="file" id="file180" style="display: none">package spectrocloud

import (
        "context"
        "fmt"
        "github.com/spectrocloud/palette-sdk-go/api/models"
        "time"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
)

func resourceRole() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                CreateContext: resourceRoleCreate,
                ReadContext:   resourceRoleRead,
                UpdateContext: resourceRoleUpdate,
                DeleteContext: resourceRoleDelete,
                Importer: &amp;schema.ResourceImporter{
                        StateContext: resourceRoleImport,
                },
                Description: "The role resource allows you to manage roles in Palette.",

                Timeouts: &amp;schema.ResourceTimeout{
                        Create: schema.DefaultTimeout(10 * time.Minute),
                        Update: schema.DefaultTimeout(10 * time.Minute),
                        Delete: schema.DefaultTimeout(10 * time.Minute),
                },
                SchemaVersion: 2,
                Schema: map[string]*schema.Schema{
                        "name": {
                                Type:        schema.TypeString,
                                Required:    true,
                                Description: "The name of the role.",
                        },
                        "type": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "project",
                                ValidateFunc: validation.StringInSlice([]string{"project", "tenant", "resource"}, false),
                                Description:  "The role type. Allowed values are `project` or `tenant` or `resource`",
                        },
                        "permissions": {
                                Type:        schema.TypeSet,
                                Required:    true,
                                Elem:        &amp;schema.Schema{Type: schema.TypeString},
                                Description: "The permission's assigned to the role.",
                        },
                },
        }
}</span>

func resourceRoleCreate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        c := getV1ClientWithResourceContext(m, "tenant")
        var diags diag.Diagnostics
        role := toRole(d)
        uid, err := c.CreateRole(role)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">d.SetId(uid)
        return diags</span>
}

func resourceRoleRead(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        c := getV1ClientWithResourceContext(m, "tenant")
        var diags diag.Diagnostics
        role, err := c.GetRoleByID(d.Id())
        if err != nil </span><span class="cov0" title="0">{
                return handleReadError(d, err, diags)
        }</span>
        <span class="cov0" title="0">err = flattenRole(d, role)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">return diags</span>
}

func resourceRoleUpdate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        c := getV1ClientWithResourceContext(m, "tenant")
        var diags diag.Diagnostics
        role := toRole(d)
        err := c.UpdateRole(role, d.Id())
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">return diags</span>
}

func resourceRoleDelete(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        c := getV1ClientWithResourceContext(m, "tenant")
        var diags diag.Diagnostics
        err := c.DeleteRole(d.Id())
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">return diags</span>
}

func resourceRoleImport(ctx context.Context, d *schema.ResourceData, m interface{}) ([]*schema.ResourceData, error) <span class="cov0" title="0">{
        c := getV1ClientWithResourceContext(m, "tenant")
        _, err := c.GetRoleByID(d.Id())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">diags := resourceRoleRead(ctx, d, m)
        if diags.HasError() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("could not read role for import: %v", diags)
        }</span>
        <span class="cov0" title="0">return []*schema.ResourceData{d}, nil</span>
}

func convertInterfaceSliceToStringSlice(input []interface{}) ([]string, error) <span class="cov0" title="0">{
        var output []string
        for _, item := range input </span><span class="cov0" title="0">{
                str, ok := item.(string)
                if !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("item %v is not a string", item)
                }</span>
                <span class="cov0" title="0">output = append(output, str)</span>
        }
        <span class="cov0" title="0">return output, nil</span>
}

func toRole(d *schema.ResourceData) *models.V1Role <span class="cov0" title="0">{
        name := d.Get("name").(string)
        roleType := d.Get("type").(string)
        permission, _ := convertInterfaceSliceToStringSlice(d.Get("permissions").(*schema.Set).List())
        return &amp;models.V1Role{
                Metadata: &amp;models.V1ObjectMeta{
                        Annotations: map[string]string{
                                "scope": roleType,
                        },
                        LastModifiedTimestamp: models.V1Time{},
                        Name:                  name,
                },
                Spec: &amp;models.V1RoleSpec{
                        Permissions: permission,
                        Scope:       models.V1Scope(roleType),
                        Type:        "user",
                },
                Status: &amp;models.V1RoleStatus{
                        IsEnabled: true,
                },
        }
}</span>

func flattenRole(d *schema.ResourceData, role *models.V1Role) error <span class="cov0" title="0">{
        var err error
        err = d.Set("name", role.Metadata.Name)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">err = d.Set("type", role.Spec.Scope)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">err = d.Set("permissions", role.Spec.Permissions)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file181" style="display: none">package spectrocloud

import (
        "context"
        "time"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
        "github.com/spectrocloud/palette-sdk-go/api/models"
)

func resourceSSHKey() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                CreateContext: resourceSSHKeyCreate,
                ReadContext:   resourceSSHKeyRead,
                UpdateContext: resourceSSHKeyUpdate,
                DeleteContext: resourceSSHKeyDelete,
                Importer: &amp;schema.ResourceImporter{
                        StateContext: resourceSSHKeyImport,
                },
                Description: "The SSH key resource allows you to manage SSH keys in Palette.",

                Timeouts: &amp;schema.ResourceTimeout{
                        Create: schema.DefaultTimeout(10 * time.Minute),
                        Update: schema.DefaultTimeout(10 * time.Minute),
                        Delete: schema.DefaultTimeout(10 * time.Minute),
                },
                SchemaVersion: 2,
                Schema: map[string]*schema.Schema{
                        "name": {
                                Type:        schema.TypeString,
                                Required:    true,
                                Description: "The name of the SSH key resource.",
                        },
                        "ssh_key": {
                                Type:        schema.TypeString,
                                Required:    true,
                                Sensitive:   true,
                                Description: "The SSH key value. This is the public key that will be used to access the cluster. Must be in the [Authorized Keys](https://www.ssh.com/academy/ssh/authorized-keys-openssh#format-of-the-authorized-keys-file) format, such as `ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDZ...`",
                        },
                        "context": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "project",
                                ValidateFunc: validation.StringInSlice([]string{"project", "tenant"}, false),
                                Description: "The context of the cluster profile. Allowed values are `project` or `tenant`. " +
                                        "Default value is `project`. " + PROJECT_NAME_NUANCE,
                        },
                },
        }
}</span>

func toSSHKey(d *schema.ResourceData) (*models.V1UserAssetSSH, error) <span class="cov0" title="0">{
        return &amp;models.V1UserAssetSSH{
                Metadata: &amp;models.V1ObjectMeta{
                        Name: d.Get("name").(string),
                },
                Spec: &amp;models.V1UserAssetSSHSpec{
                        PublicKey: d.Get("ssh_key").(string),
                },
        }, nil
}</span>

func flattenSSHKey(sshKey *models.V1UserAssetSSH, d *schema.ResourceData) error <span class="cov0" title="0">{
        err := d.Set("name", sshKey.Metadata.Name)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">err = d.Set("ssh_key", sshKey.Spec.PublicKey)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func resourceSSHKeyCreate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        sshKeyContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, sshKeyContext)
        var diags diag.Diagnostics
        sshKey, err := toSSHKey(d)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">uid, err := c.CreateSSHKey(sshKey)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">d.SetId(uid)
        return diags</span>
}

func resourceSSHKeyRead(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        sshKeyContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, sshKeyContext)
        var diags diag.Diagnostics

        sshKey, err := c.GetSSHKey(d.Id())
        if err != nil </span><span class="cov0" title="0">{
                return handleReadError(d, err, diags)
        }</span> else<span class="cov0" title="0"> if sshKey == nil </span><span class="cov0" title="0">{
                // Deleted - Terraform will recreate it
                d.SetId("")
                return diags
        }</span>
        <span class="cov0" title="0">err = flattenSSHKey(sshKey, d)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">return diags</span>
}

func resourceSSHKeyUpdate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        sshKeyContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, sshKeyContext)
        var diags diag.Diagnostics
        sshKey, err := toSSHKey(d)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">err = c.UpdateSSHKey(d.Id(), sshKey)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">return diags</span>
}

func resourceSSHKeyDelete(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        sshKeyContext := d.Get("context").(string)
        c := getV1ClientWithResourceContext(m, sshKeyContext)
        var diags diag.Diagnostics

        err := c.DeleteSSHKey(d.Id())
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">return diags</span>
}
</pre>
		
		<pre class="file" id="file182" style="display: none">package spectrocloud

import (
        "context"
        "fmt"
        "strings"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/spectrocloud/palette-sdk-go/client"
)

func resourceSSHKeyImport(ctx context.Context, d *schema.ResourceData, m interface{}) ([]*schema.ResourceData, error) <span class="cov0" title="0">{
        _, err := GetCommonSSHKey(d, m)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Read all SSH key data to populate the state
        <span class="cov0" title="0">diags := resourceSSHKeyRead(ctx, d, m)
        if diags.HasError() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("could not read SSH key for import: %v", diags)
        }</span>

        <span class="cov0" title="0">return []*schema.ResourceData{d}, nil</span>
}

func GetCommonSSHKey(d *schema.ResourceData, m interface{}) (*client.V1Client, error) <span class="cov0" title="0">{
        // Parse the import ID which can be either:
        // 1. Simple format: ssh_key_id (defaults to project context)
        // 2. Context format: ssh_key_id:context (explicit context)
        importID := d.Id()
        if importID == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("SSH key import ID is required")
        }</span>

        <span class="cov0" title="0">var context string
        var sshKeyID string

        // Check if the import ID contains context specification
        parts := strings.Split(importID, ":")
        if len(parts) == 2 </span><span class="cov0" title="0">{
                // Format: ssh_key_id:context
                sshKeyID = parts[0]
                context = parts[1]

                // Validate context
                if context != "project" &amp;&amp; context != "tenant" </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid context '%s'. Expected 'project' or 'tenant'", context)
                }</span>
        } else<span class="cov0" title="0"> if len(parts) == 1 </span><span class="cov0" title="0">{
                // Format: ssh_key_id (default to project context)
                context = "project"
                sshKeyID = parts[0]
        }</span> else<span class="cov0" title="0"> {
                return nil, fmt.Errorf("invalid import ID format. Expected 'ssh_key_id' or 'ssh_key_id:context', got: %s", importID)
        }</span>

        // Try the specified context first
        <span class="cov0" title="0">c := getV1ClientWithResourceContext(m, context)
        sshKey, err := c.GetSSHKey(sshKeyID)

        if err != nil || sshKey == nil </span><span class="cov0" title="0">{
                // If not found in specified context, try the other context
                otherContext := "tenant"
                if context == "tenant" </span><span class="cov0" title="0">{
                        otherContext = "project"
                }</span>

                <span class="cov0" title="0">c = getV1ClientWithResourceContext(m, otherContext)
                sshKey, err = c.GetSSHKey(sshKeyID)

                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unable to retrieve SSH key in either project or tenant context: %s", err)
                }</span>
                <span class="cov0" title="0">if sshKey == nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("SSH key with ID %s not found in either project or tenant context", sshKeyID)
                }</span>

                // Update context to the one where we found the resource
                <span class="cov0" title="0">context = otherContext</span>
        }

        // Set the required fields for the resource
        <span class="cov0" title="0">if err := d.Set("name", sshKey.Metadata.Name); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := d.Set("context", context); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Note: We don't set the 'ssh_key' field during import because it's marked as sensitive.
        // This follows the same pattern as other sensitive fields (like credentials in cloud accounts).
        // The user will need to provide the ssh_key value in their Terraform configuration after import.
        // This is a security best practice to prevent sensitive data from being stored in state during import.

        // Set the ID to the SSH key ID
        <span class="cov0" title="0">d.SetId(sshKeyID)

        return c, nil</span>
}
</pre>
		
		<pre class="file" id="file183" style="display: none">package spectrocloud

import (
        "context"
        "encoding/base64"
        "fmt"
        "regexp"
        "strings"
        "time"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
        "github.com/spectrocloud/palette-sdk-go/api/models"
        "github.com/spectrocloud/palette-sdk-go/client"
)

func resourceSSO() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                CreateContext: resourceSSOCreate,
                ReadContext:   resourceSSORead,
                UpdateContext: resourceSSOUpdate,
                DeleteContext: resourceSSODelete,
                Importer: &amp;schema.ResourceImporter{
                        StateContext: resourceSSOImport,
                },

                Timeouts: &amp;schema.ResourceTimeout{
                        Create: schema.DefaultTimeout(10 * time.Minute),
                        Update: schema.DefaultTimeout(10 * time.Minute),
                        Delete: schema.DefaultTimeout(10 * time.Minute),
                },
                SchemaVersion: 2,
                Schema: map[string]*schema.Schema{
                        "sso_auth_type": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "none",
                                ValidateFunc: validation.StringInSlice([]string{"none", "saml", "oidc"}, false),
                                Description:  "Defines the type of SSO authentication. Supported values: none, saml, oidc.",
                        },
                        "domains": {
                                Type:        schema.TypeSet,
                                Optional:    true,
                                Set:         schema.HashString,
                                Description: "A set of domains associated with the SSO configuration.",
                                Elem: &amp;schema.Schema{
                                        Type: schema.TypeString,
                                        ValidateFunc: func(val interface{}, key string) (warns []string, errs []error) </span><span class="cov0" title="0">{
                                                v := val.(string)

                                                if strings.TrimSpace(v) == "" </span><span class="cov0" title="0">{
                                                        errs = append(errs, fmt.Errorf("%q must not be empty", key))
                                                        return
                                                }</span>

                                                // Basic domain regex (not exhaustive but covers common cases)
                                                <span class="cov0" title="0">domainRegex := `^([a-zA-Z0-9-]+\.)+[a-zA-Z]{2,}$`
                                                if matched, _ := regexp.MatchString(domainRegex, v); !matched </span><span class="cov0" title="0">{
                                                        errs = append(errs, fmt.Errorf("%q must be a valid domain name", key))
                                                }</span>
                                                <span class="cov0" title="0">return</span>
                                        },
                                },
                        },
                        "auth_providers": {
                                Type:        schema.TypeSet,
                                Optional:    true,
                                Set:         schema.HashString,
                                Description: "A set of external authentication providers such as GitHub and Google.",
                                Elem: &amp;schema.Schema{
                                        Type:         schema.TypeString,
                                        ValidateFunc: validation.StringInSlice([]string{"", "github", "google"}, false),
                                },
                        },
                        "oidc": {
                                Type:     schema.TypeList,
                                Optional: true,
                                MaxItems: 1,
                                Elem: &amp;schema.Resource{
                                        Schema: map[string]*schema.Schema{
                                                "issuer_url": {
                                                        Type:        schema.TypeString,
                                                        Required:    true,
                                                        Description: "URL of the OIDC issuer.",
                                                },
                                                "identity_provider_ca_certificate": {
                                                        Type:        schema.TypeString,
                                                        Optional:    true,
                                                        Default:     "",
                                                        Description: "Certificate authority (CA) certificate for the identity provider.",
                                                },
                                                "insecure_skip_tls_verify": {
                                                        Type:        schema.TypeBool,
                                                        Optional:    true,
                                                        Default:     false,
                                                        Description: "Boolean to skip TLS verification for identity provider communication.  WARNING: Setting this to true disables SSL certificate verification and makes connections vulnerable to man-in-the-middle attacks. Only use this when connecting to identity providers with self-signed certificates in trusted networks.",
                                                },
                                                "client_id": {
                                                        Type:        schema.TypeString,
                                                        Required:    true,
                                                        Description: "Client ID for OIDC authentication.",
                                                        ValidateFunc: func(val interface{}, key string) (warns []string, errs []error) <span class="cov0" title="0">{
                                                                v := val.(string)
                                                                if v == "" </span><span class="cov0" title="0">{
                                                                        errs = append(errs, fmt.Errorf("%q must not be empty", key))
                                                                }</span>
                                                                <span class="cov0" title="0">return</span>
                                                        },
                                                },
                                                "client_secret": {
                                                        Type:        schema.TypeString,
                                                        Required:    true,
                                                        Sensitive:   true,
                                                        Description: "Client secret for OIDC authentication (sensitive).",
                                                        ValidateFunc: func(val interface{}, key string) (warns []string, errs []error) <span class="cov0" title="0">{
                                                                v := val.(string)
                                                                if v == "" </span><span class="cov0" title="0">{
                                                                        errs = append(errs, fmt.Errorf("%q must not be empty", key))
                                                                }</span>
                                                                <span class="cov0" title="0">return</span>
                                                        },
                                                },
                                                "callback_url": {
                                                        Type:        schema.TypeString,
                                                        Computed:    true,
                                                        Description: "URL to which the identity provider redirects after authentication.",
                                                },
                                                "logout_url": {
                                                        Type:        schema.TypeString,
                                                        Computed:    true,
                                                        Description: "URL used for logging out of the OIDC session.",
                                                },
                                                "default_team_ids": {
                                                        Type:     schema.TypeSet,
                                                        Optional: true,
                                                        Set:      schema.HashString,
                                                        Elem: &amp;schema.Schema{
                                                                Type: schema.TypeString,
                                                        },
                                                        Description: "A set of default team IDs assigned to users.",
                                                },
                                                "scopes": {
                                                        Type:     schema.TypeSet,
                                                        Required: true,
                                                        Set:      schema.HashString,
                                                        Elem: &amp;schema.Schema{
                                                                Type: schema.TypeString,
                                                        },
                                                        Description: "Scopes requested during OIDC authentication.",
                                                },
                                                "first_name": {
                                                        Type:        schema.TypeString,
                                                        Required:    true,
                                                        Description: "The name of the claim that returns the user's first name from the identity provider.",
                                                },
                                                "last_name": {
                                                        Type:        schema.TypeString,
                                                        Required:    true,
                                                        Description: "The name of the claim that returns the user's last name from the identity provider.",
                                                },
                                                "email": {
                                                        Type:        schema.TypeString,
                                                        Required:    true,
                                                        Description: "The name of the claim that returns the user's email address from the identity provider.",
                                                        ValidateFunc: func(val interface{}, key string) (warns []string, errs []error) <span class="cov0" title="0">{
                                                                v := val.(string)
                                                                if v == "" </span><span class="cov0" title="0">{
                                                                        errs = append(errs, fmt.Errorf("%q must not be empty", key))
                                                                        return
                                                                }</span>
                                                                <span class="cov0" title="0">return</span>
                                                        },
                                                },
                                                "spectro_team": {
                                                        Type:        schema.TypeString,
                                                        Required:    true,
                                                        Description: "The name of the claim that returns the user's group memberships from the Identity Provider. The values of this claim will map to SpectroCloud teams.",
                                                },
                                                "user_info_endpoint": {
                                                        Type:        schema.TypeList,
                                                        Optional:    true,
                                                        MaxItems:    1,
                                                        Description: "To allow Palette to query the OIDC userinfo endpoint using the provided Issuer URL. Palette will first attempt to retrieve role and group information from userInfo endpoint. If unavailable, Palette will fall back to using Required Claims as specified above. Use the following fields to specify what Required Claims Palette will include when querying the userinfo endpoint.",
                                                        Elem: &amp;schema.Resource{
                                                                Schema: map[string]*schema.Schema{
                                                                        "first_name": {
                                                                                Type:        schema.TypeString,
                                                                                Required:    true,
                                                                                Description: "The name of the claim that returns the user's first name from the identity provider.",
                                                                        },
                                                                        "last_name": {
                                                                                Type:        schema.TypeString,
                                                                                Required:    true,
                                                                                Description: "The name of the claim that returns the user's last name from the identity provider.",
                                                                        },
                                                                        "email": {
                                                                                Type:        schema.TypeString,
                                                                                Required:    true,
                                                                                Description: "The name of the claim that returns the user's email address from the identity provider.",
                                                                                ValidateFunc: func(val interface{}, key string) (warns []string, errs []error) <span class="cov0" title="0">{
                                                                                        v := val.(string)
                                                                                        if v == "" </span><span class="cov0" title="0">{
                                                                                                errs = append(errs, fmt.Errorf("%q must not be empty", key))
                                                                                                return
                                                                                        }</span>
                                                                                        <span class="cov0" title="0">return</span>
                                                                                },
                                                                        },
                                                                        "spectro_team": {
                                                                                Type:        schema.TypeString,
                                                                                Required:    true,
                                                                                Description: "The name of the claim that returns the user's group memberships from the Identity Provider. The values of this claim will map to SpectroCloud teams.",
                                                                        },
                                                                },
                                                        },
                                                },
                                        },
                                },
                        },
                        "saml": {
                                Type:        schema.TypeList,
                                Optional:    true,
                                MaxItems:    1,
                                Description: "Configuration for Security Assertion Markup Language (SAML) authentication.",
                                Elem: &amp;schema.Resource{
                                        Schema: map[string]*schema.Schema{
                                                "issuer": {
                                                        Type:        schema.TypeString,
                                                        Computed:    true,
                                                        Description: "SAML identity provider issuer URL.",
                                                },
                                                "certificate": {
                                                        Type:        schema.TypeString,
                                                        Computed:    true,
                                                        Description: "Certificate for SAML authentication.",
                                                },
                                                "service_provider": {
                                                        Type:         schema.TypeString,
                                                        Required:     true,
                                                        ValidateFunc: validation.StringInSlice([]string{"Azure Active Directory", "Okta", "Keycloak", "OneLogin", "Microsoft ADFS", "Others"}, false),
                                                        Description:  "The identity provider service used for SAML authentication.",
                                                },
                                                "identity_provider_metadata": {
                                                        Type:        schema.TypeString,
                                                        Required:    true,
                                                        Description: "Metadata XML of the SAML identity provider.",
                                                },
                                                "default_team_ids": {
                                                        Type:     schema.TypeSet,
                                                        Optional: true,
                                                        Set:      schema.HashString,
                                                        Elem: &amp;schema.Schema{
                                                                Type: schema.TypeString,
                                                        },
                                                        Description: "A set of default team IDs assigned to users.",
                                                },
                                                "enable_single_logout": {
                                                        Type:        schema.TypeBool,
                                                        Optional:    true,
                                                        Default:     false,
                                                        Description: "Boolean to enable SAML single logout feature.",
                                                },
                                                "single_logout_url": {
                                                        Type:        schema.TypeString,
                                                        Computed:    true,
                                                        Description: "URL used for initiating SAML single logout.",
                                                },
                                                "entity_id": {
                                                        Type:        schema.TypeString,
                                                        Computed:    true,
                                                        Description: "Entity ID used to identify the service provider.",
                                                },
                                                "name_id_format": {
                                                        Type:        schema.TypeString,
                                                        Required:    true,
                                                        Description: "Format of the NameID attribute in SAML responses.",
                                                },
                                                "login_url": {
                                                        Type:        schema.TypeString,
                                                        Computed:    true,
                                                        Description: "Login URL for the SAML identity provider.",
                                                },
                                                "first_name": {
                                                        Type:        schema.TypeString,
                                                        Optional:    true,
                                                        Default:     "FirstName",
                                                        Description: "User's first name retrieved from identity provider.",
                                                },
                                                "last_name": {
                                                        Type:        schema.TypeString,
                                                        Optional:    true,
                                                        Default:     "LastName",
                                                        Description: "User's last name retrieved from identity provider.",
                                                },
                                                "email": {
                                                        Type:        schema.TypeString,
                                                        Optional:    true,
                                                        Default:     "Email",
                                                        Description: "User's email address retrieved from identity provider.",
                                                        ValidateFunc: func(val interface{}, key string) (warns []string, errs []error) <span class="cov0" title="0">{
                                                                v := val.(string)
                                                                if v == "" </span><span class="cov0" title="0">{
                                                                        errs = append(errs, fmt.Errorf("%q must not be empty", key))
                                                                        return
                                                                }</span>
                                                                <span class="cov0" title="0">return</span>
                                                        },
                                                },
                                                "spectro_team": {
                                                        Type:        schema.TypeString,
                                                        Optional:    true,
                                                        Default:     "SpectroTeam",
                                                        Description: "The SpectroCloud team the user belongs to.",
                                                },
                                                "service_provider_metadata": {
                                                        Type:        schema.TypeString,
                                                        Computed:    true,
                                                        Description: "Metadata XML of the SAML service provider.",
                                                },
                                        },
                                },
                        },
                },
                CustomizeDiff: customDiffValidation,
        }
}

func resourceSSOImport(ctx context.Context, d *schema.ResourceData, m interface{}) ([]*schema.ResourceData, error) <span class="cov0" title="0">{
        c := getV1ClientWithResourceContext(m, tenantString)
        ssoIdParts := strings.Split(d.Id(), ":")

        if len(ssoIdParts) != 2 || (ssoIdParts[1] != "saml" &amp;&amp; ssoIdParts[1] != "oidc") </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid sso type provided, kindly use saml/oidc")
        }</span>

        <span class="cov0" title="0">givenTenantId, ssoType := ssoIdParts[0], ssoIdParts[1]

        actualTenantId, err := c.GetTenantUID()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if givenTenantId != actualTenantId </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("tenant id is not valid with current user or invalid tenant uid provided")
        }</span>

        <span class="cov0" title="0">if err := d.Set("sso_auth_type", ssoType); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">diags := resourceSSORead(ctx, d, m)
        if diags.HasError() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("could not read sso settings for import: %v", diags)
        }</span>

        <span class="cov0" title="0">domainsEntity, err := c.GetDomains(givenTenantId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if err := flattenDomains(domainsEntity, d); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">authEntity, err := c.GetProviders(givenTenantId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if err := flattenAuthProviders(authEntity, d); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">d.SetId("sso_settings")
        return []*schema.ResourceData{d}, nil</span>
}

func disableSSO(c *client.V1Client, tenantUID string) error <span class="cov0" title="0">{
        // disable
        samlSpec, err := c.GetSAML(tenantUID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">samlEntity := &amp;models.V1TenantSamlRequestSpec{
                Attributes:            samlSpec.Attributes,
                DefaultTeams:          samlSpec.DefaultTeams,
                FederationMetadata:    samlSpec.FederationMetadata,
                IdentityProvider:      samlSpec.IdentityProvider,
                IsSingleLogoutEnabled: samlSpec.IsSingleLogoutEnabled,
                IsSsoEnabled:          false,
                NameIDFormat:          samlSpec.NameIDFormat,
                SyncSsoTeams:          samlSpec.SyncSsoTeams,
        }

        samlEntity.IsSsoEnabled = false
        err = c.UpdateSAML(tenantUID, samlEntity)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">oidcEntity, err := c.GetOIDC(tenantUID) // toOIDC(d)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">oidcEntity.IsSsoEnabled = false
        err = c.UpdateOIDC(tenantUID, oidcEntity)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // disable domain
        <span class="cov0" title="0">err = c.UpdateDomain(tenantUID, toDomains([]interface{}{}))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // disable auth provider
        <span class="cov0" title="0">authPro := toAuthProviders([]interface{}{})
        authPro.IsEnabled = false
        err = c.UpdateProviders(tenantUID, authPro)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return err</span>
}

func resourceCommonUpdate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        c := getV1ClientWithResourceContext(m, tenantString)
        var diags diag.Diagnostics
        var err error
        tenantUID, err := c.GetTenantUID()
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">ssoType := d.Get("sso_auth_type").(string)
        switch ssoType </span>{
        case "none":<span class="cov0" title="0">
                err = disableSSO(c, tenantUID)
                if err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
        case "saml":<span class="cov0" title="0">
                samlEntity := toSAML(d)
                err = c.UpdateSAML(tenantUID, samlEntity)
                if err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
        case "oidc":<span class="cov0" title="0">
                oidcEntity := toOIDC(d)
                err = c.UpdateOIDC(tenantUID, oidcEntity)
                if err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
        }
        <span class="cov0" title="0">if v, ok := d.GetOk("domains"); ok </span><span class="cov0" title="0">{
                err = c.UpdateDomain(tenantUID, toDomains(v.(*schema.Set).List()))
                if err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
        }
        <span class="cov0" title="0">if v, ok := d.GetOk("auth_providers"); ok </span><span class="cov0" title="0">{
                err = c.UpdateProviders(tenantUID, toAuthProviders(v.(*schema.Set).List()))
                if err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
        }

        <span class="cov0" title="0">return diags</span>
}

func resourceSSOCreate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        diags := resourceCommonUpdate(ctx, d, m)
        if !diags.HasError() </span><span class="cov0" title="0">{
                d.SetId("sso_settings")
        }</span>

        <span class="cov0" title="0">return diags</span>
}

func resourceSSORead(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        c := getV1ClientWithResourceContext(m, tenantString)
        var diags diag.Diagnostics
        tenantUID, err := c.GetTenantUID()
        if err != nil </span><span class="cov0" title="0">{
                return handleReadError(d, err, diags)
        }</span>
        // handling case for cross-plane for singleton resource
        <span class="cov0" title="0">if d.Id() != "sso_settings" </span><span class="cov0" title="0">{
                d.SetId("")
                return diags
        }</span>
        <span class="cov0" title="0">ssoType := d.Get("sso_auth_type").(string)
        if ssoType == "saml" </span><span class="cov0" title="0">{
                samlEntity, err := c.GetSAML(tenantUID)
                if err != nil </span><span class="cov0" title="0">{
                        return handleReadError(d, err, diags)
                }</span>
                <span class="cov0" title="0">err = flattenSAML(samlEntity, d)
                if err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
        }
        <span class="cov0" title="0">if ssoType == "oidc" </span><span class="cov0" title="0">{
                oidcEntity, err := c.GetOIDC(tenantUID)
                if err != nil </span><span class="cov0" title="0">{
                        return handleReadError(d, err, diags)
                }</span>
                <span class="cov0" title="0">err = flattenOidc(oidcEntity, d)
                if err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
        }
        <span class="cov0" title="0">if _, ok := d.GetOk("domains"); ok </span><span class="cov0" title="0">{
                domainsEntity, err := c.GetDomains(tenantUID)
                if err != nil </span><span class="cov0" title="0">{
                        return handleReadError(d, err, diags)
                }</span>
                <span class="cov0" title="0">err = flattenDomains(domainsEntity, d)
                if err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
        }

        <span class="cov0" title="0">if _, ok := d.GetOk("auth_providers"); ok </span><span class="cov0" title="0">{
                authEntity, err := c.GetProviders(tenantUID)
                if err != nil </span><span class="cov0" title="0">{
                        return handleReadError(d, err, diags)
                }</span>
                <span class="cov0" title="0">err = flattenAuthProviders(authEntity, d)
                if err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
        }

        <span class="cov0" title="0">return diags</span>
}

func resourceSSOUpdate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        c := getV1ClientWithResourceContext(m, tenantString)
        var diags diag.Diagnostics
        var err error
        tenantUID, err := c.GetTenantUID()
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">diags = resourceCommonUpdate(ctx, d, m)
        if ok := d.HasChange("domains"); ok </span><span class="cov0" title="0">{
                v := d.Get("domains")
                err = c.UpdateDomain(tenantUID, toDomains(v.(*schema.Set).List()))
                if err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
        }
        <span class="cov0" title="0">if ok := d.HasChange("auth_providers"); ok </span><span class="cov0" title="0">{
                v := d.Get("auth_providers")
                err = c.UpdateProviders(tenantUID, toAuthProviders(v.(*schema.Set).List()))
                if err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
        }
        <span class="cov0" title="0">if !diags.HasError() </span><span class="cov0" title="0">{
                d.SetId("sso_settings")
        }</span>
        <span class="cov0" title="0">return diags</span>
}

func resourceSSODelete(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        c := getV1ClientWithResourceContext(m, tenantString)
        var diags diag.Diagnostics
        var err error
        tenantUID, err := c.GetTenantUID()
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">err = disableSSO(c, tenantUID)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">d.SetId("")
        return diags</span>
}

func customDiffValidation(ctx context.Context, d *schema.ResourceDiff, v interface{}) error <span class="cov0" title="0">{
        ssoAuthType, ok := d.GetOk("sso_auth_type")
        if !ok </span><span class="cov0" title="0">{
                return nil // No validation needed if not set
        }</span>

        <span class="cov0" title="0">authType := ssoAuthType.(string)
        _, samlExists := d.GetOk("saml")
        _, oidcExists := d.GetOk("oidc")

        switch authType </span>{
        case "none":<span class="cov0" title="0">
                if samlExists || oidcExists </span><span class="cov0" title="0">{
                        return fmt.Errorf("sso_auth_type is set to 'none', so 'saml' and 'oidc' should not be defined")
                }</span>
        case "saml":<span class="cov0" title="0">
                if oidcExists </span><span class="cov0" title="0">{
                        return fmt.Errorf("sso_auth_type is set to 'saml', so 'oidc' should not be defined")
                }</span>
                <span class="cov0" title="0">if !samlExists </span><span class="cov0" title="0">{
                        return fmt.Errorf("sso_auth_type is set to 'saml', so 'saml' should be defined")
                }</span>
        case "oidc":<span class="cov0" title="0">
                if samlExists </span><span class="cov0" title="0">{
                        return fmt.Errorf("sso_auth_type is set to 'oidc', so 'saml' should not be defined")
                }</span>
                <span class="cov0" title="0">if !oidcExists </span><span class="cov0" title="0">{
                        return fmt.Errorf("sso_auth_type is set to 'oidc', so 'oidc' should be defined")
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func toStringSlice(input []interface{}) []string <span class="cov0" title="0">{
        result := make([]string, len(input))
        for i, v := range input </span><span class="cov0" title="0">{
                result[i] = v.(string)
        }</span>
        <span class="cov0" title="0">return result</span>
}

func toOIDC(d *schema.ResourceData) *models.V1TenantOidcClientSpec <span class="cov0" title="0">{
        oidcSpec := &amp;models.V1TenantOidcClientSpec{}

        oidc := d.Get("oidc").([]interface{})[0].(map[string]interface{})

        oidcSpec.CallbackURL = oidc["callback_url"].(string)
        oidcSpec.ClientID = oidc["client_id"].(string)
        oidcSpec.ClientSecret = oidc["client_secret"].(string)
        oidcSpec.DefaultTeams = toStringSlice(oidc["default_team_ids"].(*schema.Set).List())
        oidcSpec.IsSsoEnabled = true
        oidcSpec.IssuerTLS = &amp;models.V1OidcIssuerTLS{
                CaCertificateBase64: oidc["identity_provider_ca_certificate"].(string),
                InsecureSkipVerify:  BoolPtr(oidc["insecure_skip_tls_verify"].(bool)),
        }
        oidcSpec.IssuerURL = oidc["issuer_url"].(string)
        oidcSpec.LogoutURL = oidc["logout_url"].(string)
        oidcSpec.RequiredClaims = &amp;models.V1TenantOidcClaims{
                Email:       oidc["email"].(string),
                FirstName:   oidc["first_name"].(string),
                LastName:    oidc["last_name"].(string),
                SpectroTeam: oidc["spectro_team"].(string),
        }
        oidcSpec.Scopes = toStringSlice(oidc["scopes"].(*schema.Set).List())
        oidcSpec.ScopesDelimiter = ""
        oidcSpec.SyncSsoTeams = true

        if uie, ok := oidc["user_info_endpoint"]; ok </span><span class="cov0" title="0">{
                if len(uie.([]interface{})) &gt; 0 </span><span class="cov0" title="0">{
                        oidcSpec.UserInfo = &amp;models.V1OidcUserInfo{
                                Claims: &amp;models.V1TenantOidcClaims{
                                        Email:       uie.([]interface{})[0].(map[string]interface{})["email"].(string),
                                        FirstName:   uie.([]interface{})[0].(map[string]interface{})["first_name"].(string),
                                        LastName:    uie.([]interface{})[0].(map[string]interface{})["last_name"].(string),
                                        SpectroTeam: uie.([]interface{})[0].(map[string]interface{})["spectro_team"].(string),
                                },
                                UseUserInfo: BoolPtr(true),
                        }
                }</span>
        }
        <span class="cov0" title="0">return oidcSpec</span>
}

func flattenOidc(oidcSpec *models.V1TenantOidcClientSpec, d *schema.ResourceData) error <span class="cov0" title="0">{
        var err error
        var oidc []interface{}
        spec := make(map[string]interface{})

        spec["callback_url"] = oidcSpec.CallbackURL
        spec["client_id"] = oidcSpec.ClientID
        spec["client_secret"] = oidcSpec.ClientSecret

        spec["default_team_ids"] = oidcSpec.DefaultTeams
        decodeCA, _ := base64.StdEncoding.DecodeString(oidcSpec.IssuerTLS.CaCertificateBase64)
        spec["identity_provider_ca_certificate"] = string(decodeCA)
        spec["insecure_skip_tls_verify"] = oidcSpec.IssuerTLS.InsecureSkipVerify
        spec["issuer_url"] = oidcSpec.IssuerURL
        spec["logout_url"] = oidcSpec.LogoutURL

        spec["email"] = oidcSpec.RequiredClaims.Email
        spec["first_name"] = oidcSpec.RequiredClaims.FirstName
        spec["last_name"] = oidcSpec.RequiredClaims.LastName
        spec["spectro_team"] = oidcSpec.RequiredClaims.SpectroTeam
        spec["scopes"] = oidcSpec.Scopes

        var userEndpoint []interface{}
        userEndpoint = append(userEndpoint, map[string]interface{}{
                "email":        oidcSpec.UserInfo.Claims.Email,
                "first_name":   oidcSpec.UserInfo.Claims.FirstName,
                "last_name":    oidcSpec.UserInfo.Claims.LastName,
                "spectro_team": oidcSpec.UserInfo.Claims.SpectroTeam,
        })
        spec["user_info_endpoint"] = userEndpoint

        oidc = append(oidc, spec)
        if err = d.Set("oidc", oidc); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return err</span>
}

func toSAML(d *schema.ResourceData) *models.V1TenantSamlRequestSpec <span class="cov0" title="0">{
        samlSpec := &amp;models.V1TenantSamlRequestSpec{}
        saml := d.Get("saml").([]interface{})[0].(map[string]interface{})
        // Attributes
        firstNameTemplate := &amp;models.V1TenantSamlSpecAttribute{
                AttributeValue:  "[FIRST_NAME_OF_USER]",
                MappedAttribute: saml["first_name"].(string),
                Name:            "FirstName",
                NameFormat:      "urn:oasis:names:tc:SAML:2.0:attrname-format:unspecified",
        }
        lastNameTemplate := &amp;models.V1TenantSamlSpecAttribute{
                AttributeValue:  "[LAST_NAME_OF_USER]",
                MappedAttribute: saml["last_name"].(string),
                Name:            "LastName",
                NameFormat:      "urn:oasis:names:tc:SAML:2.0:attrname-format:unspecified",
        }
        emailTemplate := &amp;models.V1TenantSamlSpecAttribute{
                AttributeValue:  "[EMAIL_OF_USER]",
                MappedAttribute: saml["email"].(string),
                Name:            "Email",
                NameFormat:      "urn:oasis:names:tc:SAML:2.0:attrname-format:unspecified",
        }
        spectroTeamTemplate := &amp;models.V1TenantSamlSpecAttribute{
                AttributeValue:  "[SPECTRO_TEAM_OF_USER]",
                MappedAttribute: saml["spectro_team"].(string),
                Name:            "SpectroTeam",
                NameFormat:      "urn:oasis:names:tc:SAML:2.0:attrname-format:unspecified",
        }

        attributes := make([]*models.V1TenantSamlSpecAttribute, 0)
        attributes = append(attributes, firstNameTemplate)
        attributes = append(attributes, lastNameTemplate)
        attributes = append(attributes, emailTemplate)
        attributes = append(attributes, spectroTeamTemplate)
        samlSpec.Attributes = attributes

        samlSpec.DefaultTeams = toStringSlice(saml["default_team_ids"].(*schema.Set).List())
        samlSpec.FederationMetadata = base64.StdEncoding.EncodeToString([]byte(saml["identity_provider_metadata"].(string)))
        samlSpec.IdentityProvider = saml["service_provider"].(string)
        samlSpec.IsSingleLogoutEnabled = saml["enable_single_logout"].(bool)
        samlSpec.IsSsoEnabled = true
        samlSpec.NameIDFormat = saml["name_id_format"].(string)
        samlSpec.SyncSsoTeams = true

        return samlSpec
}</span>

func flattenSAML(saml *models.V1TenantSamlSpec, d *schema.ResourceData) error <span class="cov0" title="0">{
        var err error
        var samlData []interface{}
        spec := make(map[string]interface{})
        spec["issuer"] = saml.Issuer
        spec["certificate"] = saml.Certificate
        spec["service_provider"] = saml.IdentityProvider
        decodeCA, _ := base64.StdEncoding.DecodeString(saml.FederationMetadata)
        spec["identity_provider_metadata"] = string(decodeCA)
        spec["default_team_ids"] = saml.DefaultTeams
        spec["enable_single_logout"] = saml.IsSingleLogoutEnabled
        spec["single_logout_url"] = saml.SingleLogoutURL
        spec["entity_id"] = saml.EntityID
        spec["name_id_format"] = saml.NameIDFormat
        spec["login_url"] = saml.AudienceURL
        spec["service_provider_metadata"] = saml.ServiceProviderMetadata

        attribute := make(map[string]interface{})

        for _, a := range saml.Attributes </span><span class="cov0" title="0">{
                attribute[a.Name] = a
        }</span>
        <span class="cov0" title="0">spec["first_name"] = attribute["FirstName"].(*models.V1TenantSamlSpecAttribute).MappedAttribute
        spec["last_name"] = attribute["LastName"].(*models.V1TenantSamlSpecAttribute).MappedAttribute
        spec["email"] = attribute["Email"].(*models.V1TenantSamlSpecAttribute).MappedAttribute
        spec["spectro_team"] = attribute["SpectroTeam"].(*models.V1TenantSamlSpecAttribute).MappedAttribute
        samlData = append(samlData, spec)
        if err = d.Set("saml", samlData); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return err</span>
}

func toDomains(domains []interface{}) *models.V1TenantDomains <span class="cov0" title="0">{
        domainSpec := &amp;models.V1TenantDomains{
                Domains: toStringSlice(domains),
        }
        return domainSpec
}</span>

func flattenDomains(domains *models.V1TenantDomains, d *schema.ResourceData) error <span class="cov0" title="0">{
        var err error
        if domains.Domains != nil </span><span class="cov0" title="0">{
                err = d.Set("domains", domains.Domains)
        }</span>
        <span class="cov0" title="0">return err</span>
}

func toAuthProviders(providers []interface{}) *models.V1TenantSsoAuthProvidersEntity <span class="cov0" title="0">{
        if len(providers) == 0 </span><span class="cov0" title="0">{
                authProviderSpec := &amp;models.V1TenantSsoAuthProvidersEntity{
                        IsEnabled: false,
                        SsoLogins: []string{""},
                }
                return authProviderSpec
        }</span>
        <span class="cov0" title="0">authProviderSpec := &amp;models.V1TenantSsoAuthProvidersEntity{
                IsEnabled: true,
                SsoLogins: toStringSlice(providers),
        }
        return authProviderSpec</span>
}

func flattenAuthProviders(authProviders *models.V1TenantSsoAuthProvidersEntity, d *schema.ResourceData) error <span class="cov0" title="0">{
        var err error
        if authProviders != nil </span><span class="cov0" title="0">{
                err = d.Set("auth_providers", authProviders.SsoLogins)
        }</span>
        <span class="cov0" title="0">return err</span>
}
</pre>
		
		<pre class="file" id="file184" style="display: none">package spectrocloud

import (
        "bytes"
        "context"
        "fmt"
        "sort"
        "time"

        "github.com/spectrocloud/palette-sdk-go/api/models"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/spectrocloud/palette-sdk-go/client"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
)

func resourceTeam() *schema.Resource <span class="cov6" title="4">{
        return &amp;schema.Resource{
                CreateContext: resourceTeamCreate,
                ReadContext:   resourceTeamRead,
                UpdateContext: resourceTeamUpdate,
                DeleteContext: resourceTeamDelete,
                Importer: &amp;schema.ResourceImporter{
                        StateContext: resourceTeamImport,
                },

                Timeouts: &amp;schema.ResourceTimeout{
                        Create: schema.DefaultTimeout(10 * time.Minute),
                        Update: schema.DefaultTimeout(10 * time.Minute),
                        Delete: schema.DefaultTimeout(10 * time.Minute),
                },

                SchemaVersion: 2,
                Schema: map[string]*schema.Schema{
                        "name": {
                                Type:        schema.TypeString,
                                Required:    true,
                                ForceNew:    true,
                                Description: "Name of the team. ",
                        },
                        "users": {
                                Type:     schema.TypeSet,
                                Optional: true,
                                Set:      schema.HashString,
                                Elem: &amp;schema.Schema{
                                        Type: schema.TypeString,
                                },
                                Description: "List of user ids to be associated with the team. ",
                        },
                        "project_role_mapping": {
                                Type:     schema.TypeSet,
                                Set:      resourceProjectRoleMappingHash,
                                Optional: true,
                                Elem: &amp;schema.Resource{
                                        Schema: map[string]*schema.Schema{
                                                "id": {
                                                        Type:        schema.TypeString,
                                                        Required:    true,
                                                        Description: "Project id to be associated with the team.",
                                                },
                                                "roles": {
                                                        Type:     schema.TypeSet,
                                                        Required: true,
                                                        Set:      schema.HashString,
                                                        Elem: &amp;schema.Schema{
                                                                Type: schema.TypeString,
                                                        },
                                                        Description: "List of project roles to be associated with the team. ",
                                                },
                                        },
                                },
                                Description: "List of project roles to be associated with the team. ",
                        },
                        "tenant_role_mapping": {
                                Type:     schema.TypeSet,
                                Optional: true,
                                Set:      schema.HashString,
                                Elem: &amp;schema.Schema{
                                        Type: schema.TypeString,
                                },
                                Description: "List of tenant role ids to be associated with the team. ",
                        },
                        "workspace_role_mapping": {
                                Type:     schema.TypeSet,
                                Set:      resourceWorkspaceRoleMappingHash,
                                Optional: true,
                                Elem: &amp;schema.Resource{
                                        Schema: map[string]*schema.Schema{
                                                "id": {
                                                        Type:        schema.TypeString,
                                                        Required:    true,
                                                        Description: "Project id to be associated with the team.",
                                                },
                                                "workspace": {
                                                        Type:     schema.TypeSet,
                                                        Set:      resourceProjectRoleMappingHash,
                                                        Optional: true,
                                                        Elem: &amp;schema.Resource{
                                                                Schema: map[string]*schema.Schema{
                                                                        "id": {
                                                                                Type:        schema.TypeString,
                                                                                Required:    true,
                                                                                Description: "Workspace id to be associated with the team.",
                                                                        },
                                                                        "roles": {
                                                                                Type:     schema.TypeSet,
                                                                                Set:      schema.HashString,
                                                                                Required: true,
                                                                                Elem: &amp;schema.Schema{
                                                                                        Type: schema.TypeString,
                                                                                },
                                                                                Description: "List of workspace roles to be associated with the team.",
                                                                        },
                                                                },
                                                        },
                                                        Description: "List of workspace roles to be associated with the team. ",
                                                },
                                        },
                                },
                                Description: "List of workspace roles to be associated with the team. ",
                        },
                },
        }
}</span>

func resourceTeamCreate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        c := getV1ClientWithResourceContext(m, "tenant")
        var diags diag.Diagnostics

        uid, err := c.CreateTeam(toTeam(d))
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">d.SetId(uid)

        //associate roles with team
        err = c.AssociateTeamProjectRole(uid, toTeamProjectRoleMapping(d))
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        //associate tenant roles with team
        <span class="cov0" title="0">err = c.AssociateTeamTenantRole(uid, toTeamTenantRoleMapping(d))
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        //associate workspace roles with team
        <span class="cov0" title="0">err = c.AssociateTeamWorkspaceRole(uid, toTeamWorkspaceRoleMapping(d))
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">d.SetId(uid)

        return diags</span>
}

func resourceTeamRead(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        c := getV1ClientWithResourceContext(m, "tenant")
        var diags diag.Diagnostics

        team, err := c.GetTeam(d.Id())
        if err != nil </span><span class="cov0" title="0">{
                return handleReadError(d, err, diags)
        }</span> else<span class="cov0" title="0"> if team == nil </span><span class="cov0" title="0">{
                // Deleted - Terraform will recreate it
                d.SetId("")
                return diags
        }</span>

        <span class="cov0" title="0">if err := d.Set("name", team.Metadata.Name); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">if err := d.Set("users", team.Spec.Users); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">err = setProjectRoles(c, d)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">err = setTenantRoles(c, d)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">err = setWorkspaceRoles(c, d)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">return diags</span>
}

func setProjectRoles(c *client.V1Client, d *schema.ResourceData) error <span class="cov0" title="0">{
        projectRoles, err := c.GetTeamProjectRoleAssociation(d.Id())
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if projectRoles != nil &amp;&amp; len(projectRoles.Projects) &gt; 0 </span><span class="cov0" title="0">{
                mappings := make([]interface{}, 0)
                for _, project := range projectRoles.Projects </span><span class="cov0" title="0">{
                        dataMap := make(map[string]interface{})
                        roles := make([]string, 0)
                        for _, role := range project.Roles </span><span class="cov0" title="0">{
                                roles = append(roles, role.UID)
                        }</span>
                        <span class="cov0" title="0">dataMap["id"] = project.UID
                        dataMap["roles"] = roles
                        mappings = append(mappings, dataMap)</span>
                }
                <span class="cov0" title="0">if err := d.Set("project_role_mapping", mappings); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func setTenantRoles(c *client.V1Client, d *schema.ResourceData) error <span class="cov0" title="0">{
        tenantRoles, err := c.GetTeamTenantRoleAssociation(d.Id())
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">tenantRolesIDs := make([]string, 0)
        for _, role := range tenantRoles.Roles </span><span class="cov0" title="0">{
                tenantRolesIDs = append(tenantRolesIDs, role.UID)
        }</span>
        <span class="cov0" title="0">if err := d.Set("tenant_role_mapping", tenantRolesIDs); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func setWorkspaceRoles(c *client.V1Client, d *schema.ResourceData) error <span class="cov0" title="0">{
        workspaceRoles, err := c.GetTeamWorkspaceRoleAssociation(d.Id())
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if workspaceRoles != nil &amp;&amp; len(workspaceRoles.Projects) &gt; 0 </span><span class="cov0" title="0">{
                projects := make([]interface{}, 0)
                for _, project := range workspaceRoles.Projects </span><span class="cov0" title="0">{
                        projectMap := make(map[string]interface{})
                        workspaces := make([]interface{}, 0)
                        for _, workspace := range project.Workspaces </span><span class="cov0" title="0">{
                                workspaceMap := make(map[string]interface{})
                                roles := make([]string, 0)
                                for _, role := range workspace.Roles </span><span class="cov0" title="0">{
                                        roles = append(roles, role.UID)
                                }</span>
                                <span class="cov0" title="0">if len(roles) &gt; 0 </span><span class="cov0" title="0">{
                                        workspaceMap["id"] = workspace.UID
                                        workspaceMap["roles"] = roles
                                        workspaces = append(workspaces, workspaceMap)
                                }</span>
                        }
                        <span class="cov0" title="0">if len(workspaces) &gt; 0 </span><span class="cov0" title="0">{
                                projectMap["id"] = project.UID
                                projectMap["workspace"] = workspaces
                                projects = append(projects, projectMap)
                        }</span>
                }
                <span class="cov0" title="0">if err := d.Set("workspace_role_mapping", projects); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func resourceTeamUpdate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        c := getV1ClientWithResourceContext(m, "tenant")
        var diags diag.Diagnostics

        err := c.UpdateTeam(d.Id(), toTeam(d))
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        //associate roles with team
        <span class="cov0" title="0">err = c.AssociateTeamProjectRole(d.Id(), toTeamProjectRoleMapping(d))
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        //associate tenant roles with team
        <span class="cov0" title="0">err = c.AssociateTeamTenantRole(d.Id(), toTeamTenantRoleMapping(d))
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        //associate workspace roles with team
        <span class="cov0" title="0">err = c.AssociateTeamWorkspaceRole(d.Id(), toTeamWorkspaceRoleMapping(d))
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">return diags</span>
}

func resourceTeamDelete(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        c := getV1ClientWithResourceContext(m, "tenant")
        var diags diag.Diagnostics

        err := c.DeleteTeam(d.Id())
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">return diags</span>
}

func toTeam(d *schema.ResourceData) *models.V1Team <span class="cov0" title="0">{
        userIDs := make([]string, 0)

        if d.Get("users") != nil </span><span class="cov0" title="0">{
                for _, userID := range d.Get("users").(*schema.Set).List() </span><span class="cov0" title="0">{
                        userIDs = append(userIDs, userID.(string))
                }</span>
        }

        <span class="cov0" title="0">return &amp;models.V1Team{
                Metadata: &amp;models.V1ObjectMeta{
                        Name: d.Get("name").(string),
                        UID:  d.Id(),
                },
                Spec: &amp;models.V1TeamSpec{
                        Users: userIDs,
                },
        }</span>
}

func toTeamProjectRoleMapping(d *schema.ResourceData) *models.V1ProjectRolesPatch <span class="cov5" title="3">{
        projects := make([]*models.V1ProjectRolesPatchProjectsItems0, 0)
        projectRoleMappings := d.Get("project_role_mapping").(*schema.Set).List()
        for _, mapping := range projectRoleMappings </span><span class="cov5" title="3">{
                data := mapping.(map[string]interface{})

                roles := make([]string, 0)
                if data["roles"] != nil </span><span class="cov5" title="3">{
                        for _, role := range data["roles"].(*schema.Set).List() </span><span class="cov5" title="3">{
                                roles = append(roles, role.(string))
                        }</span>
                }

                <span class="cov5" title="3">projects = append(projects, &amp;models.V1ProjectRolesPatchProjectsItems0{
                        ProjectUID: data["id"].(string),
                        Roles:      roles,
                })</span>
        }

        <span class="cov5" title="3">return &amp;models.V1ProjectRolesPatch{
                Projects: projects,
        }</span>
}

func toTeamTenantRoleMapping(d *schema.ResourceData) *models.V1TeamTenantRolesUpdate <span class="cov0" title="0">{
        roles := make([]string, 0)
        if d.Get("tenant_role_mapping") != nil </span><span class="cov0" title="0">{
                for _, role := range d.Get("tenant_role_mapping").(*schema.Set).List() </span><span class="cov0" title="0">{
                        roles = append(roles, role.(string))
                }</span>
        }

        <span class="cov0" title="0">return &amp;models.V1TeamTenantRolesUpdate{
                Roles: roles,
        }</span>
}

func toTeamWorkspaceRoleMapping(d *schema.ResourceData) *models.V1WorkspacesRolesPatch <span class="cov0" title="0">{
        oldWS, newWS := d.GetChange("workspace_role_mapping")

        oldList := oldWS.(*schema.Set).List()
        newList := newWS.(*schema.Set).List()

        // Map keyed by "projectID::workspaceID"
        workspaceMap := make(map[string]*models.V1WorkspaceRolesPatch)
        seenNew := make(map[string]struct{})

        // Step 1: Process OLD config (initialize map)
        for _, mapping := range oldList </span><span class="cov0" title="0">{
                mappingData := mapping.(map[string]interface{})
                projectID := mappingData["id"].(string)

                for _, workspace := range mappingData["workspace"].(*schema.Set).List() </span><span class="cov0" title="0">{
                        workspaceData := workspace.(map[string]interface{})
                        workspaceID := workspaceData["id"].(string)
                        key := fmt.Sprintf("%s::%s", projectID, workspaceID)

                        workspaceMap[key] = &amp;models.V1WorkspaceRolesPatch{
                                UID:   workspaceID,
                                Roles: []string{}, // Assume removed unless new overrides
                        }
                }</span>
        }

        // Step 2: Process NEW config (override old or populate fresh)
        <span class="cov0" title="0">for _, mapping := range newList </span><span class="cov0" title="0">{
                mappingData := mapping.(map[string]interface{})
                projectID := mappingData["id"].(string)

                for _, workspace := range mappingData["workspace"].(*schema.Set).List() </span><span class="cov0" title="0">{
                        workspaceData := workspace.(map[string]interface{})
                        workspaceID := workspaceData["id"].(string)
                        key := fmt.Sprintf("%s::%s", projectID, workspaceID)
                        seenNew[key] = struct{}{}

                        roles := make([]string, 0)
                        if v, ok := workspaceData["roles"]; ok &amp;&amp; v != nil </span><span class="cov0" title="0">{
                                for _, role := range v.(*schema.Set).List() </span><span class="cov0" title="0">{
                                        roles = append(roles, role.(string))
                                }</span>
                        }

                        <span class="cov0" title="0">workspaceMap[key] = &amp;models.V1WorkspaceRolesPatch{
                                UID:   workspaceID,
                                Roles: roles,
                        }</span>
                }
        }

        // Step 3: Finalize list
        <span class="cov0" title="0">workspaces := make([]*models.V1WorkspaceRolesPatch, 0, len(workspaceMap))
        for _, w := range workspaceMap </span><span class="cov0" title="0">{
                workspaces = append(workspaces, w)
        }</span>

        <span class="cov0" title="0">return &amp;models.V1WorkspacesRolesPatch{
                Workspaces: workspaces,
        }</span>
}

func resourceProjectRoleMappingHash(v interface{}) int <span class="cov9" title="9">{
        var buf bytes.Buffer
        m := v.(map[string]interface{})

        // Sort the roles to ensure order does not affect the hash
        roles := make([]string, len(m["roles"].(*schema.Set).List()))
        for i, role := range m["roles"].(*schema.Set).List() </span><span class="cov10" title="11">{
                roles[i] = role.(string)
        }</span>
        <span class="cov9" title="9">sort.Strings(roles)

        buf.WriteString(fmt.Sprintf("%s-", m["id"].(string)))

        for _, role := range roles </span><span class="cov10" title="11">{
                buf.WriteString(fmt.Sprintf("%s-", role))
        }</span>

        <span class="cov9" title="9">return int(hash(buf.String()))</span>
}

func resourceWorkspaceRoleMappingHash(v interface{}) int <span class="cov0" title="0">{
        var buf bytes.Buffer
        m := v.(map[string]interface{})

        // Hash project id
        if v, ok := m["id"].(string); ok </span><span class="cov0" title="0">{
                h := schema.HashString(v)
                buf.WriteString(fmt.Sprintf("%d-", h))
        }</span>

        // Hash workspaces
        <span class="cov0" title="0">if v, ok := m["workspace"].(*schema.Set); ok </span><span class="cov0" title="0">{
                // Sort workspace hashes to ensure consistent ordering
                workspaces := v.List()
                hashes := make([]int, len(workspaces))
                for i, workspaceInterface := range workspaces </span><span class="cov0" title="0">{
                        workspace := workspaceInterface.(map[string]interface{})
                        hashes[i] = resourceProjectRoleMappingHash(workspace)
                }</span>
                <span class="cov0" title="0">sort.Ints(hashes)

                for _, h := range hashes </span><span class="cov0" title="0">{
                        buf.WriteString(fmt.Sprintf("%d-", h))
                }</span>
        }

        <span class="cov0" title="0">return int(hash(buf.String()))</span>
}
</pre>
		
		<pre class="file" id="file185" style="display: none">package spectrocloud

import (
        "context"
        "fmt"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
)

func resourceTeamImport(ctx context.Context, d *schema.ResourceData, m interface{}) ([]*schema.ResourceData, error) <span class="cov0" title="0">{
        c := getV1ClientWithResourceContext(m, "tenant")

        // The import ID should be the team UID
        teamUID := d.Id()

        // Validate that the team exists and we can access it
        team, err := c.GetTeam(teamUID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("could not retrieve team for import: %s", err)
        }</span>
        <span class="cov0" title="0">if team == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("team with ID %s not found", teamUID)
        }</span>

        // Set the team name from the retrieved team
        <span class="cov0" title="0">if err := d.Set("name", team.Metadata.Name); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Read all team data to populate the state
        <span class="cov0" title="0">diags := resourceTeamRead(ctx, d, m)
        if diags.HasError() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("could not read team for import: %v", diags)
        }</span>

        <span class="cov0" title="0">return []*schema.ResourceData{d}, nil</span>
}
</pre>
		
		<pre class="file" id="file186" style="display: none">package spectrocloud

import (
        "bytes"
        "context"
        "fmt"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
        "github.com/spectrocloud/palette-sdk-go/client"
        "regexp"
        "sort"
        "strings"
        "time"

        "github.com/spectrocloud/palette-sdk-go/api/models"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
)

func resourceUser() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                CreateContext: resourceUserCreate,
                ReadContext:   resourceUserRead,
                UpdateContext: resourceUserUpdate,
                DeleteContext: resourceUserDelete,
                Importer: &amp;schema.ResourceImporter{
                        StateContext: resourceUserImport,
                },

                Description: "Create and manage projects in Palette.",

                Timeouts: &amp;schema.ResourceTimeout{
                        Create: schema.DefaultTimeout(10 * time.Minute),
                        Update: schema.DefaultTimeout(10 * time.Minute),
                        Delete: schema.DefaultTimeout(10 * time.Minute),
                },

                SchemaVersion: 2,
                Schema: map[string]*schema.Schema{
                        "first_name": {
                                Type:        schema.TypeString,
                                Required:    true,
                                Description: "The first name of the user.",
                        },
                        "last_name": {
                                Type:        schema.TypeString,
                                Required:    true,
                                Description: "The last name of the user.",
                        },
                        "email": {
                                Type:     schema.TypeString,
                                Required: true,
                                ForceNew: true,
                                ValidateFunc: validation.StringMatch(
                                        regexp.MustCompile(`^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$`),
                                        "must be a valid email address",
                                ),
                                Description: "The email of the user.",
                        },
                        "team_ids": {
                                Type:        schema.TypeList,
                                Optional:    true,
                                ForceNew:    true,
                                Elem:        &amp;schema.Schema{Type: schema.TypeString},
                                Description: "The team id's assigned to the user.",
                        },
                        "project_role": {
                                Type:     schema.TypeSet,
                                Set:      resourceUserProjectRoleMappingHash,
                                Optional: true,
                                Elem: &amp;schema.Resource{
                                        Schema: map[string]*schema.Schema{
                                                "project_id": {
                                                        Type:        schema.TypeString,
                                                        Required:    true,
                                                        Description: "Project id to be associated with the user.",
                                                },
                                                "role_ids": {
                                                        Type:     schema.TypeSet,
                                                        Required: true,
                                                        Set:      schema.HashString,
                                                        Elem: &amp;schema.Schema{
                                                                Type: schema.TypeString,
                                                        },
                                                        Description: "List of project role ids to be associated with the user. ",
                                                },
                                        },
                                },
                                Description: "List of project roles to be associated with the user. ",
                        },
                        "tenant_role": {
                                Type:     schema.TypeSet,
                                Optional: true,
                                Set:      schema.HashString,
                                Elem: &amp;schema.Schema{
                                        Type: schema.TypeString,
                                },
                                Description: "List of tenant role ids to be associated with the user. ",
                        },
                        "workspace_role": {
                                Type:     schema.TypeSet,
                                Set:      resourceUserWorkspaceRoleMappingHash,
                                Optional: true,
                                Elem: &amp;schema.Resource{
                                        Schema: map[string]*schema.Schema{
                                                "project_id": {
                                                        Type:        schema.TypeString,
                                                        Required:    true,
                                                        Description: "Project id to be associated with the user.",
                                                },
                                                "workspace": {
                                                        Type:     schema.TypeSet,
                                                        Set:      resourceUserWorkspaceRoleMappingHashInternal,
                                                        Required: true,
                                                        Elem: &amp;schema.Resource{
                                                                Schema: map[string]*schema.Schema{
                                                                        "id": {
                                                                                Type:        schema.TypeString,
                                                                                Required:    true,
                                                                                Description: "Workspace id to be associated with the user.",
                                                                        },
                                                                        "role_ids": {
                                                                                Type:     schema.TypeSet,
                                                                                Set:      schema.HashString,
                                                                                Required: true,
                                                                                Elem: &amp;schema.Schema{
                                                                                        Type: schema.TypeString,
                                                                                },
                                                                                Description: "List of workspace role ids to be associated with the user.",
                                                                        },
                                                                },
                                                        },
                                                        Description: "List of workspace roles to be associated with the user. ",
                                                },
                                        },
                                },
                                Description: "List of workspace roles to be associated with the user. ",
                        },
                        "resource_role": {
                                Type:     schema.TypeSet,
                                Set:      resourceUserResourceRoleMappingHash,
                                Optional: true,
                                Elem: &amp;schema.Resource{
                                        Schema: map[string]*schema.Schema{
                                                "project_ids": {
                                                        Type:     schema.TypeSet,
                                                        Set:      schema.HashString,
                                                        Required: true,
                                                        Elem: &amp;schema.Schema{
                                                                Type: schema.TypeString,
                                                        },
                                                        Description: "Project id's to be associated with the user.",
                                                },
                                                "filter_ids": {
                                                        Type:     schema.TypeSet,
                                                        Set:      schema.HashString,
                                                        Required: true,
                                                        Elem: &amp;schema.Schema{
                                                                Type: schema.TypeString,
                                                        },
                                                        Description: "List of filter ids.",
                                                },
                                                "role_ids": {
                                                        Type:     schema.TypeSet,
                                                        Set:      schema.HashString,
                                                        Required: true,
                                                        Elem: &amp;schema.Schema{
                                                                Type: schema.TypeString,
                                                        },
                                                        Description: "List of resource role ids to be associated with the user.",
                                                },
                                        },
                                },
                        },
                },
        }
}</span>

func resourceUserCreate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        c := getV1ClientWithResourceContext(m, "tenant")
        var diags diag.Diagnostics
        user := toUser(d)
        uid, err := c.CreateUser(user)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">d.SetId(uid)
        //creating roles
        if pRoles, ok := d.GetOk("project_role"); ok &amp;&amp; pRoles != nil </span><span class="cov0" title="0">{
                projectRole := toUserProjectRoleMapping(d)
                err := c.AssociateUserProjectRole(uid, projectRole)
                if err != nil </span><span class="cov0" title="0">{
                        _ = c.DeleteUser(uid)
                        return diag.FromErr(err)
                }</span>
        }

        <span class="cov0" title="0">if rRoles, ok := d.GetOk("tenant_role"); ok &amp;&amp; rRoles != nil </span><span class="cov0" title="0">{
                tenantRole := toUserTenantRoleMapping(d)
                err := c.AssociateUserTenantRole(uid, tenantRole)
                if err != nil </span><span class="cov0" title="0">{
                        _ = c.DeleteUser(uid)
                        return diag.FromErr(err)
                }</span>
        }

        <span class="cov0" title="0">if wRoles, ok := d.GetOk("workspace_role"); ok &amp;&amp; wRoles != nil </span><span class="cov0" title="0">{
                workspaceRole := toUserWorkspaceRoleMapping(d)
                err := c.AssociateUserWorkspaceRole(uid, workspaceRole)
                if err != nil </span><span class="cov0" title="0">{
                        _ = c.DeleteUser(uid)
                        return diag.FromErr(err)
                }</span>
        }

        <span class="cov0" title="0">if rRoles, ok := d.GetOk("resource_role"); ok &amp;&amp; rRoles != nil </span><span class="cov0" title="0">{
                resourceRoles := toUserResourceRoleMapping(d)
                for _, role := range resourceRoles </span><span class="cov0" title="0">{
                        err := c.CreateUserResourceRole(uid, role)
                        if err != nil </span><span class="cov0" title="0">{
                                _ = c.DeleteUser(uid)
                                return diag.FromErr(err)
                        }</span>
                }
        }

        <span class="cov0" title="0">return diags</span>
}

func resourceUserRead(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        c := getV1ClientWithResourceContext(m, "tenant")
        var diags diag.Diagnostics

        email := d.Get("email").(string)
        user, err := c.GetUserSummaryByEmail(email)
        if err != nil </span><span class="cov0" title="0">{
                if strings.Contains(err.Error(), "user not found for email") </span><span class="cov0" title="0">{
                        d.SetId("")
                        return diags
                }</span> else<span class="cov0" title="0"> {
                        return diag.FromErr(err)
                }</span>
        } else<span class="cov0" title="0"> if user == nil </span><span class="cov0" title="0">{
                // Deleted - Terraform will recreate it
                d.SetId("")
                return diags
        }</span>
        <span class="cov0" title="0">err = flattenUser(user, d, c)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">return diags</span>
}

func resourceUserUpdate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        c := getV1ClientWithResourceContext(m, "tenant")
        uid := d.Id()
        var diags diag.Diagnostics

        if d.HasChanges("project_role") </span><span class="cov0" title="0">{
                ops, _ := d.GetChange("project_role")
                if len(ops.(*schema.Set).List()) &gt; 0 </span><span class="cov0" title="0">{
                        _ = deleteProjectResourceRoles(c, ops, uid)
                }</span>
                <span class="cov0" title="0">projectRole := toUserProjectRoleMapping(d)
                if projectRole != nil </span><span class="cov0" title="0">{
                        err := c.AssociateUserProjectRole(uid, projectRole)
                        if err != nil </span><span class="cov0" title="0">{
                                return diag.FromErr(err)
                        }</span>
                }
        }
        <span class="cov0" title="0">if d.HasChanges("tenant_role") </span><span class="cov0" title="0">{
                tenantRole := toUserTenantRoleMapping(d)
                err := c.AssociateUserTenantRole(uid, tenantRole)
                if err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
        }
        <span class="cov0" title="0">if d.HasChanges("workspace_role") </span><span class="cov0" title="0">{
                ows, _ := d.GetChange("workspace_role")
                if len(ows.(*schema.Set).List()) &gt; 0 </span><span class="cov0" title="0">{
                        _ = deleteWorkspaceResourceRoles(c, ows, uid)
                }</span>
                <span class="cov0" title="0">workspaceRole := toUserWorkspaceRoleMapping(d)
                if len(workspaceRole.Workspaces) &gt; 0 </span><span class="cov0" title="0">{
                        err := c.AssociateUserWorkspaceRole(uid, workspaceRole)
                        if err != nil </span><span class="cov0" title="0">{
                                return diag.FromErr(err)
                        }</span>
                }
        }
        <span class="cov0" title="0">if d.HasChanges("resource_role") </span><span class="cov0" title="0">{
                err := deleteUserResourceRoles(c, uid)
                if err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
                <span class="cov0" title="0">resourceRoles := toUserResourceRoleMapping(d)
                for _, role := range resourceRoles </span><span class="cov0" title="0">{
                        err := c.CreateUserResourceRole(uid, role)
                        if err != nil </span><span class="cov0" title="0">{
                                return diag.FromErr(err)
                        }</span>
                }
        }

        <span class="cov0" title="0">return diags</span>
}

func resourceUserDelete(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        c := getV1ClientWithResourceContext(m, "tenant")
        var diags diag.Diagnostics

        err := c.DeleteUser(d.Id())
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">return diags</span>
}

func toUserResourceRoleMapping(d *schema.ResourceData) []*models.V1ResourceRolesUpdateEntity <span class="cov0" title="0">{
        if resourceRoles, ok := d.GetOk("resource_role"); ok &amp;&amp; resourceRoles != nil </span><span class="cov0" title="0">{
                resourceRoleEntities := make([]*models.V1ResourceRolesUpdateEntity, 0)
                for _, re := range d.Get("resource_role").(*schema.Set).List() </span><span class="cov0" title="0">{
                        resourceEntity := &amp;models.V1ResourceRolesUpdateEntity{
                                FilterRefs:  setToStringArray(re.(map[string]interface{})["filter_ids"]),
                                ProjectUids: setToStringArray(re.(map[string]interface{})["project_ids"]),
                                Roles:       setToStringArray(re.(map[string]interface{})["role_ids"]),
                        }
                        resourceRoleEntities = append(resourceRoleEntities, resourceEntity)
                }</span>
                <span class="cov0" title="0">return resourceRoleEntities</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func toUserProjectRoleMapping(d *schema.ResourceData) *models.V1ProjectRolesPatch <span class="cov0" title="0">{
        if projectRoles, ok := d.GetOk("project_role"); ok &amp;&amp; projectRoles != nil </span><span class="cov0" title="0">{
                //var role *models.V1ProjectRolesPatch
                var projects []*models.V1ProjectRolesPatchProjectsItems0
                for _, r := range projectRoles.(*schema.Set).List() </span><span class="cov0" title="0">{
                        projects = append(projects, &amp;models.V1ProjectRolesPatchProjectsItems0{
                                ProjectUID: r.(map[string]interface{})["project_id"].(string),
                                Roles:      setToStringArray(r.(map[string]interface{})["role_ids"]),
                        })
                }</span>
                <span class="cov0" title="0">return &amp;models.V1ProjectRolesPatch{
                        Projects: projects,
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func toUserTenantRoleMapping(d *schema.ResourceData) *models.V1UserRoleUIDs <span class="cov0" title="0">{
        roles := make([]string, 0)
        if d.Get("tenant_role") != nil </span><span class="cov0" title="0">{
                for _, role := range d.Get("tenant_role").(*schema.Set).List() </span><span class="cov0" title="0">{
                        roles = append(roles, role.(string))
                }</span>
        }

        <span class="cov0" title="0">return &amp;models.V1UserRoleUIDs{
                Roles: roles,
        }</span>
}

func toUserWorkspaceRoleMapping(d *schema.ResourceData) *models.V1WorkspacesRolesPatch <span class="cov0" title="0">{
        workspaces := make([]*models.V1WorkspaceRolesPatch, 0)
        workspaceRoleMappings := d.Get("workspace_role").(*schema.Set).List()

        for _, mapping := range workspaceRoleMappings </span><span class="cov0" title="0">{
                data := mapping.(map[string]interface{})

                for _, workspace := range data["workspace"].(*schema.Set).List() </span><span class="cov0" title="0">{
                        workspaceData := workspace.(map[string]interface{})
                        roles := make([]string, 0)
                        if workspaceData["role_ids"] != nil </span><span class="cov0" title="0">{
                                for _, role := range workspaceData["role_ids"].(*schema.Set).List() </span><span class="cov0" title="0">{
                                        roles = append(roles, role.(string))
                                }</span>
                        }
                        <span class="cov0" title="0">workspaces = append(workspaces, &amp;models.V1WorkspaceRolesPatch{
                                UID:   workspaceData["id"].(string),
                                Roles: roles,
                        })</span>
                }
        }

        <span class="cov0" title="0">return &amp;models.V1WorkspacesRolesPatch{
                Workspaces: workspaces,
        }</span>
}

func setToStringArray(ids interface{}) []string <span class="cov0" title="0">{
        idList := make([]string, 0)
        for _, id := range ids.(*schema.Set).List() </span><span class="cov0" title="0">{
                idList = append(idList, id.(string))
        }</span>
        <span class="cov0" title="0">return idList</span>
}

func deleteWorkspaceResourceRoles(c *client.V1Client, oldWs interface{}, userUID string) error <span class="cov0" title="0">{
        oldWorkspaces := oldWs.(*schema.Set).List()
        for _, p := range oldWorkspaces </span><span class="cov0" title="0">{
                inWS := make([]*models.V1WorkspaceRolesPatch, 0)
                for _, ws := range p.(map[string]interface{})["workspace"].(*schema.Set).List() </span><span class="cov0" title="0">{
                        inWS = append(inWS, &amp;models.V1WorkspaceRolesPatch{
                                Roles: []string{},
                                UID:   ws.(map[string]interface{})["id"].(string),
                        })
                }</span>
                <span class="cov0" title="0">deleteWS := &amp;models.V1WorkspacesRolesPatch{
                        Workspaces: inWS,
                }
                _ = c.AssociateUserWorkspaceRole(userUID, deleteWS)</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func deleteProjectResourceRoles(c *client.V1Client, oldPs interface{}, userUID string) error <span class="cov0" title="0">{
        oldProjectRoles := oldPs.(*schema.Set).List()

        for _, p := range oldProjectRoles </span><span class="cov0" title="0">{
                deletePR := &amp;models.V1ProjectRolesPatch{
                        Projects: []*models.V1ProjectRolesPatchProjectsItems0{
                                {
                                        ProjectUID: p.(map[string]interface{})["project_id"].(string),
                                        Roles:      []string{},
                                },
                        },
                }
                _ = c.AssociateUserProjectRole(userUID, deletePR)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func deleteUserResourceRoles(c *client.V1Client, userUID string) error <span class="cov0" title="0">{
        resourceRoles, _ := c.GetUserResourceRoles(userUID)
        for _, re := range resourceRoles </span><span class="cov0" title="0">{
                err := c.DeleteUserResourceRoles(userUID, re.UID)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func flattenUser(user *models.V1UserSummary, d *schema.ResourceData, c *client.V1Client) error <span class="cov0" title="0">{
        if user != nil </span><span class="cov0" title="0">{
                if err := d.Set("first_name", user.Spec.FirstName); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if err := d.Set("last_name", user.Spec.LastName); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if err := d.Set("email", user.Spec.EmailID); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">if user.Spec.Teams != nil </span><span class="cov0" title="0">{
                        var teamIds []string
                        for _, team := range user.Spec.Teams </span><span class="cov0" title="0">{
                                teamIds = append(teamIds, team.UID)
                        }</span>
                        <span class="cov0" title="0">if err := d.Set("team_ids", teamIds); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
                <span class="cov0" title="0">if err := flattenUserProjectRoleMapping(d, c); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if err := flattenUserTenantRoleMapping(d, c); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if err := flattenUserWorkspaceRoleMapping(d, c); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if err := flattenUserResourceRoleMapping(d, c); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func flattenUserResourceRoleMapping(d *schema.ResourceData, c *client.V1Client) error <span class="cov0" title="0">{
        userUID := d.Id()
        resourceRoles, err := c.GetUserResourceRoles(userUID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">rRoles := make([]interface{}, 0)
        for _, rr := range resourceRoles </span><span class="cov0" title="0">{
                rRoles = append(rRoles, map[string]interface{}{
                        "project_ids": convertSummaryToIDS(rr.ProjectUids),
                        "filter_ids":  convertSummaryToIDS(rr.FilterRefs),
                        "role_ids":    convertSummaryToIDS(rr.Roles),
                })
        }</span>
        <span class="cov0" title="0">if err := d.Set("resource_role", rRoles); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func flattenUserWorkspaceRoleMapping(d *schema.ResourceData, c *client.V1Client) error <span class="cov0" title="0">{
        userUID := d.Id()
        workspaceRoles, err := c.GetUserWorkspaceRole(userUID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">wRoles := make([]interface{}, 0)
        for _, w := range workspaceRoles.Projects </span><span class="cov0" title="0">{
                wsRoles := make([]interface{}, 0)
                for _, wr := range w.Workspaces </span><span class="cov0" title="0">{
                        wsIDS := make([]string, 0)
                        for _, ri := range wr.Roles </span><span class="cov0" title="0">{
                                wsIDS = append(wsIDS, ri.UID)
                        }</span>
                        <span class="cov0" title="0">wsRoles = append(wsRoles, map[string]interface{}{
                                "id":       wr.UID,
                                "role_ids": wsIDS,
                        })</span>
                }
                <span class="cov0" title="0">wRoles = append(wRoles, map[interface{}]interface{}{
                        "project_id": w.UID,
                        "workspace":  wsRoles,
                })</span>
        }
        <span class="cov0" title="0">if err := d.Set("workspace_role", wRoles); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func flattenUserTenantRoleMapping(d *schema.ResourceData, c *client.V1Client) error <span class="cov0" title="0">{
        userUID := d.Id()
        tenantRoles, err := c.GetUserTenantRole(userUID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">var tRoles []string
        for _, t := range tenantRoles.Roles </span><span class="cov0" title="0">{
                tRoles = append(tRoles, t.UID)
        }</span>
        <span class="cov0" title="0">if err := d.Set("tenant_role", tRoles); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func flattenUserProjectRoleMapping(d *schema.ResourceData, c *client.V1Client) error <span class="cov0" title="0">{
        userUID := d.Id()
        projectRoles, err := c.GetUserProjectRole(userUID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">pRoles := make([]interface{}, 0)
        for _, p := range projectRoles.Projects </span><span class="cov0" title="0">{
                if len(p.Roles) &gt; 0 </span><span class="cov0" title="0">{
                        roles := make([]string, 0)
                        for _, r := range p.Roles </span><span class="cov0" title="0">{
                                roles = append(roles, r.UID)
                        }</span>
                        <span class="cov0" title="0">pRoles = append(pRoles, map[string]interface{}{
                                "project_id": p.UID,
                                "role_ids":   roles,
                        })</span>
                }
        }
        <span class="cov0" title="0">if err := d.Set("project_role", pRoles); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func toUser(d *schema.ResourceData) *models.V1UserEntity <span class="cov0" title="0">{
        fName := d.Get("first_name").(string)
        lName := d.Get("last_name").(string)
        user := &amp;models.V1UserEntity{
                Metadata: &amp;models.V1ObjectMeta{
                        Name: fName + " " + lName,
                },
                Spec: &amp;models.V1UserSpecEntity{
                        EmailID:   d.Get("email").(string),
                        FirstName: fName,
                        LastName:  lName,
                },
        }
        if teams, ok := d.GetOk("team_ids"); ok &amp;&amp; teams != nil </span><span class="cov0" title="0">{
                user.Spec.Teams = convertToStrings(teams.([]interface{}))
        }</span>
        <span class="cov0" title="0">return user</span>
}

func convertToStrings(input []interface{}) []string <span class="cov0" title="0">{
        var output []string
        for _, v := range input </span><span class="cov0" title="0">{
                if str, ok := v.(string); ok </span><span class="cov0" title="0">{
                        output = append(output, str)
                }</span>
        }
        <span class="cov0" title="0">return output</span>
}

func convertSummaryToIDS(sum []*models.V1UIDSummary) []string <span class="cov0" title="0">{
        var out []string
        for _, v := range sum </span><span class="cov0" title="0">{
                out = append(out, v.UID)
        }</span>
        <span class="cov0" title="0">return out</span>
}

func resourceUserResourceRoleMappingHash(i interface{}) int <span class="cov0" title="0">{
        var buf bytes.Buffer
        m := i.(map[string]interface{})

        // Sort the roles to ensure order does not affect the hash
        pids := make([]string, len(m["project_ids"].(*schema.Set).List()))
        for i, pid := range m["project_ids"].(*schema.Set).List() </span><span class="cov0" title="0">{
                pids[i] = pid.(string)
        }</span>
        <span class="cov0" title="0">sort.Strings(pids)

        fids := make([]string, len(m["filter_ids"].(*schema.Set).List()))
        for i, fid := range m["filter_ids"].(*schema.Set).List() </span><span class="cov0" title="0">{
                fids[i] = fid.(string)
        }</span>
        <span class="cov0" title="0">sort.Strings(fids)

        rids := make([]string, len(m["role_ids"].(*schema.Set).List()))
        for i, rid := range m["role_ids"].(*schema.Set).List() </span><span class="cov0" title="0">{
                rids[i] = rid.(string)
        }</span>
        <span class="cov0" title="0">sort.Strings(rids)

        //buf.WriteString(fmt.Sprintf("%s-", m["project_id"].(string)))

        for _, id := range pids </span><span class="cov0" title="0">{
                buf.WriteString(fmt.Sprintf("%s-", id))
        }</span>
        <span class="cov0" title="0">for _, id := range fids </span><span class="cov0" title="0">{
                buf.WriteString(fmt.Sprintf("%s-", id))
        }</span>
        <span class="cov0" title="0">for _, id := range rids </span><span class="cov0" title="0">{
                buf.WriteString(fmt.Sprintf("%s-", id))
        }</span>

        <span class="cov0" title="0">return int(hash(buf.String()))</span>
}

func resourceUserWorkspaceRoleMappingHash(i interface{}) int <span class="cov0" title="0">{
        var buf bytes.Buffer
        m := i.(map[string]interface{})

        // Hash project id
        if v, ok := m["project_id"].(string); ok </span><span class="cov0" title="0">{
                h := schema.HashString(v)
                buf.WriteString(fmt.Sprintf("%d-", h))
        }</span>

        // Hash workspaces
        <span class="cov0" title="0">if v, ok := m["workspace"].(*schema.Set); ok </span><span class="cov0" title="0">{
                // Sort workspace hashes to ensure consistent ordering
                workspaces := v.List()
                hashes := make([]int, len(workspaces))
                for i, workspaceInterface := range workspaces </span><span class="cov0" title="0">{
                        workspace := workspaceInterface.(map[string]interface{})
                        hashes[i] = resourceUserWorkspaceRoleMappingHashInternal(workspace)
                }</span>
                <span class="cov0" title="0">sort.Ints(hashes)

                for _, h := range hashes </span><span class="cov0" title="0">{
                        buf.WriteString(fmt.Sprintf("%d-", h))
                }</span>
        }

        <span class="cov0" title="0">return int(hash(buf.String()))</span>
}

func resourceUserWorkspaceRoleMappingHashInternal(workspace interface{}) int <span class="cov0" title="0">{
        var buf bytes.Buffer
        m := workspace.(map[string]interface{})
        // Sort the roles to ensure order does not affect the hash
        roles := make([]string, len(m["role_ids"].(*schema.Set).List()))
        for i, role := range m["role_ids"].(*schema.Set).List() </span><span class="cov0" title="0">{
                roles[i] = role.(string)
        }</span>
        <span class="cov0" title="0">sort.Strings(roles)

        buf.WriteString(fmt.Sprintf("%s-", m["id"].(string)))

        for _, role := range roles </span><span class="cov0" title="0">{
                buf.WriteString(fmt.Sprintf("%s-", role))
        }</span>

        <span class="cov0" title="0">return int(hash(buf.String()))</span>
}

func resourceUserProjectRoleMappingHash(i interface{}) int <span class="cov0" title="0">{
        var buf bytes.Buffer
        m := i.(map[string]interface{})

        // Sort the roles to ensure order does not affect the hash
        roles := make([]string, len(m["role_ids"].(*schema.Set).List()))
        for i, role := range m["role_ids"].(*schema.Set).List() </span><span class="cov0" title="0">{
                roles[i] = role.(string)
        }</span>
        <span class="cov0" title="0">sort.Strings(roles)

        buf.WriteString(fmt.Sprintf("%s-", m["project_id"].(string)))

        for _, role := range roles </span><span class="cov0" title="0">{
                buf.WriteString(fmt.Sprintf("%s-", role))
        }</span>

        <span class="cov0" title="0">return int(hash(buf.String()))</span>
}
</pre>
		
		<pre class="file" id="file187" style="display: none">package spectrocloud

import (
        "context"
        "fmt"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
)

func resourceUserImport(ctx context.Context, d *schema.ResourceData, m interface{}) ([]*schema.ResourceData, error) <span class="cov0" title="0">{
        c := getV1ClientWithResourceContext(m, "tenant")
        user, err := c.GetUserByID(d.Id())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">err = d.Set("email", user.Spec.EmailID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">diags := resourceUserRead(ctx, d, m)
        if diags.HasError() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("could not read user for import: %v", diags)
        }</span>
        <span class="cov0" title="0">return []*schema.ResourceData{d}, nil</span>
}
</pre>
		
		<pre class="file" id="file188" style="display: none">package spectrocloud

import (
        "context"
        "errors"
        "fmt"
        "log"
        "strings"

        "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/spectrocloud/palette-sdk-go/api/models"
        "github.com/spectrocloud/palette-sdk-go/client"

        "github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/schemas"
)

func resourceWorkspace() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                CreateContext: resourceWorkspaceCreate,
                ReadContext:   resourceWorkspaceRead,
                UpdateContext: resourceWorkspaceUpdate,
                DeleteContext: resourceWorkspaceDelete,

                SchemaVersion: 3,
                StateUpgraders: []schema.StateUpgrader{
                        {
                                Type:    resourceWorkspaceResourceV2().CoreConfigSchema().ImpliedType(),
                                Upgrade: resourceWorkspaceStateUpgradeV2,
                                Version: 2,
                        },
                },
                Importer: &amp;schema.ResourceImporter{
                        StateContext: resourceWorkspaceImport,
                },
                Schema: map[string]*schema.Schema{
                        "name": {
                                Type:     schema.TypeString,
                                Required: true,
                        },
                        "tags": {
                                Type:     schema.TypeSet,
                                Optional: true,
                                Set:      schema.HashString,
                                Elem: &amp;schema.Schema{
                                        Type: schema.TypeString,
                                },
                        },
                        "description": {
                                Type:     schema.TypeString,
                                Optional: true,
                        },
                        "workspace_quota": {
                                Type:        schema.TypeList,
                                Optional:    true,
                                MaxItems:    1,
                                Description: "Workspace quota default limits assigned to the namespace.",
                                Elem: &amp;schema.Resource{
                                        Schema: map[string]*schema.Schema{
                                                "cpu": {
                                                        Type:        schema.TypeInt,
                                                        Optional:    true,
                                                        Description: "CPU that the entire workspace is allowed to consume. The default value is 0, which imposes no limit.",
                                                },
                                                "memory": {
                                                        Type:        schema.TypeInt,
                                                        Optional:    true,
                                                        Description: "Memory in Mib that the entire workspace is allowed to consume. The default value is 0, which imposes no limit.",
                                                },
                                                "gpu": {
                                                        Type:        schema.TypeInt,
                                                        Optional:    true,
                                                        Description: "GPU that the entire workspace is allowed to consume. The default value is 0, which imposes no limit.",
                                                },
                                        },
                                },
                        },
                        "clusters": {
                                Type:     schema.TypeSet,
                                Required: true,
                                Set:      resourceClusterHash,
                                Elem: &amp;schema.Resource{
                                        Schema: map[string]*schema.Schema{
                                                "uid": {
                                                        Type:     schema.TypeString,
                                                        Required: true,
                                                },
                                                "cluster_name": {
                                                        Type:     schema.TypeString,
                                                        Computed: true,
                                                },
                                        },
                                },
                        },
                        "backup_policy":        schemas.BackupPolicySchema(),
                        "cluster_rbac_binding": schemas.ClusterRbacBindingSchema(),
                        "namespaces":           schemas.WorkspaceNamespacesSchema(),
                },
        }
}</span>

func resourceWorkspaceCreate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        c := getV1ClientWithResourceContext(m, "")

        var diags diag.Diagnostics

        workspace, err := toWorkspace(d, c)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">uid, err := c.CreateWorkspace(workspace)
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">d.SetId(uid)

        resourceWorkspaceRead(ctx, d, m)

        return diags</span>
}

func resourceWorkspaceRead(_ context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        c := getV1ClientWithResourceContext(m, "")

        var diags diag.Diagnostics

        uid := d.Id()

        workspace, err := c.GetWorkspace(uid)
        if err != nil </span><span class="cov0" title="0">{
                return handleReadError(d, err, diags)
        }</span> else<span class="cov0" title="0"> if workspace == nil </span><span class="cov0" title="0">{
                d.SetId("")
                return diags
        }</span>

        <span class="cov0" title="0">wsQuota := flattenWorkspaceQuota(workspace)
        if err := d.Set("workspace_quota", wsQuota); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">fp := flattenWorkspaceClusters(workspace, c)
        if err := d.Set("clusters", fp); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">backup, err := c.GetWorkspaceBackup(uid)
        if err != nil &amp;&amp; !strings.Contains(err.Error(), "Backup not configured") </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>
        <span class="cov0" title="0">if backup != nil </span><span class="cov0" title="0">{
                if err := d.Set("backup_policy", flattenWorkspaceBackupPolicy(backup, d)); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
        }

        <span class="cov0" title="0">if err := d.Set("cluster_rbac_binding", flattenClusterRBAC(workspace.Spec.ClusterRbacs)); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">if err := d.Set("namespaces", flattenWorkspaceClusterNamespaces(workspace.Spec.ClusterNamespaces)); err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">return diags</span>
}

func flattenWorkspaceQuota(workspace *models.V1Workspace) []interface{} <span class="cov0" title="0">{
        wsq := make([]interface{}, 0)
        if workspace.Spec.Quota.ResourceAllocation != nil </span><span class="cov0" title="0">{
                quota := map[string]interface{}{
                        "cpu":    workspace.Spec.Quota.ResourceAllocation.CPUCores,
                        "memory": workspace.Spec.Quota.ResourceAllocation.MemoryMiB,
                }

                // Handle GPU configuration if present
                if workspace.Spec.Quota.ResourceAllocation.GpuConfig != nil </span><span class="cov0" title="0">{
                        quota["gpu"] = int(workspace.Spec.Quota.ResourceAllocation.GpuConfig.Limit)
                }</span> else<span class="cov0" title="0"> {
                        quota["gpu"] = 0
                }</span>

                <span class="cov0" title="0">wsq = append(wsq, quota)</span>
        }
        <span class="cov0" title="0">return wsq</span>
}

func resourceWorkspaceUpdate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        c := getV1ClientWithResourceContext(m, "")

        var diags diag.Diagnostics

        workspace, err := c.GetWorkspace(d.Id())
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">if d.HasChange("description") || d.HasChange("tags") </span><span class="cov0" title="0">{
                annotations := make(map[string]string)
                if len(d.Get("description").(string)) &gt; 0 </span><span class="cov0" title="0">{
                        annotations["description"] = d.Get("description").(string)
                }</span>
                <span class="cov0" title="0">meta := &amp;models.V1ObjectMeta{
                        Name:        d.Get("name").(string),
                        UID:         d.Id(),
                        Labels:      toTags(d),
                        Annotations: annotations,
                }
                if err := c.UpdateWorkspaceMetadata(workspace.Metadata.UID, meta); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
        }

        <span class="cov0" title="0">if d.HasChange("clusters") || d.HasChange("workspace_quota") </span><span class="cov0" title="0">{
                // resource allocation should go first because clusters are inside.
                namespaces, err := toUpdateWorkspaceNamespaces(d, c)
                if err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
                <span class="cov0" title="0">if err := c.UpdateWorkspaceResourceAllocation(d.Id(), namespaces); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err)
                }</span>
                <span class="cov0" title="0">diagnostics, done := updateWorkspaceRBACs(d, c, workspace)
                if done </span><span class="cov0" title="0">{
                        return diagnostics
                }</span>
        } else<span class="cov0" title="0"> {
                if d.HasChange("cluster_rbac_binding") </span><span class="cov0" title="0">{
                        diagnostics, done := updateWorkspaceRBACs(d, c, workspace)
                        if done </span><span class="cov0" title="0">{
                                return diagnostics
                        }</span>
                }
                <span class="cov0" title="0">if d.HasChange("namespaces") </span><span class="cov0" title="0">{
                        namespaces, err := toUpdateWorkspaceNamespaces(d, c)
                        if err != nil </span><span class="cov0" title="0">{
                                return diag.FromErr(err)
                        }</span>
                        <span class="cov0" title="0">if err := c.UpdateWorkspaceResourceAllocation(d.Id(), namespaces); err != nil </span><span class="cov0" title="0">{
                                return diag.FromErr(err)
                        }</span>
                }
        }

        <span class="cov0" title="0">if d.HasChange("backup_policy") </span><span class="cov0" title="0">{
                oldBackup, newBackup := d.GetChange("backup_policy")
                if len(d.Get("backup_policy").([]interface{})) == 0 </span><span class="cov0" title="0">{
                        if len(newBackup.([]interface{})) == 0 </span><span class="cov0" title="0">{
                                return diag.FromErr(errors.New("backup configuration cannot be removed, but the schedule can be disabled"))
                        }</span>
                } else<span class="cov0" title="0"> if len(newBackup.([]interface{})) &gt; len(oldBackup.([]interface{})) </span><span class="cov0" title="0">{
                        if err := createWorkspaceBackupPolicy(c, d); err != nil </span><span class="cov0" title="0">{
                                return diag.FromErr(err)
                        }</span>
                } else<span class="cov0" title="0"> {
                        if err := updateWorkspaceBackupPolicy(c, d); err != nil </span><span class="cov0" title="0">{
                                return diag.FromErr(err)
                        }</span>
                }
        }

        <span class="cov0" title="0">resourceWorkspaceRead(ctx, d, m)

        return diags</span>
}

func updateWorkspaceRBACs(d *schema.ResourceData, c *client.V1Client, workspace *models.V1Workspace) (diag.Diagnostics, bool) <span class="cov0" title="0">{
        rbacs := toWorkspaceRBACs(d)
        for id, rbac := range rbacs </span><span class="cov0" title="0">{
                if err := c.UpdateWorkspaceRBACS(d.Id(), workspace.Spec.ClusterRbacs[id].Metadata.UID, rbac); err != nil </span><span class="cov0" title="0">{
                        return diag.FromErr(err), true
                }</span>
        }
        <span class="cov0" title="0">return nil, false</span>
}

func resourceWorkspaceDelete(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics <span class="cov0" title="0">{
        c := getV1ClientWithResourceContext(m, "")
        var diags diag.Diagnostics
        err := c.DeleteWorkspace(d.Id())
        if err != nil </span><span class="cov0" title="0">{
                return diag.FromErr(err)
        }</span>

        <span class="cov0" title="0">return diags</span>
}

func toWorkspace(d *schema.ResourceData, c *client.V1Client) (*models.V1WorkspaceEntity, error) <span class="cov0" title="0">{
        annotations := make(map[string]string)
        if len(d.Get("description").(string)) &gt; 0 </span><span class="cov0" title="0">{
                annotations["description"] = d.Get("description").(string)
        }</span>

        <span class="cov0" title="0">quota, err := toQuota(d)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">workspace := &amp;models.V1WorkspaceEntity{
                Metadata: &amp;models.V1ObjectMeta{
                        Name:        d.Get("name").(string),
                        UID:         d.Id(),
                        Labels:      toTags(d),
                        Annotations: annotations,
                },
                Spec: &amp;models.V1WorkspaceSpec{
                        ClusterNamespaces: toWorkspaceNamespaces(d),
                        ClusterRbacs:      toWorkspaceRBACs(d),
                        ClusterRefs:       toClusterRefs(d, c),
                        Policies:          toWorkspacePolicies(d),
                        Quota:             quota,
                },
        }

        return workspace, nil</span>
}

func resourceWorkspaceImport(ctx context.Context, d *schema.ResourceData, m interface{}) ([]*schema.ResourceData, error) <span class="cov0" title="0">{
        c := getV1ClientWithResourceContext(m, "")

        // The import ID should be the workspace UID
        workspaceUID := d.Id()

        // Validate that the workspace exists and we can access it
        workspace, err := c.GetWorkspace(workspaceUID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("could not retrieve workspace for import: %s", err)
        }</span>
        <span class="cov0" title="0">if workspace == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("workspace with ID %s not found", workspaceUID)
        }</span>

        // Set the workspace name from the retrieved workspace
        <span class="cov0" title="0">if err := d.Set("name", workspace.Metadata.Name); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Read all workspace data to populate the state
        <span class="cov0" title="0">diags := resourceWorkspaceRead(ctx, d, m)
        if diags.HasError() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("could not read workspace for import: %v", diags)
        }</span>

        <span class="cov0" title="0">return []*schema.ResourceData{d}, nil</span>
}

// resourceWorkspaceResourceV2 returns the schema for version 2 of the resource
// This represents the old schema where "namespaces" was TypeList
func resourceWorkspaceResourceV2() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                Schema: map[string]*schema.Schema{
                        "name": {
                                Type:     schema.TypeString,
                                Required: true,
                        },
                        "tags": {
                                Type:     schema.TypeSet,
                                Optional: true,
                                Set:      schema.HashString,
                                Elem: &amp;schema.Schema{
                                        Type: schema.TypeString,
                                },
                        },
                        "description": {
                                Type:     schema.TypeString,
                                Optional: true,
                        },
                        "workspace_quota": {
                                Type:        schema.TypeList,
                                Optional:    true,
                                MaxItems:    1,
                                Description: "Workspace quota default limits assigned to the namespace.",
                                Elem: &amp;schema.Resource{
                                        Schema: map[string]*schema.Schema{
                                                "cpu": {
                                                        Type:        schema.TypeInt,
                                                        Optional:    true,
                                                        Description: "CPU that the entire workspace is allowed to consume. The default value is 0, which imposes no limit.",
                                                },
                                                "memory": {
                                                        Type:        schema.TypeInt,
                                                        Optional:    true,
                                                        Description: "Memory in Mib that the entire workspace is allowed to consume. The default value is 0, which imposes no limit.",
                                                },
                                                "gpu": {
                                                        Type:        schema.TypeInt,
                                                        Optional:    true,
                                                        Description: "GPU that the entire workspace is allowed to consume. The default value is 0, which imposes no limit.",
                                                },
                                        },
                                },
                        },
                        "clusters": {
                                Type:     schema.TypeSet,
                                Required: true,
                                Set:      resourceClusterHash,
                                Elem: &amp;schema.Resource{
                                        Schema: map[string]*schema.Schema{
                                                "uid": {
                                                        Type:     schema.TypeString,
                                                        Required: true,
                                                },
                                                "cluster_name": {
                                                        Type:     schema.TypeString,
                                                        Computed: true,
                                                },
                                        },
                                },
                        },
                        "backup_policy":        schemas.BackupPolicySchema(),
                        "cluster_rbac_binding": schemas.ClusterRbacBindingSchema(),
                        "namespaces": {
                                Type:        schema.TypeList,
                                Optional:    true,
                                Description: "The namespaces for the cluster.",
                                Elem: &amp;schema.Resource{
                                        Schema: map[string]*schema.Schema{
                                                "name": {
                                                        Type:        schema.TypeString,
                                                        Required:    true,
                                                        Description: "Name of the namespace. This is the name of the Kubernetes namespace in the cluster.",
                                                },
                                                "resource_allocation": {
                                                        Type:     schema.TypeMap,
                                                        Required: true,
                                                        Elem: &amp;schema.Schema{
                                                                Type: schema.TypeString,
                                                        },
                                                        Description: "Resource allocation for the namespace. This is a map containing the resource type and the resource value. Only the following field names are supported for resource configuration: `cpu_cores`, `memory_MiB`, `gpu`, and `gpu_provider`. Any other field names will not be honored by the system. For example, `{cpu_cores: '2', memory_MiB: '2048', gpu: '1', gpu_provider: 'nvidia'}`",
                                                },
                                                "cluster_resource_allocations": {
                                                        Type:     schema.TypeList,
                                                        Optional: true,
                                                        Elem: &amp;schema.Resource{
                                                                Schema: map[string]*schema.Schema{
                                                                        "uid": {
                                                                                Type:     schema.TypeString,
                                                                                Required: true,
                                                                        },
                                                                        "resource_allocation": {
                                                                                Type:     schema.TypeMap,
                                                                                Required: true,
                                                                                Elem: &amp;schema.Schema{
                                                                                        Type: schema.TypeString,
                                                                                },
                                                                                Description: "Resource allocation for the cluster. This is a map containing the resource type and the resource value. Only the following field names are supported for resource configuration: `cpu_cores`, `memory_MiB`, `gpu`. Any other field names will not be honored by the system. For example, `{cpu_cores: '2', memory_MiB: '2048', gpu: '1'}`. Note: gpu_provider is not supported here; use the default resource_allocation for GPU provider configuration.",
                                                                        },
                                                                },
                                                        },
                                                },
                                                "images_blacklist": {
                                                        Type:     schema.TypeList,
                                                        Optional: true,
                                                        Elem: &amp;schema.Schema{
                                                                Type: schema.TypeString,
                                                        },
                                                        Description: "List of images to disallow for the namespace. For example, `['nginx:latest', 'redis:latest']`",
                                                },
                                        },
                                },
                        },
                },
        }
}</span>

// resourceWorkspaceStateUpgradeV2 migrates state from version 2 to version 3
func resourceWorkspaceStateUpgradeV2(ctx context.Context, rawState map[string]interface{}, meta interface{}) (map[string]interface{}, error) <span class="cov0" title="0">{
        log.Printf("[DEBUG] Upgrading workspace state from version 2 to 3")

        // Convert namespaces from TypeList to TypeSet
        // Note: We keep the data as a list in rawState and let Terraform's schema processing
        // convert it to TypeSet during normal resource loading. This avoids JSON serialization
        // issues with schema.Set objects that contain hash functions.
        if namespacesRaw, exists := rawState["namespaces"]; exists </span><span class="cov0" title="0">{
                if namespacesList, ok := namespacesRaw.([]interface{}); ok </span><span class="cov0" title="0">{
                        log.Printf("[DEBUG] Keeping namespaces as list during state upgrade with %d items", len(namespacesList))

                        // Keep the namespaces data as-is (as a list)
                        // Terraform will convert it to TypeSet when loading the resource using the schema
                        rawState["namespaces"] = namespacesList

                        log.Printf("[DEBUG] Successfully prepared namespaces for TypeSet conversion")
                }</span> else<span class="cov0" title="0"> {
                        log.Printf("[DEBUG] namespaces is not a list, skipping conversion")
                }</span>
        } else<span class="cov0" title="0"> {
                log.Printf("[DEBUG] No namespaces found in state, skipping conversion")
        }</span>

        <span class="cov0" title="0">return rawState, nil</span>
}
</pre>
		
		<pre class="file" id="file189" style="display: none">package spectrocloud

import (
        "strings"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
        "github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/schemas"
)

// resourceClusterCustomCloudResourceV2 returns the schema for version 2 of the resource
func resourceClusterCustomCloudResourceV2() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                Schema: map[string]*schema.Schema{
                        "name": {
                                Type:        schema.TypeString,
                                Required:    true,
                                ForceNew:    true,
                                Description: "The name of the cluster.",
                        },
                        "context": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "project",
                                ValidateFunc: validation.StringInSlice([]string{"", "project", "tenant"}, false),
                                Description: "The context of the EKS cluster. Allowed values are `project` or `tenant`. " +
                                        "Default is `project`. " + PROJECT_NAME_NUANCE,
                        },
                        "cloud": {
                                Type:        schema.TypeString,
                                ForceNew:    true,
                                Required:    true,
                                Description: "The cloud provider name.",
                        },
                        "tags": {
                                Type:     schema.TypeSet,
                                Optional: true,
                                Set:      schema.HashString,
                                Elem: &amp;schema.Schema{
                                        Type: schema.TypeString,
                                },
                                Description: "A list of tags to be applied to the cluster. Tags must be in the form of `key:value`.",
                        },
                        "description": {
                                Type:        schema.TypeString,
                                Optional:    true,
                                Default:     "",
                                Description: "The description of the cluster. Default value is empty string.",
                        },
                        "cluster_profile":  schemas.ClusterProfileSchema(),
                        "cluster_template": schemas.ClusterTemplateSchema(),
                        "apply_setting": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "DownloadAndInstall",
                                ValidateFunc: validation.StringInSlice([]string{"DownloadAndInstall", "DownloadAndInstallLater"}, false),
                                Description: "The setting to apply the cluster profile. `DownloadAndInstall` will download and install packs in one action. " +
                                        "`DownloadAndInstallLater` will only download artifact and postpone install for later. " +
                                        "Default value is `DownloadAndInstall`.",
                        },
                        "cloud_account_id": {
                                Type:        schema.TypeString,
                                Required:    true,
                                ForceNew:    true,
                                Description: "The cloud account id to use for this cluster.",
                        },
                        "cloud_config_id": {
                                Type:       schema.TypeString,
                                Computed:   true,
                                Deprecated: "This field is deprecated and will be removed in the future. Use `cloud_config` instead.",
                        },
                        "cluster_timezone": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "",
                                ValidateFunc: validateTimezone,
                                Description:  "Defines the time zone used by this cluster to interpret scheduled operations. Maintenance tasks like upgrades will follow this time zone to ensure they run at the appropriate local time for the cluster. Must be in IANA timezone format (e.g., 'America/New_York', 'Asia/Kolkata', 'Europe/London').",
                        },
                        "cloud_config": {
                                Type:        schema.TypeList,
                                Required:    true,
                                MaxItems:    1,
                                Description: "The Cloud environment configuration settings such as network parameters and encryption parameters that apply to this cluster.",
                                Elem: &amp;schema.Resource{
                                        Schema: map[string]*schema.Schema{
                                                "values": {
                                                        Type:        schema.TypeString,
                                                        Required:    true,
                                                        Description: "The values of the cloud config. The values are specified in YAML format. ",
                                                },
                                                "overrides": {
                                                        Type:        schema.TypeMap,
                                                        Optional:    true,
                                                        Elem:        &amp;schema.Schema{Type: schema.TypeString},
                                                        Description: "Key-value pairs to override specific values in the YAML.",
                                                },
                                        },
                                },
                        },
                        // Version 2 used TypeList for machine_pool
                        "machine_pool": {
                                Type:        schema.TypeList,
                                Required:    true,
                                Description: "The machine pool configuration for the cluster.",
                                Elem: &amp;schema.Resource{
                                        Schema: map[string]*schema.Schema{
                                                "name": {
                                                        Type:        schema.TypeString,
                                                        Computed:    true,
                                                        Description: "The name of the machine pool. This will be derived from the name value in the `node_pool_config`.",
                                                },
                                                "count": {
                                                        Type:        schema.TypeInt,
                                                        Computed:    true,
                                                        Description: "Number of nodes in the machine pool. This will be derived from the replica value in the 'node_pool_config'.",
                                                },
                                                "taints": schemas.ClusterTaintsSchema(),
                                                "control_plane": {
                                                        Type:        schema.TypeBool,
                                                        Optional:    true,
                                                        Default:     false,
                                                        Description: "Whether this machine pool is a control plane. Defaults to `false`.",
                                                },
                                                "control_plane_as_worker": {
                                                        Type:        schema.TypeBool,
                                                        Optional:    true,
                                                        Default:     false,
                                                        Description: "Whether this machine pool is a control plane and a worker. Defaults to `false`.",
                                                },
                                                "node_pool_config": {
                                                        Type:        schema.TypeString,
                                                        Required:    true,
                                                        Description: "The values of the node pool config. The values are specified in YAML format. ",
                                                },
                                                "overrides": {
                                                        Type:        schema.TypeMap,
                                                        Optional:    true,
                                                        Elem:        &amp;schema.Schema{Type: schema.TypeString},
                                                        Description: "Key-value pairs to override specific values in the node pool config YAML.",
                                                },
                                        },
                                },
                        },
                        "pause_agent_upgrades": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "unlock",
                                ValidateFunc: validation.StringInSlice([]string{"lock", "unlock"}, false),
                                Description:  "The pause agent upgrades setting allows to control the automatic upgrade of the Palette component and agent for an individual cluster. The default value is `unlock`, meaning upgrades occur automatically. Setting it to `lock` pauses automatic agent upgrades for the cluster.",
                        },
                        "os_patch_on_boot": {
                                Type:        schema.TypeBool,
                                Optional:    true,
                                Default:     false,
                                Description: "Whether to apply OS patch on boot. Default is `false`.",
                        },
                        "os_patch_schedule": {
                                Type:             schema.TypeString,
                                Optional:         true,
                                ValidateDiagFunc: validateOsPatchSchedule,
                                Description:      "The cron schedule for OS patching. This must be in the form of cron syntax. Ex: `0 0 * * *`.",
                        },
                        "os_patch_after": {
                                Type:             schema.TypeString,
                                Optional:         true,
                                ValidateDiagFunc: validateOsPatchOnDemandAfter,
                                Description:      "Date and time after which to patch cluster `RFC3339: 2006-01-02T15:04:05Z07:00`",
                        },
                        "kubeconfig": {
                                Type:        schema.TypeString,
                                Computed:    true,
                                Description: "Kubeconfig for the cluster. This can be used to connect to the cluster using `kubectl`.",
                        },
                        "admin_kube_config": {
                                Type:        schema.TypeString,
                                Computed:    true,
                                Description: "Admin Kube-config for the cluster. This can be used to connect to the cluster using `kubectl`, With admin privilege.",
                        },
                        "backup_policy":        schemas.BackupPolicySchema(),
                        "scan_policy":          schemas.ScanPolicySchema(),
                        "cluster_rbac_binding": schemas.ClusterRbacBindingSchema(),
                        "namespaces":           schemas.ClusterNamespacesSchema(),
                        "location_config":      schemas.ClusterLocationSchema(),
                        "skip_completion": {
                                Type:        schema.TypeBool,
                                Optional:    true,
                                Default:     false,
                                Description: "If `true`, the cluster will be created asynchronously. Default value is `false`.",
                        },
                        "force_delete": {
                                Type:        schema.TypeBool,
                                Optional:    true,
                                Default:     false,
                                Description: "If set to `true`, the cluster will be force deleted and user has to manually clean up the provisioned cloud resources.",
                        },
                        "force_delete_delay": {
                                Type:             schema.TypeInt,
                                Optional:         true,
                                Default:          20,
                                Description:      "Delay duration in minutes to before invoking cluster force delete. Default and minimum is 20.",
                                ValidateDiagFunc: validation.ToDiagFunc(validation.IntAtLeast(20)),
                        },
                },
        }
}</span>

func resourceClusterEksResourceV2() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                Schema: map[string]*schema.Schema{
                        "name": {
                                Type:        schema.TypeString,
                                Required:    true,
                                ForceNew:    true,
                                Description: "The name of the cluster.",
                        },
                        "context": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "project",
                                ValidateFunc: validation.StringInSlice([]string{"", "project", "tenant"}, false),
                                Description: "The context of the EKS cluster. Allowed values are `project` or `tenant`. " +
                                        "Default is `project`. " + PROJECT_NAME_NUANCE,
                        },
                        "tags": {
                                Type:     schema.TypeSet,
                                Optional: true,
                                Set:      schema.HashString,
                                Elem: &amp;schema.Schema{
                                        Type: schema.TypeString,
                                },
                                Description: "A list of tags to be applied to the cluster. Tags must be in the form of `key:value`. The `tags` attribute will soon be deprecated. It is recommended to use `tags_map` instead.",
                        },
                        "tags_map": {
                                Type:          schema.TypeMap,
                                Optional:      true,
                                ConflictsWith: []string{"tags"},
                                Elem: &amp;schema.Schema{
                                        Type: schema.TypeString,
                                },
                                Description: "A map of tags to be applied to the cluster. tags and tags_map are mutually exclusive  only one should be used at a time",
                        },
                        "description": {
                                Type:        schema.TypeString,
                                Optional:    true,
                                Default:     "",
                                Description: "The description of the cluster. Default value is empty string.",
                        },
                        "cluster_meta_attribute": {
                                Type:        schema.TypeString,
                                Optional:    true,
                                Description: "`cluster_meta_attribute` can be used to set additional cluster metadata information, eg `{'nic_name': 'test', 'env': 'stage'}`",
                        },
                        "cluster_profile":  schemas.ClusterProfileSchema(),
                        "cluster_template": schemas.ClusterTemplateSchema(),
                        "apply_setting": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "DownloadAndInstall",
                                ValidateFunc: validation.StringInSlice([]string{"DownloadAndInstall", "DownloadAndInstallLater"}, false),
                                Description: "The setting to apply the cluster profile. `DownloadAndInstall` will download and install packs in one action. " +
                                        "`DownloadAndInstallLater` will only download artifact and postpone install for later. " +
                                        "Default value is `DownloadAndInstall`.",
                        },
                        "cloud_account_id": {
                                Type:        schema.TypeString,
                                Required:    true,
                                ForceNew:    true,
                                Description: "The AWS cloud account id to use for this cluster.",
                        },
                        "cloud_config_id": {
                                Type:        schema.TypeString,
                                Computed:    true,
                                Description: "ID of the cloud config used for the cluster. This cloud config must be of type `azure`.",
                                Deprecated:  "This field is deprecated and will be removed in the future. Use `cloud_config` instead.",
                        },
                        "review_repave_state": {
                                Type:         schema.TypeString,
                                Default:      "",
                                Optional:     true,
                                ValidateFunc: validateReviewRepaveValue,
                                Description:  "To authorize the cluster repave, set the value to `Approved` for approval and `\"\"` to decline. Default value is `\"\"`.",
                        },
                        "pause_agent_upgrades": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "unlock",
                                ValidateFunc: validation.StringInSlice([]string{"lock", "unlock"}, false),
                                Description:  "The pause agent upgrades setting allows to control the automatic upgrade of the Palette component and agent for an individual cluster. The default value is `unlock`, meaning upgrades occur automatically. Setting it to `lock` pauses automatic agent upgrades for the cluster.",
                        },
                        "os_patch_on_boot": {
                                Type:        schema.TypeBool,
                                Optional:    true,
                                Default:     false,
                                Description: "Whether to apply OS patch on boot. Default is `false`.",
                        },
                        "os_patch_schedule": {
                                Type:             schema.TypeString,
                                Optional:         true,
                                ValidateDiagFunc: validateOsPatchSchedule,
                                Description:      "Cron schedule for OS patching. This must be in the form of `0 0 * * *`.",
                        },
                        "os_patch_after": {
                                Type:             schema.TypeString,
                                Optional:         true,
                                ValidateDiagFunc: validateOsPatchOnDemandAfter,
                                Description:      "Date and time after which to patch cluster `RFC3339: 2006-01-02T15:04:05Z07:00`",
                        },
                        "cluster_timezone": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "",
                                ValidateFunc: validateTimezone,
                                Description:  "Defines the time zone used by this cluster to interpret scheduled operations. Maintenance tasks like upgrades will follow this time zone to ensure they run at the appropriate local time for the cluster. Must be in IANA timezone format (e.g., 'America/New_York', 'Asia/Kolkata', 'Europe/London').",
                        },
                        "kubeconfig": {
                                Type:        schema.TypeString,
                                Computed:    true,
                                Description: "Kubeconfig for the cluster. This can be used to connect to the cluster using `kubectl`.",
                        },
                        "admin_kube_config": {
                                Type:        schema.TypeString,
                                Computed:    true,
                                Description: "Admin Kube-config for the cluster. This can be used to connect to the cluster using `kubectl`, With admin privilege.",
                        },
                        "cloud_config": {
                                Type:        schema.TypeList,
                                Required:    true,
                                MaxItems:    1,
                                Description: "The AWS environment configuration settings such as network parameters and encryption parameters that apply to this cluster.",
                                Elem: &amp;schema.Resource{
                                        Schema: map[string]*schema.Schema{
                                                "ssh_key_name": {
                                                        Type:        schema.TypeString,
                                                        ForceNew:    true,
                                                        Optional:    true,
                                                        Description: "Public SSH key to be used for the cluster nodes.",
                                                },
                                                "region": {
                                                        Type:     schema.TypeString,
                                                        ForceNew: true,
                                                        Required: true,
                                                },
                                                "vpc_id": {
                                                        Type:     schema.TypeString,
                                                        ForceNew: true,
                                                        Optional: true,
                                                },
                                                "azs": {
                                                        Type:        schema.TypeList,
                                                        Description: "Mutually exclusive with `az_subnets`. Use for Dynamic provisioning.",
                                                        Optional:    true,
                                                        ForceNew:    true,
                                                        Elem: &amp;schema.Schema{
                                                                Type: schema.TypeString,
                                                        },
                                                },
                                                "az_subnets": {
                                                        Type:        schema.TypeMap,
                                                        Description: "Mutually exclusive with `azs`. Use for Static provisioning.",
                                                        Optional:    true,
                                                        ForceNew:    true,
                                                        DiffSuppressFunc: func(k, old, new string, d *schema.ResourceData) bool </span><span class="cov0" title="0">{
                                                                // UI strips the trailing newline on save
                                                                return strings.TrimSpace(old) == strings.TrimSpace(new)
                                                        }</span>,
                                                        Elem: &amp;schema.Schema{
                                                                Type: schema.TypeString,
                                                        },
                                                },
                                                "endpoint_access": {
                                                        Type:         schema.TypeString,
                                                        Optional:     true,
                                                        ForceNew:     true,
                                                        ValidateFunc: validation.StringInSlice([]string{"public", "private", "private_and_public"}, false),
                                                        Description:  "Choose between `private`, `public`, or `private_and_public` to define how communication is established with the endpoint for the managed Kubernetes API server and your cluster. The default value is `public`.",
                                                        Default:      "public",
                                                },
                                                "public_access_cidrs": {
                                                        Type:        schema.TypeSet,
                                                        Optional:    true,
                                                        Set:         schema.HashString,
                                                        Description: "List of CIDR blocks that define the allowed public access to the resource. Requests originating from addresses within these CIDR blocks will be permitted to access the resource. All other addresses will be denied access.",
                                                        Elem: &amp;schema.Schema{
                                                                Type: schema.TypeString,
                                                        },
                                                },
                                                "private_access_cidrs": {
                                                        Type:        schema.TypeSet,
                                                        Optional:    true,
                                                        Set:         schema.HashString,
                                                        Description: "List of CIDR blocks that define the allowed private access to the resource. Only requests originating from addresses within these CIDR blocks will be permitted to access the resource.",
                                                        Elem: &amp;schema.Schema{
                                                                Type: schema.TypeString,
                                                        },
                                                },
                                                "encryption_config_arn": {
                                                        Type:        schema.TypeString,
                                                        Description: "The ARN of the KMS encryption key to use for the cluster. Refer to the [Enable Secrets Encryption for EKS Cluster](https://docs.spectrocloud.com/clusters/public-cloud/aws/enable-secrets-encryption-kms-key/) for additional guidance.",
                                                        ForceNew:    true,
                                                        Optional:    true,
                                                },
                                        },
                                },
                        },
                        "machine_pool": {
                                Type:        schema.TypeList,
                                Required:    true,
                                Description: "The machine pool configuration for the cluster.",
                                Elem: &amp;schema.Resource{
                                        Schema: map[string]*schema.Schema{
                                                "name": {
                                                        Type:     schema.TypeString,
                                                        Required: true,
                                                        //ForceNew: true,
                                                },
                                                "additional_labels": {
                                                        Type:     schema.TypeMap,
                                                        Optional: true,
                                                        Elem: &amp;schema.Schema{
                                                                Type: schema.TypeString,
                                                        },
                                                        Description: "Additional labels to be applied to the machine pool. Labels must be in the form of `key:value`.",
                                                },
                                                "node":   schemas.NodeSchema(),
                                                "taints": schemas.ClusterTaintsSchema(),
                                                "disk_size_gb": {
                                                        Type:     schema.TypeInt,
                                                        Required: true,
                                                },
                                                "count": {
                                                        Type:        schema.TypeInt,
                                                        Required:    true,
                                                        Description: "Number of nodes in the machine pool.",
                                                },
                                                "update_strategy": {
                                                        Type:        schema.TypeString,
                                                        Optional:    true,
                                                        Default:     "RollingUpdateScaleOut",
                                                        Description: "Update strategy for the machine pool. Valid values are `RollingUpdateScaleOut` and `RollingUpdateScaleIn`.",
                                                },
                                                "min": {
                                                        Type:        schema.TypeInt,
                                                        Optional:    true,
                                                        Description: "Minimum number of nodes in the machine pool. This is used for autoscaling the machine pool.",
                                                },
                                                "max": {
                                                        Type:        schema.TypeInt,
                                                        Optional:    true,
                                                        Description: "Maximum number of nodes in the machine pool. This is used for autoscaling the machine pool.",
                                                },
                                                "instance_type": {
                                                        Type:     schema.TypeString,
                                                        Required: true,
                                                },
                                                "ami_type": {
                                                        Type:        schema.TypeString,
                                                        Optional:    true,
                                                        Default:     "AL2023_x86_64_STANDARD",
                                                        Description: "Specifies the type of Amazon Machine Image (AMI) to use for the machine pool. Valid values are [`AL2_x86_64`, `AL2_x86_64_GPU`, `AL2023_x86_64_STANDARD`, `AL2023_x86_64_NEURON` and `AL2023_x86_64_NVIDIA`]. Defaults to `AL2023_x86_64_STANDARD`.",
                                                },
                                                "capacity_type": {
                                                        Type:         schema.TypeString,
                                                        Default:      "on-demand",
                                                        Optional:     true,
                                                        ValidateFunc: validation.StringInSlice([]string{"on-demand", "spot"}, false),
                                                        Description:  "Capacity type is an instance type,  can be 'on-demand' or 'spot'. Defaults to 'on-demand'.",
                                                },
                                                "max_price": {
                                                        Type:     schema.TypeString,
                                                        Optional: true,
                                                },
                                                "azs": {
                                                        Type:        schema.TypeList,
                                                        Optional:    true,
                                                        Description: "Mutually exclusive with `az_subnets`.",
                                                        Elem: &amp;schema.Schema{
                                                                Type: schema.TypeString,
                                                        },
                                                },
                                                "az_subnets": {
                                                        Type:        schema.TypeMap,
                                                        Optional:    true,
                                                        Description: "Mutually exclusive with `azs`. Use for Static provisioning.",
                                                        Elem: &amp;schema.Schema{
                                                                Type: schema.TypeString,
                                                        },
                                                },
                                                "eks_launch_template": schemas.AwsLaunchTemplate(),
                                        },
                                },
                        },
                        "fargate_profile": {
                                Type:     schema.TypeList,
                                Optional: true,
                                Elem: &amp;schema.Resource{
                                        Schema: map[string]*schema.Schema{
                                                "name": {
                                                        Type:     schema.TypeString,
                                                        Required: true,
                                                },
                                                "subnets": {
                                                        Type:     schema.TypeList,
                                                        Optional: true,
                                                        Elem: &amp;schema.Schema{
                                                                Type: schema.TypeString,
                                                        },
                                                },
                                                "additional_tags": {
                                                        Type:     schema.TypeMap,
                                                        Optional: true,
                                                        Elem: &amp;schema.Schema{
                                                                Type: schema.TypeString,
                                                        },
                                                },
                                                "selector": {
                                                        Type:     schema.TypeList,
                                                        Required: true,
                                                        //MinItems: 1,
                                                        Elem: &amp;schema.Resource{
                                                                Schema: map[string]*schema.Schema{
                                                                        "namespace": {
                                                                                Type:     schema.TypeString,
                                                                                Required: true,
                                                                        },
                                                                        "labels": {
                                                                                Type:     schema.TypeMap,
                                                                                Optional: true,
                                                                                Elem: &amp;schema.Schema{
                                                                                        Type: schema.TypeString,
                                                                                },
                                                                        },
                                                                },
                                                        },
                                                },
                                        },
                                },
                        },
                        "backup_policy":        schemas.BackupPolicySchema(),
                        "scan_policy":          schemas.ScanPolicySchema(),
                        "cluster_rbac_binding": schemas.ClusterRbacBindingSchema(),
                        "namespaces":           schemas.ClusterNamespacesSchema(),
                        "host_config":          schemas.ClusterHostConfigSchema(),
                        "location_config":      schemas.ClusterLocationSchemaComputed(),
                        "skip_completion": {
                                Type:        schema.TypeBool,
                                Optional:    true,
                                Default:     false,
                                Description: "If `true`, the cluster will be created asynchronously. Default value is `false`.",
                        },
                        "force_delete": {
                                Type:        schema.TypeBool,
                                Optional:    true,
                                Default:     false,
                                Description: "If set to `true`, the cluster will be force deleted and user has to manually clean up the provisioned cloud resources.",
                        },
                        "force_delete_delay": {
                                Type:             schema.TypeInt,
                                Optional:         true,
                                Default:          20,
                                Description:      "Delay duration in minutes to before invoking cluster force delete. Default and minimum is 20.",
                                ValidateDiagFunc: validation.ToDiagFunc(validation.IntAtLeast(20)),
                        },
                },
        }
}

func resourceClusterAksResourceV2() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                Schema: map[string]*schema.Schema{
                        "name": {
                                Type:        schema.TypeString,
                                Required:    true,
                                ForceNew:    true,
                                Description: "",
                        },
                        "context": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "project",
                                ValidateFunc: validation.StringInSlice([]string{"", "project", "tenant"}, false),
                                Description: "The context of the AKS cluster. Allowed values are `project` or `tenant`. " +
                                        "Default is `project`. " + PROJECT_NAME_NUANCE,
                        },
                        "tags": {
                                Type:     schema.TypeSet,
                                Optional: true,
                                Set:      schema.HashString,
                                Elem: &amp;schema.Schema{
                                        Type: schema.TypeString,
                                },
                                Description: "A list of tags to be applied to the cluster. Tags must be in the form of `key:value`.",
                        },
                        "description": {
                                Type:        schema.TypeString,
                                Optional:    true,
                                Default:     "",
                                Description: "The description of the cluster. Default value is empty string.",
                        },
                        "cluster_meta_attribute": {
                                Type:        schema.TypeString,
                                Optional:    true,
                                Description: "`cluster_meta_attribute` can be used to set additional cluster metadata information, eg `{'nic_name': 'test', 'env': 'stage'}`",
                        },
                        "cluster_profile":  schemas.ClusterProfileSchema(),
                        "cluster_template": schemas.ClusterTemplateSchema(),
                        "apply_setting": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "DownloadAndInstall",
                                ValidateFunc: validation.StringInSlice([]string{"DownloadAndInstall", "DownloadAndInstallLater"}, false),
                                Description: "The setting to apply the cluster profile. `DownloadAndInstall` will download and install packs in one action. " +
                                        "`DownloadAndInstallLater` will only download artifact and postpone install for later. " +
                                        "Default value is `DownloadAndInstall`.",
                        },
                        "cloud_account_id": {
                                Type:     schema.TypeString,
                                Required: true,
                                ForceNew: true,
                        },
                        "cloud_config_id": {
                                Type:        schema.TypeString,
                                Computed:    true,
                                Description: "ID of the cloud config used for the cluster. This cloud config must be of type `azure`.",
                                Deprecated:  "This field is deprecated and will be removed in the future. Use `cloud_config` instead.",
                        },
                        "review_repave_state": {
                                Type:         schema.TypeString,
                                Default:      "",
                                Optional:     true,
                                ValidateFunc: validateReviewRepaveValue,
                                Description:  "To authorize the cluster repave, set the value to `Approved` for approval and `\"\"` to decline. Default value is `\"\"`.",
                        },
                        "pause_agent_upgrades": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "unlock",
                                ValidateFunc: validation.StringInSlice([]string{"lock", "unlock"}, false),
                                Description:  "The pause agent upgrades setting allows to control the automatic upgrade of the Palette component and agent for an individual cluster. The default value is `unlock`, meaning upgrades occur automatically. Setting it to `lock` pauses automatic agent upgrades for the cluster.",
                        },
                        "os_patch_on_boot": {
                                Type:        schema.TypeBool,
                                Optional:    true,
                                Default:     false,
                                Description: "Whether to apply OS patch on boot. Default is `false`.",
                        },
                        "os_patch_schedule": {
                                Type:             schema.TypeString,
                                Optional:         true,
                                ValidateDiagFunc: validateOsPatchSchedule,
                                Description:      "The cron schedule for OS patching. This must be in the form of cron syntax. Ex: `0 0 * * *`.",
                        },
                        "os_patch_after": {
                                Type:             schema.TypeString,
                                Optional:         true,
                                ValidateDiagFunc: validateOsPatchOnDemandAfter,
                                Description:      "The date and time after which to patch the cluster. Prefix the time value with the respective RFC. Ex: `RFC3339: 2006-01-02T15:04:05Z07:00`",
                        },
                        "kubeconfig": {
                                Type:        schema.TypeString,
                                Computed:    true,
                                Description: "Kubeconfig for the cluster. This can be used to connect to the cluster using `kubectl`.",
                        },
                        "admin_kube_config": {
                                Type:        schema.TypeString,
                                Computed:    true,
                                Description: "Admin Kube-config for the cluster. This can be used to connect to the cluster using `kubectl`, With admin privilege.",
                        },
                        "cloud_config": {
                                Type:     schema.TypeList,
                                ForceNew: true,
                                Required: true,
                                MaxItems: 1,
                                Elem: &amp;schema.Resource{
                                        Schema: map[string]*schema.Schema{
                                                "subscription_id": {
                                                        Type:     schema.TypeString,
                                                        Required: true,
                                                        ForceNew: true,
                                                },
                                                "resource_group": {
                                                        Type:     schema.TypeString,
                                                        Required: true,
                                                        ForceNew: true,
                                                },
                                                "region": {
                                                        Type:     schema.TypeString,
                                                        Required: true,
                                                        ForceNew: true,
                                                },
                                                "ssh_key": {
                                                        Type:        schema.TypeString,
                                                        Required:    true,
                                                        ForceNew:    true,
                                                        Description: "Public SSH key to be used for the cluster nodes.",
                                                },
                                                "private_cluster": {
                                                        Type:        schema.TypeBool,
                                                        Optional:    true,
                                                        Default:     false,
                                                        ForceNew:    true,
                                                        Description: "Whether to create a private cluster(API endpoint). Default is `false`.",
                                                },

                                                // fields for static placement are having flat structure as backend currently doesn't support multiple subnets.
                                                "vnet_name": {
                                                        Type:     schema.TypeString,
                                                        Optional: true,
                                                        ForceNew: true,
                                                },

                                                "vnet_resource_group": {
                                                        Type:     schema.TypeString,
                                                        Optional: true,
                                                        ForceNew: true,
                                                },

                                                "vnet_cidr_block": {
                                                        Type:     schema.TypeString,
                                                        Optional: true,
                                                        ForceNew: true,
                                                },

                                                "worker_subnet_name": {
                                                        Type:     schema.TypeString,
                                                        Optional: true,
                                                        ForceNew: true,
                                                },
                                                "worker_cidr": {
                                                        Type:     schema.TypeString,
                                                        Optional: true,
                                                        ForceNew: true,
                                                },
                                                "worker_subnet_security_group_name": {
                                                        Type:     schema.TypeString,
                                                        Optional: true,
                                                        ForceNew: true,
                                                },
                                                "control_plane_subnet_name": {
                                                        Type:     schema.TypeString,
                                                        Optional: true,
                                                        ForceNew: true,
                                                },
                                                "control_plane_cidr": {
                                                        Type:     schema.TypeString,
                                                        Optional: true,
                                                        ForceNew: true,
                                                },
                                                "control_plane_subnet_security_group_name": {
                                                        Type:     schema.TypeString,
                                                        Optional: true,
                                                        ForceNew: true,
                                                },
                                        },
                                },
                        },
                        "machine_pool": {
                                Type:     schema.TypeList,
                                Required: true,
                                Elem: &amp;schema.Resource{
                                        Schema: map[string]*schema.Schema{
                                                "name": {
                                                        Type:     schema.TypeString,
                                                        Required: true,
                                                        //ForceNew: true,
                                                },
                                                "additional_labels": {
                                                        Type:     schema.TypeMap,
                                                        Optional: true,
                                                        Elem: &amp;schema.Schema{
                                                                Type: schema.TypeString,
                                                        },
                                                },
                                                "node":   schemas.NodeSchema(),
                                                "taints": schemas.ClusterTaintsSchema(),
                                                "count": {
                                                        Type:        schema.TypeInt,
                                                        Required:    true,
                                                        Description: "Number of nodes in the machine pool.",
                                                },
                                                "update_strategy": {
                                                        Type:         schema.TypeString,
                                                        Optional:     true,
                                                        Default:      "RollingUpdateScaleOut",
                                                        Description:  "Update strategy for the machine pool. Valid values are `RollingUpdateScaleOut` and `RollingUpdateScaleIn`.",
                                                        ValidateFunc: validation.StringInSlice([]string{"RollingUpdateScaleOut", "RollingUpdateScaleIn"}, false),
                                                },
                                                "instance_type": {
                                                        Type:     schema.TypeString,
                                                        Required: true,
                                                },
                                                "min": {
                                                        Type:        schema.TypeInt,
                                                        Optional:    true,
                                                        Description: "Minimum number of nodes in the machine pool. This is used for autoscaling the machine pool.",
                                                },
                                                "max": {
                                                        Type:        schema.TypeInt,
                                                        Optional:    true,
                                                        Description: "Maximum number of nodes in the machine pool. This is used for autoscaling the machine pool.",
                                                },
                                                "disk_size_gb": {
                                                        Type:     schema.TypeInt,
                                                        Required: true,
                                                },
                                                "is_system_node_pool": {
                                                        Type:     schema.TypeBool,
                                                        Required: true,
                                                },
                                                "storage_account_type": {
                                                        Type:     schema.TypeString,
                                                        Required: true,
                                                        //ExactlyOneOf: []string{"Standard_LRS", "Standard_GRS", "Standard_RAGRS", "Standard_ZRS", "Premium_LRS", "Premium_ZRS", "Standard_GZRS", "Standard_RAGZRS"},
                                                },
                                        },
                                },
                        },
                        "backup_policy":        schemas.BackupPolicySchema(),
                        "scan_policy":          schemas.ScanPolicySchema(),
                        "cluster_rbac_binding": schemas.ClusterRbacBindingSchema(),
                        "namespaces":           schemas.ClusterNamespacesSchema(),
                        "host_config":          schemas.ClusterHostConfigSchema(),
                        "location_config":      schemas.ClusterLocationSchemaComputed(),
                        "skip_completion": {
                                Type:        schema.TypeBool,
                                Optional:    true,
                                Default:     false,
                                Description: "If `true`, the cluster will be created asynchronously. Default value is `false`.",
                        },
                        "force_delete": {
                                Type:        schema.TypeBool,
                                Optional:    true,
                                Default:     false,
                                Description: "If set to `true`, the cluster will be force deleted and user has to manually clean up the provisioned cloud resources.",
                        },
                        "force_delete_delay": {
                                Type:             schema.TypeInt,
                                Optional:         true,
                                Default:          20,
                                Description:      "Delay duration in minutes to before invoking cluster force delete. Default and minimum is 20.",
                                ValidateDiagFunc: validation.ToDiagFunc(validation.IntAtLeast(20)),
                        },
                },
        }
}</span>

func resourceClusterGkeResourceV1() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                Schema: map[string]*schema.Schema{
                        "name": {
                                Type:        schema.TypeString,
                                Required:    true,
                                ForceNew:    true,
                                Description: "The name of the cluster.",
                        },
                        "context": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "project",
                                ValidateFunc: validation.StringInSlice([]string{"", "project", "tenant"}, false),
                                Description: "The context of the GKE cluster. Allowed values are `project` or `tenant`. " +
                                        "Default is `project`. " + PROJECT_NAME_NUANCE,
                        },
                        "description": {
                                Type:        schema.TypeString,
                                Optional:    true,
                                Default:     "",
                                Description: "The description of the cluster. Default value is empty string.",
                        },
                        "tags": {
                                Type:     schema.TypeSet,
                                Optional: true,
                                Set:      schema.HashString,
                                Elem: &amp;schema.Schema{
                                        Type: schema.TypeString,
                                },
                                Description: "A list of tags to be applied to the cluster. Tags must be in the form of `key:value`.",
                        },
                        "cluster_meta_attribute": {
                                Type:        schema.TypeString,
                                Optional:    true,
                                Description: "`cluster_meta_attribute` can be used to set additional cluster metadata information, eg `{'nic_name': 'test', 'env': 'stage'}`",
                        },
                        "cluster_profile":  schemas.ClusterProfileSchema(),
                        "cluster_template": schemas.ClusterTemplateSchema(),
                        "apply_setting": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "DownloadAndInstall",
                                ValidateFunc: validation.StringInSlice([]string{"DownloadAndInstall", "DownloadAndInstallLater"}, false),
                                Description: "The setting to apply the cluster profile. `DownloadAndInstall` will download and install packs in one action. " +
                                        "`DownloadAndInstallLater` will only download artifact and postpone install for later. " +
                                        "Default value is `DownloadAndInstall`.",
                        },
                        "cloud_account_id": {
                                Type:     schema.TypeString,
                                Required: true,
                                ForceNew: true,
                        },
                        "cloud_config_id": {
                                Type:        schema.TypeString,
                                Computed:    true,
                                Description: "ID of the cloud config used for the cluster. This cloud config must be of type `azure`.",
                                Deprecated:  "This field is deprecated and will be removed in the future. Use `cloud_config` instead.",
                        },

                        "cloud_config": {
                                Type:        schema.TypeList,
                                ForceNew:    true,
                                Required:    true,
                                MaxItems:    1,
                                Description: "The GKE environment configuration settings such as project parameters and region parameters that apply to this cluster.",
                                Elem: &amp;schema.Resource{
                                        Schema: map[string]*schema.Schema{
                                                "project": {
                                                        Type:        schema.TypeString,
                                                        ForceNew:    true,
                                                        Required:    true,
                                                        Description: "GCP project name.",
                                                },
                                                "region": {
                                                        Type:     schema.TypeString,
                                                        ForceNew: true,
                                                        Required: true,
                                                },
                                        },
                                },
                        },
                        "update_worker_pool_in_parallel": {
                                Type:     schema.TypeBool,
                                Optional: true,
                                Default:  true,
                        },
                        "machine_pool": {
                                Type:        schema.TypeList,
                                Required:    true,
                                Description: "The machine pool configuration for the cluster.",
                                Elem: &amp;schema.Resource{
                                        Schema: map[string]*schema.Schema{
                                                "name": {
                                                        Type:     schema.TypeString,
                                                        Required: true,
                                                },
                                                "count": {
                                                        Type:        schema.TypeInt,
                                                        Required:    true,
                                                        Description: "Number of nodes in the machine pool.",
                                                },
                                                "disk_size_gb": {
                                                        Type:     schema.TypeInt,
                                                        Optional: true,
                                                        Default:  60,
                                                },
                                                "additional_labels": {
                                                        Type:     schema.TypeMap,
                                                        Optional: true,
                                                        Elem: &amp;schema.Schema{
                                                                Type: schema.TypeString,
                                                        },
                                                        Description: "Additional labels to be applied to the machine pool. Labels must be in the form of `key:value`.",
                                                },
                                                "instance_type": {
                                                        Type:     schema.TypeString,
                                                        Required: true,
                                                },
                                                "update_strategy": {
                                                        Type:        schema.TypeString,
                                                        Optional:    true,
                                                        Default:     "RollingUpdateScaleOut",
                                                        Description: "Update strategy for the machine pool. Valid values are `RollingUpdateScaleOut` and `RollingUpdateScaleIn`.",
                                                },
                                                "node":   schemas.NodeSchema(),
                                                "taints": schemas.ClusterTaintsSchema(),
                                        },
                                },
                        },
                        "pause_agent_upgrades": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "unlock",
                                ValidateFunc: validation.StringInSlice([]string{"lock", "unlock"}, false),
                                Description:  "The pause agent upgrades setting allows to control the automatic upgrade of the Palette component and agent for an individual cluster. The default value is `unlock`, meaning upgrades occur automatically. Setting it to `lock` pauses automatic agent upgrades for the cluster.",
                        },
                        "review_repave_state": {
                                Type:         schema.TypeString,
                                Default:      "",
                                Optional:     true,
                                ValidateFunc: validation.StringInSlice([]string{"", "Approved", "Pending"}, false),
                                Description:  "To authorize the cluster repave, set the value to `Approved` for approval and `\"\"` to decline. Default value is `\"\"`.",
                        },
                        "os_patch_on_boot": {
                                Type:        schema.TypeBool,
                                Optional:    true,
                                Default:     false,
                                Description: "Whether to apply OS patch on boot. Default is `false`.",
                        },
                        "os_patch_schedule": {
                                Type:             schema.TypeString,
                                Optional:         true,
                                ValidateDiagFunc: validateOsPatchSchedule,
                                Description:      "Cron schedule for OS patching. This must be in the form of `0 0 * * *`.",
                        },
                        "os_patch_after": {
                                Type:             schema.TypeString,
                                Optional:         true,
                                ValidateDiagFunc: validateOsPatchOnDemandAfter,
                                Description:      "Date and time after which to patch cluster `RFC3339: 2006-01-02T15:04:05Z07:00`",
                        },
                        "kubeconfig": {
                                Type:        schema.TypeString,
                                Computed:    true,
                                Description: "Kubeconfig for the cluster. This can be used to connect to the cluster using `kubectl`.",
                        },
                        "admin_kube_config": {
                                Type:        schema.TypeString,
                                Computed:    true,
                                Description: "Admin Kube-config for the cluster. This can be used to connect to the cluster using `kubectl`, With admin privilege.",
                        },
                        "backup_policy":        schemas.BackupPolicySchema(),
                        "scan_policy":          schemas.ScanPolicySchema(),
                        "cluster_rbac_binding": schemas.ClusterRbacBindingSchema(),
                        "namespaces":           schemas.ClusterNamespacesSchema(),
                        "host_config":          schemas.ClusterHostConfigSchema(),
                        "location_config":      schemas.ClusterLocationSchemaComputed(),
                        "skip_completion": {
                                Type:        schema.TypeBool,
                                Optional:    true,
                                Default:     false,
                                Description: "If `true`, the cluster will be created asynchronously. Default value is `false`.",
                        },
                        "force_delete": {
                                Type:        schema.TypeBool,
                                Optional:    true,
                                Default:     false,
                                Description: "If set to `true`, the cluster will be force deleted and user has to manually clean up the provisioned cloud resources.",
                        },
                        "force_delete_delay": {
                                Type:             schema.TypeInt,
                                Optional:         true,
                                Default:          20,
                                Description:      "Delay duration in minutes to before invoking cluster force delete. Default and minimum is 20.",
                                ValidateDiagFunc: validation.ToDiagFunc(validation.IntAtLeast(20)),
                        },
                },
        }
}</span>

func resourceClusterOpenStackResourceV1() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                Schema: map[string]*schema.Schema{
                        "name": {
                                Type:     schema.TypeString,
                                Required: true,
                                ForceNew: true,
                        },
                        "context": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "project",
                                ValidateFunc: validation.StringInSlice([]string{"", "project", "tenant"}, false),
                                Description: "The context of the OpenStack cluster. Allowed values are `project` or `tenant`. " +
                                        "Default is `project`. " + PROJECT_NAME_NUANCE,
                        },
                        "tags": {
                                Type:     schema.TypeSet,
                                Optional: true,
                                Set:      schema.HashString,
                                Elem: &amp;schema.Schema{
                                        Type: schema.TypeString,
                                },
                                Description: "A list of tags to be applied to the cluster. Tags must be in the form of `key:value`.",
                        },
                        "description": {
                                Type:        schema.TypeString,
                                Optional:    true,
                                Default:     "",
                                Description: "The description of the cluster. Default value is empty string.",
                        },
                        "cluster_meta_attribute": {
                                Type:        schema.TypeString,
                                Optional:    true,
                                Description: "`cluster_meta_attribute` can be used to set additional cluster metadata information, eg `{'nic_name': 'test', 'env': 'stage'}`",
                        },
                        "cluster_profile":  schemas.ClusterProfileSchema(),
                        "cluster_template": schemas.ClusterTemplateSchema(),
                        "apply_setting": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "DownloadAndInstall",
                                ValidateFunc: validation.StringInSlice([]string{"DownloadAndInstall", "DownloadAndInstallLater"}, false),
                                Description: "The setting to apply the cluster profile. `DownloadAndInstall` will download and install packs in one action. " +
                                        "`DownloadAndInstallLater` will only download artifact and postpone install for later. " +
                                        "Default value is `DownloadAndInstall`.",
                        },
                        "cloud_account_id": {
                                Type:     schema.TypeString,
                                Required: true,
                                ForceNew: true,
                        },
                        "cloud_config_id": {
                                Type:        schema.TypeString,
                                Computed:    true,
                                Description: "ID of the cloud config used for the cluster. This cloud config must be of type `azure`.",
                                Deprecated:  "This field is deprecated and will be removed in the future. Use `cloud_config` instead.",
                        },
                        "review_repave_state": {
                                Type:         schema.TypeString,
                                Default:      "",
                                Optional:     true,
                                ValidateFunc: validateReviewRepaveValue,
                                Description:  "To authorize the cluster repave, set the value to `Approved` for approval and `\"\"` to decline. Default value is `\"\"`.",
                        },
                        "pause_agent_upgrades": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "unlock",
                                ValidateFunc: validation.StringInSlice([]string{"lock", "unlock"}, false),
                                Description:  "The pause agent upgrades setting allows to control the automatic upgrade of the Palette component and agent for an individual cluster. The default value is `unlock`, meaning upgrades occur automatically. Setting it to `lock` pauses automatic agent upgrades for the cluster.",
                        },
                        "os_patch_on_boot": {
                                Type:        schema.TypeBool,
                                Optional:    true,
                                Default:     false,
                                Description: "Whether to apply OS patch on boot. Default is `false`.",
                        },
                        "os_patch_schedule": {
                                Type:             schema.TypeString,
                                Optional:         true,
                                ValidateDiagFunc: validateOsPatchSchedule,
                                Description:      "Cron schedule for OS patching. This must be in the form of `0 0 * * *`.",
                        },
                        "os_patch_after": {
                                Type:             schema.TypeString,
                                Optional:         true,
                                ValidateDiagFunc: validateOsPatchOnDemandAfter,
                                Description:      "The date and time after which to patch the cluster. Prefix the time value with the respective RFC. Ex: `RFC3339: 2006-01-02T15:04:05Z07:00`",
                        },
                        "cluster_timezone": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "",
                                ValidateFunc: validateTimezone,
                                Description:  "Defines the time zone used by this cluster to interpret scheduled operations. Maintenance tasks like upgrades will follow this time zone to ensure they run at the appropriate local time for the cluster. Must be in IANA timezone format (e.g., 'America/New_York', 'Asia/Kolkata', 'Europe/London').",
                        },
                        "kubeconfig": {
                                Type:        schema.TypeString,
                                Computed:    true,
                                Description: "Kubeconfig for the cluster. This can be used to connect to the cluster using `kubectl`.",
                        },
                        "admin_kube_config": {
                                Type:        schema.TypeString,
                                Computed:    true,
                                Description: "Admin Kube-config for the cluster. This can be used to connect to the cluster using `kubectl`, With admin privilege.",
                        },
                        "cloud_config": {
                                Type:     schema.TypeList,
                                ForceNew: true,
                                Required: true,
                                MaxItems: 1,
                                Elem: &amp;schema.Resource{
                                        Schema: map[string]*schema.Schema{
                                                "domain": {
                                                        Type:     schema.TypeString,
                                                        Required: true,
                                                },
                                                "region": {
                                                        Type:     schema.TypeString,
                                                        Required: true,
                                                },
                                                "project": {
                                                        Type:     schema.TypeString,
                                                        Required: true,
                                                },
                                                "ssh_key": {
                                                        Type:        schema.TypeString,
                                                        Required:    true,
                                                        Description: "Public SSH key to be used for the cluster nodes.",
                                                },
                                                "network_id": {
                                                        Type:     schema.TypeString,
                                                        Optional: true,
                                                },
                                                "subnet_id": {
                                                        Type:     schema.TypeString,
                                                        Optional: true,
                                                },
                                                "dns_servers": {
                                                        Type:     schema.TypeSet,
                                                        Required: true,
                                                        ForceNew: true,
                                                        Set:      schema.HashString,
                                                        Elem: &amp;schema.Schema{
                                                                Type: schema.TypeString,
                                                        },
                                                },
                                                "subnet_cidr": {
                                                        Type:     schema.TypeString,
                                                        Required: true,
                                                },
                                        },
                                },
                        },
                        "machine_pool": {
                                Type:        schema.TypeList, // V2: TypeList, V3: TypeSet
                                Required:    true,
                                Description: "The machine pool configuration for the cluster.",
                                Elem: &amp;schema.Resource{
                                        Schema: map[string]*schema.Schema{
                                                "additional_labels": {
                                                        Type:     schema.TypeMap,
                                                        Optional: true,
                                                        Elem: &amp;schema.Schema{
                                                                Type: schema.TypeString,
                                                        },
                                                        Description: "Additional labels to be applied to the machine pool. Labels must be in the form of `key:value`.",
                                                },
                                                "taints": schemas.ClusterTaintsSchema(),
                                                "node":   schemas.NodeSchema(),
                                                "control_plane": {
                                                        Type:        schema.TypeBool,
                                                        Optional:    true,
                                                        Default:     false,
                                                        Description: "Whether this machine pool is a control plane. Defaults to `false`.",
                                                },
                                                "control_plane_as_worker": {
                                                        Type:        schema.TypeBool,
                                                        Optional:    true,
                                                        Default:     false,
                                                        Description: "Whether this machine pool is a control plane and a worker. Defaults to `false`.",
                                                },
                                                "name": {
                                                        Type:     schema.TypeString,
                                                        Required: true,
                                                },
                                                "count": {
                                                        Type:        schema.TypeInt,
                                                        Required:    true,
                                                        Description: "Number of nodes in the machine pool.",
                                                },
                                                "node_repave_interval": {
                                                        Type:        schema.TypeInt,
                                                        Optional:    true,
                                                        Default:     0,
                                                        Description: "Minimum number of seconds node should be Ready, before the next node is selected for repave. Default value is `0`, Applicable only for worker pools.",
                                                },
                                                "update_strategy": {
                                                        Type:         schema.TypeString,
                                                        Optional:     true,
                                                        Default:      "RollingUpdateScaleOut",
                                                        Description:  "Update strategy for the machine pool. Valid values are `RollingUpdateScaleOut` and `RollingUpdateScaleIn`.",
                                                        ValidateFunc: validation.StringInSlice([]string{"RollingUpdateScaleOut", "RollingUpdateScaleIn"}, false),
                                                },
                                                "instance_type": {
                                                        Type:     schema.TypeString,
                                                        Required: true,
                                                },
                                                "azs": {
                                                        Type:     schema.TypeList,
                                                        Optional: true,
                                                        Elem: &amp;schema.Schema{
                                                                Type: schema.TypeString,
                                                        },
                                                },
                                                "subnet_id": {
                                                        Type:     schema.TypeString,
                                                        Optional: true,
                                                },
                                        },
                                },
                        },
                        "backup_policy":        schemas.BackupPolicySchema(),
                        "scan_policy":          schemas.ScanPolicySchema(),
                        "cluster_rbac_binding": schemas.ClusterRbacBindingSchema(),
                        "namespaces":           schemas.ClusterNamespacesSchema(),
                        "host_config":          schemas.ClusterHostConfigSchema(),
                        "location_config":      schemas.ClusterLocationSchema(),
                        "skip_completion": {
                                Type:        schema.TypeBool,
                                Optional:    true,
                                Default:     false,
                                Description: "If `true`, the cluster will be created asynchronously. Default value is `false`.",
                        },
                        "force_delete": {
                                Type:        schema.TypeBool,
                                Optional:    true,
                                Default:     false,
                                Description: "If set to `true`, the cluster will be force deleted and user has to manually clean up the provisioned cloud resources.",
                        },
                        "force_delete_delay": {
                                Type:             schema.TypeInt,
                                Optional:         true,
                                Default:          20,
                                Description:      "Delay duration in minutes to before invoking cluster force delete. Default and minimum is 20.",
                                ValidateDiagFunc: validation.ToDiagFunc(validation.IntAtLeast(20)),
                        },
                },
        }
}</span>

// resourceClusterEdgeNativeResourceV2 returns the V2 schema with edge_host as TypeList
func resourceClusterEdgeNativeResourceV2() *schema.Resource <span class="cov8" title="1">{
        return &amp;schema.Resource{
                SchemaVersion: 2,
                Schema: map[string]*schema.Schema{
                        "name": {
                                Type:     schema.TypeString,
                                Required: true,
                                ForceNew: true,
                        },
                        "context": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "project",
                                ValidateFunc: validation.StringInSlice([]string{"", "project", "tenant"}, false),
                                Description: "The context of the Edge cluster. Allowed values are `project` or `tenant`. " +
                                        "Default is `project`. " + PROJECT_NAME_NUANCE,
                        },
                        "tags": {
                                Type:     schema.TypeSet,
                                Optional: true,
                                Set:      schema.HashString,
                                Elem: &amp;schema.Schema{
                                        Type: schema.TypeString,
                                },
                                Description: "A list of tags to be applied to the cluster. Tags must be in the form of `key:value`.",
                        },
                        "description": {
                                Type:        schema.TypeString,
                                Optional:    true,
                                Default:     "",
                                Description: "The description of the cluster. Default value is empty string.",
                        },
                        "cluster_meta_attribute": {
                                Type:        schema.TypeString,
                                Optional:    true,
                                Description: "`cluster_meta_attribute` can be used to set additional cluster metadata information, eg `{'nic_name': 'test', 'env': 'stage'}`",
                        },
                        "cluster_profile":  schemas.ClusterProfileSchema(),
                        "cluster_template": schemas.ClusterTemplateSchema(),
                        "apply_setting": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "DownloadAndInstall",
                                ValidateFunc: validation.StringInSlice([]string{"DownloadAndInstall", "DownloadAndInstallLater"}, false),
                                Description: "The setting to apply the cluster profile. `DownloadAndInstall` will download and install packs in one action. " +
                                        "`DownloadAndInstallLater` will only download artifact and postpone install for later. " +
                                        "Default value is `DownloadAndInstall`.",
                        },
                        "cloud_account_id": {
                                Type:     schema.TypeString,
                                Optional: true,
                                ForceNew: true,
                        },
                        "cloud_config_id": {
                                Type:        schema.TypeString,
                                Computed:    true,
                                Description: "ID of the cloud config used for the cluster. This cloud config must be of type `azure`.",
                                Deprecated:  "This field is deprecated and will be removed in the future. Use `cloud_config` instead.",
                        },
                        "review_repave_state": {
                                Type:         schema.TypeString,
                                Default:      "",
                                Optional:     true,
                                ValidateFunc: validateReviewRepaveValue,
                                Description:  "To authorize the cluster repave, set the value to `Approved` for approval and `\"\"` to decline. Default value is `\"\"`.",
                        },
                        "os_patch_on_boot": {
                                Type:        schema.TypeBool,
                                Optional:    true,
                                Default:     false,
                                Description: "Whether to apply OS patch on boot. Default is `false`.",
                        },
                        "os_patch_schedule": {
                                Type:             schema.TypeString,
                                Optional:         true,
                                ValidateDiagFunc: validateOsPatchSchedule,
                                Description:      "The cron schedule for OS patching. This must be in the form of cron syntax. Ex: `0 0 * * *`.",
                        },
                        "os_patch_after": {
                                Type:             schema.TypeString,
                                Optional:         true,
                                ValidateDiagFunc: validateOsPatchOnDemandAfter,
                                Description:      "Date and time after which to patch cluster `RFC3339: 2006-01-02T15:04:05Z07:00`",
                        },
                        "kubeconfig": {
                                Type:        schema.TypeString,
                                Computed:    true,
                                Description: "Kubeconfig for the cluster. This can be used to connect to the cluster using `kubectl`.",
                        },
                        "admin_kube_config": {
                                Type:        schema.TypeString,
                                Computed:    true,
                                Description: "Admin Kube-config for the cluster. This can be used to connect to the cluster using `kubectl`, With admin privilege.",
                        },
                        "cloud_config": {
                                Type:     schema.TypeList,
                                ForceNew: true,
                                Required: true,
                                MinItems: 1,
                                MaxItems: 1,
                                Elem: &amp;schema.Resource{
                                        Schema: map[string]*schema.Schema{
                                                "ssh_keys": {
                                                        Type:     schema.TypeSet,
                                                        Optional: true,
                                                        Set:      schema.HashString,
                                                        Elem: &amp;schema.Schema{
                                                                Type: schema.TypeString,
                                                        },
                                                        Description: "List of public SSH (Secure Shell) to establish, administer, and communicate with remote clusters.",
                                                },
                                                "vip": {
                                                        Type:        schema.TypeString,
                                                        Optional:    true,
                                                        Description: "The `vip` can be specified as either an IP address or a fully qualified domain name (FQDN). If `overlay_cidr_range` is set, the `vip` should be within the specified `overlay_cidr_range`. By default, the `vip` is set to the first IP address within the given `overlay_cidr_range`.",
                                                },
                                                "overlay_cidr_range": {
                                                        Type:        schema.TypeString,
                                                        Optional:    true,
                                                        ForceNew:    true,
                                                        Description: "The Overlay (VPN) creates a virtual network, using techniques like VxLAN. It overlays the existing network infrastructure, enhancing connectivity either at Layer 2 or Layer 3, making it flexible and adaptable for various needs. For example, `100.64.192.0/24`",
                                                },
                                                "is_two_node_cluster": {
                                                        Type:        schema.TypeBool,
                                                        Optional:    true,
                                                        Default:     false,
                                                        Description: "Set to `true` to enable a two-node cluster.",
                                                },
                                                "ntp_servers": {
                                                        Type:     schema.TypeSet,
                                                        Optional: true,
                                                        Set:      schema.HashString,
                                                        Elem: &amp;schema.Schema{
                                                                Type: schema.TypeString,
                                                        },
                                                        Description: "A list of NTP servers to be used by the cluster.",
                                                },
                                        },
                                },
                        },
                        "machine_pool": {
                                Type:     schema.TypeSet,
                                Required: true,
                                Set:      resourceMachinePoolEdgeNativeHash,
                                Elem: &amp;schema.Resource{
                                        Schema: map[string]*schema.Schema{
                                                "name": {
                                                        Type:     schema.TypeString,
                                                        Required: true,
                                                        //ForceNew: true,
                                                },
                                                "additional_labels": {
                                                        Type:     schema.TypeMap,
                                                        Optional: true,
                                                        Elem: &amp;schema.Schema{
                                                                Type: schema.TypeString,
                                                        },
                                                },
                                                "node":   schemas.NodeSchema(),
                                                "taints": schemas.ClusterTaintsSchema(),
                                                "control_plane": {
                                                        Type:     schema.TypeBool,
                                                        Optional: true,
                                                        Default:  false,
                                                        //ForceNew: true,
                                                        Description: "Whether this machine pool is a control plane. Defaults to `false`.",
                                                },
                                                "control_plane_as_worker": {
                                                        Type:     schema.TypeBool,
                                                        Optional: true,
                                                        Default:  false,
                                                        //ForceNew: true,
                                                        Description: "Whether this machine pool is a control plane and a worker. Defaults to `false`.",
                                                },
                                                "node_repave_interval": {
                                                        Type:        schema.TypeInt,
                                                        Optional:    true,
                                                        Default:     0,
                                                        Description: "Minimum number of seconds node should be Ready, before the next node is selected for repave. Default value is `0`, Applicable only for worker pools.",
                                                },
                                                "update_strategy": {
                                                        Type:         schema.TypeString,
                                                        Optional:     true,
                                                        Default:      "RollingUpdateScaleOut",
                                                        Description:  "Update strategy for the machine pool. Valid values are `RollingUpdateScaleOut` and `RollingUpdateScaleIn`.",
                                                        ValidateFunc: validation.StringInSlice([]string{"RollingUpdateScaleOut", "RollingUpdateScaleIn"}, false),
                                                },
                                                "edge_host": {
                                                        Type:     schema.TypeList,
                                                        Required: true,
                                                        Elem: &amp;schema.Resource{
                                                                Schema: map[string]*schema.Schema{
                                                                        "host_name": {
                                                                                Type:        schema.TypeString,
                                                                                Optional:    true,
                                                                                Default:     "",
                                                                                Description: "Edge host name",
                                                                        },
                                                                        "host_uid": {
                                                                                Type:        schema.TypeString,
                                                                                Description: "Edge host id",
                                                                                Required:    true,
                                                                        },
                                                                        "static_ip": {
                                                                                Type:        schema.TypeString,
                                                                                Description: "Edge host static IP address",
                                                                                Optional:    true,
                                                                        },
                                                                        "nic_name": {
                                                                                Type:        schema.TypeString,
                                                                                Description: "NIC Name for edge host.",
                                                                                Optional:    true,
                                                                        },
                                                                        "default_gateway": {
                                                                                Type:        schema.TypeString,
                                                                                Description: "Edge host default gateway",
                                                                                Optional:    true,
                                                                        },
                                                                        "subnet_mask": {
                                                                                Type:        schema.TypeString,
                                                                                Description: "Edge host subnet mask",
                                                                                Optional:    true,
                                                                        },
                                                                        "dns_servers": {
                                                                                Type:        schema.TypeSet,
                                                                                Optional:    true,
                                                                                Set:         schema.HashString,
                                                                                Description: "Edge host DNS servers",
                                                                                Elem: &amp;schema.Schema{
                                                                                        Type: schema.TypeString,
                                                                                },
                                                                        },
                                                                        "two_node_role": {
                                                                                Type:         schema.TypeString,
                                                                                Description:  "Two node role for edge host. Valid values are `primary` and `secondary`.",
                                                                                Optional:     true,
                                                                                ValidateFunc: validation.StringInSlice([]string{"primary", "secondary"}, false),
                                                                        },
                                                                },
                                                        },
                                                },
                                        },
                                },
                        },
                        "pause_agent_upgrades": {
                                Type:         schema.TypeString,
                                Optional:     true,
                                Default:      "unlock",
                                ValidateFunc: validation.StringInSlice([]string{"lock", "unlock"}, false),
                                Description:  "The pause agent upgrades setting allows to control the automatic upgrade of the Palette component and agent for an individual cluster. The default value is `unlock`, meaning upgrades occur automatically. Setting it to `lock` pauses automatic agent upgrades for the cluster.",
                        },
                        "backup_policy":        schemas.BackupPolicySchema(),
                        "scan_policy":          schemas.ScanPolicySchema(),
                        "cluster_rbac_binding": schemas.ClusterRbacBindingSchema(),
                        "namespaces":           schemas.ClusterNamespacesSchema(),
                        "host_config":          schemas.ClusterHostConfigSchema(),
                        "location_config":      schemas.ClusterLocationSchema(),
                        "skip_completion": {
                                Type:        schema.TypeBool,
                                Optional:    true,
                                Default:     false,
                                Description: "If `true`, the cluster will be created asynchronously. Default value is `false`.",
                        },
                        "force_delete": {
                                Type:        schema.TypeBool,
                                Optional:    true,
                                Default:     false,
                                Description: "If set to `true`, the cluster will be force deleted and user has to manually clean up the provisioned cloud resources.",
                        },
                        "force_delete_delay": {
                                Type:             schema.TypeInt,
                                Optional:         true,
                                Default:          20,
                                Description:      "Delay duration in minutes to before invoking cluster force delete. Default and minimum is 20.",
                                ValidateDiagFunc: validation.ToDiagFunc(validation.IntAtLeast(20)),
                        },
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file190" style="display: none">package schemas

import (
        "strings"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
)

func AppPackSchema() *schema.Schema <span class="cov8" title="1">{
        return &amp;schema.Schema{
                Type:        schema.TypeList,
                Required:    true,
                Description: "A list of packs to be applied to the application profile.",
                Elem: &amp;schema.Resource{
                        Schema: map[string]*schema.Schema{
                                "type": {
                                        Type:        schema.TypeString,
                                        Optional:    true,
                                        Description: "The type of Pack. Allowed values are `container`, `helm`, `manifest`, or `operator-instance`.",
                                        Default:     "spectro",
                                },
                                "source_app_tier": {
                                        Type:        schema.TypeString,
                                        Description: "The unique id of the pack to be used as the source for the pack.",
                                        Optional:    true,
                                },
                                "registry_uid": {
                                        Type:        schema.TypeString,
                                        Description: "The unique id of the registry to be used for the pack. Either `registry_uid` or `registry_name` can be specified, but not both.",
                                        Optional:    true,
                                },
                                "registry_name": {
                                        Type:        schema.TypeString,
                                        Description: "The name of the registry to be used for the pack. This can be used instead of `registry_uid` for better readability. Either `registry_uid` or `registry_name` can be specified, but not both.",
                                        Optional:    true,
                                },
                                "uid": {
                                        Type:        schema.TypeString,
                                        Description: "The unique id of the pack. This is a computed field and is not required to be set.",
                                        Computed:    true,
                                        Optional:    true,
                                },
                                "name": {
                                        Type:        schema.TypeString,
                                        Description: "The name of the specified pack.",
                                        Required:    true,
                                },
                                "properties": {
                                        Type:        schema.TypeMap,
                                        Optional:    true,
                                        Description: "The various properties required by different database tiers eg: `databaseName` and `databaseVolumeSize` size for Redis etc.",
                                        Elem: &amp;schema.Schema{
                                                Type: schema.TypeString,
                                        },
                                },
                                "install_order": {
                                        Type:        schema.TypeInt,
                                        Description: "The installation priority order of the app profile. The order of priority goes from lowest number to highest number. For example, a value of `-3` would be installed before an app profile with a higher number value. No upper and lower limits exist, and you may specify positive and negative integers. The default value is `0`. ",
                                        Default:     0,
                                        Optional:    true,
                                },
                                "manifest": {
                                        Type:        schema.TypeList,
                                        Optional:    true,
                                        Description: "The manifest of the pack.",
                                        Elem: &amp;schema.Resource{
                                                Schema: map[string]*schema.Schema{
                                                        "uid": {
                                                                Type:     schema.TypeString,
                                                                Computed: true,
                                                        },
                                                        "name": {
                                                                Type:        schema.TypeString,
                                                                Description: "The name of the manifest.",
                                                                Required:    true,
                                                        },
                                                        "content": {
                                                                Type:        schema.TypeString,
                                                                Required:    true,
                                                                Description: "The content of the manifest.",
                                                                DiffSuppressFunc: func(k, old, new string, d *schema.ResourceData) bool </span><span class="cov0" title="0">{
                                                                        // UI strips the trailing newline on save
                                                                        return strings.TrimSpace(old) == strings.TrimSpace(new)
                                                                }</span>,
                                                        },
                                                },
                                        },
                                },
                                "tag": {
                                        Type:        schema.TypeString,
                                        Description: "The identifier or version to label the pack.",
                                        Optional:    true,
                                },
                                "values": {
                                        Type:        schema.TypeString,
                                        Optional:    true,
                                        Description: "The values to be used for the pack. This is a stringified JSON object.",
                                        DiffSuppressFunc: func(k, old, new string, d *schema.ResourceData) bool <span class="cov0" title="0">{
                                                // UI strips the trailing newline on save
                                                return strings.TrimSpace(old) == strings.TrimSpace(new)
                                        }</span>,
                                },
                        },
                },
        }
}
</pre>
		
		<pre class="file" id="file191" style="display: none">package schemas

import (
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
)

func BackupPolicySchema() *schema.Schema <span class="cov10" title="23">{
        return &amp;schema.Schema{
                Type:        schema.TypeList,
                Optional:    true,
                MaxItems:    1,
                Description: "The backup policy for the cluster. If not specified, no backups will be taken.",
                Elem: &amp;schema.Resource{
                        Schema: map[string]*schema.Schema{
                                "prefix": {
                                        Type:        schema.TypeString,
                                        Required:    true,
                                        Description: "Prefix for the backup name. The backup name will be of the format &lt;prefix&gt;-&lt;cluster-name&gt;-&lt;timestamp&gt;.",
                                },
                                "backup_location_id": {
                                        Type:        schema.TypeString,
                                        Required:    true,
                                        Description: "The ID of the backup location to use for the backup.",
                                },
                                "schedule": {
                                        Type:        schema.TypeString,
                                        Required:    true,
                                        Description: "The schedule for the backup. The schedule is specified in cron format. For example, to run the backup every day at 1:00 AM, the schedule should be set to `0 1 * * *`.",
                                },
                                "expiry_in_hour": {
                                        Type:        schema.TypeInt,
                                        Required:    true,
                                        Description: "The number of hours after which the backup will be deleted. For example, if the expiry is set to 24, the backup will be deleted after 24 hours.",
                                },
                                "include_disks": {
                                        Type:        schema.TypeBool,
                                        Optional:    true,
                                        Default:     true,
                                        Description: "Whether to include the disks in the backup. If set to false, only the cluster configuration will be backed up.",
                                },
                                "include_cluster_resources": {
                                        Type:          schema.TypeBool,
                                        Optional:      true,
                                        Default:       true,
                                        ConflictsWith: []string{"backup_policy.0.include_cluster_resources_mode"},
                                        Description:   "Indicates whether to include cluster resources in the backup. If set to false, only the cluster configuration and disks will be backed up. (Note: Starting with Palette version 4.6, the include_cluster_resources attribute will be deprecated, and a new attribute, include_cluster_resources_mode, will be introduced.)",
                                },
                                "include_cluster_resources_mode": {
                                        Type:         schema.TypeString,
                                        Optional:     true,
                                        Description:  "Specifies whether to include the cluster resources in the backup. Supported values are `always`, `never`, and `auto`.",
                                        ValidateFunc: validation.StringInSlice([]string{"always", "never", "auto"}, false),
                                },
                                "namespaces": {
                                        Type:     schema.TypeSet,
                                        Optional: true,
                                        Set:      schema.HashString,
                                        Elem: &amp;schema.Schema{
                                                Type: schema.TypeString,
                                        },
                                        Description: "The list of Kubernetes namespaces to include in the backup. If not specified, all namespaces will be included.",
                                },
                                "cluster_uids": {
                                        Type:     schema.TypeSet,
                                        Optional: true,
                                        Set:      schema.HashString,
                                        Elem: &amp;schema.Schema{
                                                Type: schema.TypeString,
                                        },
                                        Description: "The list of cluster UIDs to include in the backup. If `include_all_clusters` is set to `true`, then all clusters will be included.",
                                },
                                "include_all_clusters": {
                                        Type:        schema.TypeBool,
                                        Optional:    true,
                                        Description: "Whether to include all clusters in the backup. If set to false, only the clusters specified in `cluster_uids` will be included.",
                                },
                        },
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file192" style="display: none">package schemas

import (
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
)

func ClusterHostConfigSchema() *schema.Schema <span class="cov10" title="18">{
        return &amp;schema.Schema{
                Type:        schema.TypeList,
                Optional:    true,
                Description: "The host configuration for the cluster.",
                Elem: &amp;schema.Resource{
                        Schema: map[string]*schema.Schema{
                                "host_endpoint_type": {
                                        Type:         schema.TypeString,
                                        Optional:     true,
                                        Default:      "Ingress",
                                        ValidateFunc: validation.StringInSlice([]string{"Ingress", "LoadBalancer"}, false),
                                        Description:  "The type of endpoint for the cluster. Can be either 'Ingress' or 'LoadBalancer'. The default is 'Ingress'.",
                                },
                                "ingress_host": {
                                        Type:        schema.TypeString,
                                        Optional:    true,
                                        Description: "The host for the Ingress endpoint. Required if 'host_endpoint_type' is set to 'Ingress'.",
                                },
                                "external_traffic_policy": {
                                        Type:        schema.TypeString,
                                        Optional:    true,
                                        Description: "The external traffic policy for the cluster.",
                                },
                                "load_balancer_source_ranges": {
                                        Type:        schema.TypeString,
                                        Optional:    true,
                                        Description: "The source ranges for the load balancer. Required if 'host_endpoint_type' is set to 'LoadBalancer'.",
                                },
                        },
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file193" style="display: none">package schemas

import "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

func ClusterLocationSchema() *schema.Schema <span class="cov8" title="9">{
        return &amp;schema.Schema{
                Type:     schema.TypeList,
                Optional: true,
                DiffSuppressFunc: func(k, oldValue, newValue string, d *schema.ResourceData) bool </span><span class="cov0" title="0">{
                        _, hasClusterConfig := d.GetOk("location_config")
                        if hasClusterConfig </span><span class="cov0" title="0">{
                                if d.Get("location_config") != nil </span><span class="cov0" title="0">{
                                        for _, locationConfig := range d.Get("location_config").([]interface{}) </span><span class="cov0" title="0">{
                                                lat := locationConfig.(map[string]interface{})["latitude"].(float64)
                                                long := locationConfig.(map[string]interface{})["longitude"].(float64)
                                                if lat == 0 &amp;&amp; long == 0 </span><span class="cov0" title="0">{
                                                        return true
                                                }</span>
                                        }
                                }
                        }
                        <span class="cov0" title="0">return false</span>
                },
                Elem: &amp;schema.Resource{
                        Schema: map[string]*schema.Schema{
                                "country_code": {
                                        Type:        schema.TypeString,
                                        Description: "The country code of the country the cluster is located in.",
                                        Optional:    true,
                                        Default:     "",
                                },
                                "country_name": {
                                        Type:        schema.TypeString,
                                        Description: "The name of the country.",
                                        Optional:    true,
                                        Default:     "",
                                },
                                "region_code": {
                                        Type:        schema.TypeString,
                                        Description: "The region code of where the cluster is located in.",
                                        Optional:    true,
                                        Default:     "",
                                },
                                "region_name": {
                                        Type:        schema.TypeString,
                                        Description: "The name of the region.",
                                        Optional:    true,
                                        Default:     "",
                                },
                                "latitude": {
                                        Type:        schema.TypeFloat,
                                        Description: "The latitude coordinates value.",
                                        Required:    true,
                                },
                                "longitude": {
                                        Type:        schema.TypeFloat,
                                        Required:    true,
                                        Description: "The longitude coordinates value.",
                                },
                        },
                },
        }
}

func ClusterLocationSchemaComputed() *schema.Schema <span class="cov10" title="12">{
        return &amp;schema.Schema{
                Type:        schema.TypeList,
                Computed:    true,
                Description: "The location of the cluster.",
                Elem: &amp;schema.Resource{
                        Schema: map[string]*schema.Schema{
                                "country_code": {
                                        Type:        schema.TypeString,
                                        Computed:    true,
                                        Description: "The country code of the country the cluster is located in.",
                                },
                                "country_name": {
                                        Type:        schema.TypeString,
                                        Computed:    true,
                                        Description: "The name of the country.",
                                },
                                "region_code": {
                                        Type:        schema.TypeString,
                                        Computed:    true,
                                        Description: "The region code of where the cluster is located in.",
                                },
                                "region_name": {
                                        Type:        schema.TypeString,
                                        Computed:    true,
                                        Description: "The name of the region.",
                                },
                                "latitude": {
                                        Type:        schema.TypeFloat,
                                        Computed:    true,
                                        Description: "The latitude coordinates value.",
                                },
                                "longitude": {
                                        Type:        schema.TypeFloat,
                                        Computed:    true,
                                        Description: "The longitude coordinates value.",
                                },
                        },
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file194" style="display: none">package schemas

import "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

func ClusterNamespacesSchema() *schema.Schema <span class="cov10" title="21">{
        return &amp;schema.Schema{
                Type:        schema.TypeList,
                Optional:    true,
                Description: "The namespaces for the cluster.",
                Elem: &amp;schema.Resource{
                        Schema: map[string]*schema.Schema{
                                "name": {
                                        Type:        schema.TypeString,
                                        Required:    true,
                                        Description: "Name of the namespace. This is the name of the Kubernetes namespace in the cluster.",
                                },
                                "resource_allocation": {
                                        Type:     schema.TypeMap,
                                        Required: true,
                                        Elem: &amp;schema.Schema{
                                                Type: schema.TypeString,
                                        },
                                        Description: "Resource allocation for the namespace. This is a map containing the resource type and the resource value. For example, `{cpu_cores: '2', memory_MiB: '2048', gpu_limit: '1', gpu_provider: 'nvidia'}`",
                                },
                        },
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file195" style="display: none">package schemas

import (
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
)

func NodeSchema() *schema.Schema <span class="cov10" title="17">{
        return &amp;schema.Schema{
                Type:     schema.TypeList,
                Optional: true,
                Elem: &amp;schema.Resource{
                        Schema: map[string]*schema.Schema{
                                "node_id": {
                                        Type:        schema.TypeString,
                                        Required:    true,
                                        Description: "The node_id of the node, For example `i-07f899a33dee624f7`",
                                },
                                "action": {
                                        Type:         schema.TypeString,
                                        Required:     true,
                                        Description:  "The action to perform on the node. Valid values are: `cordon`, `uncordon`.",
                                        ValidateFunc: validation.StringInSlice([]string{"cordon", "uncordon"}, false),
                                },
                        },
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file196" style="display: none">package schemas

import (
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
)

func ClusterProfileSchema() *schema.Schema <span class="cov10" title="23">{
        return &amp;schema.Schema{
                Type:     schema.TypeList,
                Optional: true,
                Elem: &amp;schema.Resource{
                        Schema: map[string]*schema.Schema{
                                "id": {
                                        Type:        schema.TypeString,
                                        Required:    true,
                                        Description: "The ID of the cluster profile.",
                                },
                                "pack": PackSchema(),
                                "variables": {
                                        Type:        schema.TypeMap,
                                        Optional:    true,
                                        Description: "A map of cluster profile variables, specified as key-value pairs. For example: `priority = \"5\"`.",
                                        Elem: &amp;schema.Schema{
                                                Type: schema.TypeString,
                                        },
                                },
                        },
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file197" style="display: none">package schemas

import (
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
)

func ClusterRbacBindingSchema() *schema.Schema <span class="cov10" title="23">{
        return &amp;schema.Schema{
                Type:        schema.TypeList,
                Optional:    true,
                Description: "The RBAC binding for the cluster.",
                Elem: &amp;schema.Resource{
                        Schema: map[string]*schema.Schema{
                                "type": {
                                        Type:         schema.TypeString,
                                        Required:     true,
                                        ValidateFunc: validation.StringInSlice([]string{"RoleBinding", "ClusterRoleBinding"}, false),
                                        Description:  "The type of the RBAC binding. Can be one of the following values: `RoleBinding`, or `ClusterRoleBinding`.",
                                },
                                "namespace": {
                                        Type:        schema.TypeString,
                                        Optional:    true,
                                        Description: "The Kubernetes namespace of the RBAC binding. Required if 'type' is set to 'RoleBinding'.",
                                },
                                "role": {
                                        Type:     schema.TypeMap,
                                        Optional: true,
                                        Elem: &amp;schema.Schema{
                                                Type: schema.TypeString,
                                        },
                                        Description: "The role of the RBAC binding. Required if 'type' is set to 'RoleBinding'. Must include 'name' and 'kind' fields.",
                                },
                                "subjects": {
                                        Type:     schema.TypeList,
                                        Optional: true,
                                        Elem: &amp;schema.Resource{
                                                Schema: map[string]*schema.Schema{
                                                        "type": {
                                                                Type:         schema.TypeString,
                                                                Required:     true,
                                                                ValidateFunc: validation.StringInSlice([]string{"User", "Group", "ServiceAccount"}, false),
                                                                Description:  "The type of the subject. Can be one of the following values: `User`, `Group`, or `ServiceAccount`.",
                                                        },
                                                        "name": {
                                                                Type:        schema.TypeString,
                                                                Required:    true,
                                                                Description: "The name of the subject. Required if 'type' is set to 'User' or 'Group'.",
                                                        },
                                                        "namespace": {
                                                                Type:        schema.TypeString,
                                                                Optional:    true,
                                                                Description: "The Kubernetes namespace of the subject. Required if 'type' is set to 'ServiceAccount'.",
                                                        },
                                                },
                                        },
                                },
                        },
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file198" style="display: none">package schemas

import "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

func ClusterTaintsSchema() *schema.Schema <span class="cov10" title="19">{
        return &amp;schema.Schema{
                Type:     schema.TypeList,
                Optional: true,
                Elem: &amp;schema.Resource{
                        Schema: map[string]*schema.Schema{
                                "key": {
                                        Type:        schema.TypeString,
                                        Required:    true,
                                        Description: "The key of the taint.",
                                },
                                "value": {
                                        Type:        schema.TypeString,
                                        Required:    true,
                                        Description: "The value of the taint.",
                                },
                                "effect": {
                                        Type:        schema.TypeString,
                                        Required:    true,
                                        Description: "The effect of the taint. Allowed values are: `NoSchedule`, `PreferNoSchedule` or `NoExecute`.",
                                },
                        },
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file199" style="display: none">package schemas

import "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

func ClusterTemplateSchema() *schema.Schema <span class="cov10" title="19">{
        return &amp;schema.Schema{
                Type:        schema.TypeList,
                Optional:    true,
                MaxItems:    1,
                Description: "The cluster template of the cluster.",
                Elem: &amp;schema.Resource{
                        Schema: map[string]*schema.Schema{
                                "id": {
                                        Type:        schema.TypeString,
                                        Required:    true,
                                        Description: "The ID of the cluster template.",
                                },
                                "name": {
                                        Type:        schema.TypeString,
                                        Computed:    true,
                                        Description: "The name of the cluster template.",
                                },
                                "cluster_profile": {
                                        Type:        schema.TypeSet,
                                        Optional:    true,
                                        Description: "The cluster profile of the cluster template.",
                                        Elem: &amp;schema.Resource{
                                                Schema: map[string]*schema.Schema{
                                                        "id": {
                                                                Type:        schema.TypeString,
                                                                Required:    true,
                                                                Description: "The UID of the cluster profile.",
                                                        },
                                                        "variables": {
                                                                Type:        schema.TypeMap,
                                                                Optional:    true,
                                                                Description: "A map of cluster profile variables, specified as key-value pairs. For example: `priority = \"5\"`.",
                                                                Elem: &amp;schema.Schema{
                                                                        Type: schema.TypeString,
                                                                },
                                                        },
                                                },
                                        },
                                },
                        },
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file200" style="display: none">package schemas

import (
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
)

// ClusterTypeSchema returns the schema for the cluster_type field.
// This field specifies the type of cluster and can only be set during cluster creation.
// After creation, this field is read-only and any changes will be rejected.
func ClusterTypeSchema() *schema.Schema <span class="cov10" title="3">{
        return &amp;schema.Schema{
                Type:         schema.TypeString,
                Optional:     true,
                Computed:     true,
                ValidateFunc: validation.StringInSlice([]string{"PureManage", "PureAttach"}, false),
                Description: "The cluster type. Valid values are `PureManage` and `PureAttach`. " +
                        "This field can only be set during cluster creation and cannot be modified after the cluster is created. " +
                        "If not specified, the cluster will use the default type determined by the system.",
        }
}</span>
</pre>
		
		<pre class="file" id="file201" style="display: none">package schemas

import "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

func AwsLaunchTemplate() *schema.Schema <span class="cov10" title="2">{
        return &amp;schema.Schema{
                Type:     schema.TypeList,
                Optional: true,
                MaxItems: 1,
                Elem: &amp;schema.Resource{
                        Schema: map[string]*schema.Schema{
                                "ami_id": {
                                        Type:        schema.TypeString,
                                        Optional:    true,
                                        Description: "The ID of the custom Amazon Machine Image (AMI). If you do not set an `ami_id`, Palette will repave the cluster when it automatically updates the EKS AMI.",
                                },
                                "root_volume_type": {
                                        Type:        schema.TypeString,
                                        Optional:    true,
                                        Description: "The type of the root volume.",
                                },
                                "root_volume_iops": {
                                        Type:        schema.TypeInt,
                                        Optional:    true,
                                        Description: "The number of input/output operations per second (IOPS) for the root volume.",
                                },
                                "root_volume_throughput": {
                                        Type:        schema.TypeInt,
                                        Optional:    true,
                                        Description: "The throughput of the root volume in MiB/s.",
                                },
                                "additional_security_groups": {
                                        Type: schema.TypeSet,
                                        Set:  schema.HashString,
                                        Elem: &amp;schema.Schema{
                                                Type: schema.TypeString,
                                        },
                                        Optional:    true,
                                        Description: "Additional security groups to attach to the instance.",
                                },
                        },
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file202" style="display: none">package schemas

import "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

func OverrideScalingSchema() *schema.Schema <span class="cov10" title="12">{
        return &amp;schema.Schema{
                Type:        schema.TypeList,
                Optional:    true,
                MaxItems:    1,
                Description: "Rolling update strategy for the machine pool.",
                Elem: &amp;schema.Resource{
                        Schema: map[string]*schema.Schema{
                                "max_surge": {
                                        Type:        schema.TypeString,
                                        Optional:    true,
                                        Default:     "",
                                        Description: "Max extra nodes during rolling update. Integer or percentage (e.g., '1' or '20%'). Only valid when type=OverrideScaling. Both maxSurge and maxUnavailable are required.",
                                },
                                "max_unavailable": {
                                        Type:        schema.TypeString,
                                        Optional:    true,
                                        Default:     "",
                                        Description: "Max unavailable nodes during rolling update. Integer or percentage (e.g., '0' or '10%'). Only valid when type=OverrideScaling. Both maxSurge and maxUnavailable are required.",
                                },
                        },
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file203" style="display: none">package schemas

import (
        "fmt"
        "strings"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
)

func PackSchema() *schema.Schema <span class="cov10" title="24">{
        return &amp;schema.Schema{
                Type:        schema.TypeList,
                Optional:    true,
                Description: "For packs of type `spectro`, `helm`, and `manifest`, at least one pack must be specified.",
                Elem: &amp;schema.Resource{
                        Schema: map[string]*schema.Schema{
                                "uid": {
                                        Type:        schema.TypeString,
                                        Computed:    true,
                                        Optional:    true,
                                        Description: "The unique identifier of the pack. The value can be looked up using the [`spectrocloud_pack`](https://registry.terraform.io/providers/spectrocloud/spectrocloud/latest/docs/data-sources/pack) data source. This value is required if the pack type is `spectro` and for `helm` if the chart is from a public helm registry. If not provided, all of `name`, `tag`, and `registry_uid` must be specified to resolve the pack UID internally.",
                                },
                                "type": {
                                        Type:        schema.TypeString,
                                        Optional:    true,
                                        Default:     "spectro",
                                        Description: "The type of the pack. Allowed values are `spectro`, `manifest`, `helm`, or `oci`. The default value is spectro. If using an OCI registry for pack, set the type to `oci`.",
                                },
                                "name": {
                                        Type:        schema.TypeString,
                                        Required:    true,
                                        Description: "The name of the pack. The name must be unique within the cluster profile. ",
                                },
                                "registry_uid": {
                                        Type:     schema.TypeString,
                                        Optional: true,
                                        Description: "The registry UID of the pack. The registry UID is the unique identifier of the registry. " +
                                                "This attribute is required if there is more than one registry that contains a pack with the same name. " +
                                                "If `uid` is not provided, this field is required along with `name` and `tag` to resolve the pack UID internally. " +
                                                "Either `registry_uid` or `registry_name` can be specified, but not both.",
                                },
                                "registry_name": {
                                        Type:     schema.TypeString,
                                        Optional: true,
                                        Description: "The registry name of the pack. The registry name is the human-readable name of the registry. " +
                                                "This attribute can be used instead of `registry_uid` for better readability. " +
                                                "If `uid` is not provided, this field can be used along with `name` and `tag` to resolve the pack UID internally. " +
                                                "Either `registry_uid` or `registry_name` can be specified, but not both.",
                                },
                                "tag": {
                                        Type:     schema.TypeString,
                                        Optional: true,
                                        Description: "The tag of the pack. The tag is the version of the pack. This attribute is required if the pack type is `spectro` or `helm`. " +
                                                "If `uid` is not provided, this field is required along with `name` and `registry_uid` (or `registry_name`) to resolve the pack UID internally.",
                                },
                                "values": {
                                        Type:        schema.TypeString,
                                        Optional:    true,
                                        Description: "The values of the pack. The values are the configuration values of the pack. The values are specified in YAML format. ",
                                        DiffSuppressFunc: func(k, old, new string, d *schema.ResourceData) bool </span><span class="cov0" title="0">{
                                                // UI strips the trailing newline on save
                                                return strings.TrimSpace(old) == strings.TrimSpace(new)
                                        }</span>,
                                },
                                "manifest": {
                                        Type:     schema.TypeList,
                                        Optional: true,
                                        Elem: &amp;schema.Resource{
                                                Schema: map[string]*schema.Schema{
                                                        "uid": {
                                                                Type:     schema.TypeString,
                                                                Computed: true,
                                                        },
                                                        "name": {
                                                                Type:        schema.TypeString,
                                                                Required:    true,
                                                                Description: "The name of the manifest. The name must be unique within the pack. ",
                                                        },
                                                        "content": {
                                                                Type:     schema.TypeString,
                                                                Required: true,
                                                                DiffSuppressFunc: func(k, old, new string, d *schema.ResourceData) bool <span class="cov0" title="0">{
                                                                        // UI strips the trailing newline on save
                                                                        return strings.TrimSpace(old) == strings.TrimSpace(new)
                                                                }</span>,
                                                                Description: "The content of the manifest. The content is the YAML content of the manifest. ",
                                                        },
                                                },
                                        },
                                },
                        },
                },
        }
}

// ValidatePackUIDOrResolutionFields validates that either uid is provided
// OR all of name, tag, and registry_uid/registry_name are specified for pack resolution.
func ValidatePackUIDOrResolutionFields(packData map[string]interface{}) error <span class="cov0" title="0">{
        uid := ""
        if packData["uid"] != nil </span><span class="cov0" title="0">{
                uid = packData["uid"].(string)
        }</span>

        <span class="cov0" title="0">name := ""
        if packData["name"] != nil </span><span class="cov0" title="0">{
                name = packData["name"].(string)
        }</span>

        <span class="cov0" title="0">tag := ""
        if packData["tag"] != nil </span><span class="cov0" title="0">{
                tag = packData["tag"].(string)
        }</span>

        <span class="cov0" title="0">registryUID := ""
        if packData["registry_uid"] != nil </span><span class="cov0" title="0">{
                registryUID = packData["registry_uid"].(string)
        }</span>

        <span class="cov0" title="0">registryName := ""
        if packData["registry_name"] != nil </span><span class="cov0" title="0">{
                registryName = packData["registry_name"].(string)
        }</span>

        <span class="cov0" title="0">packType := ""
        if packData["type"] != nil </span><span class="cov0" title="0">{
                packType = packData["type"].(string)
        }</span>

        // Validate that both registry_uid and registry_name are not provided together
        <span class="cov0" title="0">if registryUID != "" &amp;&amp; registryName != "" </span><span class="cov0" title="0">{
                return fmt.Errorf("pack %s: only one of 'registry_uid' or 'registry_name' can be specified, not both", name)
        }</span>

        // Skip validation for manifest packs as they have special handling
        <span class="cov0" title="0">if packType == "manifest" </span><span class="cov0" title="0">{
                return nil
        }</span>

        // If uid is provided, validation passes
        <span class="cov0" title="0">if uid != "" </span><span class="cov0" title="0">{
                return nil
        }</span>

        // If uid is not provided, check if all required fields for resolution are present
        <span class="cov0" title="0">missingFields := make([]string, 0)

        if name == "" </span><span class="cov0" title="0">{
                missingFields = append(missingFields, "name")
        }</span>
        <span class="cov0" title="0">if tag == "" </span><span class="cov0" title="0">{
                missingFields = append(missingFields, "tag")
        }</span>
        <span class="cov0" title="0">if registryUID == "" &amp;&amp; registryName == "" </span><span class="cov0" title="0">{
                missingFields = append(missingFields, "registry_uid or registry_name")
        }</span>

        <span class="cov0" title="0">if len(missingFields) &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("pack %s: either 'uid' must be provided, or all of the following fields must be specified for pack resolution: %s. Missing: %s",
                        name, "name, tag, registry_uid (or registry_name)", strings.Join(missingFields, ", "))
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file204" style="display: none">package schemas

import (
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
)

func ProfileVariables() *schema.Schema <span class="cov8" title="1">{
        return &amp;schema.Schema{
                Type:     schema.TypeList,
                MaxItems: 1,
                Optional: true,
                Elem: &amp;schema.Resource{
                        Schema: map[string]*schema.Schema{
                                "variable": {
                                        Type:     schema.TypeList,
                                        Required: true,
                                        Elem: &amp;schema.Resource{
                                                Schema: map[string]*schema.Schema{
                                                        "name": {
                                                                Type:        schema.TypeString,
                                                                Required:    true,
                                                                Description: "The name of the variable should be unique among variables.",
                                                        },
                                                        "display_name": {
                                                                Type:        schema.TypeString,
                                                                Required:    true,
                                                                Description: "The display name of the variable should be unique among variables.",
                                                        },
                                                        "format": {
                                                                Type:         schema.TypeString,
                                                                Optional:     true,
                                                                Default:      "string",
                                                                ValidateFunc: validation.StringInSlice([]string{"string", "number", "boolean", "ipv4", "ipv4cidr", "ipv6", "version"}, false),
                                                                Description:  "The format of the variable. Default is `string`, `format` field can only be set during cluster profile creation. Allowed formats include `string`, `number`, `boolean`, `ipv4`, `ipv4cidr`, `ipv6`, `version`.",
                                                        },
                                                        "description": {
                                                                Type:        schema.TypeString,
                                                                Optional:    true,
                                                                Description: "The description of the variable.",
                                                        },
                                                        "default_value": {
                                                                Type:        schema.TypeString,
                                                                Optional:    true,
                                                                Description: "The default value of the variable.",
                                                        },
                                                        "regex": {
                                                                Type:        schema.TypeString,
                                                                Optional:    true,
                                                                Description: "Regular expression pattern which the variable value must match.",
                                                        },
                                                        "required": {
                                                                Type:        schema.TypeBool,
                                                                Optional:    true,
                                                                Description: "The `required` to specify if the variable is optional or mandatory. If it is mandatory then default value must be provided.",
                                                        },
                                                        "immutable": {
                                                                Type:        schema.TypeBool,
                                                                Optional:    true,
                                                                Description: "If `immutable` is set to `true`, then variable value can't be editable. By default the `immutable` flag will be set to `false`.",
                                                        },
                                                        "is_sensitive": {
                                                                Type:        schema.TypeBool,
                                                                Optional:    true,
                                                                Description: "If `is_sensitive` is set to `true`, then default value will be masked. By default the `is_sensitive` flag will be set to false.",
                                                        },
                                                        "hidden": {
                                                                Type:        schema.TypeBool,
                                                                Optional:    true,
                                                                Description: "If `hidden` is set to `true`, then variable will be hidden for overriding the value. By default the `hidden` flag will be set to `false`.",
                                                        },
                                                },
                                        },
                                },
                        },
                },
                Description: "List of variables for the cluster profile.",
        }
}</span>
</pre>
		
		<pre class="file" id="file205" style="display: none">package schemas

import "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

func ScanPolicySchema() *schema.Schema <span class="cov10" title="21">{
        return &amp;schema.Schema{
                Type:        schema.TypeList,
                Optional:    true,
                MaxItems:    1,
                Description: "The scan policy for the cluster.",
                Elem: &amp;schema.Resource{
                        Schema: map[string]*schema.Schema{
                                "configuration_scan_schedule": {
                                        Type:        schema.TypeString,
                                        Required:    true,
                                        Description: "The schedule for configuration scan.",
                                },
                                "penetration_scan_schedule": {
                                        Type:        schema.TypeString,
                                        Required:    true,
                                        Description: "The schedule for penetration scan.",
                                },
                                "conformance_scan_schedule": {
                                        Type:        schema.TypeString,
                                        Required:    true,
                                        Description: "The schedule for conformance scan.",
                                },
                        },
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file206" style="display: none">package schemas

import (
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
)

func SubnetSchema() *schema.Schema <span class="cov10" title="2">{
        return &amp;schema.Schema{
                Type:         schema.TypeList,
                Optional:     true,
                MaxItems:     1,
                RequiredWith: []string{"cloud_config.0.network_resource_group", "cloud_config.0.virtual_network_name", "cloud_config.0.virtual_network_cidr_block"},
                Elem: &amp;schema.Resource{
                        Schema: map[string]*schema.Schema{
                                "name": {
                                        Type:        schema.TypeString,
                                        Required:    true,
                                        Description: "Name of the subnet.",
                                },
                                "cidr_block": {
                                        Type:        schema.TypeString,
                                        Required:    true,
                                        Description: "CidrBlock is the CIDR block to be used when the provider creates a managed virtual network.",
                                },
                                "security_group_name": {
                                        Type:        schema.TypeString,
                                        Optional:    true,
                                        Description: "Network Security Group(NSG) to be attached to subnet.",
                                },
                        },
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file207" style="display: none">package schemas

import (
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
)

func VMDeviceSchema() *schema.Schema <span class="cov0" title="0">{
        return &amp;schema.Schema{
                Type:     schema.TypeSet,
                Optional: true,
                MaxItems: 1,
                Elem: &amp;schema.Resource{
                        Schema: map[string]*schema.Schema{
                                "disk": {
                                        Type:     schema.TypeList,
                                        Required: true,
                                        Elem:     VMDiskSchema(),
                                },
                                "interface": {
                                        Type:     schema.TypeList,
                                        Required: true,
                                        Elem:     VMInterfaceSchema(),
                                },
                        },
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file208" style="display: none">package schemas

import (
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
)

func VMDiskSchema() *schema.Schema <span class="cov0" title="0">{
        return &amp;schema.Schema{
                Type:     schema.TypeList,
                Required: true,
                Elem: &amp;schema.Resource{
                        Schema: map[string]*schema.Schema{
                                "name": {
                                        Type:        schema.TypeString,
                                        Required:    true,
                                        Description: "The name of the disk. This is the name that will be used to identify the disk in the guest OS.",
                                },
                                "bus": {
                                        Type:        schema.TypeString,
                                        Required:    true,
                                        Description: "The bus type of the disk. This is the name that will be used to identify the disk in the guest OS.",
                                },
                        },
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file209" style="display: none">package schemas

import (
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
)

func VMInterfaceSchema() *schema.Schema <span class="cov0" title="0">{
        return &amp;schema.Schema{
                Type:     schema.TypeList,
                Required: true,
                Elem: &amp;schema.Resource{
                        Schema: map[string]*schema.Schema{
                                "name": {
                                        Type:        schema.TypeString,
                                        Required:    true,
                                        Description: "The name of the interface. This is the name that will be used to identify the device interface in the guest OS.",
                                },
                                "type": {
                                        Type:         schema.TypeString,
                                        Optional:     true,
                                        Default:      "masquerade",
                                        ValidateFunc: validation.StringInSlice([]string{"masquerade", "bridge", "macvtap"}, false),
                                        Description:  "The type of the interface. Can be one of `masquerade`, `bridge`, or `macvtap`. Defaults to `masquerade`.",
                                },
                                "model": {
                                        Type:        schema.TypeString,
                                        Optional:    true,
                                        Default:     "virtio",
                                        Description: "The model of the interface.",
                                },
                        },
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file210" style="display: none">package schemas

import "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

func VMNicSchema() *schema.Schema <span class="cov0" title="0">{
        return &amp;schema.Schema{
                Type:     schema.TypeSet,
                Optional: true,
                Elem: &amp;schema.Resource{
                        Schema: map[string]*schema.Schema{
                                "nic": {
                                        Type:     schema.TypeList,
                                        Optional: true,
                                        Elem: &amp;schema.Resource{
                                                Schema: map[string]*schema.Schema{
                                                        "name": {
                                                                Type:        schema.TypeString,
                                                                Required:    true,
                                                                Description: "The name of the network interface.",
                                                        },
                                                        "multus": {
                                                                Type:     schema.TypeList,
                                                                Optional: true,
                                                                MaxItems: 1,
                                                                Elem: &amp;schema.Resource{
                                                                        Schema: map[string]*schema.Schema{
                                                                                "network_name": {
                                                                                        Type:        schema.TypeString,
                                                                                        Required:    true,
                                                                                        Description: "The name of the network attachment definition.",
                                                                                },
                                                                                "default": {
                                                                                        Type:        schema.TypeBool,
                                                                                        Optional:    true,
                                                                                        Description: "Set this network as the default one for the pod.",
                                                                                },
                                                                        },
                                                                },
                                                                Description: "The multus configuration for the network interface.",
                                                        },
                                                        "network_type": {
                                                                Type:        schema.TypeString,
                                                                Optional:    true,
                                                                Description: "The name of the network to be attached to the virtual machine.",
                                                        },
                                                },
                                        },
                                        Description: "The network specification for the virtual machine.",
                                },
                        },
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file211" style="display: none">package schemas

import (
        "bytes"
        "fmt"
        "hash/fnv"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
)

func VMVolumeSchema() *schema.Schema <span class="cov0" title="0">{
        return &amp;schema.Schema{
                Type:     schema.TypeList,
                Optional: true,
                Elem: &amp;schema.Resource{
                        Schema: map[string]*schema.Schema{
                                "name": {
                                        Type:     schema.TypeString,
                                        Required: true,
                                },
                                "container_disk": {
                                        Type:     schema.TypeSet,
                                        Optional: true,
                                        Set:      resourceContainerDiskHash,
                                        Elem: &amp;schema.Resource{
                                                Schema: map[string]*schema.Schema{
                                                        "image_url": {
                                                                Type:        schema.TypeString,
                                                                Required:    true,
                                                                ForceNew:    true,
                                                                Description: "The URL of the container image to use as the disk. This can be a local file path, a remote URL, or a registry URL.",
                                                        },
                                                },
                                        },
                                        Description: "A container disk is a disk that is backed by a container image. The container image is expected to contain a disk image in a supported format. The disk image is extracted from the container image and used as the disk for the VM.",
                                },
                                "cloud_init_no_cloud": {
                                        Type:     schema.TypeSet,
                                        Optional: true,
                                        Set:      resourceCloudInitDiskHash,
                                        Elem: &amp;schema.Resource{
                                                Schema: map[string]*schema.Schema{
                                                        "user_data": {
                                                                Type:        schema.TypeString,
                                                                Required:    true,
                                                                Description: "The user data to use for the cloud-init no cloud disk. This can be a local file path, a remote URL, or a registry URL.",
                                                        },
                                                },
                                        },
                                        Description: "Used to specify a cloud-init `noCloud` image. The image is expected to contain a disk image in a supported format. The disk image is extracted from the cloud-init `noCloud `image and used as the disk for the VM",
                                },
                                "data_volume": {
                                        Type:     schema.TypeSet,
                                        Optional: true,
                                        Set:      resourceDataVolumeHash,
                                        Elem: &amp;schema.Resource{
                                                Schema: map[string]*schema.Schema{
                                                        "storage": {
                                                                Type:        schema.TypeString,
                                                                Required:    true,
                                                                Description: "Storage size of the data volume.",
                                                        },
                                                },
                                        },
                                        Description: "The name of the data volume to use as the disk.",
                                },
                        },
                },
        }
}</span>

func resourceContainerDiskHash(v interface{}) int <span class="cov0" title="0">{
        var buf bytes.Buffer
        m := v.(map[string]interface{})

        buf.WriteString(fmt.Sprintf("%s-", m["image_url"].(string)))

        return int(hash(buf.String()))
}</span>

func resourceCloudInitDiskHash(v interface{}) int <span class="cov0" title="0">{
        var buf bytes.Buffer
        m := v.(map[string]interface{})

        buf.WriteString(fmt.Sprintf("%s-", m["user_data"].(string)))

        return int(hash(buf.String()))
}</span>

func resourceDataVolumeHash(v interface{}) int <span class="cov0" title="0">{
        var buf bytes.Buffer
        m := v.(map[string]interface{})

        buf.WriteString(fmt.Sprintf("%s-", m["storage"].(string)))

        return int(hash(buf.String()))
}</span>

func hash(s string) uint32 <span class="cov0" title="0">{
        h := fnv.New32a()
        _, _ = h.Write([]byte(s))
        return h.Sum32()
}</span>
</pre>
		
		<pre class="file" id="file212" style="display: none">package schemas

import (
        "bytes"
        "fmt"
        "sort"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
)

func WorkspaceNamespacesSchema() *schema.Schema <span class="cov8" title="1">{
        return &amp;schema.Schema{
                Type:        schema.TypeSet,
                Optional:    true,
                Description: "The namespaces for the cluster.",
                Set:         resourceWorkspaceNamespaceHash,
                Elem: &amp;schema.Resource{
                        Schema: map[string]*schema.Schema{
                                "name": {
                                        Type:        schema.TypeString,
                                        Required:    true,
                                        Description: "Name of the namespace. This is the name of the Kubernetes namespace in the cluster.",
                                },
                                "resource_allocation": {
                                        Type:     schema.TypeMap,
                                        Required: true,
                                        Elem: &amp;schema.Schema{
                                                Type: schema.TypeString,
                                        },
                                        Description: "Resource allocation for the namespace. This is a map containing the resource type and the resource value. Only the following field names are supported for resource configuration: `cpu_cores`, `memory_MiB`, `gpu`, and `gpu_provider`. Any other field names will not be honored by the system. For example, `{cpu_cores: '2', memory_MiB: '2048', gpu: '1', gpu_provider: 'nvidia'}`",
                                },
                                "cluster_resource_allocations": {
                                        Type:     schema.TypeList,
                                        Optional: true,
                                        MaxItems: 1,
                                        Elem: &amp;schema.Resource{
                                                Schema: map[string]*schema.Schema{
                                                        "uid": {
                                                                Type:     schema.TypeString,
                                                                Required: true,
                                                        },
                                                        "resource_allocation": {
                                                                Type:     schema.TypeMap,
                                                                Required: true,
                                                                Elem: &amp;schema.Schema{
                                                                        Type: schema.TypeString,
                                                                },
                                                                Description: "Resource allocation for the cluster. This is a map containing the resource type and the resource value. Only the following field names are supported for resource configuration: `cpu_cores`, `memory_MiB`, `gpu`. Any other field names will not be honored by the system. For example, `{cpu_cores: '2', memory_MiB: '2048', gpu: '1'}`. Note: gpu_provider is not supported here; use the default resource_allocation for GPU provider configuration.",
                                                        },
                                                },
                                        },
                                },
                                "images_blacklist": {
                                        Type:     schema.TypeList,
                                        Optional: true,
                                        Elem: &amp;schema.Schema{
                                                Type: schema.TypeString,
                                        },
                                        Description: "List of images to disallow for the namespace. For example, `['nginx:latest', 'redis:latest']`",
                                },
                        },
                },
        }
}</span>

// resourceWorkspaceNamespaceHash creates a hash for workspace namespace TypeSet
// Namespace name is the primary identifier
func resourceWorkspaceNamespaceHash(v interface{}) int <span class="cov0" title="0">{
        m := v.(map[string]interface{})
        var buf bytes.Buffer

        // Primary identifier - name is required
        if val, ok := m["name"]; ok </span><span class="cov0" title="0">{
                if nameStr, ok := val.(string); ok &amp;&amp; nameStr != "" </span><span class="cov0" title="0">{
                        buf.WriteString(fmt.Sprintf("name-%s-", nameStr))
                }</span>
        }

        // Resource allocation - include in hash for drift detection
        // Exclude default/computed values to prevent hash mismatches
        <span class="cov0" title="0">if val, ok := m["resource_allocation"]; ok &amp;&amp; val != nil </span><span class="cov0" title="0">{
                if resourceAlloc, ok := val.(map[string]interface{}); ok &amp;&amp; len(resourceAlloc) &gt; 0 </span><span class="cov0" title="0">{
                        // Check if gpu_limit is set and non-zero (do this first)
                        gpuLimitSet := false
                        if gpuLimitVal, hasGpuLimit := resourceAlloc["gpu"]; hasGpuLimit </span><span class="cov0" title="0">{
                                if gpuLimitStr, ok := gpuLimitVal.(string); ok &amp;&amp; gpuLimitStr != "" &amp;&amp; gpuLimitStr != "0" </span><span class="cov0" title="0">{
                                        gpuLimitSet = true
                                }</span>
                        }

                        // Sort keys for deterministic hashing
                        <span class="cov0" title="0">keys := make([]string, 0, len(resourceAlloc))
                        for k := range resourceAlloc </span><span class="cov0" title="0">{
                                keys = append(keys, k)
                        }</span>
                        <span class="cov0" title="0">sort.Strings(keys)

                        for _, k := range keys </span><span class="cov0" title="0">{
                                v, ok := resourceAlloc[k].(string)
                                if !ok || v == "" </span><span class="cov0" title="0">{
                                        continue</span> // Skip empty values
                                }

                                // Skip default gpu_limit ("0")
                                <span class="cov0" title="0">if k == "gpu" &amp;&amp; v == "0" </span><span class="cov0" title="0">{
                                        continue</span>
                                }

                                // For gpu_provider: only include if gpu is set and non-zero
                                <span class="cov0" title="0">if k == "gpu_provider" </span><span class="cov0" title="0">{
                                        if !gpuLimitSet </span><span class="cov0" title="0">{
                                                continue</span> // Skip gpu_provider if gpu_limit is not set or is "0"
                                        }
                                        // Include gpu_provider when gpu_limit is set
                                        // Note: We include it even if it's "nvidia" (default) because
                                        // the user might have explicitly set it
                                }

                                // Include the field in hash
                                <span class="cov0" title="0">buf.WriteString(fmt.Sprintf("resource_allocation-%s-%s-", k, v))</span>
                        }
                }
        }
        // Resource allocation - include in hash for drift detection
        // if val, ok := m["resource_allocation"]; ok &amp;&amp; val != nil {
        //         if resourceAlloc, ok := val.(map[string]interface{}); ok &amp;&amp; len(resourceAlloc) &gt; 0 {
        //                 // Sort keys for deterministic hashing
        //                 keys := make([]string, 0, len(resourceAlloc))
        //                 for k := range resourceAlloc {
        //                         keys = append(keys, k)
        //                 }
        //                 sort.Strings(keys)
        //                 for _, k := range keys {
        //                         if v, ok := resourceAlloc[k].(string); ok &amp;&amp; v != "" {
        //                                 buf.WriteString(fmt.Sprintf("resource_allocation-%s-%s-", k, v))
        //                         }
        //                 }
        //         }
        // }

        // Cluster resource allocations - include in hash
        <span class="cov0" title="0">if val, ok := m["cluster_resource_allocations"]; ok &amp;&amp; val != nil </span><span class="cov0" title="0">{
                if clusterAllocs, ok := val.([]interface{}); ok &amp;&amp; len(clusterAllocs) &gt; 0 </span><span class="cov0" title="0">{
                        // Sort by UID for deterministic hashing
                        clusterUIDs := make([]string, 0, len(clusterAllocs))
                        clusterAllocMap := make(map[string]map[string]interface{})
                        for _, alloc := range clusterAllocs </span><span class="cov0" title="0">{
                                if allocMap, ok := alloc.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                        if uid, ok := allocMap["uid"].(string); ok &amp;&amp; uid != "" </span><span class="cov0" title="0">{
                                                clusterUIDs = append(clusterUIDs, uid)
                                                clusterAllocMap[uid] = allocMap
                                        }</span>
                                }
                        }
                        <span class="cov0" title="0">sort.Strings(clusterUIDs)
                        for _, uid := range clusterUIDs </span><span class="cov0" title="0">{
                                buf.WriteString(fmt.Sprintf("cluster_alloc-uid-%s-", uid))
                                if resourceAlloc, ok := clusterAllocMap[uid]["resource_allocation"]; ok &amp;&amp; resourceAlloc != nil </span><span class="cov0" title="0">{
                                        if ra, ok := resourceAlloc.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                                keys := make([]string, 0, len(ra))
                                                for k := range ra </span><span class="cov0" title="0">{
                                                        keys = append(keys, k)
                                                }</span>
                                                <span class="cov0" title="0">sort.Strings(keys)
                                                for _, k := range keys </span><span class="cov0" title="0">{
                                                        if v, ok := ra[k].(string); ok &amp;&amp; v != "" </span><span class="cov0" title="0">{
                                                                buf.WriteString(fmt.Sprintf("cluster_alloc-%s-%s-%s-", uid, k, v))
                                                        }</span>
                                                }
                                        }
                                }
                        }
                }
        }

        // Images blacklist - include in hash
        <span class="cov0" title="0">if val, ok := m["images_blacklist"]; ok &amp;&amp; val != nil </span><span class="cov0" title="0">{
                if images, ok := val.([]interface{}); ok &amp;&amp; len(images) &gt; 0 </span><span class="cov0" title="0">{
                        imageStrs := make([]string, 0, len(images))
                        for _, img := range images </span><span class="cov0" title="0">{
                                if imgStr, ok := img.(string); ok &amp;&amp; imgStr != "" </span><span class="cov0" title="0">{
                                        imageStrs = append(imageStrs, imgStr)
                                }</span>
                        }
                        // Sort for deterministic hashing
                        <span class="cov0" title="0">sort.Strings(imageStrs)
                        for _, img := range imageStrs </span><span class="cov0" title="0">{
                                buf.WriteString(fmt.Sprintf("images_blacklist-%s-", img))
                        }</span>
                }
        }
        <span class="cov0" title="0">return int(hash(buf.String()))</span>
}
</pre>
		
		<pre class="file" id="file213" style="display: none">// Copyright (c) Spectro Cloud
// SPDX-License-Identifier: MPL-2.0

// Package testutil provides common utilities for testing the Spectro Cloud provider.
package testutil

import (
        "context"
        "fmt"
        "net/http"
        "os"
        "strings"
        "testing"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/hashicorp/terraform-plugin-testing/helper/resource"
        "github.com/hashicorp/terraform-plugin-testing/terraform"
        "github.com/spectrocloud/palette-sdk-go/client"
        "github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/testutil/vcr"
)

// TestAccPreCheck validates the necessary test environment variables exist
// before running acceptance tests.
func TestAccPreCheck(t *testing.T) <span class="cov0" title="0">{
        if v := os.Getenv("SPECTROCLOUD_APIKEY"); v == "" </span><span class="cov0" title="0">{
                t.Fatal("SPECTROCLOUD_APIKEY must be set for acceptance tests")
        }</span>
        <span class="cov0" title="0">if v := os.Getenv("SPECTROCLOUD_HOST"); v == "" </span><span class="cov0" title="0">{
                // Set default if not provided
                os.Setenv("SPECTROCLOUD_HOST", "api.spectrocloud.com")
        }</span>
}

// TestAccPreCheckWithVCR is like TestAccPreCheck but skips API key requirement
// when running in VCR replay mode.
func TestAccPreCheckWithVCR(t *testing.T) <span class="cov0" title="0">{
        mode := vcr.GetMode()
        if mode == vcr.ModeReplaying </span><span class="cov0" title="0">{
                // In replay mode, we don't need real credentials
                return
        }</span>
        <span class="cov0" title="0">TestAccPreCheck(t)</span>
}

// ProviderFactories returns the provider factories for acceptance tests
func ProviderFactories(provider *schema.Provider) map[string]func() (*schema.Provider, error) <span class="cov0" title="0">{
        return map[string]func() (*schema.Provider, error){
                "spectrocloud": func() (*schema.Provider, error) </span><span class="cov0" title="0">{
                        return provider, nil
                }</span>,
        }
}

// VCRProviderFactories returns provider factories configured with VCR transport
func VCRProviderFactories(t *testing.T, cassetteName string, provider *schema.Provider) (map[string]func() (*schema.Provider, error), func()) <span class="cov0" title="0">{
        mode := vcr.GetMode()

        recorder, err := vcr.NewRecorder(cassetteName, mode)
        if err != nil </span><span class="cov0" title="0">{
                if mode == vcr.ModeReplaying </span><span class="cov0" title="0">{
                        t.Skipf("Skipping test: cassette %s not found. Run with VCR_RECORD=true to record.", cassetteName)
                }</span>
                <span class="cov0" title="0">t.Fatalf("Failed to create VCR recorder: %v", err)</span>
        }

        // Configure HTTP client with VCR transport
        <span class="cov0" title="0">httpClient := &amp;http.Client{Transport: recorder}

        // Create provider with custom HTTP client
        providerFunc := func() (*schema.Provider, error) </span><span class="cov0" title="0">{
                // The provider will use the VCR-enabled HTTP client
                return provider, nil
        }</span>

        <span class="cov0" title="0">cleanup := func() </span><span class="cov0" title="0">{
                if err := recorder.Stop(); err != nil </span><span class="cov0" title="0">{
                        t.Errorf("Failed to stop VCR recorder: %v", err)
                }</span>
        }

        // Store HTTP client for use in provider configuration
        <span class="cov0" title="0">_ = httpClient // Will be used when we configure the provider

        return map[string]func() (*schema.Provider, error){
                "spectrocloud": providerFunc,
        }, cleanup</span>
}

// GetTestClient creates a Palette SDK client for testing
func GetTestClient() (*client.V1Client, error) <span class="cov0" title="0">{
        host := os.Getenv("SPECTROCLOUD_HOST")
        if host == "" </span><span class="cov0" title="0">{
                host = "api.spectrocloud.com"
        }</span>

        <span class="cov0" title="0">apiKey := os.Getenv("SPECTROCLOUD_APIKEY")
        if apiKey == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("SPECTROCLOUD_APIKEY environment variable not set")
        }</span>

        <span class="cov0" title="0">c := client.New(
                client.WithPaletteURI(host),
                client.WithAPIKey(apiKey),
                client.WithInsecureSkipVerify(true),
                client.WithRetries(3),
        )

        return c, nil</span>
}

// GetTestClientWithVCR creates a client configured with VCR transport
// NOTE: This function requires the palette-sdk-go to support custom HTTP client injection.
// Until then, VCR testing will use the acceptance test approach with terraform-plugin-testing.
func GetTestClientWithVCR(t *testing.T, cassetteName string) (*client.V1Client, func()) <span class="cov0" title="0">{
        mode := vcr.GetMode()

        recorder, err := vcr.NewRecorder(cassetteName, mode)
        if err != nil </span><span class="cov0" title="0">{
                if mode == vcr.ModeReplaying </span><span class="cov0" title="0">{
                        t.Skipf("Skipping test: cassette %s not found", cassetteName)
                }</span>
                <span class="cov0" title="0">t.Fatalf("Failed to create VCR recorder: %v", err)</span>
        }

        <span class="cov0" title="0">host := os.Getenv("SPECTROCLOUD_HOST")
        if host == "" </span><span class="cov0" title="0">{
                host = "api.spectrocloud.com"
        }</span>

        <span class="cov0" title="0">apiKey := os.Getenv("SPECTROCLOUD_APIKEY")
        if apiKey == "" &amp;&amp; mode != vcr.ModeReplaying </span><span class="cov0" title="0">{
                t.Fatal("SPECTROCLOUD_APIKEY must be set when not in VCR replay mode")
        }</span>
        <span class="cov0" title="0">if apiKey == "" </span><span class="cov0" title="0">{
                apiKey = "vcr-replay-dummy-key"
        }</span>

        // TODO: The palette-sdk-go client needs to support custom HTTP client/transport injection
        // For now, we create a standard client. To fully enable VCR, add this to palette-sdk-go:
        //   func WithHTTPClient(httpClient *http.Client) func(*V1Client) { ... }
        //
        // Then use: client.WithHTTPClient(&amp;http.Client{Transport: recorder})
        <span class="cov0" title="0">c := client.New(
                client.WithPaletteURI(host),
                client.WithAPIKey(apiKey),
                client.WithInsecureSkipVerify(true),
                client.WithRetries(1),
        )

        // Store recorder for use (currently not connected to client)
        _ = recorder

        cleanup := func() </span><span class="cov0" title="0">{
                if err := recorder.Stop(); err != nil </span><span class="cov0" title="0">{
                        t.Errorf("Failed to stop VCR recorder: %v", err)
                }</span>
        }

        <span class="cov0" title="0">return c, cleanup</span>
}

// ComposeTestCheckFunc is a helper to compose multiple check functions
func ComposeTestCheckFunc(fs ...resource.TestCheckFunc) resource.TestCheckFunc <span class="cov0" title="0">{
        return resource.ComposeTestCheckFunc(fs...)
}</span>

// CheckResourceExists is a helper to verify a resource exists
func CheckResourceExists(resourceName string, checkFunc func(rs *terraform.ResourceState) error) resource.TestCheckFunc <span class="cov0" title="0">{
        return func(s *terraform.State) error </span><span class="cov0" title="0">{
                rs, ok := s.RootModule().Resources[resourceName]
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("resource not found: %s", resourceName)
                }</span>
                <span class="cov0" title="0">if rs.Primary.ID == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("resource ID not set: %s", resourceName)
                }</span>
                <span class="cov0" title="0">if checkFunc != nil </span><span class="cov0" title="0">{
                        return checkFunc(rs)
                }</span>
                <span class="cov0" title="0">return nil</span>
        }
}

// CheckResourceDestroyed is a helper to verify a resource was destroyed
func CheckResourceDestroyed(resourceType string, checkFunc func(id string) error) resource.TestCheckFunc <span class="cov0" title="0">{
        return func(s *terraform.State) error </span><span class="cov0" title="0">{
                for _, rs := range s.RootModule().Resources </span><span class="cov0" title="0">{
                        if rs.Type != resourceType </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">if err := checkFunc(rs.Primary.ID); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
                <span class="cov0" title="0">return nil</span>
        }
}

// RandomName generates a random name with a prefix for test resources
func RandomName(prefix string) string <span class="cov4" title="3">{
        return fmt.Sprintf("%s-%s", prefix, RandomString(8))
}</span>

// RandomString generates a random alphanumeric string
func RandomString(length int) string <span class="cov4" title="3">{
        const charset = "abcdefghijklmnopqrstuvwxyz0123456789"
        result := make([]byte, length)
        for i := range result </span><span class="cov10" title="24">{
                result[i] = charset[i%len(charset)]
        }</span>
        <span class="cov4" title="3">return string(result)</span>
}

// TestContext creates a context for test operations
func TestContext() context.Context <span class="cov0" title="0">{
        return context.Background()
}</span>

// ConfigCompose combines multiple Terraform configuration strings
func ConfigCompose(configs ...string) string <span class="cov0" title="0">{
        var builder strings.Builder
        for _, config := range configs </span><span class="cov0" title="0">{
                builder.WriteString(config)
                builder.WriteString("\n")
        }</span>
        <span class="cov0" title="0">return builder.String()</span>
}

// SkipIfEnvNotSet skips the test if any of the specified environment variables are not set
func SkipIfEnvNotSet(t *testing.T, envVars ...string) <span class="cov0" title="0">{
        for _, envVar := range envVars </span><span class="cov0" title="0">{
                if os.Getenv(envVar) == "" </span><span class="cov0" title="0">{
                        t.Skipf("Skipping test: %s environment variable not set", envVar)
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file214" style="display: none">// Copyright (c) Spectro Cloud
// SPDX-License-Identifier: MPL-2.0

package testutil

import (
        "github.com/spectrocloud/palette-sdk-go/api/models"
)

// Fixtures provides factory methods for creating test data
type Fixtures struct{}

// NewFixtures creates a new Fixtures instance
func NewFixtures() *Fixtures <span class="cov1" title="1">{
        return &amp;Fixtures{}
}</span>

// ProjectOption is a functional option for configuring a test project
type ProjectOption func(*models.V1ProjectEntity)

// Project creates a test project entity with optional configurations
func (f *Fixtures) Project(opts ...ProjectOption) *models.V1ProjectEntity <span class="cov0" title="0">{
        project := &amp;models.V1ProjectEntity{
                Metadata: &amp;models.V1ObjectMeta{
                        Name:        "test-project",
                        UID:         "",
                        Labels:      make(map[string]string),
                        Annotations: make(map[string]string),
                },
        }

        for _, opt := range opts </span><span class="cov0" title="0">{
                opt(project)
        }</span>

        <span class="cov0" title="0">return project</span>
}

// WithProjectName sets the project name
func WithProjectName(name string) ProjectOption <span class="cov0" title="0">{
        return func(p *models.V1ProjectEntity) </span><span class="cov0" title="0">{
                p.Metadata.Name = name
        }</span>
}

// WithProjectUID sets the project UID
func WithProjectUID(uid string) ProjectOption <span class="cov0" title="0">{
        return func(p *models.V1ProjectEntity) </span><span class="cov0" title="0">{
                p.Metadata.UID = uid
        }</span>
}

// WithProjectDescription sets the project description
func WithProjectDescription(description string) ProjectOption <span class="cov0" title="0">{
        return func(p *models.V1ProjectEntity) </span><span class="cov0" title="0">{
                if p.Metadata.Annotations == nil </span><span class="cov0" title="0">{
                        p.Metadata.Annotations = make(map[string]string)
                }</span>
                <span class="cov0" title="0">p.Metadata.Annotations["description"] = description</span>
        }
}

// WithProjectLabels sets the project labels (tags)
func WithProjectLabels(labels map[string]string) ProjectOption <span class="cov0" title="0">{
        return func(p *models.V1ProjectEntity) </span><span class="cov0" title="0">{
                p.Metadata.Labels = labels
        }</span>
}

// ProjectResponse creates a test project response (as returned by API)
func (f *Fixtures) ProjectResponse(opts ...ProjectResponseOption) *models.V1Project <span class="cov1" title="1">{
        project := &amp;models.V1Project{
                Metadata: &amp;models.V1ObjectMeta{
                        Name:        "test-project",
                        UID:         "test-uid-123",
                        Labels:      make(map[string]string),
                        Annotations: make(map[string]string),
                },
                Spec: &amp;models.V1ProjectSpec{
                        LogoURL: "",
                },
                Status: &amp;models.V1ProjectStatus{
                        IsDisabled: false,
                },
        }

        for _, opt := range opts </span><span class="cov10" title="3">{
                opt(project)
        }</span>

        <span class="cov1" title="1">return project</span>
}

// ProjectResponseOption is a functional option for configuring a test project response
type ProjectResponseOption func(*models.V1Project)

// WithResponseProjectName sets the project name in response
func WithResponseProjectName(name string) ProjectResponseOption <span class="cov1" title="1">{
        return func(p *models.V1Project) </span><span class="cov1" title="1">{
                p.Metadata.Name = name
        }</span>
}

// WithResponseProjectUID sets the project UID in response
func WithResponseProjectUID(uid string) ProjectResponseOption <span class="cov1" title="1">{
        return func(p *models.V1Project) </span><span class="cov1" title="1">{
                p.Metadata.UID = uid
        }</span>
}

// WithResponseProjectDescription sets the project description in response
func WithResponseProjectDescription(description string) ProjectResponseOption <span class="cov1" title="1">{
        return func(p *models.V1Project) </span><span class="cov1" title="1">{
                if p.Metadata.Annotations == nil </span><span class="cov0" title="0">{
                        p.Metadata.Annotations = make(map[string]string)
                }</span>
                <span class="cov1" title="1">p.Metadata.Annotations["description"] = description</span>
        }
}

// WithResponseProjectLabels sets the project labels in response
func WithResponseProjectLabels(labels map[string]string) ProjectResponseOption <span class="cov0" title="0">{
        return func(p *models.V1Project) </span><span class="cov0" title="0">{
                p.Metadata.Labels = labels
        }</span>
}
</pre>
		
		<pre class="file" id="file215" style="display: none">// Copyright (c) Spectro Cloud
// SPDX-License-Identifier: MPL-2.0

// Package vcr provides HTTP recording and replay functionality for testing.
// This implements a VCR (Video Cassette Recorder) pattern that:
// - Records real HTTP interactions during "record" mode
// - Replays recorded interactions during "replay" mode
// - Eliminates the need for external mock servers
package vcr

import (
        "bytes"
        "crypto/md5"
        "encoding/hex"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "os"
        "path/filepath"
        "sort"
        "strings"
        "sync"
)

// Mode represents the VCR operating mode
type Mode int

const (
        // ModeDisabled - VCR is disabled, pass through to real transport
        ModeDisabled Mode = iota
        // ModeRecording - Record real HTTP interactions to cassette
        ModeRecording
        // ModeReplaying - Replay interactions from cassette
        ModeReplaying
)

// Interaction represents a single HTTP request/response pair
type Interaction struct {
        Request  Request  `json:"request"`
        Response Response `json:"response"`
}

// Request represents a recorded HTTP request
type Request struct {
        Method  string            `json:"method"`
        URL     string            `json:"url"`
        Headers map[string]string `json:"headers,omitempty"`
        Body    string            `json:"body,omitempty"`
}

// Response represents a recorded HTTP response
type Response struct {
        StatusCode int               `json:"status_code"`
        Status     string            `json:"status"`
        Headers    map[string]string `json:"headers,omitempty"`
        Body       string            `json:"body"`
}

// Cassette stores all interactions for a test scenario
type Cassette struct {
        Name         string        `json:"name"`
        Interactions []Interaction `json:"interactions"`

        mu    sync.Mutex
        index int
}

// Recorder is the main VCR recorder/player
type Recorder struct {
        cassette      *Cassette
        mode          Mode
        realTransport http.RoundTripper
        mu            sync.Mutex

        // FilterHeaders contains headers to filter out (e.g., Authorization)
        FilterHeaders []string

        // MatcherFunc allows custom request matching logic
        MatcherFunc func(r *http.Request, recorded *Request) bool
}

// NewRecorder creates a new VCR recorder
func NewRecorder(cassetteName string, mode Mode) (*Recorder, error) <span class="cov1" title="1">{
        r := &amp;Recorder{
                mode:          mode,
                realTransport: http.DefaultTransport,
                FilterHeaders: []string{"Authorization", "ApiKey", "X-Api-Key"},
        }

        cassetteDir := getCassetteDir()
        cassettePath := filepath.Join(cassetteDir, cassetteName+".json")

        if mode == ModeReplaying </span><span class="cov1" title="1">{
                // Load existing cassette
                cassette, err := LoadCassette(cassettePath)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to load cassette %s: %w", cassetteName, err)
                }</span>
                <span class="cov1" title="1">r.cassette = cassette</span>
        } else<span class="cov0" title="0"> if mode == ModeRecording </span><span class="cov0" title="0">{
                // Create new cassette
                r.cassette = &amp;Cassette{
                        Name:         cassetteName,
                        Interactions: []Interaction{},
                }
        }</span>

        <span class="cov1" title="1">return r, nil</span>
}

// SetRealTransport sets the underlying transport for recording mode
func (r *Recorder) SetRealTransport(transport http.RoundTripper) <span class="cov0" title="0">{
        r.realTransport = transport
}</span>

// RoundTrip implements http.RoundTripper
func (r *Recorder) RoundTrip(req *http.Request) (*http.Response, error) <span class="cov0" title="0">{
        if r.mode == ModeDisabled </span><span class="cov0" title="0">{
                return r.realTransport.RoundTrip(req)
        }</span>

        <span class="cov0" title="0">if r.mode == ModeReplaying </span><span class="cov0" title="0">{
                return r.replay(req)
        }</span>

        <span class="cov0" title="0">return r.record(req)</span>
}

// record makes a real request and records the interaction
func (r *Recorder) record(req *http.Request) (*http.Response, error) <span class="cov0" title="0">{
        // Read request body
        var reqBody []byte
        if req.Body != nil </span><span class="cov0" title="0">{
                var err error
                reqBody, err = io.ReadAll(req.Body)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to read request body: %w", err)
                }</span>
                <span class="cov0" title="0">req.Body = io.NopCloser(bytes.NewReader(reqBody))</span>
        }

        // Make real request
        <span class="cov0" title="0">resp, err := r.realTransport.RoundTrip(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Read response body
        <span class="cov0" title="0">respBody, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read response body: %w", err)
        }</span>
        <span class="cov0" title="0">resp.Body.Close()
        resp.Body = io.NopCloser(bytes.NewReader(respBody))

        // Record interaction
        interaction := Interaction{
                Request: Request{
                        Method:  req.Method,
                        URL:     req.URL.String(),
                        Headers: r.filterHeaders(req.Header),
                        Body:    string(reqBody),
                },
                Response: Response{
                        StatusCode: resp.StatusCode,
                        Status:     resp.Status,
                        Headers:    headerToMap(resp.Header),
                        Body:       string(respBody),
                },
        }

        r.mu.Lock()
        r.cassette.Interactions = append(r.cassette.Interactions, interaction)
        r.mu.Unlock()

        return resp, nil</span>
}

// replay finds a matching interaction and returns the recorded response
func (r *Recorder) replay(req *http.Request) (*http.Response, error) <span class="cov0" title="0">{
        r.mu.Lock()
        defer r.mu.Unlock()

        // Read request body for matching
        var reqBody []byte
        if req.Body != nil </span><span class="cov0" title="0">{
                var err error
                reqBody, err = io.ReadAll(req.Body)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to read request body: %w", err)
                }</span>
                <span class="cov0" title="0">req.Body = io.NopCloser(bytes.NewReader(reqBody))</span>
        }

        // Find matching interaction
        <span class="cov0" title="0">for _, interaction := range r.cassette.Interactions </span><span class="cov0" title="0">{
                if r.matches(req, &amp;interaction.Request, string(reqBody)) </span><span class="cov0" title="0">{
                        return r.buildResponse(&amp;interaction.Response, req), nil
                }</span>
        }

        <span class="cov0" title="0">return nil, fmt.Errorf("no matching interaction found for %s %s", req.Method, req.URL.String())</span>
}

// matches checks if a request matches a recorded request
func (r *Recorder) matches(req *http.Request, recorded *Request, reqBody string) bool <span class="cov0" title="0">{
        // Use custom matcher if provided
        if r.MatcherFunc != nil </span><span class="cov0" title="0">{
                return r.MatcherFunc(req, recorded)
        }</span>

        // Default matching: method + URL path (without query params for flexibility)
        <span class="cov0" title="0">if req.Method != recorded.Method </span><span class="cov0" title="0">{
                return false
        }</span>

        // Compare URL paths
        <span class="cov0" title="0">reqPath := req.URL.Path
        recordedURL := recorded.URL
        if idx := strings.Index(recordedURL, "?"); idx != -1 </span><span class="cov0" title="0">{
                recordedURL = recordedURL[:idx]
        }</span>
        <span class="cov0" title="0">if !strings.HasSuffix(recordedURL, reqPath) &amp;&amp; !strings.Contains(recordedURL, reqPath) </span><span class="cov0" title="0">{
                return false
        }</span>

        // For POST/PUT/PATCH, also match body hash for uniqueness
        <span class="cov0" title="0">if req.Method == "POST" || req.Method == "PUT" || req.Method == "PATCH" </span><span class="cov0" title="0">{
                if hashBody(reqBody) != hashBody(recorded.Body) </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return true</span>
}

// buildResponse creates an http.Response from a recorded Response
func (r *Recorder) buildResponse(recorded *Response, req *http.Request) *http.Response <span class="cov0" title="0">{
        header := make(http.Header)
        for k, v := range recorded.Headers </span><span class="cov0" title="0">{
                header.Set(k, v)
        }</span>

        <span class="cov0" title="0">return &amp;http.Response{
                StatusCode:    recorded.StatusCode,
                Status:        recorded.Status,
                Header:        header,
                Body:          io.NopCloser(bytes.NewReader([]byte(recorded.Body))),
                ContentLength: int64(len(recorded.Body)),
                Request:       req,
        }</span>
}

// filterHeaders removes sensitive headers from the recording
func (r *Recorder) filterHeaders(h http.Header) map[string]string <span class="cov0" title="0">{
        result := make(map[string]string)
        for key, values := range h </span><span class="cov0" title="0">{
                skip := false
                for _, filter := range r.FilterHeaders </span><span class="cov0" title="0">{
                        if strings.EqualFold(key, filter) </span><span class="cov0" title="0">{
                                skip = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !skip &amp;&amp; len(values) &gt; 0 </span><span class="cov0" title="0">{
                        result[key] = values[0]
                }</span>
        }
        <span class="cov0" title="0">return result</span>
}

// Stop saves the cassette if in recording mode
func (r *Recorder) Stop() error <span class="cov1" title="1">{
        if r.mode == ModeRecording &amp;&amp; r.cassette != nil </span><span class="cov0" title="0">{
                return r.cassette.Save()
        }</span>
        <span class="cov1" title="1">return nil</span>
}

// Save writes the cassette to disk
func (c *Cassette) Save() error <span class="cov0" title="0">{
        cassetteDir := getCassetteDir()
        if err := os.MkdirAll(cassetteDir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create cassette directory: %w", err)
        }</span>

        <span class="cov0" title="0">cassettePath := filepath.Join(cassetteDir, c.Name+".json")

        data, err := json.MarshalIndent(c, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal cassette: %w", err)
        }</span>

        <span class="cov0" title="0">if err := os.WriteFile(cassettePath, data, 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write cassette: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// LoadCassette loads a cassette from disk
func LoadCassette(path string) (*Cassette, error) <span class="cov1" title="1">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">var cassette Cassette
        if err := json.Unmarshal(data, &amp;cassette); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal cassette: %w", err)
        }</span>

        <span class="cov1" title="1">return &amp;cassette, nil</span>
}

// getCassetteDir returns the directory for storing cassettes
func getCassetteDir() string <span class="cov1" title="1">{
        // Check for custom cassette directory
        if dir := os.Getenv("VCR_CASSETTE_DIR"); dir != "" </span><span class="cov0" title="0">{
                return dir
        }</span>

        // Try multiple locations for cassettes
        // 1. Current working directory
        <span class="cov1" title="1">cwd, _ := os.Getwd()

        // 2. testdata/cassettes relative to cwd
        dir := filepath.Join(cwd, "testdata", "cassettes")
        if _, err := os.Stat(dir); err == nil </span><span class="cov1" title="1">{
                return dir
        }</span>

        // 3. spectrocloud/testdata/cassettes (from project root)
        <span class="cov0" title="0">dir = filepath.Join(cwd, "spectrocloud", "testdata", "cassettes")
        if _, err := os.Stat(dir); err == nil </span><span class="cov0" title="0">{
                return dir
        }</span>

        // 4. ../testdata/cassettes (from spectrocloud dir)
        <span class="cov0" title="0">dir = filepath.Join(cwd, "..", "testdata", "cassettes")
        if _, err := os.Stat(dir); err == nil </span><span class="cov0" title="0">{
                return dir
        }</span>

        // Default to testdata/cassettes in current directory
        <span class="cov0" title="0">return filepath.Join("testdata", "cassettes")</span>
}

// headerToMap converts http.Header to map[string]string
func headerToMap(h http.Header) map[string]string <span class="cov0" title="0">{
        result := make(map[string]string)
        for key, values := range h </span><span class="cov0" title="0">{
                if len(values) &gt; 0 </span><span class="cov0" title="0">{
                        result[key] = values[0]
                }</span>
        }
        <span class="cov0" title="0">return result</span>
}

// hashBody creates a simple hash of request body for matching
func hashBody(body string) string <span class="cov0" title="0">{
        if body == "" </span><span class="cov0" title="0">{
                return ""
        }</span>

        // Normalize JSON for consistent hashing
        <span class="cov0" title="0">var normalized interface{}
        if err := json.Unmarshal([]byte(body), &amp;normalized); err == nil </span><span class="cov0" title="0">{
                if sortedBody, err := json.Marshal(sortKeys(normalized)); err == nil </span><span class="cov0" title="0">{
                        body = string(sortedBody)
                }</span>
        }

        <span class="cov0" title="0">hash := md5.Sum([]byte(body))
        return hex.EncodeToString(hash[:])</span>
}

// sortKeys recursively sorts map keys for consistent JSON comparison
func sortKeys(v interface{}) interface{} <span class="cov0" title="0">{
        switch v := v.(type) </span>{
        case map[string]interface{}:<span class="cov0" title="0">
                sorted := make(map[string]interface{})
                keys := make([]string, 0, len(v))
                for k := range v </span><span class="cov0" title="0">{
                        keys = append(keys, k)
                }</span>
                <span class="cov0" title="0">sort.Strings(keys)
                for _, k := range keys </span><span class="cov0" title="0">{
                        sorted[k] = sortKeys(v[k])
                }</span>
                <span class="cov0" title="0">return sorted</span>
        case []interface{}:<span class="cov0" title="0">
                for i, item := range v </span><span class="cov0" title="0">{
                        v[i] = sortKeys(item)
                }</span>
                <span class="cov0" title="0">return v</span>
        default:<span class="cov0" title="0">
                return v</span>
        }
}

// GetMode returns the VCR mode based on environment variables
func GetMode() Mode <span class="cov10" title="2">{
        if os.Getenv("VCR_RECORD") == "true" || os.Getenv("VCR_RECORD") == "1" </span><span class="cov0" title="0">{
                return ModeRecording
        }</span>
        <span class="cov10" title="2">if os.Getenv("VCR_DISABLED") == "true" || os.Getenv("VCR_DISABLED") == "1" </span><span class="cov0" title="0">{
                return ModeDisabled
        }</span>
        <span class="cov10" title="2">return ModeReplaying</span>
}
</pre>
		
		<pre class="file" id="file216" style="display: none">package spectrocloud

import (
        "math"
        "time"

        "github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/common"
)

// SafeInt32 converts int to int32 with bounds checking to prevent overflow
func SafeInt32(value int) int32 <span class="cov0" title="0">{
        if value &gt; math.MaxInt32 </span><span class="cov0" title="0">{
                return math.MaxInt32
        }</span>
        <span class="cov0" title="0">if value &lt; math.MinInt32 </span><span class="cov0" title="0">{
                return math.MinInt32
        }</span>
        <span class="cov0" title="0">return int32(value)</span>
}

// SafeInt64 converts int to int64 with bounds checking to prevent overflow
func SafeInt64(value int) int64 <span class="cov0" title="0">{
        return int64(value)
}</span>

// SafeUint32 converts int to uint32 with bounds checking to prevent overflow
func SafeUint32(value int) uint32 <span class="cov0" title="0">{
        return common.SafeUint32(value)
}</span>

func expandStringList(configured []interface{}) []string <span class="cov0" title="0">{
        vs := make([]string, 0)
        for _, v := range configured </span><span class="cov0" title="0">{
                if v != nil </span><span class="cov0" title="0">{
                        vs = append(vs, v.(string))
                }</span>
        }
        <span class="cov0" title="0">return vs</span>
}

func expandStringMap(configured map[string]interface{}) map[string]string <span class="cov0" title="0">{
        vs := make(map[string]string)
        for i, j := range configured </span><span class="cov0" title="0">{
                vs[i] = j.(string)
        }</span>
        <span class="cov0" title="0">return vs</span>
}

func stringContains(a []string, x string) bool <span class="cov0" title="0">{
        for _, n := range a </span><span class="cov0" title="0">{
                if x == n </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func filter[T any](ss []T, test func(T) bool) (ret []T) <span class="cov0" title="0">{
        for _, s := range ss </span><span class="cov0" title="0">{
                if test(s) </span><span class="cov0" title="0">{
                        ret = append(ret, s)
                }</span>
        }
        <span class="cov0" title="0">return</span>
}

func IsMapSubset[K, V comparable](m, sub map[K]V) bool <span class="cov0" title="0">{
        if len(sub) &gt; len(m) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">for k, vsub := range sub </span><span class="cov0" title="0">{
                if vm, found := m[k]; !found || vm != vsub </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov0" title="0">return true</span>
}

func Bool(b *bool) bool <span class="cov0" title="0">{
        if b == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return *b</span>
}

func BoolPtr(b bool) *bool <span class="cov0" title="0">{
        bol := b
        return &amp;bol
}</span>

func Int(i *int) int <span class="cov0" title="0">{
        if i == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">return *i</span>
}

func IntPtr(i int) *int <span class="cov0" title="0">{
        it := i
        return &amp;it
}</span>

func Int8(i *int8) int8 <span class="cov0" title="0">{
        if i == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">return *i</span>
}

func Int8WithDefault(i *int8, defaultVal int8) int8 <span class="cov0" title="0">{
        if i == nil </span><span class="cov0" title="0">{
                return defaultVal
        }</span>
        <span class="cov0" title="0">return *i</span>
}

func Int8Ptr(i int8) *int8 <span class="cov0" title="0">{
        it := i
        return &amp;it
}</span>

func Int16(i *int16) int16 <span class="cov0" title="0">{
        if i == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">return *i</span>
}

func Int16WithDefault(i *int16, defaultVal int16) int16 <span class="cov0" title="0">{
        if i == nil </span><span class="cov0" title="0">{
                return defaultVal
        }</span>
        <span class="cov0" title="0">return *i</span>
}

func Int16Ptr(i int16) *int16 <span class="cov0" title="0">{
        it := i
        return &amp;it
}</span>

func Int32(i *int32) int32 <span class="cov0" title="0">{
        if i == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">return *i</span>
}

func Int32WithDefault(i *int32, defaultVal int32) int32 <span class="cov0" title="0">{
        if i == nil </span><span class="cov0" title="0">{
                return defaultVal
        }</span>
        <span class="cov0" title="0">return *i</span>
}

func Int32Ptr(i int32) *int32 <span class="cov0" title="0">{
        it := i
        return &amp;it
}</span>

func Int64(i *int64) int64 <span class="cov0" title="0">{
        if i == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">return *i</span>
}

func Int64WithDefault(i *int64, defaultVal int64) int64 <span class="cov0" title="0">{
        if i == nil </span><span class="cov0" title="0">{
                return defaultVal
        }</span>
        <span class="cov0" title="0">return *i</span>
}

func Int64Ptr(i int64) *int64 <span class="cov0" title="0">{
        it := i
        return &amp;it
}</span>

func Float32Ptr(f float32) *float32 <span class="cov0" title="0">{
        it := f
        return &amp;it
}</span>

func Float32WithDefault(f *float32, defaultVal float32) float32 <span class="cov0" title="0">{
        if f == nil </span><span class="cov0" title="0">{
                return defaultVal
        }</span>
        <span class="cov0" title="0">return *f</span>
}

func Float64Ptr(f float64) *float64 <span class="cov0" title="0">{
        it := f
        return &amp;it
}</span>

func Float64WithDefault(f *float64, defaultVal float64) float64 <span class="cov0" title="0">{
        if f == nil </span><span class="cov0" title="0">{
                return defaultVal
        }</span>
        <span class="cov0" title="0">return *f</span>
}

func String(s *string) string <span class="cov0" title="0">{
        if s == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return *s</span>
}

func StringWithDefaultValue(s *string, defaultVal string) string <span class="cov0" title="0">{
        if s == nil </span><span class="cov0" title="0">{
                return defaultVal
        }</span>
        <span class="cov0" title="0">return *s</span>
}

func StringPtr(s string) *string <span class="cov0" title="0">{
        str := s
        return &amp;str
}</span>

func Time(t *time.Time) time.Time <span class="cov0" title="0">{
        if t == nil </span><span class="cov0" title="0">{
                return time.Time{}
        }</span>
        <span class="cov0" title="0">return *t</span>
}

func Interface(val *interface{}) interface{} <span class="cov0" title="0">{
        if val == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return val</span>
}
</pre>
		
		<pre class="file" id="file217" style="display: none">package spectrocloud

import (
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

        "github.com/spectrocloud/palette-sdk-go/api/models"
        "github.com/spectrocloud/palette-sdk-go/client"
)

func toWorkspacePolicies(d *schema.ResourceData) *models.V1WorkspacePolicies <span class="cov0" title="0">{
        policies := toPolicies(d)

        if policies.BackupPolicy == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">include_all_clusters, cluster_uids := getExtraFields(d)

        return &amp;models.V1WorkspacePolicies{
                BackupPolicy: &amp;models.V1WorkspaceBackupConfigEntity{
                        BackupConfig:       policies.BackupPolicy,
                        ClusterUids:        cluster_uids,
                        IncludeAllClusters: include_all_clusters,
                },
        }</span>
}

func createWorkspaceBackupPolicy(c *client.V1Client, d *schema.ResourceData) error <span class="cov0" title="0">{
        if policy := toWorkspaceBackupPolicy(d); policy != nil </span><span class="cov0" title="0">{
                return c.CreateWorkspaceBackupConfig(d.Id(), policy)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func updateWorkspaceBackupPolicy(c *client.V1Client, d *schema.ResourceData) error <span class="cov0" title="0">{
        if policy := toWorkspaceBackupPolicy(d); policy != nil </span><span class="cov0" title="0">{
                return c.UpdateWorkspaceBackupConfig(d.Id(), policy)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func toWorkspaceBackupPolicy(d *schema.ResourceData) *models.V1WorkspaceBackupConfigEntity <span class="cov0" title="0">{
        policy := toBackupPolicy(d)
        if policy == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">include_all_clusters, cluster_uids := getExtraFields(d)

        return &amp;models.V1WorkspaceBackupConfigEntity{
                BackupConfig:       policy,
                ClusterUids:        cluster_uids,
                IncludeAllClusters: include_all_clusters,
        }</span>
}

func getExtraFields(d *schema.ResourceData) (bool, []string) <span class="cov0" title="0">{
        include_all_clusters := true
        cluster_uids := make([]string, 0)
        if policies, found := d.GetOk("backup_policy"); found </span><span class="cov0" title="0">{
                policy := policies.([]interface{})[0].(map[string]interface{})

                if policy["cluster_uids"] != nil </span><span class="cov0" title="0">{
                        for _, uid := range policy["cluster_uids"].(*schema.Set).List() </span><span class="cov0" title="0">{
                                cluster_uids = append(cluster_uids, uid.(string))
                        }</span>
                }

                <span class="cov0" title="0">if policy["include_all_clusters"] != nil </span><span class="cov0" title="0">{
                        include_all_clusters = policy["include_all_clusters"].(bool)
                }</span>
        }

        <span class="cov0" title="0">if len(cluster_uids) &gt; 0 </span><span class="cov0" title="0">{
                return include_all_clusters, cluster_uids
        }</span>

        <span class="cov0" title="0">return include_all_clusters, nil</span>
}

// func detachWorkspaceBackupPolicy(c *client.V1Client) error {
//         return errors.New("not implemented")
// }
</pre>
		
		<pre class="file" id="file218" style="display: none">package spectrocloud

import (
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/spectrocloud/palette-sdk-go/api/models"
        "github.com/spectrocloud/palette-sdk-go/client"
)

func toClusterRefs(d *schema.ResourceData, c *client.V1Client) []*models.V1WorkspaceClusterRef <span class="cov0" title="0">{
        clusterRefs := make([]*models.V1WorkspaceClusterRef, 0)

        clusters := d.Get("clusters")
        if clusters == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">for _, cluster := range clusters.(*schema.Set).List() </span><span class="cov0" title="0">{
                clusterValue := cluster.(map[string]interface{})
                uid := clusterValue["uid"].(string)

                // Try to get cluster name from the data first (if available from computed field)
                clusterName := ""
                if nameValue, exists := clusterValue["cluster_name"]; exists &amp;&amp; nameValue != nil </span><span class="cov0" title="0">{
                        clusterName = nameValue.(string)
                }</span>

                // If cluster name is not available in data and client is provided, fetch it from API
                <span class="cov0" title="0">if clusterName == "" &amp;&amp; c != nil </span><span class="cov0" title="0">{
                        if clusterDetails, err := c.GetCluster(uid); err == nil &amp;&amp; clusterDetails != nil </span><span class="cov0" title="0">{
                                clusterName = clusterDetails.Metadata.Name
                        }</span>
                }

                <span class="cov0" title="0">clusterRefs = append(clusterRefs, &amp;models.V1WorkspaceClusterRef{
                        ClusterUID:  uid,
                        ClusterName: clusterName,
                })</span>
        }

        <span class="cov0" title="0">return clusterRefs</span>
}
</pre>
		
		<pre class="file" id="file219" style="display: none">package spectrocloud

import (
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/spectrocloud/palette-sdk-go/api/models"
        "github.com/spectrocloud/palette-sdk-go/client"
)

func flattenWorkspaceClusters(workspace *models.V1Workspace, c *client.V1Client) []interface{} <span class="cov0" title="0">{
        clusters := workspace.Spec.ClusterRefs

        if len(clusters) &gt; 0 </span><span class="cov0" title="0">{
                wsp_clusters := make([]interface{}, 0)

                for _, cluster := range clusters </span><span class="cov0" title="0">{
                        wsp_cluster := make(map[string]interface{})

                        wsp_cluster["uid"] = cluster.ClusterUID

                        // Fetch cluster name using the API (if client is available)
                        if c != nil </span><span class="cov0" title="0">{
                                if clusterDetails, err := c.GetCluster(cluster.ClusterUID); err == nil &amp;&amp; clusterDetails != nil </span><span class="cov0" title="0">{
                                        wsp_cluster["cluster_name"] = clusterDetails.Metadata.Name
                                }</span> else<span class="cov0" title="0"> {
                                        // If we can't fetch the cluster name, set it to empty string
                                        wsp_cluster["cluster_name"] = ""
                                }</span>
                        } else<span class="cov0" title="0"> {
                                // For tests or when client is not available
                                wsp_cluster["cluster_name"] = ""
                        }</span>

                        <span class="cov0" title="0">wsp_clusters = append(wsp_clusters, wsp_cluster)</span>
                }

                <span class="cov0" title="0">return wsp_clusters</span>
        } else<span class="cov0" title="0"> {
                return make([]interface{}, 0)
        }</span>
}

func flattenWorkspaceBackupPolicy(backup *models.V1WorkspaceBackup, d *schema.ResourceData) []interface{} <span class="cov0" title="0">{
        result := make([]interface{}, 0, 1)
        if backup.Spec.Config == nil &amp;&amp; backup.Spec.Config.BackupConfig == nil </span><span class="cov0" title="0">{
                return result
        }</span>
        <span class="cov0" title="0">result = flattenBackupPolicy(backup.Spec.Config.BackupConfig, d)
        data := result[0].(map[string]interface{})
        data["cluster_uids"] = backup.Spec.Config.ClusterUids
        data["include_all_clusters"] = backup.Spec.Config.IncludeAllClusters
        return result</span>
}
</pre>
		
		<pre class="file" id="file220" style="display: none">package spectrocloud

import (
        "fmt"
        "math"
        "regexp"
        "strconv"
        "strings"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/spectrocloud/palette-sdk-go/api/models"
        "github.com/spectrocloud/palette-sdk-go/client"
        "github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/constants"
)

// Helper function to create V1WorkspaceResourceAllocation from resource allocation map
func toWorkspaceResourceAllocation(resourceAllocation map[string]interface{}) (*models.V1WorkspaceResourceAllocation, error) <span class="cov0" title="0">{
        cpuCoresVal, ok := resourceAllocation["cpu_cores"]
        if !ok || cpuCoresVal == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cpu_cores is required in resource_allocation")
        }</span>
        <span class="cov0" title="0">cpuCoresStr, ok := cpuCoresVal.(string)
        if !ok || cpuCoresStr == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cpu_cores must be a non-empty string")
        }</span>
        <span class="cov0" title="0">cpu_cores, err := strconv.ParseFloat(resourceAllocation["cpu_cores"].(string), 64)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // FIX: Safe type assertion for memory_MiB - prevents panic when nil or missing
        <span class="cov0" title="0">memoryVal, ok := resourceAllocation["memory_MiB"]
        if !ok || memoryVal == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("memory_MiB is required in resource_allocation")
        }</span>
        <span class="cov0" title="0">memoryStr, ok := memoryVal.(string)
        if !ok || memoryStr == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("memory_MiB must be a non-empty string")
        }</span>
        <span class="cov0" title="0">memory_MiB, err := strconv.ParseFloat(resourceAllocation["memory_MiB"].(string), 64)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">resource_alloc := &amp;models.V1WorkspaceResourceAllocation{
                CPUCores:  cpu_cores,
                MemoryMiB: memory_MiB,
        }

        // Handle GPU configuration if specified - same pattern as cpu_cores and memory_MiB
        if gpuVal, exists := resourceAllocation["gpu"]; exists &amp;&amp; gpuVal != nil </span><span class="cov0" title="0">{
                gpuInt, err := strconv.Atoi(gpuVal.(string))
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid gpu value: %v", gpuVal)
                }</span>

                <span class="cov0" title="0">if gpuInt &gt; 0 </span><span class="cov0" title="0">{
                        if gpuInt &gt; constants.Int32MaxValue </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("gpu value %d is out of range for int32", gpuInt)
                        }</span>
                        <span class="cov0" title="0">provider := "nvidia" // Default provider for cluster allocations
                        // gpu_provider is optional - mainly used for default resource allocations
                        if gpuProvider, providerExists := resourceAllocation["gpu_provider"]; providerExists &amp;&amp; gpuProvider != nil </span><span class="cov0" title="0">{
                                if providerStr, ok := gpuProvider.(string); ok &amp;&amp; providerStr != "" </span><span class="cov0" title="0">{
                                        provider = providerStr
                                }</span>
                        }
                        <span class="cov0" title="0">resource_alloc.GpuConfig = &amp;models.V1GpuConfig{
                                Limit:    SafeInt32(gpuInt),
                                Provider: &amp;provider,
                        }</span>
                }
        }

        <span class="cov0" title="0">return resource_alloc, nil</span>
}

func toWorkspaceNamespaces(d *schema.ResourceData) []*models.V1WorkspaceClusterNamespace <span class="cov0" title="0">{
        workspaceNamespaces := make([]*models.V1WorkspaceClusterNamespace, 0)
        if d.Get("namespaces") == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        // Handle both TypeSet and TypeList for backward compatibility
        <span class="cov0" title="0">var namespaceList []interface{}
        namespacesRaw := d.Get("namespaces")
        if namespaceSet, ok := namespacesRaw.(*schema.Set); ok </span><span class="cov0" title="0">{
                namespaceList = namespaceSet.List()
        }</span> else<span class="cov0" title="0"> if namespaceListRaw, ok := namespacesRaw.([]interface{}); ok </span><span class="cov0" title="0">{
                namespaceList = namespaceListRaw // Backward compatibility during migration
        }</span> else<span class="cov0" title="0"> {
                return nil
        }</span>

        <span class="cov0" title="0">for _, clusterNamespace := range namespaceList </span><span class="cov0" title="0">{
                ns := toWorkspaceNamespace(clusterNamespace)
                if ns != nil </span><span class="cov0" title="0">{
                        workspaceNamespaces = append(workspaceNamespaces, ns)
                }</span>
        }

        <span class="cov0" title="0">return workspaceNamespaces</span>
}

func toWorkspaceNamespace(clusterNamespaceConfig interface{}) *models.V1WorkspaceClusterNamespace <span class="cov0" title="0">{
        m := clusterNamespaceConfig.(map[string]interface{})

        resourceAllocationRaw, exists := m["resource_allocation"]
        if !exists || resourceAllocationRaw == nil </span><span class="cov0" title="0">{
                return nil // Return nil if resource_allocation is missing
        }</span>

        // Handle default resource allocation
        <span class="cov0" title="0">resourceAllocation, ok := m["resource_allocation"].(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return nil // Return nil if type assertion fails
        }</span>
        <span class="cov0" title="0">defaultResourceAlloc, err := toWorkspaceResourceAllocation(resourceAllocation)
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Handle cluster resource allocations
        <span class="cov0" title="0">var clusterResourceAllocations []*models.V1ClusterResourceAllocation
        if clusterAllocationsData, exists := m["cluster_resource_allocations"]; exists </span><span class="cov0" title="0">{
                clusterAllocations := clusterAllocationsData.([]interface{})
                for _, clusterAlloc := range clusterAllocations </span><span class="cov0" title="0">{
                        clusterAllocMap := clusterAlloc.(map[string]interface{})
                        uid := clusterAllocMap["uid"].(string)

                        clusterResourceAllocationRaw, exists := clusterAllocMap["resource_allocation"]
                        if !exists || clusterResourceAllocationRaw == nil </span><span class="cov0" title="0">{
                                continue</span> // Skip if missing
                        }

                        <span class="cov0" title="0">clusterResourceAllocation, ok := clusterResourceAllocationRaw.(map[string]interface{})
                        if !ok </span><span class="cov0" title="0">{
                                continue</span> // Skip if type assertion fails
                        }

                        //clusterResourceAllocation := clusterAllocMap["resource_allocation"].(map[string]interface{})

                        <span class="cov0" title="0">resourceAlloc, err := toWorkspaceResourceAllocation(clusterResourceAllocation)
                        if err != nil </span><span class="cov0" title="0">{
                                continue</span> // Skip invalid allocations
                        }

                        <span class="cov0" title="0">clusterResourceAllocations = append(clusterResourceAllocations, &amp;models.V1ClusterResourceAllocation{
                                ClusterUID:         uid,
                                ResourceAllocation: resourceAlloc,
                        })</span>
                }
        }

        // Handle images blacklist
        <span class="cov0" title="0">images, _ := m["images_blacklist"].([]interface{})
        blacklist := make([]string, 0)
        for _, image := range images </span><span class="cov0" title="0">{
                blacklist = append(blacklist, image.(string))
        }</span>

        <span class="cov0" title="0">name := m["name"].(string)
        IsRegex := IsRegex(name)

        ns := &amp;models.V1WorkspaceClusterNamespace{
                Image: &amp;models.V1WorkspaceNamespaceImage{
                        BlackListedImages: blacklist,
                },
                Name:    name,
                IsRegex: IsRegex,
                NamespaceResourceAllocation: &amp;models.V1WorkspaceNamespaceResourceAllocation{
                        ClusterResourceAllocations: clusterResourceAllocations,
                        DefaultResourceAllocation:  defaultResourceAlloc,
                },
        }

        return ns</span>
}

func IsRegex(name string) bool <span class="cov0" title="0">{
        last := string(name[len(name)-1])

        if !((strings.HasPrefix(name, "~/") || strings.HasPrefix(name, "/")) &amp;&amp; last == "/") </span><span class="cov0" title="0">{
                return false // not a regular expression since it doesn't start with ~/ / or end with /
        }</span>

        <span class="cov0" title="0">exp := name
        if strings.HasPrefix(name, "~/") &amp;&amp; len(name) &gt; 3 </span><span class="cov0" title="0">{
                exp = name[2 : len(name)-2]
        }</span>
        <span class="cov0" title="0">if strings.HasPrefix(name, "/") &amp;&amp; len(name) &gt; 2 </span><span class="cov0" title="0">{
                exp = name[1 : len(name)-1]
        }</span>

        <span class="cov0" title="0">_, err := regexp.Compile(exp)
        if err == nil </span><span class="cov0" title="0">{
                return true
        }</span> else<span class="cov0" title="0"> {
                return false // not a valid regex doesn't compile
        }</span>
}

func toUpdateWorkspaceNamespaces(d *schema.ResourceData, c *client.V1Client) (*models.V1WorkspaceClusterNamespacesEntity, error) <span class="cov0" title="0">{
        quota, err := toQuota(d)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;models.V1WorkspaceClusterNamespacesEntity{
                ClusterNamespaces: toWorkspaceNamespaces(d),
                ClusterRefs:       toClusterRefs(d, c),
                Quota:             quota,
        }, nil</span>
}

// Helper function to flatten V1WorkspaceResourceAllocation to resource allocation map
// includeProvider controls whether to include gpu_provider field (true for default allocations, false for cluster allocations)
func flattenWorkspaceResourceAllocation(resourceAlloc *models.V1WorkspaceResourceAllocation, includeProvider bool) map[string]interface{} <span class="cov0" title="0">{
        result := make(map[string]interface{})

        // Convert CPU cores with bounds checking to prevent integer overflow
        cpuCoresRounded := math.Round(resourceAlloc.CPUCores)
        if cpuCoresRounded &gt; math.MaxInt || cpuCoresRounded &lt; math.MinInt </span><span class="cov0" title="0">{
                // Fallback to string representation if out of int range
                result["cpu_cores"] = fmt.Sprintf("%.0f", cpuCoresRounded)
        }</span> else<span class="cov0" title="0"> {
                result["cpu_cores"] = strconv.Itoa(int(cpuCoresRounded))
        }</span>

        // Convert memory with bounds checking to prevent integer overflow
        <span class="cov0" title="0">memoryMiBRounded := math.Round(resourceAlloc.MemoryMiB)
        if memoryMiBRounded &gt; math.MaxInt || memoryMiBRounded &lt; math.MinInt </span><span class="cov0" title="0">{
                // Fallback to string representation if out of int range
                result["memory_MiB"] = fmt.Sprintf("%.0f", memoryMiBRounded)
        }</span> else<span class="cov0" title="0"> {
                result["memory_MiB"] = strconv.Itoa(int(memoryMiBRounded))
        }</span>

        // Handle GPU configuration if present
        <span class="cov0" title="0">if resourceAlloc.GpuConfig != nil </span><span class="cov0" title="0">{
                // Convert GPU limit with bounds checking to prevent integer overflow
                gpuLimit := int64(resourceAlloc.GpuConfig.Limit)
                if gpuLimit &gt; math.MaxInt || gpuLimit &lt; math.MinInt </span><span class="cov0" title="0">{
                        // Fallback to string representation if out of int range
                        result["gpu"] = fmt.Sprintf("%d", gpuLimit)
                }</span> else<span class="cov0" title="0"> {
                        result["gpu"] = strconv.Itoa(int(gpuLimit))
                }</span>
                // Only include gpu_provider for default resource allocations, not cluster-specific ones
                <span class="cov0" title="0">if includeProvider </span><span class="cov0" title="0">{
                        if resourceAlloc.GpuConfig.Provider != nil </span><span class="cov0" title="0">{
                                result["gpu_provider"] = *resourceAlloc.GpuConfig.Provider
                        }</span> else<span class="cov0" title="0"> {
                                result["gpu_provider"] = "nvidia" // Default provider
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                result["gpu"] = "0"
                if includeProvider </span><span class="cov0" title="0">{
                        result["gpu_provider"] = ""
                }</span>
        }

        <span class="cov0" title="0">return result</span>
}

func flattenWorkspaceClusterNamespaces(items []*models.V1WorkspaceClusterNamespace) []interface{} <span class="cov0" title="0">{
        result := make([]interface{}, 0)
        for _, namespace := range items </span><span class="cov0" title="0">{
                flattenNamespace := make(map[string]interface{})
                flattenNamespace["name"] = namespace.Name

                // Flatten default resource allocation using helper (include gpu_provider)
                if namespace.NamespaceResourceAllocation != nil &amp;&amp; namespace.NamespaceResourceAllocation.DefaultResourceAllocation != nil </span><span class="cov0" title="0">{
                        flattenNamespace["resource_allocation"] = flattenWorkspaceResourceAllocation(namespace.NamespaceResourceAllocation.DefaultResourceAllocation, true)
                }</span>

                // Flatten cluster resource allocations (exclude gpu_provider)
                <span class="cov0" title="0">if namespace.NamespaceResourceAllocation != nil &amp;&amp; len(namespace.NamespaceResourceAllocation.ClusterResourceAllocations) &gt; 0 </span><span class="cov0" title="0">{
                        clusterAllocations := make([]interface{}, 0)
                        for _, clusterAlloc := range namespace.NamespaceResourceAllocation.ClusterResourceAllocations </span><span class="cov0" title="0">{
                                clusterAllocMap := map[string]interface{}{
                                        "uid": clusterAlloc.ClusterUID,
                                }
                                if clusterAlloc.ResourceAllocation != nil </span><span class="cov0" title="0">{
                                        clusterAllocMap["resource_allocation"] = flattenWorkspaceResourceAllocation(clusterAlloc.ResourceAllocation, false)
                                }</span>
                                <span class="cov0" title="0">clusterAllocations = append(clusterAllocations, clusterAllocMap)</span>
                        }
                        <span class="cov0" title="0">flattenNamespace["cluster_resource_allocations"] = clusterAllocations</span>
                }

                // Handle images blacklist
                <span class="cov0" title="0">if namespace.Image != nil </span><span class="cov0" title="0">{
                        flattenNamespace["images_blacklist"] = namespace.Image.BlackListedImages
                }</span>

                <span class="cov0" title="0">result = append(result, flattenNamespace)</span>
        }
        <span class="cov0" title="0">return result</span>
}
</pre>
		
		<pre class="file" id="file221" style="display: none">package spectrocloud

import (
        "fmt"

        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
        "github.com/spectrocloud/palette-sdk-go/api/models"
        "github.com/spectrocloud/terraform-provider-spectrocloud/spectrocloud/constants"
)

func toWorkspaceRBACs(d *schema.ResourceData) []*models.V1ClusterRbac <span class="cov0" title="0">{
        rbacs := toClusterRBACsInputEntities(d)
        workspace_rbacs := make([]*models.V1ClusterRbac, 0)
        for _, rbac := range rbacs </span><span class="cov0" title="0">{
                workspace_rbacs = append(workspace_rbacs,
                        &amp;models.V1ClusterRbac{
                                Spec: rbac.Spec,
                        })
        }</span>

        <span class="cov0" title="0">return workspace_rbacs</span>
}

func toQuota(d *schema.ResourceData) (*models.V1WorkspaceQuota, error) <span class="cov0" title="0">{
        wsQuota, ok := d.GetOk("workspace_quota")
        if !ok || len(wsQuota.([]interface{})) == 0 </span><span class="cov0" title="0">{
                return &amp;models.V1WorkspaceQuota{
                        ResourceAllocation: &amp;models.V1WorkspaceResourceAllocation{
                                CPUCores:  0,
                                MemoryMiB: 0,
                        },
                }, nil
        }</span>

        <span class="cov0" title="0">q := wsQuota.([]interface{})[0].(map[string]interface{})
        resourceAllocation := &amp;models.V1WorkspaceResourceAllocation{
                CPUCores:  float64(q["cpu"].(int)),
                MemoryMiB: float64(q["memory"].(int)),
        }

        // Handle GPU configuration if specified
        if gpuVal, exists := q["gpu"]; exists &amp;&amp; gpuVal.(int) &gt; 0 </span><span class="cov0" title="0">{
                gpuInt := gpuVal.(int)
                if gpuInt &gt; constants.Int32MaxValue </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("gpu value %d is out of range for int32", gpuInt)
                }</span>
                <span class="cov0" title="0">provider := "nvidia" // Default to nvidia as it's the only supported provider
                resourceAllocation.GpuConfig = &amp;models.V1GpuConfig{
                        Limit:    SafeInt32(gpuInt),
                        Provider: &amp;provider,
                }</span>
        }

        <span class="cov0" title="0">return &amp;models.V1WorkspaceQuota{
                ResourceAllocation: resourceAllocation,
        }, nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
